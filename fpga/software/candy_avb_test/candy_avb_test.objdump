
candy_avb_test.elf:     file format elf32-littlenios2
candy_avb_test.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x01000250

Program Header:
    LOAD off    0x00001000 vaddr 0x00080000 paddr 0x00080000 align 2**12
         filesz 0x00000000 memsz 0x00000000 flags r-x
    LOAD off    0x00001020 vaddr 0x01000020 paddr 0x01000020 align 2**12
         filesz 0x0001cea0 memsz 0x0072ae80 flags rwx

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000000  00080000  00080000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000230  01000020  01000020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         0001a4f0  01000250  01000250  00001250  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       000006d4  0101a740  0101a740  0001b740  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       000020ac  0101ae14  0101ae14  0001be14  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          0070e08a  0101cec0  0101cec0  0001dec0  2**2
                  ALLOC, SMALL_DATA
  6 .onchip_flash_0_data 00000000  00080020  00080020  0001dec0  2**0
                  CONTENTS
  7 .new_sdram_controller_0 00000000  0172aea0  0172aea0  0001dec0  2**0
                  CONTENTS
  8 .comment      00000023  00000000  00000000  0001dec0  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 00001230  00000000  00000000  0001dee8  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   0002cba5  00000000  00000000  0001f118  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 0000b70d  00000000  00000000  0004bcbd  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   0000f90a  00000000  00000000  000573ca  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  00004364  00000000  00000000  00066cd4  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    00006d7d  00000000  00000000  0006b038  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    00017d7a  00000000  00000000  00071db5  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_alt_sim_info 00000050  00000000  00000000  00089b30  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_ranges 00001910  00000000  00000000  00089b80  2**3
                  CONTENTS, READONLY, DEBUGGING
 18 .thread_model 00000003  00000000  00000000  000927ca  2**0
                  CONTENTS, READONLY
 19 .cpu          00000007  00000000  00000000  000927cd  2**0
                  CONTENTS, READONLY
 20 .qsys         00000001  00000000  00000000  000927d4  2**0
                  CONTENTS, READONLY
 21 .simulation_enabled 00000001  00000000  00000000  000927d5  2**0
                  CONTENTS, READONLY
 22 .sysid_hash   00000004  00000000  00000000  000927d6  2**0
                  CONTENTS, READONLY
 23 .sysid_base   00000004  00000000  00000000  000927da  2**0
                  CONTENTS, READONLY
 24 .sysid_time   00000004  00000000  00000000  000927de  2**0
                  CONTENTS, READONLY
 25 .stderr_dev   0000000a  00000000  00000000  000927e2  2**0
                  CONTENTS, READONLY
 26 .stdin_dev    0000000a  00000000  00000000  000927ec  2**0
                  CONTENTS, READONLY
 27 .stdout_dev   0000000a  00000000  00000000  000927f6  2**0
                  CONTENTS, READONLY
 28 .sopc_system_name 00000013  00000000  00000000  00092800  2**0
                  CONTENTS, READONLY
 29 .quartus_project_dir 0000003a  00000000  00000000  00092813  2**0
                  CONTENTS, READONLY
 30 .jdi          00006762  00000000  00000000  0009284d  2**0
                  CONTENTS, READONLY
 31 .sopcinfo     00092810  00000000  00000000  00098faf  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00080000 l    d  .entry	00000000 .entry
01000020 l    d  .exceptions	00000000 .exceptions
01000250 l    d  .text	00000000 .text
0101a740 l    d  .rodata	00000000 .rodata
0101ae14 l    d  .rwdata	00000000 .rwdata
0101cec0 l    d  .bss	00000000 .bss
00080020 l    d  .onchip_flash_0_data	00000000 .onchip_flash_0_data
0172aea0 l    d  .new_sdram_controller_0	00000000 .new_sdram_controller_0
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../candy_avb_test_bsp//obj/HAL/src/crt0.o
01000294 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 obj/default/FreeRTOS/Source/portable/GCC/NiosII/port_asm.o
01000020 l       .exceptions	00000000 save_context
0100009c l       .exceptions	00000000 save_sp_to_pxCurrentTCB
010000ac l       .exceptions	00000000 hw_irq_test
01000150 l       .exceptions	00000000 soft_exceptions
010000c0 l       .exceptions	00000000 hw_irq_handler
010000d4 l       .exceptions	00000000 restore_context
0100016c l       .exceptions	00000000 call_scheduler
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 BlockQ.c
0101cec0 l     O .bss	00000006 sBlockingConsumerCount
0101cec6 l     O .bss	00000006 sBlockingProducerCount
010005a8 l     F .text	000000a4 vBlockingQueueConsumer
0100051c l     F .text	0000008c vBlockingQueueProducer
0101cecc l     O .bss	00000006 sLastBlockingConsumerCount.2714
0101ced2 l     O .bss	00000006 sLastBlockingProducerCount.2715
00000000 l    df *ABS*	00000000 GenQTest.c
0101ced8 l     O .bss	00000004 xErrorDetected
0101cedc l     O .bss	00000004 ulLoopCounter
0101cee0 l     O .bss	00000004 ulLoopCounter2
0101cee4 l     O .bss	00000004 ulGuardedVariable
0101cee8 l     O .bss	00000004 xHighPriorityMutexTask
0101ceec l     O .bss	00000004 xMediumPriorityMutexTask
01000874 l     F .text	00000464 prvSendFrontAndBackTest
01000fdc l     F .text	0000005c prvLowPriorityMutexTask
01001038 l     F .text	0000002c prvMediumPriorityMutexTask
01001064 l     F .text	00000070 prvHighPriorityMutexTask
01000cd8 l     F .text	0000019c prvTakeTwoMutexesReturnInDifferentOrder
01000e74 l     F .text	00000168 prvTakeTwoMutexesReturnInSameOrder
0101cef0 l     O .bss	00000004 ulLastLoopCounter.2739
0101cef4 l     O .bss	00000004 ulLastLoopCounter2.2740
00000000 l    df *ABS*	00000000 PollQ.c
0101cef8 l     O .bss	00000004 xPollingConsumerCount
0101cefc l     O .bss	00000004 xPollingProducerCount
0101cf00 l     O .bss	00000004 xPolledQueue.2681
01001270 l     F .text	000000b4 vPolledQueueConsumer
010011cc l     F .text	000000a4 vPolledQueueProducer
00000000 l    df *ABS*	00000000 QPeek.c
0101cf04 l     O .bss	00000004 xErrorDetected
0101cf08 l     O .bss	00000004 ulLoopCounter
01001710 l     F .text	0000016c prvLowPriorityPeekTask
01001684 l     F .text	0000008c prvMediumPriorityPeekTask
010015bc l     F .text	000000c8 prvHighPriorityPeekTask
01001458 l     F .text	00000164 prvHighestPriorityPeekTask
0101cf0c l     O .bss	00000004 ulLastLoopCounter.2717
00000000 l    df *ABS*	00000000 blocktim.c
0101cf1c l     O .bss	00000004 xTestQueue
0101cf20 l     O .bss	00000004 xSecondary
0101cf24 l     O .bss	00000004 xPrimaryCycles
0101cf28 l     O .bss	00000004 xSecondaryCycles
0101cf2c l     O .bss	00000004 xErrorOccurred
0101cf30 l     O .bss	00000004 xRunIndicator
01001958 l     F .text	00000428 vPrimaryBlockTimeTestTask
01001d80 l     F .text	00000130 vSecondaryBlockTimeTestTask
01001eb0 l     F .text	00000118 prvBasicDelayTests
0101cf34 l     O .bss	00000004 xLastPrimaryCycleCount.2330
0101cf38 l     O .bss	00000004 xLastSecondaryCycleCount.2331
00000000 l    df *ABS*	00000000 comtest.c
0101cf3c l     O .bss	00000004 xPort
0101cf40 l     O .bss	00000004 uxBaseLED
0101cf44 l     O .bss	00000004 uxRxLoops
010020cc l     F .text	000000b4 vComTxTask
01002180 l     F .text	00000118 vComRxTask
00000000 l    df *ABS*	00000000 countsem.c
0101cf48 l     O .bss	00000004 xErrorDetected
0101d0b8 l     O .bss	00000018 xParameters
01002578 l     F .text	000000b0 prvCountingSemaphoreTask
010023d8 l     F .text	000000d0 prvDecrementSemaphoreCount
010024a8 l     F .text	000000d0 prvIncrementSemaphoreCount
0101cf4c l     O .bss	00000004 uxLastCount0.2295
0101cf50 l     O .bss	00000004 uxLastCount1.2296
00000000 l    df *ABS*	00000000 death.c
0101cf54 l     O .bss	00000002 usCreationCount
0101cf58 l     O .bss	00000004 uxTasksRunningAtStart
0101cde4 l     O .rwdata	00000004 uxMaxNumberOfExtraTasksRunning
010027a0 l     F .text	00000098 vCreateTasks
0100271c l     F .text	00000084 vSuicidalTask
0101cde8 l     O .rwdata	00000002 usLastCreationCount.2594
0101cf5c l     O .bss	00000004 uxTasksRunningNow.2596
00000000 l    df *ABS*	00000000 dynamic.c
0101cf64 l     O .bss	00000004 xContinuousIncrementHandle
0101cf68 l     O .bss	00000004 xLimitedIncrementHandle
0101cf6c l     O .bss	00000004 ulCounter
0101cf70 l     O .bss	00000002 usCheckVariable
0101cf74 l     O .bss	00000004 xSuspendedQueueSendError
0101cf78 l     O .bss	00000004 xSuspendedQueueReceiveError
0101cf7c l     O .bss	00000004 ulExpectedValue
01002a18 l     F .text	00000060 vContinuousIncrementTask
010029c4 l     F .text	00000054 vLimitedIncrementTask
01002a78 l     F .text	000000dc vCounterControlTask
01002b54 l     F .text	0000005c vQueueSendWhenSuspendedTask
01002bb0 l     F .text	00000088 vQueueReceiveWhenSuspendedTask
0101cf80 l     O .bss	00000004 ulValueToSend.2718
0101cf84 l     O .bss	00000002 usLastTaskCheck.2731
0101cf88 l     O .bss	00000004 ulLastExpectedValue.2732
00000000 l    df *ABS*	00000000 flash.c
0101cf90 l     O .bss	00000004 uxFlashTaskNumber
01002d2c l     F .text	00000088 vLEDFlashTask
00000000 l    df *ABS*	00000000 integer.c
0101cf94 l     O .bss	00000004 xTaskCheck
01002e38 l     F .text	00000094 vCompeteingIntMathTask
00000000 l    df *ABS*	00000000 recmutex.c
0101cf98 l     O .bss	00000004 xMutex
0101cf9c l     O .bss	00000004 xErrorOccurred
0101cfa0 l     O .bss	00000004 xControllingIsSuspended
0101cfa4 l     O .bss	00000004 xBlockingIsSuspended
0101cfa8 l     O .bss	00000004 uxControllingCycles
0101cfac l     O .bss	00000004 uxBlockingCycles
0101cfb0 l     O .bss	00000004 uxPollingCycles
0101cfb4 l     O .bss	00000004 xControllingTaskHandle
0101cfb8 l     O .bss	00000004 xBlockingTaskHandle
01003000 l     F .text	000000fc prvRecursiveMutexControllingTask
010030fc l     F .text	000000a8 prvRecursiveMutexBlockingTask
010031a4 l     F .text	000000b4 prvRecursiveMutexPollingTask
0101cfbc l     O .bss	00000004 uxLastControllingCycles.2294
0101cfc0 l     O .bss	00000004 uxLastBlockingCycles.2295
0101cfc4 l     O .bss	00000004 uxLastPollingCycles.2296
00000000 l    df *ABS*	00000000 semtest.c
0101cfc8 l     O .bss	00000008 sCheckVariables
0101cfd0 l     O .bss	00000002 sNextCheckVariable
010034cc l     F .text	00000184 prvSemaphoreTest
0101cfd2 l     O .bss	00000008 sLastCheckVariables.2704
00000000 l    df *ABS*	00000000 ParTest.c
0101cfdc l     O .bss	00000004 ulLedStates
00000000 l    df *ABS*	00000000 list.c
00000000 l    df *ABS*	00000000 port.c
01003c14 l     F .text	00000090 prvSetupTimerInterrupt
00000000 l    df *ABS*	00000000 heap_2.c
0101d0d0 l     O .bss	0070bdc0 ucHeap
0101cdec l     O .rwdata	00000002 heapSTRUCT_SIZE
0101cfe0 l     O .bss	00000008 xStart
0101cfe8 l     O .bss	00000008 xEnd
0101cdf0 l     O .rwdata	00000004 xFreeBytesRemaining
0101cff0 l     O .bss	00000004 xHeapHasBeenInitialised.2579
01004214 l     F .text	00000074 prvHeapInit
00000000 l    df *ABS*	00000000 queue.c
0100443c l     F .text	00000084 prvInitialiseNewQueue
010044c0 l     F .text	00000060 prvInitialiseMutex
01004f14 l     F .text	0000018c prvCopyDataToQueue
010052c0 l     F .text	00000058 prvIsQueueFull
0100513c l     F .text	000000f4 prvUnlockQueue
010050a0 l     F .text	0000009c prvCopyDataFromQueue
01005230 l     F .text	00000050 prvIsQueueEmpty
00000000 l    df *ABS*	00000000 tasks.c
01728e90 l     O .bss	00000064 pxReadyTasksLists
01728ef4 l     O .bss	00000014 xDelayedTaskList1
01728f08 l     O .bss	00000014 xDelayedTaskList2
0101cff8 l     O .bss	00000004 pxDelayedTaskList
0101cffc l     O .bss	00000004 pxOverflowDelayedTaskList
01728f1c l     O .bss	00000014 xPendingReadyList
01728f30 l     O .bss	00000014 xTasksWaitingTermination
0101d000 l     O .bss	00000004 uxDeletedTasksWaitingCleanUp
01728f44 l     O .bss	00000014 xSuspendedTaskList
0101d004 l     O .bss	00000004 uxCurrentNumberOfTasks
0101d008 l     O .bss	00000004 xTickCount
0101d00c l     O .bss	00000004 uxTopReadyPriority
0101d010 l     O .bss	00000004 xSchedulerRunning
0101d014 l     O .bss	00000004 uxPendedTicks
0101d018 l     O .bss	00000004 xYieldPending
0101d01c l     O .bss	00000004 xNumOfOverflows
0101d020 l     O .bss	00000004 uxTaskNumber
0101d024 l     O .bss	00000004 xNextTaskUnblockTime
0101d028 l     O .bss	00000004 xIdleTaskHandle
0101d02c l     O .bss	00000004 uxSchedulerSuspended
01005448 l     F .text	000001d0 prvInitialiseNewTask
01005618 l     F .text	000000fc prvAddNewTaskToReadyList
0100684c l     F .text	000000b8 prvInitialiseTaskLists
01006a70 l     F .text	00000044 prvDeleteTCB
01006ab4 l     F .text	00000068 prvResetNextTaskUnblockTime
0100755c l     F .text	000000e8 prvAddCurrentTaskToDelayedList
01005c84 l     F .text	00000094 prvTaskIsTaskSuspended
01006830 l     F .text	0000001c prvIdleTask
01006904 l     F .text	000000a8 prvCheckTasksWaitingTermination
010069ac l     F .text	00000064 prvTaskCheckFreeStackSpace
00000000 l    df *ABS*	00000000 serial.c
0101d030 l     O .bss	00000004 xRxedChars
0101d034 l     O .bss	00000004 xCharsForTx
010078ac l     F .text	0000006c vUARTInterruptHandler
01007918 l     F .text	0000009c vUARTReceiveHandler
010079b4 l     F .text	00000098 vUARTTransmitHandler
00000000 l    df *ABS*	00000000 SigmaStudioFW.c
00000000 l    df *ABS*	00000000 hello_world.c
01009158 l     F .text	00000554 prvPrintTask1
01008a00 l     F .text	00000080 eth_ocm_isr
01008af0 l     F .text	000000c4 eth_ocm_rx_isr
01008a80 l     F .text	00000070 eth_ocm_read_init
01008d1c l     F .text	00000068 eth_ocm_wait
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 extendsfdf2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 printf.c
00000000 l    df *ABS*	00000000 putchar.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 vfprintf.c
0101ac16 l     O .rodata	00000010 zeroes.4404
0100c050 l     F .text	000000bc __sbprintf
0101ac26 l     O .rodata	00000010 blanks.4403
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 dtoa.c
0100c260 l     F .text	00000200 quorem
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 findfp.c
0100dd90 l     F .text	00000008 __fp_unlock
0100dda4 l     F .text	0000019c __sinit.part.1
0100df40 l     F .text	00000008 __fp_lock
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 impure.c
0101b11c l     O .rwdata	00000424 impure_data
00000000 l    df *ABS*	00000000 locale.c
0101b560 l     O .rwdata	00000020 lc_ctype_charset
0101b540 l     O .rwdata	00000020 lc_message_charset
0101b580 l     O .rwdata	00000038 lconv
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 mprec.c
0101ac58 l     O .rodata	0000000c p05.2768
00000000 l    df *ABS*	00000000 putc.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 s_fpclassify.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 strcmp.c
00000000 l    df *ABS*	00000000 vfprintf.c
01011234 l     F .text	000000fc __sprint_r.part.0
0101ad8c l     O .rodata	00000010 blanks.4348
0101ad7c l     O .rodata	00000010 zeroes.4349
010127c0 l     F .text	000000bc __sbprintf
00000000 l    df *ABS*	00000000 wbuf.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 closer.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fputwc.c
00000000 l    df *ABS*	00000000 fstatr.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 isattyr.c
00000000 l    df *ABS*	00000000 lseekr.c
00000000 l    df *ABS*	00000000 readr.c
00000000 l    df *ABS*	00000000 wcrtomb.c
00000000 l    df *ABS*	00000000 wctomb_r.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 adddf3.c
00000000 l    df *ABS*	00000000 divdf3.c
00000000 l    df *ABS*	00000000 eqdf2.c
00000000 l    df *ABS*	00000000 gedf2.c
00000000 l    df *ABS*	00000000 ledf2.c
00000000 l    df *ABS*	00000000 muldf3.c
00000000 l    df *ABS*	00000000 subdf3.c
00000000 l    df *ABS*	00000000 fixdfsi.c
00000000 l    df *ABS*	00000000 floatsidf.c
00000000 l    df *ABS*	00000000 floatunsidf.c
00000000 l    df *ABS*	00000000 alt_close.c
01016264 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_dev.c
01016370 l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_fstat.c
0101639c l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_isatty.c
01016638 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_lseek.c
01016718 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
00000000 l    df *ABS*	00000000 alt_read.c
010168ec l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_remap_cached.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
0101ce9c l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_write.c
01016b9c l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_sys_init.c
01016cd0 l     F .text	00000034 alt_dev_reg
0101bb68 l     O .rwdata	00001060 jtaguart_0
0101cbc8 l     O .rwdata	000000c4 uart
0101cc8c l     O .rwdata	0000003c modular_adc_0
0101ccc8 l     O .rwdata	00000100 onchip_flash_0
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
01017000 l     F .text	0000020c altera_avalon_jtag_uart_irq
0101720c l     F .text	000000a0 altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
01017844 l     F .text	00000078 alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 altera_avalon_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_uart_init.c
01017af4 l     F .text	0000009c altera_avalon_uart_irq
01017b90 l     F .text	000000e4 altera_avalon_uart_rxirq
01017c74 l     F .text	00000148 altera_avalon_uart_txirq
00000000 l    df *ABS*	00000000 altera_avalon_uart_read.c
01017e10 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 altera_avalon_uart_write.c
01018028 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 altera_modular_adc.c
01018210 l     F .text	000000a8 alt_adc_irq
00000000 l    df *ABS*	00000000 altera_onchip_flash.c
0101877c l     F .text	00000034 alt_flash_device_register
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_dcache_flush.c
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
010199b8 l     F .text	0000003c alt_get_errno
00000000 l    df *ABS*	00000000 alt_do_ctors.c
00000000 l    df *ABS*	00000000 alt_do_dtors.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_flash_dev.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
01019ca4 l     F .text	000000c4 alt_open_fd
00000000 l    df *ABS*	00000000 alt_open.c
01019de4 l     F .text	0000003c alt_get_errno
01019e20 l     F .text	000000c4 alt_file_locked
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 alt_exit.c
01009cb8 g     F .text	00000018 putchar
01010710 g     F .text	00000074 _mprec_log10
010184b0 g     F .text	00000050 adc_stop
01000298 g     F .text	00000284 vStartBlockingQueueTasks
010107fc g     F .text	0000008c __any_on
0101d052 g     O .bss	00000002 R11_CONVERTER_CONTROL_REGISTERS_IC_2_Default
01012eb4 g     F .text	00000054 _isatty_r
0101ac64 g     O .rodata	00000028 __mprec_tinytens
01016828 g     F .text	0000007c alt_main
01009cd0 g     F .text	000000c0 _puts_r
0172ada0 g     O .bss	00000100 alt_irq
0101ce1f g     O .rwdata	00000005 R22_CRC_REGISTERS_IC_1_Default
01012f08 g     F .text	00000060 _lseek_r
010000c4 g       .exceptions	00000000 restore_sp_from_pxCurrentTCB
010064c0 g     F .text	00000064 vTaskPlaceOnUnorderedEventList
010041d4 g     F .text	00000020 xPortGetFreeHeapSize
0101d068 g     O .bss	00000004 itest
01014df4 g     F .text	00000088 .hidden __eqdf2
0172aea0 g       *ABS*	00000000 __alt_heap_start
01005948 g     F .text	00000058 uxTaskPriorityGet
0100187c g     F .text	00000044 xAreQueuePeekTasksStillRunning
01009c74 g     F .text	0000003c printf
01012fc8 g     F .text	0000009c _wcrtomb_r
010110f4 g     F .text	0000005c __sseek
0100e0e0 g     F .text	00000010 __sinit
0101d05a g     O .bss	00000001 R29_SERIAL_DATAGPIO_PIN_CONFIG_IC_2_Default
01007e50 g     F .text	00000084 SIGMA_WRITE_REGISTER_BLOCK
0101287c g     F .text	00000140 __swbuf_r
0100eba8 g     F .text	0000007c _setlocale_r
0100df48 g     F .text	00000068 __sfmoreglue
0101ce4b g     O .rwdata	00000003 R9_ADC_CONTROL_REGISTERS_IC_2_Default
0101af59 g     O .rwdata	00000030 Param_Data_IC_1
010168c8 g     F .text	00000024 __malloc_unlock
0101ce2f g     O .rwdata	00000001 R37_DSP_RUN_REGISTER_IC_1_Default
01016a88 g     F .text	00000034 alt_remap_cached
010010d4 g     F .text	00000060 xAreGenericQueueTasksStillRunning
0101af97 g     O .rwdata	00000145 Program_Data_IC_2
0101d045 g     O .bss	00000001 R28_ROUTING_MATRIX_OUTPUTS_IC_1_Default
0100f730 g     F .text	0000015c memmove
01001fc8 g     F .text	00000068 xAreBlockTimeTestTasksStillRunning
01006d68 g     F .text	00000054 vTaskEnterCritical
0100e0c8 g     F .text	00000018 _cleanup
010048bc g     F .text	000000e8 xQueueGenericSendFromISR
01006194 g     F .text	00000040 pcTaskGetName
0100f88c g     F .text	000000a8 _Balloc
01014e7c g     F .text	000000dc .hidden __gtdf2
0101a1dc g     F .text	00000024 altera_nios2_gen2_irq_init
01728f58 g     O .bss	00001402 i2c_write_data
0101ce63 g     O .rwdata	00000002 R32_CLOCK_ENABLE_REGISTERS_IC_2_Default
00080000 g     F .entry	00000000 __reset
0100457c g     F .text	00000090 xQueueGiveMutexRecursive
01002f48 g     F .text	000000b8 vStartRecursiveMutexTasks
0101cff4 g     O .bss	00000004 pxCurrentTCB
0101d04b g     O .bss	00000002 R5_SERIAL_PORT_CONTROL_REGISTERS_IC_2_Default
01018674 g     F .text	00000048 adc_interrupt_disable
01012e58 g     F .text	0000005c _fstat_r
0101d09c g     O .bss	00000004 errno
01011070 g     F .text	00000008 __seofread
0172a784 g     O .bss	0000061a pkt
01018364 g     F .text	00000074 altera_modular_adc_init
0101d0a8 g     O .bss	00000004 alt_argv
01024de4 g       *ABS*	00000000 _gp
01016b6c g     F .text	00000030 usleep
010059ec g     F .text	000001b8 vTaskPrioritySet
0101962c g     F .text	00000090 alt_onchip_flash_poll_for_status_write_passed
010087e8 g     F .text	00000040 adc_callback
0101ce67 g     O .rwdata	00000001 R39_DEJITTER_REGISTER_CONTROL_IC_2_Default
01007fdc g     F .text	000000e4 SIGMA_SAFELOAD_WRITE_DATA
0101d03d g     O .bss	00000001 R7_MICCTRLREGISTER_IC_1_Default
0101cdf4 g     O .rwdata	00000008 NON_MODULO_RAM_Data_IC_1
0101b9e8 g     O .rwdata	00000180 alt_fd_list
0101ce24 g     O .rwdata	00000002 R24_NON_MODULO_REGISTERS_IC_1_Default
01002298 g     F .text	0000003c xAreComTestTasksStillRunning
0101cdfe g     O .rwdata	00000006 R3_PLLCRLREGISTER_IC_1_Default
01003bbc g     F .text	00000038 xPortStartScheduler
01009cb0 g     F .text	00000008 _putchar_r
01005f54 g     F .text	00000048 vTaskEndScheduler
01019b58 g     F .text	00000090 alt_find_dev
010099d4 g     F .text	00000148 memcpy
01006470 g     F .text	00000050 vTaskPlaceOnEventList
01003258 g     F .text	0000009c xAreRecursiveMutexTasksStillRunning
00080000 g       *ABS*	00000000 __alt_mem_onchip_flash_0_data
0100dd98 g     F .text	0000000c _cleanup_r
010160e0 g     F .text	000000dc .hidden __floatsidf
0101cf10 g     O .bss	00000004 xHighPriorityTask
01018578 g     F .text	0000003c adc_set_mode_run_continuously
01019d68 g     F .text	0000007c alt_io_redirect
0101d06c g     O .bss	00000004 ftest
0101ce41 g     O .rwdata	00000002 R4_DELAY_IC_2_Default
01014f58 g     F .text	000000f4 .hidden __ltdf2
01004d98 g     F .text	0000007c xQueuePeekFromISR
01007cb8 g     F .text	00000198 i2c_multiple_write
0101a740 g       *ABS*	00000000 __DTOR_END__
01009d90 g     F .text	00000014 puts
01004108 g     F .text	000000cc vPortFree
01010f54 g     F .text	00000074 __fpclassifyd
0101b0dc g     O .rwdata	00000030 Param_Data_IC_2
0101066c g     F .text	000000a4 __ratio
010127a4 g     F .text	0000001c __vfiprintf_internal
01017404 g     F .text	0000021c altera_avalon_jtag_uart_read
01009c44 g     F .text	00000030 _printf_r
010097a4 g     F .text	00000064 .hidden __udivsi3
01002cb8 g     F .text	00000074 vStartLEDFlashTasks
01016674 g     F .text	000000a4 isatty
0101959c g     F .text	00000090 alt_onchip_flash_poll_for_status_erase_passed
0101acb4 g     O .rodata	000000c8 __mprec_tens
0101cf14 g     O .bss	00000004 xMediumPriorityTask
01006a10 g     F .text	00000060 uxTaskGetStackHighWaterMark
0100ec24 g     F .text	0000000c __locale_charset
0101ce3b g     O .rwdata	00000006 R3_PLLCRLREGISTER_IC_2_Default
0101ce17 g     O .rwdata	00000003 R12_DAC_CONTROL_REGISTERS_IC_1_Default
0101ce66 g     O .rwdata	00000001 R37_DSP_RUN_REGISTER_IC_2_Default
010038b8 g     F .text	0000008c vListInsertEnd
0101d098 g     O .bss	00000004 __malloc_top_pad
0101cea8 g     O .rwdata	00000008 altera_onchip_flash_list
0101ce54 g     O .rwdata	00000001 R15_JACKREGISTER_IC_2_Default
0101ce70 g     O .rwdata	00000004 __mb_cur_max
010028c0 g     F .text	00000104 vStartDynamicPriorityTasks
0100ec54 g     F .text	0000000c _localeconv_r
0100fc98 g     F .text	0000003c __i2b
0100e564 g     F .text	000004bc __sfvwrite_r
010076f8 g     F .text	00000024 vSerialClose
0101ce06 g     O .rwdata	00000002 R5_SERIAL_PORT_CONTROL_REGISTERS_IC_1_Default
0101ce39 g     O .rwdata	00000001 R0_SAMPLE_RATE_SETTING_IC_2_Default
01010fc8 g     F .text	00000054 _sbrk_r
0101d04a g     O .bss	00000001 R1_DSP_RUN_REGISTER_IC_2_Default
01005de4 g     F .text	000000e0 xTaskResumeFromISR
01012f68 g     F .text	00000060 _read_r
0101cea0 g     O .rwdata	00000008 altera_modular_adc_list
0100388c g     F .text	0000002c vListInitialiseItem
01019940 g     F .text	00000078 alt_dcache_flush
01018918 g     F .text	00000168 alt_onchip_flash_erase_block
010037b8 g     F .text	0000006c vParTestToggleLED
0101ce90 g     O .rwdata	00000004 alt_max_fd
01003ca4 g     F .text	00000040 vPortSysTickHandler
01012b4c g     F .text	000000f0 _fclose_r
0100dd60 g     F .text	00000030 fflush
0101d094 g     O .bss	00000004 __malloc_max_sbrked_mem
010059a0 g     F .text	0000004c uxTaskPriorityGetFromISR
01003ce4 g     F .text	00000170 alt_irq_register
01009860 g     F .text	00000110 .hidden __extendsfdf2
0100372c g     F .text	0000008c vParTestSetLED
0101d05d g     O .bss	00000001 R38_DEJITTER_REGISTER_CONTROL_IC_2_Default
01013c60 g     F .text	000008ac .hidden __adddf3
01007c24 g     F .text	00000094 i2c_write_byte_stop
01010414 g     F .text	0000010c __b2d
01013728 g     F .text	00000538 .hidden __umoddi3
01016754 g     F .text	000000d4 lseek
0101ce68 g     O .rwdata	00000004 _global_impure_ptr
010109f0 g     F .text	00000564 _realloc_r
0172aea0 g       *ABS*	00000000 __bss_end
0101af89 g     O .rwdata	0000000e R10_PLAYBACK_OUTPUT_SIGNAL_PATH_REGISTERS_IC_1_Default
01003e54 g     F .text	000000e0 alt_iic_isr_register
0100064c g     F .text	00000128 xAreBlockingQueuesStillRunning
0101a0d4 g     F .text	00000108 alt_tick
0101ce0c g     O .rwdata	00000008 R8_RECORD_INPUT_SIGNAL_PATH_REGISTERS_IC_1_Default
010131b0 g     F .text	00000578 .hidden __udivdi3
01012db4 g     F .text	00000024 _fputwc_r
01018740 g     F .text	0000003c adc_wait_for_interrupt
0101ac8c g     O .rodata	00000028 __mprec_bigtens
0100fa7c g     F .text	00000104 __s2b
010161bc g     F .text	000000a8 .hidden __floatunsidf
01007f50 g     F .text	0000008c SIGMA_SAFELOAD_WRITE_ADDR
01010154 g     F .text	00000060 __mcmp
01003f34 g     F .text	000001d4 pvPortMalloc
01017a48 g     F .text	000000ac altera_avalon_uart_init
01001324 g     F .text	00000048 xArePollingQueuesStillRunning
0100e100 g     F .text	00000018 __fp_lock_all
010165ec g     F .text	0000004c alt_ic_irq_enabled
010080c0 g     F .text	00000080 SIGMA_SAFELOAD_WRITE_TRANSFER_BIT
01004ed8 g     F .text	0000003c vQueueDelete
01003bf4 g     F .text	00000020 vPortEndScheduler
01003824 g     F .text	00000068 vListInitialise
0101d05c g     O .bss	00000001 R31_SERIAL_PORT_SAMPLE_RATE_SETTING_IC_2_Default
0101a038 g     F .text	0000009c alt_alarm_stop
0101d0a0 g     O .bss	00000004 alt_irq_active
0101ce52 g     O .rwdata	00000002 R14_COMMUNICATION_PORT_PAD_CONTROL_REGISTERS_IC_2_Default
0101ce1d g     O .rwdata	00000001 R15_JACKREGISTER_IC_1_Default
0100017c g     F .exceptions	000000d4 alt_irq_handler
0101b9c0 g     O .rwdata	00000028 alt_dev_null
01006120 g     F .text	00000028 xTaskGetTickCount
01004708 g     F .text	000001b4 xQueueGenericSend
0101ce62 g     O .rwdata	00000001 R26_SAMPLE_RATE_SETTING_IC_2_Default
01018538 g     F .text	00000040 adc_set_mode_run_once
01007acc g     F .text	000000a8 i2c_start
0101d03c g     O .bss	00000001 R1_DSP_RUN_REGISTER_IC_1_Default
0100fb80 g     F .text	00000068 __hi0bits
01000774 g     F .text	00000100 vStartGenericQueueTasks
0101d046 g     O .bss	00000001 R29_SERIAL_DATAGPIO_PIN_CONFIG_IC_1_Default
01016060 g     F .text	00000080 .hidden __fixdfsi
01002628 g     F .text	0000008c xAreCountingSemaphoreTasksStillRunning
01006c6c g     F .text	000000fc xTaskPriorityDisinherit
0101ce88 g     O .rwdata	00000008 alt_dev_list
01016bd8 g     F .text	000000f8 write
01010888 g     F .text	000000a0 _putc_r
01008d84 g     F .text	000003d4 init_MAC
01006524 g     F .text	000000f4 xTaskRemoveFromEventList
01007ed4 g     F .text	0000007c SIGMA_WRITE_REGISTER_CONTROL
010163d8 g     F .text	000000b0 fstat
0101ae14 g     O .rwdata	00000145 Program_Data_IC_1
01014f58 g     F .text	000000f4 .hidden __ledf2
01007820 g     F .text	0000008c vSerialPutString
0100fecc g     F .text	00000140 __pow5mult
01018500 g     F .text	00000038 adc_start
01007790 g     F .text	00000090 xSerialPutChar
01011348 g     F .text	0000145c ___vfiprintf_internal_r
0101d08c g     O .bss	00000004 __nlocale_changed
01009808 g     F .text	00000058 .hidden __umodsi3
0101ce4e g     O .rwdata	00000003 R12_DAC_CONTROL_REGISTERS_IC_2_Default
01008c28 g     F .text	00000078 eth_ocm_write_phy_reg
0172aea0 g       *ABS*	00000000 end
01005714 g     F .text	000000e8 vTaskDelete
01002838 g     F .text	00000088 xIsCreateTaskStillRunning
01018064 g     F .text	000001ac altera_avalon_uart_write
01016f40 g     F .text	000000c0 altera_avalon_jtag_uart_init
01006e60 g     F .text	00000038 pvTaskIncrementMutexHeldCount
0101a740 g       *ABS*	00000000 __CTOR_LIST__
01800000 g       *ABS*	00000000 __alt_stack_pointer
010178bc g     F .text	0000007c alt_avalon_timer_sc_init
01017998 g     F .text	00000060 altera_avalon_uart_write_fd
01009970 g     F .text	00000064 .hidden __clzsi2
010179f8 g     F .text	00000050 altera_avalon_uart_close_fd
01017620 g     F .text	00000224 altera_avalon_jtag_uart_write
0100e0f0 g     F .text	00000004 __sfp_lock_acquire
0100f64c g     F .text	000000e4 memchr
01009e3c g     F .text	000021f8 ___vfprintf_internal_r
0100672c g     F .text	000000dc xTaskCheckForTimeOut
0101887c g     F .text	0000009c alt_onchip_flash_get_info
0100e254 g     F .text	00000310 _free_r
0100ec30 g     F .text	00000010 __locale_mb_cur_max
0101d080 g     O .bss	00000004 adc_busy
0101a58c g     F .text	00000180 __call_exitprocs
01002030 g     F .text	0000009c vAltStartComTestTasks
0172a35a g     O .bss	00000400 test
0101d088 g     O .bss	00000004 __mlocale_changed
01006e98 g     F .text	000000b0 ulTaskNotifyTake
0101ce74 g     O .rwdata	00000004 __malloc_sbrk_base
01000250 g     F .text	00000048 _start
0101d0b0 g     O .bss	00000004 _alt_tick_rate
01005f9c g     F .text	0000002c vTaskSuspendAll
0101ce56 g     O .rwdata	00000005 R22_CRC_REGISTERS_IC_2_Default
01006148 g     F .text	0000002c xTaskGetTickCountFromISR
01008bb4 g     F .text	00000074 eth_ocm_set_phy_addr
0101000c g     F .text	00000148 __lshift
0101d0b4 g     O .bss	00000004 _alt_nticks
01016928 g     F .text	000000fc read
01016d3c g     F .text	000000a0 alt_sys_init
0101d044 g     O .bss	00000001 R27_ROUTING_MATRIX_INPUTS_IC_1_Default
01003a1c g     F .text	00000098 uxListRemove
0101a474 g     F .text	00000118 __register_exitproc
0100fcd4 g     F .text	000001f8 __multiply
010172ac g     F .text	00000068 altera_avalon_jtag_uart_close
01006b44 g     F .text	00000128 vTaskPriorityInherit
0101d078 g     O .bss	00000008 adc
0172a75c g     O .bss	00000028 __malloc_current_mallinfo
010074e4 g     F .text	00000078 xTaskNotifyStateClear
01005d18 g     F .text	000000cc vTaskResume
01010520 g     F .text	0000014c __d2b
0101d047 g     O .bss	00000001 R30_DSP_SLEW_MODES_IC_1_Default
01006398 g     F .text	000000d8 vTaskSwitchContext
0101d04d g     O .bss	00000004 R6_ALC_CONTROL_REGISTERS_IC_2_Default
01016ddc g     F .text	00000060 altera_avalon_jtag_uart_read_fd
0101a308 g     F .text	000000a4 alt_get_fd
010197e8 g     F .text	00000158 alt_busy_sleep
01012a34 g     F .text	00000054 _close_r
01006f48 g     F .text	000000f4 xTaskNotifyWait
0101a3f8 g     F .text	0000007c memcmp
01016e9c g     F .text	00000050 altera_avalon_jtag_uart_close_fd
0172aea0 g       *ABS*	00000000 __alt_stack_base
0101ce30 g     O .rwdata	00000001 R39_DEJITTER_REGISTER_CONTROL_IC_1_Default
01016eec g     F .text	00000054 altera_avalon_jtag_uart_ioctl_fd
0101d049 g     O .bss	00000001 R38_DEJITTER_REGISTER_CONTROL_IC_1_Default
0101d03e g     O .bss	00000002 R11_CONVERTER_CONTROL_REGISTERS_IC_1_Default
0100c10c g     F .text	00000154 __swsetup_r
01018630 g     F .text	00000044 adc_interrupt_enable
01005ba4 g     F .text	000000e0 vTaskSuspend
0101450c g     F .text	000008e8 .hidden __divdf3
010187b0 g     F .text	000000cc alt_onchip_flash_read
0100dfb0 g     F .text	00000118 __sfp
01010784 g     F .text	00000078 __copybits
01006174 g     F .text	00000020 uxTaskGetNumberOfTasks
0101b5b8 g     O .rwdata	00000408 __malloc_av_
0100e0fc g     F .text	00000004 __sinit_lock_release
0101504c g     F .text	00000718 .hidden __muldf3
0101101c g     F .text	00000054 __sread
0101a200 g     F .text	00000108 alt_find_file
010199f4 g     F .text	000000a4 alt_dev_llist_insert
010168a4 g     F .text	00000024 __malloc_lock
01016abc g     F .text	000000b0 sbrk
0100460c g     F .text	000000a4 xQueueTakeMutexRecursive
0100dd04 g     F .text	0000005c _fflush_r
0101cf18 g     O .bss	00000004 xHighestPriorityTask
01012a88 g     F .text	000000c4 _calloc_r
0101ceb0 g     O .rwdata	00000008 alt_flash_dev_list
0100703c g     F .text	000001a4 xTaskGenericNotify
0101ce65 g     O .rwdata	00000001 R36_SAMPLE_RATE_SETTING_IC_2_Default
0101cec0 g       *ABS*	00000000 __bss_start
0101ce08 g     O .rwdata	00000004 R6_ALC_CONTROL_REGISTERS_IC_1_Default
01009b1c g     F .text	00000128 memset
01008884 g     F .text	0000017c main
0101ce1a g     O .rwdata	00000001 R13_SERIAL_PORT_PAD_CONTROL_REGISTERS_IC_1_Default
0101d0ac g     O .bss	00000004 alt_envp
010018c0 g     F .text	00000098 vCreateBlockTimeTasks
0101d090 g     O .bss	00000004 __malloc_max_total_mem
01016e3c g     F .text	00000060 altera_avalon_jtag_uart_write_fd
010129bc g     F .text	00000018 __swbuf
0101ce04 g     O .rwdata	00000002 R4_DELAY_IC_1_Default
010182b8 g     F .text	000000ac alt_adc_word_read
01003944 g     F .text	000000d8 vListInsert
01011150 g     F .text	00000008 __sclose
01800000 g       *ABS*	00000000 __alt_heap_limit
01012c3c g     F .text	00000014 fclose
0100c460 g     F .text	00001688 _dtoa_r
0100ee40 g     F .text	0000080c _malloc_r
01013124 g     F .text	00000030 __ascii_wctomb
0101ce94 g     O .rwdata	00000004 alt_errno
0101ce5b g     O .rwdata	00000002 R24_NON_MODULO_REGISTERS_IC_2_Default
010057fc g     F .text	000000f0 vTaskDelayUntil
0101950c g     F .text	00000090 alt_onchip_flash_poll_for_status_to_go_idle
01003650 g     F .text	000000b8 xAreSemaphoreTasksStillRunning
0101ce14 g     O .rwdata	00000003 R9_ADC_CONTROL_REGISTERS_IC_1_Default
0100ea20 g     F .text	000000c4 _fwalk
0101d051 g     O .bss	00000001 R7_MICCTRLREGISTER_IC_2_Default
01004cb4 g     F .text	000000e4 xQueueReceiveFromISR
01006b1c g     F .text	00000028 xTaskGetCurrentTaskHandle
01010928 g     F .text	000000c8 putc
010096ac g     F .text	00000084 .hidden __divsi3
0100439c g     F .text	000000a0 xQueueGenericCreate
0101ce2e g     O .rwdata	00000001 R36_SAMPLE_RATE_SETTING_IC_1_Default
0100e130 g     F .text	00000124 _malloc_trim_r
0101a740 g       *ABS*	00000000 __CTOR_END__
01019030 g     F .text	000004dc altera_onchip_flash_init
01011158 g     F .text	000000dc strcmp
010046b0 g     F .text	00000058 xQueueCreateCountingSemaphore
0101a740 g       *ABS*	00000000 __DTOR_LIST__
0101d064 g     O .bss	00000004 led_toggle
0101cf60 g     O .bss	00000004 xCreatedTask
010071e0 g     F .text	000001e0 xTaskGenericNotifyFromISR
01014df4 g     F .text	00000088 .hidden __nedf2
01016d04 g     F .text	00000038 alt_irq_init
01002db4 g     F .text	00000084 vStartIntegerMathTasks
01006618 g     F .text	000000d8 xTaskRemoveFromUnorderedEventList
01016a24 g     F .text	00000064 alt_release_fd
01005fc8 g     F .text	00000158 xTaskResumeAll
0101ce2c g     O .rwdata	00000002 R32_CLOCK_ENABLE_REGISTERS_IC_1_Default
0101ce55 g     O .rwdata	00000001 R21_DSP_ENABLE_REGISTER_IC_2_Default
01004e54 g     F .text	00000054 uxQueueSpacesAvailable
0101aacf g     O .rodata	00000100 .hidden __clz_tab
01005ec4 g     F .text	00000090 vTaskStartScheduler
0101d084 g     O .bss	00000004 _PathLocale
0101ce43 g     O .rwdata	00000008 R8_RECORD_INPUT_SIGNAL_PATH_REGISTERS_IC_2_Default
0101a3ac g     F .text	00000014 atexit
010129d4 g     F .text	00000060 _write_r
01003ab4 g     F .text	00000028 prvReadGp
0100ec60 g     F .text	00000018 setlocale
01005318 g     F .text	00000048 xQueueIsQueueFullFromISR
0100136c g     F .text	000000ec vStartQueuePeekTasks
0101ce1b g     O .rwdata	00000002 R14_COMMUNICATION_PORT_PAD_CONTROL_REGISTERS_IC_1_Default
0101ce6c g     O .rwdata	00000004 _impure_ptr
0101d0a4 g     O .bss	00000004 alt_argc
01008828 g     F .text	0000005c adc_init
0100dae8 g     F .text	0000021c __sflush_r
0100771c g     F .text	00000074 xSerialGetChar
01019af8 g     F .text	00000060 _do_dtors
0100ec4c g     F .text	00000008 __locale_cjk_lang
01002ecc g     F .text	0000007c xAreIntegerMathsTaskStillRunning
01001134 g     F .text	00000098 vStartPolledQueueTasks
010022d4 g     F .text	00000104 vStartCountingSemaphoreTasks
0101ce2b g     O .rwdata	00000001 R26_SAMPLE_RATE_SETTING_IC_1_Default
010103b0 g     F .text	00000064 __ulp
01003708 g     F .text	00000024 vParTestInitialise
0100e118 g     F .text	00000018 __fp_unlock_all
01006808 g     F .text	00000028 vTaskMissedYield
0101ce80 g     O .rwdata	00000008 alt_fs_list
01018a80 g     F .text	000002d8 alt_onchip_flash_write_block
0101ce51 g     O .rwdata	00000001 R13_SERIAL_PORT_PAD_CONTROL_REGISTERS_IC_2_Default
01004e14 g     F .text	00000040 uxQueueMessagesWaiting
01004a80 g     F .text	00000234 xQueueGenericReceive
01008494 g     F .text	00000354 default_download_IC_2
010061d4 g     F .text	000001c4 xTaskIncrementTick
0101ce31 g     O .rwdata	00000008 NON_MODULO_RAM_Data_IC_2
0100ec78 g     F .text	0000000c localeconv
0101ce1e g     O .rwdata	00000001 R21_DSP_ENABLE_REGISTER_IC_1_Default
01000000 g       *ABS*	00000000 __alt_mem_new_sdram_controller_0
0101cdc8 g     O .rwdata	0000001c eth_ocm_0
0101d040 g     O .bss	00000004 R23_GPIO_REGISTERS_IC_1_Default
01016488 g     F .text	00000050 alt_ic_isr_register
01004288 g     F .text	00000114 xQueueGenericReset
0101cec0 g       *ABS*	00000000 _edata
010026b4 g     F .text	00000068 vCreateSuicidalTasks
01017938 g     F .text	00000060 altera_avalon_uart_read_fd
01018d58 g     F .text	000002d8 alt_onchip_flash_write
0172aea0 g       *ABS*	00000000 _end
01019be8 g     F .text	00000068 alt_flash_open_dev
01018700 g     F .text	00000040 adc_interrupt_asserted
01012c50 g     F .text	00000164 __fputwc
01017314 g     F .text	000000f0 altera_avalon_jtag_uart_ioctl
0101ce3a g     O .rwdata	00000001 R2_CLKCTRLREGISTER_IC_2_Default
01005360 g     F .text	000000e8 xTaskCreate
0101d038 g     O .bss	00000004 uartControl
01008ca0 g     F .text	0000007c eth_ocm_read_phy_reg
0101ce26 g     O .rwdata	00000005 R25_WATCHDOG_REGISTERS_IC_1_Default
010041f4 g     F .text	00000020 vPortInitialiseBlocks
0101b10c g     O .rwdata	0000000e R10_PLAYBACK_OUTPUT_SIGNAL_PATH_REGISTERS_IC_2_Default
01016560 g     F .text	0000008c alt_ic_irq_disable
01011078 g     F .text	0000007c __swrite
0101ce78 g     O .rwdata	00000004 __malloc_trim_threshold
010186bc g     F .text	00000044 adc_clear_interrupt_status
0100ec40 g     F .text	0000000c __locale_msgcharset
0101a3c0 g     F .text	00000038 exit
0100eae4 g     F .text	000000c4 _fwalk_reent
010101b4 g     F .text	000001fc __mdiff
01019c50 g     F .text	00000054 alt_flash_close_dev
01009730 g     F .text	00000074 .hidden __modsi3
0101ce5d g     O .rwdata	00000005 R25_WATCHDOG_REGISTERS_IC_2_Default
010058ec g     F .text	0000005c vTaskDelay
01800000 g       *ABS*	00000000 __alt_data_end
0100e0f4 g     F .text	00000004 __sfp_lock_release
0101d059 g     O .bss	00000001 R28_ROUTING_MATRIX_OUTPUTS_IC_2_Default
0101d05e g     O .bss	00000001 start
0101cf8c g     O .bss	00000004 xSuspendedTestQueue
01017dbc g     F .text	00000054 altera_avalon_uart_close
01018470 g     F .text	00000040 altera_modular_adc_open
0101a70c g     F .text	00000034 _exit
010196bc g     F .text	0000012c alt_alarm_start
0101cdfd g     O .rwdata	00000001 R2_CLKCTRLREGISTER_IC_1_Default
0100ec84 g     F .text	000001bc __smakebuf_r
0101d05b g     O .bss	00000001 R30_DSP_SLEW_MODES_IC_2_Default
01006dbc g     F .text	00000060 vTaskExitCritical
01002c38 g     F .text	00000080 xAreDynamicPriorityTasksStillRunning
01009da4 g     F .text	00000098 strlen
01003adc g     F .text	000000e0 pxPortInitialiseStack
01019ee4 g     F .text	00000154 open
01014e7c g     F .text	000000dc .hidden __gedf2
010185b4 g     F .text	0000007c adc_recalibrate
0101ce7c g     O .rwdata	00000004 __wctomb
0101d058 g     O .bss	00000001 R27_ROUTING_MATRIX_INPUTS_IC_2_Default
01011330 g     F .text	00000018 __sprint_r
010066f0 g     F .text	0000003c vTaskSetTimeOutState
0101d060 g     O .bss	00000004 phy_adr
01007a4c g     F .text	00000080 i2c_setup
0101ce98 g     O .rwdata	00000004 alt_priority_mask
010164d8 g     F .text	00000088 alt_ic_irq_enable
0100c034 g     F .text	0000001c __vfprintf_internal
01017e4c g     F .text	000001dc altera_avalon_uart_read
01013154 g     F .text	0000005c _wctomb_r
01004ea8 g     F .text	00000030 uxQueueMessagesWaitingFromISR
01005280 g     F .text	00000040 xQueueIsQueueEmptyFromISR
01008140 g     F .text	00000354 default_download_IC_1
01015764 g     F .text	000008fc .hidden __subdf3
010032f4 g     F .text	000001d8 vStartSemaphoreTasks
0101d070 g     O .bss	00000008 dtest
0100fbe8 g     F .text	000000b0 __lo0bits
0101d054 g     O .bss	00000004 R23_GPIO_REGISTERS_IC_2_Default
0101ceb8 g     O .rwdata	00000008 alt_alarm_list
01019a98 g     F .text	00000060 _do_ctors
01006e1c g     F .text	00000044 uxTaskResetEventItemValue
01013064 g     F .text	000000c0 wcrtomb
01004520 g     F .text	0000005c xQueueCreateMutex
0101cdfc g     O .rwdata	00000001 R0_SAMPLE_RATE_SETTING_IC_1_Default
010162a0 g     F .text	000000d0 close
01007644 g     F .text	000000b4 xSerialPortInitMinimal
010073c0 g     F .text	00000124 vTaskNotifyGiveFromISR
010049a4 g     F .text	000000dc xQueueGiveFromISR
01012dd8 g     F .text	00000080 fputwc
01007b74 g     F .text	000000b0 i2c_write_byte
010183d8 g     F .text	00000098 alt_adc_register_callback
0100e0f8 g     F .text	00000004 __sinit_lock_acquire
0101d048 g     O .bss	00000001 R31_SERIAL_PORT_SAMPLE_RATE_SETTING_IC_1_Default
0100f95c g     F .text	00000120 __multadd
0100f934 g     F .text	00000028 _Bfree



Disassembly of section .exceptions:

01000020 <save_context>:
# Entry point for exceptions.
.section .exceptions.entry, "xa"		

# Save the entire context of a task.
save_context:
	addi	ea, ea, -4			# Point to the next instruction.
 1000020:	ef7fff04 	addi	ea,ea,-4
	addi	sp,	sp, -116		# Create space on the stack.
 1000024:	deffe304 	addi	sp,sp,-116
	stw		ra, 0(sp)
 1000028:	dfc00015 	stw	ra,0(sp)
								# Leave a gap for muldiv 0
	stw		at, 8(sp)		 
 100002c:	d8400215 	stw	at,8(sp)
	stw		r2, 12(sp)
 1000030:	d8800315 	stw	r2,12(sp)
	stw		r3, 16(sp)
 1000034:	d8c00415 	stw	r3,16(sp)
	stw		r4, 20(sp)
 1000038:	d9000515 	stw	r4,20(sp)
	stw		r5, 24(sp) 
 100003c:	d9400615 	stw	r5,24(sp)
	stw		r6, 28(sp) 
 1000040:	d9800715 	stw	r6,28(sp)
	stw		r7, 32(sp) 
 1000044:	d9c00815 	stw	r7,32(sp)
	stw		r8, 36(sp) 
 1000048:	da000915 	stw	r8,36(sp)
	stw		r9, 40(sp) 
 100004c:	da400a15 	stw	r9,40(sp)
	stw		r10, 44(sp)
 1000050:	da800b15 	stw	r10,44(sp)
	stw		r11, 48(sp)
 1000054:	dac00c15 	stw	r11,48(sp)
	stw		r12, 52(sp)
 1000058:	db000d15 	stw	r12,52(sp)
	stw		r13, 56(sp)
 100005c:	db400e15 	stw	r13,56(sp)
	stw		r14, 60(sp)
 1000060:	db800f15 	stw	r14,60(sp)
	stw		r15, 64(sp)
 1000064:	dbc01015 	stw	r15,64(sp)
	rdctl	r5, estatus 		# Save the eStatus
 1000068:	000b307a 	rdctl	r5,estatus
	stw		r5, 68(sp)
 100006c:	d9401115 	stw	r5,68(sp)
	stw		ea, 72(sp)			# Save the PC
 1000070:	df401215 	stw	ea,72(sp)
	stw		r16, 76(sp)			# Save the remaining registers
 1000074:	dc001315 	stw	r16,76(sp)
	stw		r17, 80(sp)
 1000078:	dc401415 	stw	r17,80(sp)
	stw		r18, 84(sp)
 100007c:	dc801515 	stw	r18,84(sp)
	stw		r19, 88(sp)
 1000080:	dcc01615 	stw	r19,88(sp)
	stw		r20, 92(sp)
 1000084:	dd001715 	stw	r20,92(sp)
	stw		r21, 96(sp)
 1000088:	dd401815 	stw	r21,96(sp)
	stw		r22, 100(sp)
 100008c:	dd801915 	stw	r22,100(sp)
	stw		r23, 104(sp)
 1000090:	ddc01a15 	stw	r23,104(sp)
	stw		gp, 108(sp)
 1000094:	de801b15 	stw	gp,108(sp)
	stw		fp, 112(sp)
 1000098:	df001c15 	stw	fp,112(sp)

0100009c <save_sp_to_pxCurrentTCB>:
 100009c:	060040b4 	movhi	et,258

save_sp_to_pxCurrentTCB:
	movia	et, pxCurrentTCB	# Load the address of the pxCurrentTCB pointer
 10000a0:	c633fd04 	addi	et,et,-12300
	ldw		et, (et)			# Load the value of the pxCurrentTCB pointer
 10000a4:	c6000017 	ldw	et,0(et)
	stw		sp, (et)			# Store the stack pointer into the top of the TCB
 10000a8:	c6c00015 	stw	sp,0(et)

010000ac <hw_irq_test>:
hw_irq_test:
	/*
     * Test to see if the exception was a software exception or caused 
     * by an external interrupt, and vector accordingly.
     */
    rdctl	r4, ipending		# Load the Pending Interrupts indication
 10000ac:	0009313a 	rdctl	r4,ipending
	rdctl	r5, estatus 		# Load the eStatus (enabled interrupts).
 10000b0:	000b307a 	rdctl	r5,estatus
    andi	r2, r5, 1			# Are interrupts enabled globally.
 10000b4:	2880004c 	andi	r2,r5,1
    beq		r2, zero, soft_exceptions		# Interrupts are not enabled.
 10000b8:	10002526 	beq	r2,zero,1000150 <soft_exceptions>
    beq		r4, zero, soft_exceptions		# There are no interrupts triggered.
 10000bc:	20002426 	beq	r4,zero,1000150 <soft_exceptions>

010000c0 <hw_irq_handler>:

	.section .exceptions.irqhandler, "xa"
hw_irq_handler:
	call	alt_irq_handler					# Call the alt_irq_handler to deliver to the registered interrupt handler.
 10000c0:	100017c0 	call	100017c <alt_irq_handler>

010000c4 <restore_sp_from_pxCurrentTCB>:
 10000c4:	060040b4 	movhi	et,258

    .section .exceptions.irqreturn, "xa"
restore_sp_from_pxCurrentTCB:
	movia	et, pxCurrentTCB		# Load the address of the pxCurrentTCB pointer
 10000c8:	c633fd04 	addi	et,et,-12300
	ldw		et, (et)				# Load the value of the pxCurrentTCB pointer
 10000cc:	c6000017 	ldw	et,0(et)
	ldw		sp, (et)				# Load the stack pointer with the top value of the TCB
 10000d0:	c6c00017 	ldw	sp,0(et)

010000d4 <restore_context>:

restore_context:
	ldw		ra, 0(sp)		# Restore the registers.
 10000d4:	dfc00017 	ldw	ra,0(sp)
							# Leave a gap for muldiv 0.
	ldw		at, 8(sp)
 10000d8:	d8400217 	ldw	at,8(sp)
	ldw		r2, 12(sp)
 10000dc:	d8800317 	ldw	r2,12(sp)
	ldw		r3, 16(sp)
 10000e0:	d8c00417 	ldw	r3,16(sp)
	ldw		r4, 20(sp)
 10000e4:	d9000517 	ldw	r4,20(sp)
	ldw		r5, 24(sp) 
 10000e8:	d9400617 	ldw	r5,24(sp)
	ldw		r6, 28(sp) 
 10000ec:	d9800717 	ldw	r6,28(sp)
	ldw		r7, 32(sp) 
 10000f0:	d9c00817 	ldw	r7,32(sp)
	ldw		r8, 36(sp) 
 10000f4:	da000917 	ldw	r8,36(sp)
	ldw		r9, 40(sp) 
 10000f8:	da400a17 	ldw	r9,40(sp)
	ldw		r10, 44(sp)
 10000fc:	da800b17 	ldw	r10,44(sp)
	ldw		r11, 48(sp)
 1000100:	dac00c17 	ldw	r11,48(sp)
	ldw		r12, 52(sp)
 1000104:	db000d17 	ldw	r12,52(sp)
	ldw		r13, 56(sp)
 1000108:	db400e17 	ldw	r13,56(sp)
	ldw		r14, 60(sp)
 100010c:	db800f17 	ldw	r14,60(sp)
	ldw		r15, 64(sp)
 1000110:	dbc01017 	ldw	r15,64(sp)
	ldw		et, 68(sp)		# Load the eStatus
 1000114:	de001117 	ldw	et,68(sp)
	wrctl	estatus, et 	# Write the eStatus
 1000118:	c001707a 	wrctl	estatus,et
	ldw		ea, 72(sp)		# Load the Program Counter
 100011c:	df401217 	ldw	ea,72(sp)
	ldw		r16, 76(sp)
 1000120:	dc001317 	ldw	r16,76(sp)
	ldw		r17, 80(sp)
 1000124:	dc401417 	ldw	r17,80(sp)
	ldw		r18, 84(sp)
 1000128:	dc801517 	ldw	r18,84(sp)
	ldw		r19, 88(sp)
 100012c:	dcc01617 	ldw	r19,88(sp)
	ldw		r20, 92(sp)
 1000130:	dd001717 	ldw	r20,92(sp)
	ldw		r21, 96(sp)
 1000134:	dd401817 	ldw	r21,96(sp)
	ldw		r22, 100(sp)
 1000138:	dd801917 	ldw	r22,100(sp)
	ldw		r23, 104(sp)
 100013c:	ddc01a17 	ldw	r23,104(sp)
	ldw		gp, 108(sp)
 1000140:	de801b17 	ldw	gp,108(sp)
	ldw		fp, 112(sp)
 1000144:	df001c17 	ldw	fp,112(sp)
	addi	sp,	sp, 116		# Release stack space
 1000148:	dec01d04 	addi	sp,sp,116

    eret					# Return to address ea, loading eStatus into Status.
 100014c:	ef80083a 	eret

01000150 <soft_exceptions>:
   
	.section .exceptions.soft, "xa"
soft_exceptions:
	ldw		et, 0(ea)				# Load the instruction where the interrupt occured.
 1000150:	ee000017 	ldw	et,0(ea)
	movhi	at, %hi(0x003B683A)		# Load the registers with the trap instruction code
 1000154:	00400ef4 	movhi	at,59
	ori		at, at, %lo(0x003B683A)
 1000158:	085a0e94 	ori	at,at,26682
   	cmpne	et, et, at				# Compare the trap instruction code to the last excuted instruction
 100015c:	c070c03a 	cmpne	et,et,at
  	beq		et, r0, call_scheduler	# its a trap so switchcontext
 1000160:	c0000226 	beq	et,zero,100016c <call_scheduler>
  	break							# This is an un-implemented instruction or muldiv problem.
 1000164:	003da03a 	break	0
  	br		restore_context			# its something else
 1000168:	003fda06 	br	10000d4 <__alt_data_end+0xff8000d4>

0100016c <call_scheduler>:

call_scheduler:
	addi	ea, ea, 4						# A trap was called, increment the program counter so it is not called again.
 100016c:	ef400104 	addi	ea,ea,4
	stw		ea, 72(sp)						# Save the new program counter to the context.
 1000170:	df401215 	stw	ea,72(sp)
	call	vTaskSwitchContext				# Pick the next context.
 1000174:	10063980 	call	1006398 <vTaskSwitchContext>
	br		restore_sp_from_pxCurrentTCB	# Switch in the task context and restore. 
 1000178:	003fd206 	br	10000c4 <__alt_data_end+0xff8000c4>

0100017c <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
 100017c:	defff904 	addi	sp,sp,-28
 1000180:	dfc00615 	stw	ra,24(sp)
 1000184:	df000515 	stw	fp,20(sp)
 1000188:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
 100018c:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
 1000190:	0005313a 	rdctl	r2,ipending
 1000194:	e0bffe15 	stw	r2,-8(fp)

  return active;
 1000198:	e0bffe17 	ldw	r2,-8(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
 100019c:	e0bffb15 	stw	r2,-20(fp)

  do
  {
    i = 0;
 10001a0:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
 10001a4:	00800044 	movi	r2,1
 10001a8:	e0bffc15 	stw	r2,-16(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
 10001ac:	e0fffb17 	ldw	r3,-20(fp)
 10001b0:	e0bffc17 	ldw	r2,-16(fp)
 10001b4:	1884703a 	and	r2,r3,r2
 10001b8:	10001426 	beq	r2,zero,100020c <alt_irq_handler+0x90>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
 10001bc:	00805cf4 	movhi	r2,371
 10001c0:	10ab6804 	addi	r2,r2,-21088
 10001c4:	e0fffd17 	ldw	r3,-12(fp)
 10001c8:	180690fa 	slli	r3,r3,3
 10001cc:	10c5883a 	add	r2,r2,r3
 10001d0:	10c00017 	ldw	r3,0(r2)
 10001d4:	00805cf4 	movhi	r2,371
 10001d8:	10ab6804 	addi	r2,r2,-21088
 10001dc:	e13ffd17 	ldw	r4,-12(fp)
 10001e0:	200890fa 	slli	r4,r4,3
 10001e4:	1105883a 	add	r2,r2,r4
 10001e8:	10800104 	addi	r2,r2,4
 10001ec:	10800017 	ldw	r2,0(r2)
 10001f0:	1009883a 	mov	r4,r2
 10001f4:	183ee83a 	callr	r3
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
 10001f8:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
 10001fc:	0005313a 	rdctl	r2,ipending
 1000200:	e0bfff15 	stw	r2,-4(fp)

  return active;
 1000204:	e0bfff17 	ldw	r2,-4(fp)
 1000208:	00000706 	br	1000228 <alt_irq_handler+0xac>
      }
      mask <<= 1;
 100020c:	e0bffc17 	ldw	r2,-16(fp)
 1000210:	1085883a 	add	r2,r2,r2
 1000214:	e0bffc15 	stw	r2,-16(fp)
      i++;
 1000218:	e0bffd17 	ldw	r2,-12(fp)
 100021c:	10800044 	addi	r2,r2,1
 1000220:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
 1000224:	003fe106 	br	10001ac <__alt_data_end+0xff8001ac>

    active = alt_irq_pending ();
 1000228:	e0bffb15 	stw	r2,-20(fp)
    
  } while (active);
 100022c:	e0bffb17 	ldw	r2,-20(fp)
 1000230:	103fdb1e 	bne	r2,zero,10001a0 <__alt_data_end+0xff8001a0>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
 1000234:	0001883a 	nop
}
 1000238:	0001883a 	nop
 100023c:	e037883a 	mov	sp,fp
 1000240:	dfc00117 	ldw	ra,4(sp)
 1000244:	df000017 	ldw	fp,0(sp)
 1000248:	dec00204 	addi	sp,sp,8
 100024c:	f800283a 	ret

Disassembly of section .text:

01000250 <_start>:

    /* Assume the data cache size is always a power of two. */
#if NIOS2_DCACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_DCACHE_SIZE)
#else
    movui r2, NIOS2_DCACHE_SIZE
 1000250:	00820014 	movui	r2,2048
#endif

0:
    initd 0(r2)
 1000254:	10000033 	initd	0(r2)
#ifdef NIOS2_ECC_PRESENT
    addi r2, r2, -4
#else
    addi r2, r2, -NIOS2_DCACHE_LINE_SIZE
 1000258:	10bff804 	addi	r2,r2,-32
#endif
    bgt r2, zero, 0b
 100025c:	00bffd16 	blt	zero,r2,1000254 <__alt_data_end+0xff800254>

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
 1000260:	06c06034 	movhi	sp,384
    ori sp, sp, %lo(__alt_stack_pointer)
 1000264:	dec00014 	ori	sp,sp,0
    movhi gp, %hi(_gp)
 1000268:	068040b4 	movhi	gp,258
    ori gp, gp, %lo(_gp)
 100026c:	d6937914 	ori	gp,gp,19940
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
 1000270:	00804074 	movhi	r2,257
    ori r2, r2, %lo(__bss_start)
 1000274:	10b3b014 	ori	r2,r2,52928

    movhi r3, %hi(__bss_end)
 1000278:	00c05cb4 	movhi	r3,370
    ori r3, r3, %lo(__bss_end)
 100027c:	18eba814 	ori	r3,r3,44704

    beq r2, r3, 1f
 1000280:	10c00326 	beq	r2,r3,1000290 <_start+0x40>

0:
    stw zero, (r2)
 1000284:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
 1000288:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
 100028c:	10fffd36 	bltu	r2,r3,1000284 <__alt_data_end+0xff800284>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
 1000290:	10168280 	call	1016828 <alt_main>

01000294 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
 1000294:	003fff06 	br	1000294 <__alt_data_end+0xff800294>

01000298 <vStartBlockingQueueTasks>:
static volatile short sBlockingProducerCount[ blckqNUM_TASK_SETS ] = { ( uint16_t ) 0, ( uint16_t ) 0, ( uint16_t ) 0 };

/*-----------------------------------------------------------*/

void vStartBlockingQueueTasks( UBaseType_t uxPriority )
{
 1000298:	defff104 	addi	sp,sp,-60
 100029c:	dfc00e15 	stw	ra,56(sp)
 10002a0:	df000d15 	stw	fp,52(sp)
 10002a4:	df000d04 	addi	fp,sp,52
 10002a8:	e13fff15 	stw	r4,-4(fp)
xBlockingQueueParameters *pxQueueParameters1, *pxQueueParameters2;
xBlockingQueueParameters *pxQueueParameters3, *pxQueueParameters4;
xBlockingQueueParameters *pxQueueParameters5, *pxQueueParameters6;
const UBaseType_t uxQueueSize1 = 1, uxQueueSize5 = 5;
 10002ac:	00800044 	movi	r2,1
 10002b0:	e0bff515 	stw	r2,-44(fp)
 10002b4:	00800144 	movi	r2,5
 10002b8:	e0bff615 	stw	r2,-40(fp)
const TickType_t xBlockTime = pdMS_TO_TICKS( ( TickType_t ) 1000 );
 10002bc:	0080fa04 	movi	r2,1000
 10002c0:	e0bff715 	stw	r2,-36(fp)
const TickType_t xDontBlock = ( TickType_t ) 0;
 10002c4:	e03ff815 	stw	zero,-32(fp)

	/* Create the first two tasks as described at the top of the file. */

	/* First create the structure used to pass parameters to the consumer tasks. */
	pxQueueParameters1 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
 10002c8:	01000304 	movi	r4,12
 10002cc:	1003f340 	call	1003f34 <pvPortMalloc>
 10002d0:	e0bff915 	stw	r2,-28(fp)

	/* Create the queue used by the first two tasks to pass the incrementing number.
	Pass a pointer to the queue in the parameter structure. */
	pxQueueParameters1->xQueue = xQueueCreate( uxQueueSize1, ( UBaseType_t ) sizeof( uint16_t ) );
 10002d4:	000d883a 	mov	r6,zero
 10002d8:	01400084 	movi	r5,2
 10002dc:	e13ff517 	ldw	r4,-44(fp)
 10002e0:	100439c0 	call	100439c <xQueueGenericCreate>
 10002e4:	1007883a 	mov	r3,r2
 10002e8:	e0bff917 	ldw	r2,-28(fp)
 10002ec:	10c00015 	stw	r3,0(r2)

	/* The consumer is created first so gets a block time as described above. */
	pxQueueParameters1->xBlockTime = xBlockTime;
 10002f0:	e0bff917 	ldw	r2,-28(fp)
 10002f4:	e0fff717 	ldw	r3,-36(fp)
 10002f8:	10c00115 	stw	r3,4(r2)

	/* Pass in the variable that this task is going to increment so we can check it
	is still running. */
	pxQueueParameters1->psCheckVariable = &( sBlockingConsumerCount[ 0 ] );
 10002fc:	e0bff917 	ldw	r2,-28(fp)
 1000300:	d0e03704 	addi	r3,gp,-32548
 1000304:	10c00215 	stw	r3,8(r2)

	/* Create the structure used to pass parameters to the producer task. */
	pxQueueParameters2 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
 1000308:	01000304 	movi	r4,12
 100030c:	1003f340 	call	1003f34 <pvPortMalloc>
 1000310:	e0bffa15 	stw	r2,-24(fp)

	/* Pass the queue to this task also, using the parameter structure. */
	pxQueueParameters2->xQueue = pxQueueParameters1->xQueue;
 1000314:	e0bff917 	ldw	r2,-28(fp)
 1000318:	10c00017 	ldw	r3,0(r2)
 100031c:	e0bffa17 	ldw	r2,-24(fp)
 1000320:	10c00015 	stw	r3,0(r2)

	/* The producer is not going to block - as soon as it posts the consumer will
	wake and remove the item so the producer should always have room to post. */
	pxQueueParameters2->xBlockTime = xDontBlock;
 1000324:	e0bffa17 	ldw	r2,-24(fp)
 1000328:	e0fff817 	ldw	r3,-32(fp)
 100032c:	10c00115 	stw	r3,4(r2)

	/* Pass in the variable that this task is going to increment so we can check
	it is still running. */
	pxQueueParameters2->psCheckVariable = &( sBlockingProducerCount[ 0 ] );
 1000330:	e0bffa17 	ldw	r2,-24(fp)
 1000334:	d0e03884 	addi	r3,gp,-32542
 1000338:	10c00215 	stw	r3,8(r2)


	/* Note the producer has a lower priority than the consumer when the tasks are
	spawned. */
	xTaskCreate( vBlockingQueueConsumer, "QConsB1", blckqSTACK_SIZE, ( void * ) pxQueueParameters1, uxPriority, NULL );
 100033c:	d8000115 	stw	zero,4(sp)
 1000340:	e0bfff17 	ldw	r2,-4(fp)
 1000344:	d8800015 	stw	r2,0(sp)
 1000348:	e1fff917 	ldw	r7,-28(fp)
 100034c:	01810004 	movi	r6,1024
 1000350:	014040b4 	movhi	r5,258
 1000354:	2969d004 	addi	r5,r5,-22720
 1000358:	01004034 	movhi	r4,256
 100035c:	21016a04 	addi	r4,r4,1448
 1000360:	10053600 	call	1005360 <xTaskCreate>
	xTaskCreate( vBlockingQueueProducer, "QProdB2", blckqSTACK_SIZE, ( void * ) pxQueueParameters2, tskIDLE_PRIORITY, NULL );
 1000364:	d8000115 	stw	zero,4(sp)
 1000368:	d8000015 	stw	zero,0(sp)
 100036c:	e1fffa17 	ldw	r7,-24(fp)
 1000370:	01810004 	movi	r6,1024
 1000374:	014040b4 	movhi	r5,258
 1000378:	2969d204 	addi	r5,r5,-22712
 100037c:	01004034 	movhi	r4,256
 1000380:	21014704 	addi	r4,r4,1308
 1000384:	10053600 	call	1005360 <xTaskCreate>


	/* Create the second two tasks as described at the top of the file.   This uses
	the same mechanism but reverses the task priorities. */

	pxQueueParameters3 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
 1000388:	01000304 	movi	r4,12
 100038c:	1003f340 	call	1003f34 <pvPortMalloc>
 1000390:	e0bffb15 	stw	r2,-20(fp)
	pxQueueParameters3->xQueue = xQueueCreate( uxQueueSize1, ( UBaseType_t ) sizeof( uint16_t ) );
 1000394:	000d883a 	mov	r6,zero
 1000398:	01400084 	movi	r5,2
 100039c:	e13ff517 	ldw	r4,-44(fp)
 10003a0:	100439c0 	call	100439c <xQueueGenericCreate>
 10003a4:	1007883a 	mov	r3,r2
 10003a8:	e0bffb17 	ldw	r2,-20(fp)
 10003ac:	10c00015 	stw	r3,0(r2)
	pxQueueParameters3->xBlockTime = xDontBlock;
 10003b0:	e0bffb17 	ldw	r2,-20(fp)
 10003b4:	e0fff817 	ldw	r3,-32(fp)
 10003b8:	10c00115 	stw	r3,4(r2)
	pxQueueParameters3->psCheckVariable = &( sBlockingProducerCount[ 1 ] );
 10003bc:	e0bffb17 	ldw	r2,-20(fp)
 10003c0:	d0e03904 	addi	r3,gp,-32540
 10003c4:	10c00215 	stw	r3,8(r2)

	pxQueueParameters4 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
 10003c8:	01000304 	movi	r4,12
 10003cc:	1003f340 	call	1003f34 <pvPortMalloc>
 10003d0:	e0bffc15 	stw	r2,-16(fp)
	pxQueueParameters4->xQueue = pxQueueParameters3->xQueue;
 10003d4:	e0bffb17 	ldw	r2,-20(fp)
 10003d8:	10c00017 	ldw	r3,0(r2)
 10003dc:	e0bffc17 	ldw	r2,-16(fp)
 10003e0:	10c00015 	stw	r3,0(r2)
	pxQueueParameters4->xBlockTime = xBlockTime;
 10003e4:	e0bffc17 	ldw	r2,-16(fp)
 10003e8:	e0fff717 	ldw	r3,-36(fp)
 10003ec:	10c00115 	stw	r3,4(r2)
	pxQueueParameters4->psCheckVariable = &( sBlockingConsumerCount[ 1 ] );
 10003f0:	e0bffc17 	ldw	r2,-16(fp)
 10003f4:	d0e03784 	addi	r3,gp,-32546
 10003f8:	10c00215 	stw	r3,8(r2)

	xTaskCreate( vBlockingQueueConsumer, "QConsB3", blckqSTACK_SIZE, ( void * ) pxQueueParameters3, tskIDLE_PRIORITY, NULL );
 10003fc:	d8000115 	stw	zero,4(sp)
 1000400:	d8000015 	stw	zero,0(sp)
 1000404:	e1fffb17 	ldw	r7,-20(fp)
 1000408:	01810004 	movi	r6,1024
 100040c:	014040b4 	movhi	r5,258
 1000410:	2969d404 	addi	r5,r5,-22704
 1000414:	01004034 	movhi	r4,256
 1000418:	21016a04 	addi	r4,r4,1448
 100041c:	10053600 	call	1005360 <xTaskCreate>
	xTaskCreate( vBlockingQueueProducer, "QProdB4", blckqSTACK_SIZE, ( void * ) pxQueueParameters4, uxPriority, NULL );
 1000420:	d8000115 	stw	zero,4(sp)
 1000424:	e0bfff17 	ldw	r2,-4(fp)
 1000428:	d8800015 	stw	r2,0(sp)
 100042c:	e1fffc17 	ldw	r7,-16(fp)
 1000430:	01810004 	movi	r6,1024
 1000434:	014040b4 	movhi	r5,258
 1000438:	2969d604 	addi	r5,r5,-22696
 100043c:	01004034 	movhi	r4,256
 1000440:	21014704 	addi	r4,r4,1308
 1000444:	10053600 	call	1005360 <xTaskCreate>



	/* Create the last two tasks as described above.  The mechanism is again just
	the same.  This time both parameter structures are given a block time. */
	pxQueueParameters5 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
 1000448:	01000304 	movi	r4,12
 100044c:	1003f340 	call	1003f34 <pvPortMalloc>
 1000450:	e0bffd15 	stw	r2,-12(fp)
	pxQueueParameters5->xQueue = xQueueCreate( uxQueueSize5, ( UBaseType_t ) sizeof( uint16_t ) );
 1000454:	000d883a 	mov	r6,zero
 1000458:	01400084 	movi	r5,2
 100045c:	e13ff617 	ldw	r4,-40(fp)
 1000460:	100439c0 	call	100439c <xQueueGenericCreate>
 1000464:	1007883a 	mov	r3,r2
 1000468:	e0bffd17 	ldw	r2,-12(fp)
 100046c:	10c00015 	stw	r3,0(r2)
	pxQueueParameters5->xBlockTime = xBlockTime;
 1000470:	e0bffd17 	ldw	r2,-12(fp)
 1000474:	e0fff717 	ldw	r3,-36(fp)
 1000478:	10c00115 	stw	r3,4(r2)
	pxQueueParameters5->psCheckVariable = &( sBlockingProducerCount[ 2 ] );
 100047c:	e0bffd17 	ldw	r2,-12(fp)
 1000480:	d0e03984 	addi	r3,gp,-32538
 1000484:	10c00215 	stw	r3,8(r2)

	pxQueueParameters6 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
 1000488:	01000304 	movi	r4,12
 100048c:	1003f340 	call	1003f34 <pvPortMalloc>
 1000490:	e0bffe15 	stw	r2,-8(fp)
	pxQueueParameters6->xQueue = pxQueueParameters5->xQueue;
 1000494:	e0bffd17 	ldw	r2,-12(fp)
 1000498:	10c00017 	ldw	r3,0(r2)
 100049c:	e0bffe17 	ldw	r2,-8(fp)
 10004a0:	10c00015 	stw	r3,0(r2)
	pxQueueParameters6->xBlockTime = xBlockTime;
 10004a4:	e0bffe17 	ldw	r2,-8(fp)
 10004a8:	e0fff717 	ldw	r3,-36(fp)
 10004ac:	10c00115 	stw	r3,4(r2)
	pxQueueParameters6->psCheckVariable = &( sBlockingConsumerCount[ 2 ] );
 10004b0:	e0bffe17 	ldw	r2,-8(fp)
 10004b4:	d0e03804 	addi	r3,gp,-32544
 10004b8:	10c00215 	stw	r3,8(r2)

	xTaskCreate( vBlockingQueueProducer, "QProdB5", blckqSTACK_SIZE, ( void * ) pxQueueParameters5, tskIDLE_PRIORITY, NULL );
 10004bc:	d8000115 	stw	zero,4(sp)
 10004c0:	d8000015 	stw	zero,0(sp)
 10004c4:	e1fffd17 	ldw	r7,-12(fp)
 10004c8:	01810004 	movi	r6,1024
 10004cc:	014040b4 	movhi	r5,258
 10004d0:	2969d804 	addi	r5,r5,-22688
 10004d4:	01004034 	movhi	r4,256
 10004d8:	21014704 	addi	r4,r4,1308
 10004dc:	10053600 	call	1005360 <xTaskCreate>
	xTaskCreate( vBlockingQueueConsumer, "QConsB6", blckqSTACK_SIZE, ( void * ) pxQueueParameters6, tskIDLE_PRIORITY, NULL );
 10004e0:	d8000115 	stw	zero,4(sp)
 10004e4:	d8000015 	stw	zero,0(sp)
 10004e8:	e1fffe17 	ldw	r7,-8(fp)
 10004ec:	01810004 	movi	r6,1024
 10004f0:	014040b4 	movhi	r5,258
 10004f4:	2969da04 	addi	r5,r5,-22680
 10004f8:	01004034 	movhi	r4,256
 10004fc:	21016a04 	addi	r4,r4,1448
 1000500:	10053600 	call	1005360 <xTaskCreate>
}
 1000504:	0001883a 	nop
 1000508:	e037883a 	mov	sp,fp
 100050c:	dfc00117 	ldw	ra,4(sp)
 1000510:	df000017 	ldw	fp,0(sp)
 1000514:	dec00204 	addi	sp,sp,8
 1000518:	f800283a 	ret

0100051c <vBlockingQueueProducer>:
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vBlockingQueueProducer, pvParameters )
{
 100051c:	defffa04 	addi	sp,sp,-24
 1000520:	dfc00515 	stw	ra,20(sp)
 1000524:	df000415 	stw	fp,16(sp)
 1000528:	df000404 	addi	fp,sp,16
 100052c:	e13fff15 	stw	r4,-4(fp)
uint16_t usValue = 0;
 1000530:	e03ffe0d 	sth	zero,-8(fp)
xBlockingQueueParameters *pxQueueParameters;
short sErrorEverOccurred = pdFALSE;
 1000534:	e03ffc0d 	sth	zero,-16(fp)

	pxQueueParameters = ( xBlockingQueueParameters * ) pvParameters;
 1000538:	e0bfff17 	ldw	r2,-4(fp)
 100053c:	e0bffd15 	stw	r2,-12(fp)

	for( ;; )
	{
		if( xQueueSend( pxQueueParameters->xQueue, ( void * ) &usValue, pxQueueParameters->xBlockTime ) != pdPASS )
 1000540:	e0bffd17 	ldw	r2,-12(fp)
 1000544:	10c00017 	ldw	r3,0(r2)
 1000548:	e0bffd17 	ldw	r2,-12(fp)
 100054c:	11000117 	ldw	r4,4(r2)
 1000550:	e0bffe04 	addi	r2,fp,-8
 1000554:	000f883a 	mov	r7,zero
 1000558:	200d883a 	mov	r6,r4
 100055c:	100b883a 	mov	r5,r2
 1000560:	1809883a 	mov	r4,r3
 1000564:	10047080 	call	1004708 <xQueueGenericSend>
 1000568:	10800060 	cmpeqi	r2,r2,1
 100056c:	1000031e 	bne	r2,zero,100057c <vBlockingQueueProducer+0x60>
		{
			sErrorEverOccurred = pdTRUE;
 1000570:	00800044 	movi	r2,1
 1000574:	e0bffc0d 	sth	r2,-16(fp)
 1000578:	003ff106 	br	1000540 <__alt_data_end+0xff800540>
		}
		else
		{
			/* We have successfully posted a message, so increment the variable
			used to check we are still running. */
			if( sErrorEverOccurred == pdFALSE )
 100057c:	e0bffc0f 	ldh	r2,-16(fp)
 1000580:	1000051e 	bne	r2,zero,1000598 <vBlockingQueueProducer+0x7c>
			{
				( *pxQueueParameters->psCheckVariable )++;
 1000584:	e0bffd17 	ldw	r2,-12(fp)
 1000588:	10800217 	ldw	r2,8(r2)
 100058c:	10c0000b 	ldhu	r3,0(r2)
 1000590:	18c00044 	addi	r3,r3,1
 1000594:	10c0000d 	sth	r3,0(r2)
			}

			/* Increment the variable we are going to post next time round.  The
			consumer will expect the numbers to	follow in numerical order. */
			++usValue;
 1000598:	e0bffe0b 	ldhu	r2,-8(fp)
 100059c:	10800044 	addi	r2,r2,1
 10005a0:	e0bffe0d 	sth	r2,-8(fp)

			#if configUSE_PREEMPTION == 0
				taskYIELD();
			#endif
		}
	}
 10005a4:	003fe606 	br	1000540 <__alt_data_end+0xff800540>

010005a8 <vBlockingQueueConsumer>:
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vBlockingQueueConsumer, pvParameters )
{
 10005a8:	defffa04 	addi	sp,sp,-24
 10005ac:	dfc00515 	stw	ra,20(sp)
 10005b0:	df000415 	stw	fp,16(sp)
 10005b4:	df000404 	addi	fp,sp,16
 10005b8:	e13fff15 	stw	r4,-4(fp)
uint16_t usData, usExpectedValue = 0;
 10005bc:	e03ffc0d 	sth	zero,-16(fp)
xBlockingQueueParameters *pxQueueParameters;
short sErrorEverOccurred = pdFALSE;
 10005c0:	e03ffc8d 	sth	zero,-14(fp)

	pxQueueParameters = ( xBlockingQueueParameters * ) pvParameters;
 10005c4:	e0bfff17 	ldw	r2,-4(fp)
 10005c8:	e0bffd15 	stw	r2,-12(fp)

	for( ;; )
	{
		if( xQueueReceive( pxQueueParameters->xQueue, &usData, pxQueueParameters->xBlockTime ) == pdPASS )
 10005cc:	e0bffd17 	ldw	r2,-12(fp)
 10005d0:	10c00017 	ldw	r3,0(r2)
 10005d4:	e0bffd17 	ldw	r2,-12(fp)
 10005d8:	11000117 	ldw	r4,4(r2)
 10005dc:	e0bffe04 	addi	r2,fp,-8
 10005e0:	000f883a 	mov	r7,zero
 10005e4:	200d883a 	mov	r6,r4
 10005e8:	100b883a 	mov	r5,r2
 10005ec:	1809883a 	mov	r4,r3
 10005f0:	1004a800 	call	1004a80 <xQueueGenericReceive>
 10005f4:	10800058 	cmpnei	r2,r2,1
 10005f8:	103ff41e 	bne	r2,zero,10005cc <__alt_data_end+0xff8005cc>
		{
			if( usData != usExpectedValue )
 10005fc:	e0bffe0b 	ldhu	r2,-8(fp)
 1000600:	10ffffcc 	andi	r3,r2,65535
 1000604:	e0bffc0b 	ldhu	r2,-16(fp)
 1000608:	18800526 	beq	r3,r2,1000620 <vBlockingQueueConsumer+0x78>
			{
				/* Catch-up. */
				usExpectedValue = usData;
 100060c:	e0bffe0b 	ldhu	r2,-8(fp)
 1000610:	e0bffc0d 	sth	r2,-16(fp)

				sErrorEverOccurred = pdTRUE;
 1000614:	00800044 	movi	r2,1
 1000618:	e0bffc8d 	sth	r2,-14(fp)
 100061c:	003feb06 	br	10005cc <__alt_data_end+0xff8005cc>
			}
			else
			{
				/* We have successfully received a message, so increment the
				variable used to check we are still running. */
				if( sErrorEverOccurred == pdFALSE )
 1000620:	e0bffc8f 	ldh	r2,-14(fp)
 1000624:	1000051e 	bne	r2,zero,100063c <vBlockingQueueConsumer+0x94>
				{
					( *pxQueueParameters->psCheckVariable )++;
 1000628:	e0bffd17 	ldw	r2,-12(fp)
 100062c:	10800217 	ldw	r2,8(r2)
 1000630:	10c0000b 	ldhu	r3,0(r2)
 1000634:	18c00044 	addi	r3,r3,1
 1000638:	10c0000d 	sth	r3,0(r2)
				}

				/* Increment the value we expect to remove from the queue next time
				round. */
				++usExpectedValue;
 100063c:	e0bffc0b 	ldhu	r2,-16(fp)
 1000640:	10800044 	addi	r2,r2,1
 1000644:	e0bffc0d 	sth	r2,-16(fp)
					taskYIELD();
				}
			}
			#endif
		}
	}
 1000648:	003fe006 	br	10005cc <__alt_data_end+0xff8005cc>

0100064c <xAreBlockingQueuesStillRunning>:
}
/*-----------------------------------------------------------*/

/* This is called to check that all the created tasks are still running. */
BaseType_t xAreBlockingQueuesStillRunning( void )
{
 100064c:	defffd04 	addi	sp,sp,-12
 1000650:	df000215 	stw	fp,8(sp)
 1000654:	df000204 	addi	fp,sp,8
static short sLastBlockingConsumerCount[ blckqNUM_TASK_SETS ] = { ( uint16_t ) 0, ( uint16_t ) 0, ( uint16_t ) 0 };
static short sLastBlockingProducerCount[ blckqNUM_TASK_SETS ] = { ( uint16_t ) 0, ( uint16_t ) 0, ( uint16_t ) 0 };
BaseType_t xReturn = pdPASS, xTasks;
 1000658:	00800044 	movi	r2,1
 100065c:	e0bffe15 	stw	r2,-8(fp)
	changed or not.

	Loop through each check variable to and return pdFALSE if any are found not
	to have changed since the last call. */

	for( xTasks = 0; xTasks < blckqNUM_TASK_SETS; xTasks++ )
 1000660:	e03fff15 	stw	zero,-4(fp)
 1000664:	00003b06 	br	1000754 <xAreBlockingQueuesStillRunning+0x108>
	{
		if( sBlockingConsumerCount[ xTasks ] == sLastBlockingConsumerCount[ xTasks ]  )
 1000668:	e0bfff17 	ldw	r2,-4(fp)
 100066c:	1087883a 	add	r3,r2,r2
 1000670:	d0a03704 	addi	r2,gp,-32548
 1000674:	1885883a 	add	r2,r3,r2
 1000678:	1100000b 	ldhu	r4,0(r2)
 100067c:	e0bfff17 	ldw	r2,-4(fp)
 1000680:	1087883a 	add	r3,r2,r2
 1000684:	d0a03a04 	addi	r2,gp,-32536
 1000688:	1885883a 	add	r2,r3,r2
 100068c:	1080000b 	ldhu	r2,0(r2)
 1000690:	20ffffcc 	andi	r3,r4,65535
 1000694:	18e0001c 	xori	r3,r3,32768
 1000698:	18e00004 	addi	r3,r3,-32768
 100069c:	10bfffcc 	andi	r2,r2,65535
 10006a0:	10a0001c 	xori	r2,r2,32768
 10006a4:	10a00004 	addi	r2,r2,-32768
 10006a8:	1880011e 	bne	r3,r2,10006b0 <xAreBlockingQueuesStillRunning+0x64>
		{
			xReturn = pdFALSE;
 10006ac:	e03ffe15 	stw	zero,-8(fp)
		}
		sLastBlockingConsumerCount[ xTasks ] = sBlockingConsumerCount[ xTasks ];
 10006b0:	e0bfff17 	ldw	r2,-4(fp)
 10006b4:	1087883a 	add	r3,r2,r2
 10006b8:	d0a03704 	addi	r2,gp,-32548
 10006bc:	1885883a 	add	r2,r3,r2
 10006c0:	10c0000b 	ldhu	r3,0(r2)
 10006c4:	e0bfff17 	ldw	r2,-4(fp)
 10006c8:	1089883a 	add	r4,r2,r2
 10006cc:	d0a03a04 	addi	r2,gp,-32536
 10006d0:	2085883a 	add	r2,r4,r2
 10006d4:	10c0000d 	sth	r3,0(r2)


		if( sBlockingProducerCount[ xTasks ] == sLastBlockingProducerCount[ xTasks ]  )
 10006d8:	e0bfff17 	ldw	r2,-4(fp)
 10006dc:	1087883a 	add	r3,r2,r2
 10006e0:	d0a03884 	addi	r2,gp,-32542
 10006e4:	1885883a 	add	r2,r3,r2
 10006e8:	1100000b 	ldhu	r4,0(r2)
 10006ec:	e0bfff17 	ldw	r2,-4(fp)
 10006f0:	1087883a 	add	r3,r2,r2
 10006f4:	d0a03b84 	addi	r2,gp,-32530
 10006f8:	1885883a 	add	r2,r3,r2
 10006fc:	1080000b 	ldhu	r2,0(r2)
 1000700:	20ffffcc 	andi	r3,r4,65535
 1000704:	18e0001c 	xori	r3,r3,32768
 1000708:	18e00004 	addi	r3,r3,-32768
 100070c:	10bfffcc 	andi	r2,r2,65535
 1000710:	10a0001c 	xori	r2,r2,32768
 1000714:	10a00004 	addi	r2,r2,-32768
 1000718:	1880011e 	bne	r3,r2,1000720 <xAreBlockingQueuesStillRunning+0xd4>
		{
			xReturn = pdFALSE;
 100071c:	e03ffe15 	stw	zero,-8(fp)
		}
		sLastBlockingProducerCount[ xTasks ] = sBlockingProducerCount[ xTasks ];
 1000720:	e0bfff17 	ldw	r2,-4(fp)
 1000724:	1087883a 	add	r3,r2,r2
 1000728:	d0a03884 	addi	r2,gp,-32542
 100072c:	1885883a 	add	r2,r3,r2
 1000730:	10c0000b 	ldhu	r3,0(r2)
 1000734:	e0bfff17 	ldw	r2,-4(fp)
 1000738:	1089883a 	add	r4,r2,r2
 100073c:	d0a03b84 	addi	r2,gp,-32530
 1000740:	2085883a 	add	r2,r4,r2
 1000744:	10c0000d 	sth	r3,0(r2)
	changed or not.

	Loop through each check variable to and return pdFALSE if any are found not
	to have changed since the last call. */

	for( xTasks = 0; xTasks < blckqNUM_TASK_SETS; xTasks++ )
 1000748:	e0bfff17 	ldw	r2,-4(fp)
 100074c:	10800044 	addi	r2,r2,1
 1000750:	e0bfff15 	stw	r2,-4(fp)
 1000754:	e0bfff17 	ldw	r2,-4(fp)
 1000758:	108000d0 	cmplti	r2,r2,3
 100075c:	103fc21e 	bne	r2,zero,1000668 <__alt_data_end+0xff800668>
			xReturn = pdFALSE;
		}
		sLastBlockingProducerCount[ xTasks ] = sBlockingProducerCount[ xTasks ];
	}

	return xReturn;
 1000760:	e0bffe17 	ldw	r2,-8(fp)
}
 1000764:	e037883a 	mov	sp,fp
 1000768:	df000017 	ldw	fp,0(sp)
 100076c:	dec00104 	addi	sp,sp,4
 1000770:	f800283a 	ret

01000774 <vStartGenericQueueTasks>:
static TaskHandle_t xHighPriorityMutexTask, xMediumPriorityMutexTask;

/*-----------------------------------------------------------*/

void vStartGenericQueueTasks( UBaseType_t uxPriority )
{
 1000774:	defff904 	addi	sp,sp,-28
 1000778:	dfc00615 	stw	ra,24(sp)
 100077c:	df000515 	stw	fp,20(sp)
 1000780:	df000504 	addi	fp,sp,20
 1000784:	e13fff15 	stw	r4,-4(fp)
QueueHandle_t xQueue;
SemaphoreHandle_t xMutex;

	/* Create the queue that we are going to use for the
	prvSendFrontAndBackTest demo. */
	xQueue = xQueueCreate( genqQUEUE_LENGTH, sizeof( uint32_t ) );
 1000788:	000d883a 	mov	r6,zero
 100078c:	01400104 	movi	r5,4
 1000790:	01000144 	movi	r4,5
 1000794:	100439c0 	call	100439c <xQueueGenericCreate>
 1000798:	e0bffd15 	stw	r2,-12(fp)

	if( xQueue != NULL )
 100079c:	e0bffd17 	ldw	r2,-12(fp)
 10007a0:	10000a26 	beq	r2,zero,10007cc <vStartGenericQueueTasks+0x58>
		vQueueAddToRegistry( xQueue, "Gen_Queue_Test" );

		/* Create the demo task and pass it the queue just created.  We are
		passing the queue handle by value so it does not matter that it is
		declared on the stack here. */
		xTaskCreate( prvSendFrontAndBackTest, "GenQ", configMINIMAL_STACK_SIZE, ( void * ) xQueue, uxPriority, NULL );
 10007a4:	d8000115 	stw	zero,4(sp)
 10007a8:	e0bfff17 	ldw	r2,-4(fp)
 10007ac:	d8800015 	stw	r2,0(sp)
 10007b0:	e1fffd17 	ldw	r7,-12(fp)
 10007b4:	01810004 	movi	r6,1024
 10007b8:	014040b4 	movhi	r5,258
 10007bc:	2969dc04 	addi	r5,r5,-22672
 10007c0:	01004034 	movhi	r4,256
 10007c4:	21021d04 	addi	r4,r4,2164
 10007c8:	10053600 	call	1005360 <xTaskCreate>
	}

	/* Create the mutex used by the prvMutexTest task. */
	xMutex = xSemaphoreCreateMutex();
 10007cc:	01000044 	movi	r4,1
 10007d0:	10045200 	call	1004520 <xQueueCreateMutex>
 10007d4:	e0bffe15 	stw	r2,-8(fp)

	if( xMutex != NULL )
 10007d8:	e0bffe17 	ldw	r2,-8(fp)
 10007dc:	10001f26 	beq	r2,zero,100085c <vStartGenericQueueTasks+0xe8>
		vQueueAddToRegistry( ( QueueHandle_t ) xMutex, "Gen_Queue_Mutex" );

		/* Create the mutex demo tasks and pass it the mutex just created.  We
		are passing the mutex handle by value so it does not matter that it is
		declared on the stack here. */
		xTaskCreate( prvLowPriorityMutexTask, "MuLow", configMINIMAL_STACK_SIZE, ( void * ) xMutex, genqMUTEX_LOW_PRIORITY, NULL );
 10007e0:	d8000115 	stw	zero,4(sp)
 10007e4:	d8000015 	stw	zero,0(sp)
 10007e8:	e1fffe17 	ldw	r7,-8(fp)
 10007ec:	01810004 	movi	r6,1024
 10007f0:	014040b4 	movhi	r5,258
 10007f4:	2969de04 	addi	r5,r5,-22664
 10007f8:	01004034 	movhi	r4,256
 10007fc:	2103f704 	addi	r4,r4,4060
 1000800:	10053600 	call	1005360 <xTaskCreate>
		xTaskCreate( prvMediumPriorityMutexTask, "MuMed", configMINIMAL_STACK_SIZE, NULL, genqMUTEX_MEDIUM_PRIORITY, &xMediumPriorityMutexTask );
 1000804:	d0a04204 	addi	r2,gp,-32504
 1000808:	d8800115 	stw	r2,4(sp)
 100080c:	00800084 	movi	r2,2
 1000810:	d8800015 	stw	r2,0(sp)
 1000814:	000f883a 	mov	r7,zero
 1000818:	01810004 	movi	r6,1024
 100081c:	014040b4 	movhi	r5,258
 1000820:	2969e004 	addi	r5,r5,-22656
 1000824:	01004034 	movhi	r4,256
 1000828:	21040e04 	addi	r4,r4,4152
 100082c:	10053600 	call	1005360 <xTaskCreate>
		xTaskCreate( prvHighPriorityMutexTask, "MuHigh", configMINIMAL_STACK_SIZE, ( void * ) xMutex, genqMUTEX_HIGH_PRIORITY, &xHighPriorityMutexTask );
 1000830:	d0a04104 	addi	r2,gp,-32508
 1000834:	d8800115 	stw	r2,4(sp)
 1000838:	008000c4 	movi	r2,3
 100083c:	d8800015 	stw	r2,0(sp)
 1000840:	e1fffe17 	ldw	r7,-8(fp)
 1000844:	01810004 	movi	r6,1024
 1000848:	014040b4 	movhi	r5,258
 100084c:	2969e204 	addi	r5,r5,-22648
 1000850:	01004034 	movhi	r4,256
 1000854:	21041904 	addi	r4,r4,4196
 1000858:	10053600 	call	1005360 <xTaskCreate>
	}
}
 100085c:	0001883a 	nop
 1000860:	e037883a 	mov	sp,fp
 1000864:	dfc00117 	ldw	ra,4(sp)
 1000868:	df000017 	ldw	fp,0(sp)
 100086c:	dec00204 	addi	sp,sp,8
 1000870:	f800283a 	ret

01000874 <prvSendFrontAndBackTest>:
/*-----------------------------------------------------------*/

static void prvSendFrontAndBackTest( void *pvParameters )
{
 1000874:	defffa04 	addi	sp,sp,-24
 1000878:	dfc00515 	stw	ra,20(sp)
 100087c:	df000415 	stw	fp,16(sp)
 1000880:	df000404 	addi	fp,sp,16
 1000884:	e13fff15 	stw	r4,-4(fp)

		/* Queue a message for printing to say the task has started. */
		vPrintDisplayMessage( &pcTaskStartMsg );
	#endif

	xQueue = ( QueueHandle_t ) pvParameters;
 1000888:	e0bfff17 	ldw	r2,-4(fp)
 100088c:	e0bffc15 	stw	r2,-16(fp)
	{
		/* The queue is empty, so sending an item to the back of the queue
		should have the same efect as sending it to the front of the queue.

		First send to the front and check everything is as expected. */
		xQueueSendToFront( xQueue, ( void * ) &ulLoopCounter, intsemNO_BLOCK );
 1000890:	01c00044 	movi	r7,1
 1000894:	000d883a 	mov	r6,zero
 1000898:	d1603e04 	addi	r5,gp,-32520
 100089c:	e13ffc17 	ldw	r4,-16(fp)
 10008a0:	10047080 	call	1004708 <xQueueGenericSend>

		if( uxQueueMessagesWaiting( xQueue ) != 1 )
 10008a4:	e13ffc17 	ldw	r4,-16(fp)
 10008a8:	1004e140 	call	1004e14 <uxQueueMessagesWaiting>
 10008ac:	10800060 	cmpeqi	r2,r2,1
 10008b0:	1000021e 	bne	r2,zero,10008bc <prvSendFrontAndBackTest+0x48>
		{
			xErrorDetected = pdTRUE;
 10008b4:	00800044 	movi	r2,1
 10008b8:	d0a03d15 	stw	r2,-32524(gp)
		}

		if( xQueueReceive( xQueue, ( void * ) &ulData, intsemNO_BLOCK ) != pdPASS )
 10008bc:	e0bffd04 	addi	r2,fp,-12
 10008c0:	000f883a 	mov	r7,zero
 10008c4:	000d883a 	mov	r6,zero
 10008c8:	100b883a 	mov	r5,r2
 10008cc:	e13ffc17 	ldw	r4,-16(fp)
 10008d0:	1004a800 	call	1004a80 <xQueueGenericReceive>
 10008d4:	10800060 	cmpeqi	r2,r2,1
 10008d8:	1000021e 	bne	r2,zero,10008e4 <prvSendFrontAndBackTest+0x70>
		{
			xErrorDetected = pdTRUE;
 10008dc:	00800044 	movi	r2,1
 10008e0:	d0a03d15 	stw	r2,-32524(gp)
		}

		/* The data we sent to the queue should equal the data we just received
		from the queue. */
		if( ulLoopCounter != ulData )
 10008e4:	d0e03e17 	ldw	r3,-32520(gp)
 10008e8:	e0bffd17 	ldw	r2,-12(fp)
 10008ec:	18800226 	beq	r3,r2,10008f8 <prvSendFrontAndBackTest+0x84>
		{
			xErrorDetected = pdTRUE;
 10008f0:	00800044 	movi	r2,1
 10008f4:	d0a03d15 	stw	r2,-32524(gp)
		}

		/* Then do the same, sending the data to the back, checking everything
		is as expected. */
		if( uxQueueMessagesWaiting( xQueue ) != 0 )
 10008f8:	e13ffc17 	ldw	r4,-16(fp)
 10008fc:	1004e140 	call	1004e14 <uxQueueMessagesWaiting>
 1000900:	10000226 	beq	r2,zero,100090c <prvSendFrontAndBackTest+0x98>
		{
			xErrorDetected = pdTRUE;
 1000904:	00800044 	movi	r2,1
 1000908:	d0a03d15 	stw	r2,-32524(gp)
		}

		xQueueSendToBack( xQueue, ( void * ) &ulLoopCounter, intsemNO_BLOCK );
 100090c:	000f883a 	mov	r7,zero
 1000910:	000d883a 	mov	r6,zero
 1000914:	d1603e04 	addi	r5,gp,-32520
 1000918:	e13ffc17 	ldw	r4,-16(fp)
 100091c:	10047080 	call	1004708 <xQueueGenericSend>

		if( uxQueueMessagesWaiting( xQueue ) != 1 )
 1000920:	e13ffc17 	ldw	r4,-16(fp)
 1000924:	1004e140 	call	1004e14 <uxQueueMessagesWaiting>
 1000928:	10800060 	cmpeqi	r2,r2,1
 100092c:	1000021e 	bne	r2,zero,1000938 <prvSendFrontAndBackTest+0xc4>
		{
			xErrorDetected = pdTRUE;
 1000930:	00800044 	movi	r2,1
 1000934:	d0a03d15 	stw	r2,-32524(gp)
		}

		if( xQueueReceive( xQueue, ( void * ) &ulData, intsemNO_BLOCK ) != pdPASS )
 1000938:	e0bffd04 	addi	r2,fp,-12
 100093c:	000f883a 	mov	r7,zero
 1000940:	000d883a 	mov	r6,zero
 1000944:	100b883a 	mov	r5,r2
 1000948:	e13ffc17 	ldw	r4,-16(fp)
 100094c:	1004a800 	call	1004a80 <xQueueGenericReceive>
 1000950:	10800060 	cmpeqi	r2,r2,1
 1000954:	1000021e 	bne	r2,zero,1000960 <prvSendFrontAndBackTest+0xec>
		{
			xErrorDetected = pdTRUE;
 1000958:	00800044 	movi	r2,1
 100095c:	d0a03d15 	stw	r2,-32524(gp)
		}

		if( uxQueueMessagesWaiting( xQueue ) != 0 )
 1000960:	e13ffc17 	ldw	r4,-16(fp)
 1000964:	1004e140 	call	1004e14 <uxQueueMessagesWaiting>
 1000968:	10000226 	beq	r2,zero,1000974 <prvSendFrontAndBackTest+0x100>
		{
			xErrorDetected = pdTRUE;
 100096c:	00800044 	movi	r2,1
 1000970:	d0a03d15 	stw	r2,-32524(gp)
		}

		/* The data we sent to the queue should equal the data we just received
		from the queue. */
		if( ulLoopCounter != ulData )
 1000974:	d0e03e17 	ldw	r3,-32520(gp)
 1000978:	e0bffd17 	ldw	r2,-12(fp)
 100097c:	18800226 	beq	r3,r2,1000988 <prvSendFrontAndBackTest+0x114>
		{
			xErrorDetected = pdTRUE;
 1000980:	00800044 	movi	r2,1
 1000984:	d0a03d15 	stw	r2,-32524(gp)
		#endif



		/* Place 2, 3, 4 into the queue, adding items to the back of the queue. */
		for( ulData = 2; ulData < 5; ulData++ )
 1000988:	00800084 	movi	r2,2
 100098c:	e0bffd15 	stw	r2,-12(fp)
 1000990:	00000906 	br	10009b8 <prvSendFrontAndBackTest+0x144>
		{
			xQueueSendToBack( xQueue, ( void * ) &ulData, intsemNO_BLOCK );
 1000994:	e0bffd04 	addi	r2,fp,-12
 1000998:	000f883a 	mov	r7,zero
 100099c:	000d883a 	mov	r6,zero
 10009a0:	100b883a 	mov	r5,r2
 10009a4:	e13ffc17 	ldw	r4,-16(fp)
 10009a8:	10047080 	call	1004708 <xQueueGenericSend>
		#endif



		/* Place 2, 3, 4 into the queue, adding items to the back of the queue. */
		for( ulData = 2; ulData < 5; ulData++ )
 10009ac:	e0bffd17 	ldw	r2,-12(fp)
 10009b0:	10800044 	addi	r2,r2,1
 10009b4:	e0bffd15 	stw	r2,-12(fp)
 10009b8:	e0bffd17 	ldw	r2,-12(fp)
 10009bc:	10800170 	cmpltui	r2,r2,5
 10009c0:	103ff41e 	bne	r2,zero,1000994 <__alt_data_end+0xff800994>
			xQueueSendToBack( xQueue, ( void * ) &ulData, intsemNO_BLOCK );
		}

		/* Now the order in the queue should be 2, 3, 4, with 2 being the first
		thing to be read out.  Now add 1 then 0 to the front of the queue. */
		if( uxQueueMessagesWaiting( xQueue ) != 3 )
 10009c4:	e13ffc17 	ldw	r4,-16(fp)
 10009c8:	1004e140 	call	1004e14 <uxQueueMessagesWaiting>
 10009cc:	108000e0 	cmpeqi	r2,r2,3
 10009d0:	1000021e 	bne	r2,zero,10009dc <prvSendFrontAndBackTest+0x168>
		{
			xErrorDetected = pdTRUE;
 10009d4:	00800044 	movi	r2,1
 10009d8:	d0a03d15 	stw	r2,-32524(gp)
		}
		ulData = 1;
 10009dc:	00800044 	movi	r2,1
 10009e0:	e0bffd15 	stw	r2,-12(fp)
		xQueueSendToFront( xQueue, ( void * ) &ulData, intsemNO_BLOCK );
 10009e4:	e0bffd04 	addi	r2,fp,-12
 10009e8:	01c00044 	movi	r7,1
 10009ec:	000d883a 	mov	r6,zero
 10009f0:	100b883a 	mov	r5,r2
 10009f4:	e13ffc17 	ldw	r4,-16(fp)
 10009f8:	10047080 	call	1004708 <xQueueGenericSend>
		ulData = 0;
 10009fc:	e03ffd15 	stw	zero,-12(fp)
		xQueueSendToFront( xQueue, ( void * ) &ulData, intsemNO_BLOCK );
 1000a00:	e0bffd04 	addi	r2,fp,-12
 1000a04:	01c00044 	movi	r7,1
 1000a08:	000d883a 	mov	r6,zero
 1000a0c:	100b883a 	mov	r5,r2
 1000a10:	e13ffc17 	ldw	r4,-16(fp)
 1000a14:	10047080 	call	1004708 <xQueueGenericSend>

		/* Now the queue should be full, and when we read the data out we
		should receive 0, 1, 2, 3, 4. */
		if( uxQueueMessagesWaiting( xQueue ) != 5 )
 1000a18:	e13ffc17 	ldw	r4,-16(fp)
 1000a1c:	1004e140 	call	1004e14 <uxQueueMessagesWaiting>
 1000a20:	10800160 	cmpeqi	r2,r2,5
 1000a24:	1000021e 	bne	r2,zero,1000a30 <prvSendFrontAndBackTest+0x1bc>
		{
			xErrorDetected = pdTRUE;
 1000a28:	00800044 	movi	r2,1
 1000a2c:	d0a03d15 	stw	r2,-32524(gp)
		}

		if( xQueueSendToFront( xQueue, ( void * ) &ulData, intsemNO_BLOCK ) != errQUEUE_FULL )
 1000a30:	e0bffd04 	addi	r2,fp,-12
 1000a34:	01c00044 	movi	r7,1
 1000a38:	000d883a 	mov	r6,zero
 1000a3c:	100b883a 	mov	r5,r2
 1000a40:	e13ffc17 	ldw	r4,-16(fp)
 1000a44:	10047080 	call	1004708 <xQueueGenericSend>
 1000a48:	10000226 	beq	r2,zero,1000a54 <prvSendFrontAndBackTest+0x1e0>
		{
			xErrorDetected = pdTRUE;
 1000a4c:	00800044 	movi	r2,1
 1000a50:	d0a03d15 	stw	r2,-32524(gp)
		}

		if( xQueueSendToBack( xQueue, ( void * ) &ulData, intsemNO_BLOCK ) != errQUEUE_FULL )
 1000a54:	e0bffd04 	addi	r2,fp,-12
 1000a58:	000f883a 	mov	r7,zero
 1000a5c:	000d883a 	mov	r6,zero
 1000a60:	100b883a 	mov	r5,r2
 1000a64:	e13ffc17 	ldw	r4,-16(fp)
 1000a68:	10047080 	call	1004708 <xQueueGenericSend>
 1000a6c:	10000226 	beq	r2,zero,1000a78 <prvSendFrontAndBackTest+0x204>
		{
			xErrorDetected = pdTRUE;
 1000a70:	00800044 	movi	r2,1
 1000a74:	d0a03d15 	stw	r2,-32524(gp)
		#if configUSE_PREEMPTION == 0
			taskYIELD();
		#endif

		/* Check the data we read out is in the expected order. */
		for( ulData = 0; ulData < genqQUEUE_LENGTH; ulData++ )
 1000a78:	e03ffd15 	stw	zero,-12(fp)
 1000a7c:	00002406 	br	1000b10 <prvSendFrontAndBackTest+0x29c>
		{
			/* Try peeking the data first. */
			if( xQueuePeek( xQueue, &ulData2, intsemNO_BLOCK ) != pdPASS )
 1000a80:	e0bffe04 	addi	r2,fp,-8
 1000a84:	01c00044 	movi	r7,1
 1000a88:	000d883a 	mov	r6,zero
 1000a8c:	100b883a 	mov	r5,r2
 1000a90:	e13ffc17 	ldw	r4,-16(fp)
 1000a94:	1004a800 	call	1004a80 <xQueueGenericReceive>
 1000a98:	10800060 	cmpeqi	r2,r2,1
 1000a9c:	1000021e 	bne	r2,zero,1000aa8 <prvSendFrontAndBackTest+0x234>
			{
				xErrorDetected = pdTRUE;
 1000aa0:	00800044 	movi	r2,1
 1000aa4:	d0a03d15 	stw	r2,-32524(gp)
			}

			if( ulData != ulData2 )
 1000aa8:	e0fffd17 	ldw	r3,-12(fp)
 1000aac:	e0bffe17 	ldw	r2,-8(fp)
 1000ab0:	18800226 	beq	r3,r2,1000abc <prvSendFrontAndBackTest+0x248>
			{
				xErrorDetected = pdTRUE;
 1000ab4:	00800044 	movi	r2,1
 1000ab8:	d0a03d15 	stw	r2,-32524(gp)
			}


			/* Now try receiving the data for real.  The value should be the
			same.  Clobber the value first so we know we really received it. */
			ulData2 = ~ulData2;
 1000abc:	e0bffe17 	ldw	r2,-8(fp)
 1000ac0:	0084303a 	nor	r2,zero,r2
 1000ac4:	e0bffe15 	stw	r2,-8(fp)
			if( xQueueReceive( xQueue, &ulData2, intsemNO_BLOCK ) != pdPASS )
 1000ac8:	e0bffe04 	addi	r2,fp,-8
 1000acc:	000f883a 	mov	r7,zero
 1000ad0:	000d883a 	mov	r6,zero
 1000ad4:	100b883a 	mov	r5,r2
 1000ad8:	e13ffc17 	ldw	r4,-16(fp)
 1000adc:	1004a800 	call	1004a80 <xQueueGenericReceive>
 1000ae0:	10800060 	cmpeqi	r2,r2,1
 1000ae4:	1000021e 	bne	r2,zero,1000af0 <prvSendFrontAndBackTest+0x27c>
			{
				xErrorDetected = pdTRUE;
 1000ae8:	00800044 	movi	r2,1
 1000aec:	d0a03d15 	stw	r2,-32524(gp)
			}

			if( ulData != ulData2 )
 1000af0:	e0fffd17 	ldw	r3,-12(fp)
 1000af4:	e0bffe17 	ldw	r2,-8(fp)
 1000af8:	18800226 	beq	r3,r2,1000b04 <prvSendFrontAndBackTest+0x290>
			{
				xErrorDetected = pdTRUE;
 1000afc:	00800044 	movi	r2,1
 1000b00:	d0a03d15 	stw	r2,-32524(gp)
		#if configUSE_PREEMPTION == 0
			taskYIELD();
		#endif

		/* Check the data we read out is in the expected order. */
		for( ulData = 0; ulData < genqQUEUE_LENGTH; ulData++ )
 1000b04:	e0bffd17 	ldw	r2,-12(fp)
 1000b08:	10800044 	addi	r2,r2,1
 1000b0c:	e0bffd15 	stw	r2,-12(fp)
 1000b10:	e0bffd17 	ldw	r2,-12(fp)
 1000b14:	10800170 	cmpltui	r2,r2,5
 1000b18:	103fd91e 	bne	r2,zero,1000a80 <__alt_data_end+0xff800a80>
				xErrorDetected = pdTRUE;
			}
		}

		/* The queue should now be empty again. */
		if( uxQueueMessagesWaiting( xQueue ) != 0 )
 1000b1c:	e13ffc17 	ldw	r4,-16(fp)
 1000b20:	1004e140 	call	1004e14 <uxQueueMessagesWaiting>
 1000b24:	10000226 	beq	r2,zero,1000b30 <prvSendFrontAndBackTest+0x2bc>
		{
			xErrorDetected = pdTRUE;
 1000b28:	00800044 	movi	r2,1
 1000b2c:	d0a03d15 	stw	r2,-32524(gp)
			taskYIELD();
		#endif


		/* Our queue is empty once more, add 10, 11 to the back. */
		ulData = 10;
 1000b30:	00800284 	movi	r2,10
 1000b34:	e0bffd15 	stw	r2,-12(fp)
		if( xQueueSend( xQueue, &ulData, intsemNO_BLOCK ) != pdPASS )
 1000b38:	e0bffd04 	addi	r2,fp,-12
 1000b3c:	000f883a 	mov	r7,zero
 1000b40:	000d883a 	mov	r6,zero
 1000b44:	100b883a 	mov	r5,r2
 1000b48:	e13ffc17 	ldw	r4,-16(fp)
 1000b4c:	10047080 	call	1004708 <xQueueGenericSend>
 1000b50:	10800060 	cmpeqi	r2,r2,1
 1000b54:	1000021e 	bne	r2,zero,1000b60 <prvSendFrontAndBackTest+0x2ec>
		{
			xErrorDetected = pdTRUE;
 1000b58:	00800044 	movi	r2,1
 1000b5c:	d0a03d15 	stw	r2,-32524(gp)
		}
		ulData = 11;
 1000b60:	008002c4 	movi	r2,11
 1000b64:	e0bffd15 	stw	r2,-12(fp)
		if( xQueueSend( xQueue, &ulData, intsemNO_BLOCK ) != pdPASS )
 1000b68:	e0bffd04 	addi	r2,fp,-12
 1000b6c:	000f883a 	mov	r7,zero
 1000b70:	000d883a 	mov	r6,zero
 1000b74:	100b883a 	mov	r5,r2
 1000b78:	e13ffc17 	ldw	r4,-16(fp)
 1000b7c:	10047080 	call	1004708 <xQueueGenericSend>
 1000b80:	10800060 	cmpeqi	r2,r2,1
 1000b84:	1000021e 	bne	r2,zero,1000b90 <prvSendFrontAndBackTest+0x31c>
		{
			xErrorDetected = pdTRUE;
 1000b88:	00800044 	movi	r2,1
 1000b8c:	d0a03d15 	stw	r2,-32524(gp)
		}

		if( uxQueueMessagesWaiting( xQueue ) != 2 )
 1000b90:	e13ffc17 	ldw	r4,-16(fp)
 1000b94:	1004e140 	call	1004e14 <uxQueueMessagesWaiting>
 1000b98:	108000a0 	cmpeqi	r2,r2,2
 1000b9c:	1000021e 	bne	r2,zero,1000ba8 <prvSendFrontAndBackTest+0x334>
		{
			xErrorDetected = pdTRUE;
 1000ba0:	00800044 	movi	r2,1
 1000ba4:	d0a03d15 	stw	r2,-32524(gp)
		}

		/* Now we should have 10, 11 in the queue.  Add 7, 8, 9 to the
		front. */
		for( ulData = 9; ulData >= 7; ulData-- )
 1000ba8:	00800244 	movi	r2,9
 1000bac:	e0bffd15 	stw	r2,-12(fp)
 1000bb0:	00000d06 	br	1000be8 <prvSendFrontAndBackTest+0x374>
		{
			if( xQueueSendToFront( xQueue, ( void * ) &ulData, intsemNO_BLOCK ) != pdPASS )
 1000bb4:	e0bffd04 	addi	r2,fp,-12
 1000bb8:	01c00044 	movi	r7,1
 1000bbc:	000d883a 	mov	r6,zero
 1000bc0:	100b883a 	mov	r5,r2
 1000bc4:	e13ffc17 	ldw	r4,-16(fp)
 1000bc8:	10047080 	call	1004708 <xQueueGenericSend>
 1000bcc:	10800060 	cmpeqi	r2,r2,1
 1000bd0:	1000021e 	bne	r2,zero,1000bdc <prvSendFrontAndBackTest+0x368>
			{
				xErrorDetected = pdTRUE;
 1000bd4:	00800044 	movi	r2,1
 1000bd8:	d0a03d15 	stw	r2,-32524(gp)
			xErrorDetected = pdTRUE;
		}

		/* Now we should have 10, 11 in the queue.  Add 7, 8, 9 to the
		front. */
		for( ulData = 9; ulData >= 7; ulData-- )
 1000bdc:	e0bffd17 	ldw	r2,-12(fp)
 1000be0:	10bfffc4 	addi	r2,r2,-1
 1000be4:	e0bffd15 	stw	r2,-12(fp)
 1000be8:	e0bffd17 	ldw	r2,-12(fp)
 1000bec:	108001e8 	cmpgeui	r2,r2,7
 1000bf0:	103ff01e 	bne	r2,zero,1000bb4 <__alt_data_end+0xff800bb4>
			}
		}

		/* Now check that the queue is full, and that receiving data provides
		the expected sequence of 7, 8, 9, 10, 11. */
		if( uxQueueMessagesWaiting( xQueue ) != 5 )
 1000bf4:	e13ffc17 	ldw	r4,-16(fp)
 1000bf8:	1004e140 	call	1004e14 <uxQueueMessagesWaiting>
 1000bfc:	10800160 	cmpeqi	r2,r2,5
 1000c00:	1000021e 	bne	r2,zero,1000c0c <prvSendFrontAndBackTest+0x398>
		{
			xErrorDetected = pdTRUE;
 1000c04:	00800044 	movi	r2,1
 1000c08:	d0a03d15 	stw	r2,-32524(gp)
		}

		if( xQueueSendToFront( xQueue, ( void * ) &ulData, intsemNO_BLOCK ) != errQUEUE_FULL )
 1000c0c:	e0bffd04 	addi	r2,fp,-12
 1000c10:	01c00044 	movi	r7,1
 1000c14:	000d883a 	mov	r6,zero
 1000c18:	100b883a 	mov	r5,r2
 1000c1c:	e13ffc17 	ldw	r4,-16(fp)
 1000c20:	10047080 	call	1004708 <xQueueGenericSend>
 1000c24:	10000226 	beq	r2,zero,1000c30 <prvSendFrontAndBackTest+0x3bc>
		{
			xErrorDetected = pdTRUE;
 1000c28:	00800044 	movi	r2,1
 1000c2c:	d0a03d15 	stw	r2,-32524(gp)
		}

		if( xQueueSendToBack( xQueue, ( void * ) &ulData, intsemNO_BLOCK ) != errQUEUE_FULL )
 1000c30:	e0bffd04 	addi	r2,fp,-12
 1000c34:	000f883a 	mov	r7,zero
 1000c38:	000d883a 	mov	r6,zero
 1000c3c:	100b883a 	mov	r5,r2
 1000c40:	e13ffc17 	ldw	r4,-16(fp)
 1000c44:	10047080 	call	1004708 <xQueueGenericSend>
 1000c48:	10000226 	beq	r2,zero,1000c54 <prvSendFrontAndBackTest+0x3e0>
		{
			xErrorDetected = pdTRUE;
 1000c4c:	00800044 	movi	r2,1
 1000c50:	d0a03d15 	stw	r2,-32524(gp)
		#if configUSE_PREEMPTION == 0
			taskYIELD();
		#endif

		/* Check the data we read out is in the expected order. */
		for( ulData = 7; ulData < ( 7 + genqQUEUE_LENGTH ); ulData++ )
 1000c54:	008001c4 	movi	r2,7
 1000c58:	e0bffd15 	stw	r2,-12(fp)
 1000c5c:	00001206 	br	1000ca8 <prvSendFrontAndBackTest+0x434>
		{
			if( xQueueReceive( xQueue, &ulData2, intsemNO_BLOCK ) != pdPASS )
 1000c60:	e0bffe04 	addi	r2,fp,-8
 1000c64:	000f883a 	mov	r7,zero
 1000c68:	000d883a 	mov	r6,zero
 1000c6c:	100b883a 	mov	r5,r2
 1000c70:	e13ffc17 	ldw	r4,-16(fp)
 1000c74:	1004a800 	call	1004a80 <xQueueGenericReceive>
 1000c78:	10800060 	cmpeqi	r2,r2,1
 1000c7c:	1000021e 	bne	r2,zero,1000c88 <prvSendFrontAndBackTest+0x414>
			{
				xErrorDetected = pdTRUE;
 1000c80:	00800044 	movi	r2,1
 1000c84:	d0a03d15 	stw	r2,-32524(gp)
			}

			if( ulData != ulData2 )
 1000c88:	e0fffd17 	ldw	r3,-12(fp)
 1000c8c:	e0bffe17 	ldw	r2,-8(fp)
 1000c90:	18800226 	beq	r3,r2,1000c9c <prvSendFrontAndBackTest+0x428>
			{
				xErrorDetected = pdTRUE;
 1000c94:	00800044 	movi	r2,1
 1000c98:	d0a03d15 	stw	r2,-32524(gp)
		#if configUSE_PREEMPTION == 0
			taskYIELD();
		#endif

		/* Check the data we read out is in the expected order. */
		for( ulData = 7; ulData < ( 7 + genqQUEUE_LENGTH ); ulData++ )
 1000c9c:	e0bffd17 	ldw	r2,-12(fp)
 1000ca0:	10800044 	addi	r2,r2,1
 1000ca4:	e0bffd15 	stw	r2,-12(fp)
 1000ca8:	e0bffd17 	ldw	r2,-12(fp)
 1000cac:	10800330 	cmpltui	r2,r2,12
 1000cb0:	103feb1e 	bne	r2,zero,1000c60 <__alt_data_end+0xff800c60>
			{
				xErrorDetected = pdTRUE;
			}
		}

		if( uxQueueMessagesWaiting( xQueue ) != 0 )
 1000cb4:	e13ffc17 	ldw	r4,-16(fp)
 1000cb8:	1004e140 	call	1004e14 <uxQueueMessagesWaiting>
 1000cbc:	10000226 	beq	r2,zero,1000cc8 <prvSendFrontAndBackTest+0x454>
		{
			xErrorDetected = pdTRUE;
 1000cc0:	00800044 	movi	r2,1
 1000cc4:	d0a03d15 	stw	r2,-32524(gp)
		}

		ulLoopCounter++;
 1000cc8:	d0a03e17 	ldw	r2,-32520(gp)
 1000ccc:	10800044 	addi	r2,r2,1
 1000cd0:	d0a03e15 	stw	r2,-32520(gp)
	}
 1000cd4:	003eee06 	br	1000890 <__alt_data_end+0xff800890>

01000cd8 <prvTakeTwoMutexesReturnInDifferentOrder>:
}
/*-----------------------------------------------------------*/

static void prvTakeTwoMutexesReturnInDifferentOrder( SemaphoreHandle_t xMutex, SemaphoreHandle_t xLocalMutex )
{
 1000cd8:	defffc04 	addi	sp,sp,-16
 1000cdc:	dfc00315 	stw	ra,12(sp)
 1000ce0:	df000215 	stw	fp,8(sp)
 1000ce4:	df000204 	addi	fp,sp,8
 1000ce8:	e13ffe15 	stw	r4,-8(fp)
 1000cec:	e17fff15 	stw	r5,-4(fp)
	/* Take the mutex.  It should be available now. */
	if( xSemaphoreTake( xMutex, intsemNO_BLOCK ) != pdPASS )
 1000cf0:	000f883a 	mov	r7,zero
 1000cf4:	000d883a 	mov	r6,zero
 1000cf8:	000b883a 	mov	r5,zero
 1000cfc:	e13ffe17 	ldw	r4,-8(fp)
 1000d00:	1004a800 	call	1004a80 <xQueueGenericReceive>
 1000d04:	10800060 	cmpeqi	r2,r2,1
 1000d08:	1000021e 	bne	r2,zero,1000d14 <prvTakeTwoMutexesReturnInDifferentOrder+0x3c>
	{
		xErrorDetected = pdTRUE;
 1000d0c:	00800044 	movi	r2,1
 1000d10:	d0a03d15 	stw	r2,-32524(gp)
	}

	/* Set the guarded variable to a known start value. */
	ulGuardedVariable = 0;
 1000d14:	d0204015 	stw	zero,-32512(gp)

	/* This task's priority should be as per that assigned when the task was
	created. */
	if( uxTaskPriorityGet( NULL ) != genqMUTEX_LOW_PRIORITY )
 1000d18:	0009883a 	mov	r4,zero
 1000d1c:	10059480 	call	1005948 <uxTaskPriorityGet>
 1000d20:	10000226 	beq	r2,zero,1000d2c <prvTakeTwoMutexesReturnInDifferentOrder+0x54>
	{
		xErrorDetected = pdTRUE;
 1000d24:	00800044 	movi	r2,1
 1000d28:	d0a03d15 	stw	r2,-32524(gp)
	}

	/* Now unsuspend the high priority task.  This will attempt to take the
	mutex, and block when it finds it cannot obtain it. */
	vTaskResume( xHighPriorityMutexTask );
 1000d2c:	d0a04117 	ldw	r2,-32508(gp)
 1000d30:	1009883a 	mov	r4,r2
 1000d34:	1005d180 	call	1005d18 <vTaskResume>
	}
	#endif /* INCLUDE_eTaskGetState */

	/* The priority of the high priority task should now have been inherited
	as by now it will have attempted to get the mutex. */
	if( uxTaskPriorityGet( NULL ) != genqMUTEX_HIGH_PRIORITY )
 1000d38:	0009883a 	mov	r4,zero
 1000d3c:	10059480 	call	1005948 <uxTaskPriorityGet>
 1000d40:	108000e0 	cmpeqi	r2,r2,3
 1000d44:	1000021e 	bne	r2,zero,1000d50 <prvTakeTwoMutexesReturnInDifferentOrder+0x78>
	{
		xErrorDetected = pdTRUE;
 1000d48:	00800044 	movi	r2,1
 1000d4c:	d0a03d15 	stw	r2,-32524(gp)
	}

	/* Attempt to set the priority of this task to the test priority -
	between the	idle priority and the medium/high test priorities, but the
	actual priority should remain at the high priority. */
	vTaskPrioritySet( NULL, genqMUTEX_TEST_PRIORITY );
 1000d50:	01400044 	movi	r5,1
 1000d54:	0009883a 	mov	r4,zero
 1000d58:	10059ec0 	call	10059ec <vTaskPrioritySet>
	if( uxTaskPriorityGet( NULL ) != genqMUTEX_HIGH_PRIORITY )
 1000d5c:	0009883a 	mov	r4,zero
 1000d60:	10059480 	call	1005948 <uxTaskPriorityGet>
 1000d64:	108000e0 	cmpeqi	r2,r2,3
 1000d68:	1000021e 	bne	r2,zero,1000d74 <prvTakeTwoMutexesReturnInDifferentOrder+0x9c>
	{
		xErrorDetected = pdTRUE;
 1000d6c:	00800044 	movi	r2,1
 1000d70:	d0a03d15 	stw	r2,-32524(gp)
	}

	/* Now unsuspend the medium priority task.  This should not run as the
	inherited priority of this task is above that of the medium priority
	task. */
	vTaskResume( xMediumPriorityMutexTask );
 1000d74:	d0a04217 	ldw	r2,-32504(gp)
 1000d78:	1009883a 	mov	r4,r2
 1000d7c:	1005d180 	call	1005d18 <vTaskResume>

	/* If the medium priority task did run then it will have incremented the
	guarded variable. */
	if( ulGuardedVariable != 0 )
 1000d80:	d0a04017 	ldw	r2,-32512(gp)
 1000d84:	10000226 	beq	r2,zero,1000d90 <prvTakeTwoMutexesReturnInDifferentOrder+0xb8>
	{
		xErrorDetected = pdTRUE;
 1000d88:	00800044 	movi	r2,1
 1000d8c:	d0a03d15 	stw	r2,-32524(gp)
	}

	/* Take the local mutex too, so two mutexes are now held. */
	if( xSemaphoreTake( xLocalMutex, intsemNO_BLOCK ) != pdPASS )
 1000d90:	000f883a 	mov	r7,zero
 1000d94:	000d883a 	mov	r6,zero
 1000d98:	000b883a 	mov	r5,zero
 1000d9c:	e13fff17 	ldw	r4,-4(fp)
 1000da0:	1004a800 	call	1004a80 <xQueueGenericReceive>
 1000da4:	10800060 	cmpeqi	r2,r2,1
 1000da8:	1000021e 	bne	r2,zero,1000db4 <prvTakeTwoMutexesReturnInDifferentOrder+0xdc>
	{
		xErrorDetected = pdTRUE;
 1000dac:	00800044 	movi	r2,1
 1000db0:	d0a03d15 	stw	r2,-32524(gp)
	yet be disinherited because the local mutex is still held.  This is a
	simplification to allow FreeRTOS to be integrated with middleware that
	attempts to hold multiple mutexes without bloating the code with complex
	algorithms.  It is possible that the high priority mutex task will
	execute as it shares a priority with this task. */
	if( xSemaphoreGive( xMutex ) != pdPASS )
 1000db4:	000f883a 	mov	r7,zero
 1000db8:	000d883a 	mov	r6,zero
 1000dbc:	000b883a 	mov	r5,zero
 1000dc0:	e13ffe17 	ldw	r4,-8(fp)
 1000dc4:	10047080 	call	1004708 <xQueueGenericSend>
 1000dc8:	10800060 	cmpeqi	r2,r2,1
 1000dcc:	1000021e 	bne	r2,zero,1000dd8 <prvTakeTwoMutexesReturnInDifferentOrder+0x100>
	{
		xErrorDetected = pdTRUE;
 1000dd0:	00800044 	movi	r2,1
 1000dd4:	d0a03d15 	stw	r2,-32524(gp)
	#endif

	/* The guarded variable is only incremented by the medium priority task,
	which still should not have executed as this task should remain at the
	higher priority, ensure this is the case. */
	if( ulGuardedVariable != 0 )
 1000dd8:	d0a04017 	ldw	r2,-32512(gp)
 1000ddc:	10000226 	beq	r2,zero,1000de8 <prvTakeTwoMutexesReturnInDifferentOrder+0x110>
	{
		xErrorDetected = pdTRUE;
 1000de0:	00800044 	movi	r2,1
 1000de4:	d0a03d15 	stw	r2,-32524(gp)
	}

	if( uxTaskPriorityGet( NULL ) != genqMUTEX_HIGH_PRIORITY )
 1000de8:	0009883a 	mov	r4,zero
 1000dec:	10059480 	call	1005948 <uxTaskPriorityGet>
 1000df0:	108000e0 	cmpeqi	r2,r2,3
 1000df4:	1000021e 	bne	r2,zero,1000e00 <prvTakeTwoMutexesReturnInDifferentOrder+0x128>
	{
		xErrorDetected = pdTRUE;
 1000df8:	00800044 	movi	r2,1
 1000dfc:	d0a03d15 	stw	r2,-32524(gp)
	This time the priority of this task should be disinherited back to the
	priority to which it was set while the mutex was held.  This means
	the medium priority task should execute and increment the guarded
	variable.   When this task next	runs both the high and medium priority
	tasks will have been suspended again. */
	if( xSemaphoreGive( xLocalMutex ) != pdPASS )
 1000e00:	000f883a 	mov	r7,zero
 1000e04:	000d883a 	mov	r6,zero
 1000e08:	000b883a 	mov	r5,zero
 1000e0c:	e13fff17 	ldw	r4,-4(fp)
 1000e10:	10047080 	call	1004708 <xQueueGenericSend>
 1000e14:	10800060 	cmpeqi	r2,r2,1
 1000e18:	1000021e 	bne	r2,zero,1000e24 <prvTakeTwoMutexesReturnInDifferentOrder+0x14c>
	{
		xErrorDetected = pdTRUE;
 1000e1c:	00800044 	movi	r2,1
 1000e20:	d0a03d15 	stw	r2,-32524(gp)
	#if configUSE_PREEMPTION == 0
		taskYIELD();
	#endif

	/* Check the guarded variable did indeed increment... */
	if( ulGuardedVariable != 1 )
 1000e24:	d0a04017 	ldw	r2,-32512(gp)
 1000e28:	10800060 	cmpeqi	r2,r2,1
 1000e2c:	1000021e 	bne	r2,zero,1000e38 <prvTakeTwoMutexesReturnInDifferentOrder+0x160>
	{
		xErrorDetected = pdTRUE;
 1000e30:	00800044 	movi	r2,1
 1000e34:	d0a03d15 	stw	r2,-32524(gp)
	}

	/* ... and that the priority of this task has been disinherited to
	genqMUTEX_TEST_PRIORITY. */
	if( uxTaskPriorityGet( NULL ) != genqMUTEX_TEST_PRIORITY )
 1000e38:	0009883a 	mov	r4,zero
 1000e3c:	10059480 	call	1005948 <uxTaskPriorityGet>
 1000e40:	10800060 	cmpeqi	r2,r2,1
 1000e44:	1000021e 	bne	r2,zero,1000e50 <prvTakeTwoMutexesReturnInDifferentOrder+0x178>
	{
		xErrorDetected = pdTRUE;
 1000e48:	00800044 	movi	r2,1
 1000e4c:	d0a03d15 	stw	r2,-32524(gp)
	}

	/* Set the priority of this task back to its original value, ready for
	the next loop around this test. */
	vTaskPrioritySet( NULL, genqMUTEX_LOW_PRIORITY );
 1000e50:	000b883a 	mov	r5,zero
 1000e54:	0009883a 	mov	r4,zero
 1000e58:	10059ec0 	call	10059ec <vTaskPrioritySet>
}
 1000e5c:	0001883a 	nop
 1000e60:	e037883a 	mov	sp,fp
 1000e64:	dfc00117 	ldw	ra,4(sp)
 1000e68:	df000017 	ldw	fp,0(sp)
 1000e6c:	dec00204 	addi	sp,sp,8
 1000e70:	f800283a 	ret

01000e74 <prvTakeTwoMutexesReturnInSameOrder>:
/*-----------------------------------------------------------*/

static void prvTakeTwoMutexesReturnInSameOrder( SemaphoreHandle_t xMutex, SemaphoreHandle_t xLocalMutex )
{
 1000e74:	defffc04 	addi	sp,sp,-16
 1000e78:	dfc00315 	stw	ra,12(sp)
 1000e7c:	df000215 	stw	fp,8(sp)
 1000e80:	df000204 	addi	fp,sp,8
 1000e84:	e13ffe15 	stw	r4,-8(fp)
 1000e88:	e17fff15 	stw	r5,-4(fp)
	/* Take the mutex.  It should be available now. */
	if( xSemaphoreTake( xMutex, intsemNO_BLOCK ) != pdPASS )
 1000e8c:	000f883a 	mov	r7,zero
 1000e90:	000d883a 	mov	r6,zero
 1000e94:	000b883a 	mov	r5,zero
 1000e98:	e13ffe17 	ldw	r4,-8(fp)
 1000e9c:	1004a800 	call	1004a80 <xQueueGenericReceive>
 1000ea0:	10800060 	cmpeqi	r2,r2,1
 1000ea4:	1000021e 	bne	r2,zero,1000eb0 <prvTakeTwoMutexesReturnInSameOrder+0x3c>
	{
		xErrorDetected = pdTRUE;
 1000ea8:	00800044 	movi	r2,1
 1000eac:	d0a03d15 	stw	r2,-32524(gp)
	}

	/* Set the guarded variable to a known start value. */
	ulGuardedVariable = 0;
 1000eb0:	d0204015 	stw	zero,-32512(gp)

	/* This task's priority should be as per that assigned when the task was
	created. */
	if( uxTaskPriorityGet( NULL ) != genqMUTEX_LOW_PRIORITY )
 1000eb4:	0009883a 	mov	r4,zero
 1000eb8:	10059480 	call	1005948 <uxTaskPriorityGet>
 1000ebc:	10000226 	beq	r2,zero,1000ec8 <prvTakeTwoMutexesReturnInSameOrder+0x54>
	{
		xErrorDetected = pdTRUE;
 1000ec0:	00800044 	movi	r2,1
 1000ec4:	d0a03d15 	stw	r2,-32524(gp)
	}

	/* Now unsuspend the high priority task.  This will attempt to take the
	mutex, and block when it finds it cannot obtain it. */
	vTaskResume( xHighPriorityMutexTask );
 1000ec8:	d0a04117 	ldw	r2,-32508(gp)
 1000ecc:	1009883a 	mov	r4,r2
 1000ed0:	1005d180 	call	1005d18 <vTaskResume>
	}
	#endif /* INCLUDE_eTaskGetState */

	/* The priority of the high priority task should now have been inherited
	as by now it will have attempted to get the mutex. */
	if( uxTaskPriorityGet( NULL ) != genqMUTEX_HIGH_PRIORITY )
 1000ed4:	0009883a 	mov	r4,zero
 1000ed8:	10059480 	call	1005948 <uxTaskPriorityGet>
 1000edc:	108000e0 	cmpeqi	r2,r2,3
 1000ee0:	1000021e 	bne	r2,zero,1000eec <prvTakeTwoMutexesReturnInSameOrder+0x78>
	{
		xErrorDetected = pdTRUE;
 1000ee4:	00800044 	movi	r2,1
 1000ee8:	d0a03d15 	stw	r2,-32524(gp)
	}

	/* Now unsuspend the medium priority task.  This should not run as the
	inherited priority of this task is above that of the medium priority
	task. */
	vTaskResume( xMediumPriorityMutexTask );
 1000eec:	d0a04217 	ldw	r2,-32504(gp)
 1000ef0:	1009883a 	mov	r4,r2
 1000ef4:	1005d180 	call	1005d18 <vTaskResume>

	/* If the medium priority task did run then it will have incremented the
	guarded variable. */
	if( ulGuardedVariable != 0 )
 1000ef8:	d0a04017 	ldw	r2,-32512(gp)
 1000efc:	10000226 	beq	r2,zero,1000f08 <prvTakeTwoMutexesReturnInSameOrder+0x94>
	{
		xErrorDetected = pdTRUE;
 1000f00:	00800044 	movi	r2,1
 1000f04:	d0a03d15 	stw	r2,-32524(gp)
	}

	/* Take the local mutex too, so two mutexes are now held. */
	if( xSemaphoreTake( xLocalMutex, intsemNO_BLOCK ) != pdPASS )
 1000f08:	000f883a 	mov	r7,zero
 1000f0c:	000d883a 	mov	r6,zero
 1000f10:	000b883a 	mov	r5,zero
 1000f14:	e13fff17 	ldw	r4,-4(fp)
 1000f18:	1004a800 	call	1004a80 <xQueueGenericReceive>
 1000f1c:	10800060 	cmpeqi	r2,r2,1
 1000f20:	1000021e 	bne	r2,zero,1000f2c <prvTakeTwoMutexesReturnInSameOrder+0xb8>
	{
		xErrorDetected = pdTRUE;
 1000f24:	00800044 	movi	r2,1
 1000f28:	d0a03d15 	stw	r2,-32524(gp)
	not	yet be disinherited because the shared mutex is still held.  This is a
	simplification to allow FreeRTOS to be integrated with middleware that
	attempts to hold multiple mutexes without bloating the code with complex
	algorithms.  It is possible that the high priority mutex task will
	execute as it shares a priority with this task. */
	if( xSemaphoreGive( xLocalMutex ) != pdPASS )
 1000f2c:	000f883a 	mov	r7,zero
 1000f30:	000d883a 	mov	r6,zero
 1000f34:	000b883a 	mov	r5,zero
 1000f38:	e13fff17 	ldw	r4,-4(fp)
 1000f3c:	10047080 	call	1004708 <xQueueGenericSend>
 1000f40:	10800060 	cmpeqi	r2,r2,1
 1000f44:	1000021e 	bne	r2,zero,1000f50 <prvTakeTwoMutexesReturnInSameOrder+0xdc>
	{
		xErrorDetected = pdTRUE;
 1000f48:	00800044 	movi	r2,1
 1000f4c:	d0a03d15 	stw	r2,-32524(gp)
	#endif

	/* The guarded variable is only incremented by the medium priority task,
	which still should not have executed as this task should remain at the
	higher priority, ensure this is the case. */
	if( ulGuardedVariable != 0 )
 1000f50:	d0a04017 	ldw	r2,-32512(gp)
 1000f54:	10000226 	beq	r2,zero,1000f60 <prvTakeTwoMutexesReturnInSameOrder+0xec>
	{
		xErrorDetected = pdTRUE;
 1000f58:	00800044 	movi	r2,1
 1000f5c:	d0a03d15 	stw	r2,-32524(gp)
	}

	if( uxTaskPriorityGet( NULL ) != genqMUTEX_HIGH_PRIORITY )
 1000f60:	0009883a 	mov	r4,zero
 1000f64:	10059480 	call	1005948 <uxTaskPriorityGet>
 1000f68:	108000e0 	cmpeqi	r2,r2,3
 1000f6c:	1000021e 	bne	r2,zero,1000f78 <prvTakeTwoMutexesReturnInSameOrder+0x104>
	{
		xErrorDetected = pdTRUE;
 1000f70:	00800044 	movi	r2,1
 1000f74:	d0a03d15 	stw	r2,-32524(gp)
	/* Now also give back the shared mutex, taking the held count back to 0.
	This time the priority of this task should be disinherited back to the
	priority at which it was created.  This means the medium priority task
	should execute and increment the guarded variable.  When this task next runs
	both the high and medium priority tasks will have been suspended again. */
	if( xSemaphoreGive( xMutex ) != pdPASS )
 1000f78:	000f883a 	mov	r7,zero
 1000f7c:	000d883a 	mov	r6,zero
 1000f80:	000b883a 	mov	r5,zero
 1000f84:	e13ffe17 	ldw	r4,-8(fp)
 1000f88:	10047080 	call	1004708 <xQueueGenericSend>
 1000f8c:	10800060 	cmpeqi	r2,r2,1
 1000f90:	1000021e 	bne	r2,zero,1000f9c <prvTakeTwoMutexesReturnInSameOrder+0x128>
	{
		xErrorDetected = pdTRUE;
 1000f94:	00800044 	movi	r2,1
 1000f98:	d0a03d15 	stw	r2,-32524(gp)
	#if configUSE_PREEMPTION == 0
		taskYIELD();
	#endif

	/* Check the guarded variable did indeed increment... */
	if( ulGuardedVariable != 1 )
 1000f9c:	d0a04017 	ldw	r2,-32512(gp)
 1000fa0:	10800060 	cmpeqi	r2,r2,1
 1000fa4:	1000021e 	bne	r2,zero,1000fb0 <prvTakeTwoMutexesReturnInSameOrder+0x13c>
	{
		xErrorDetected = pdTRUE;
 1000fa8:	00800044 	movi	r2,1
 1000fac:	d0a03d15 	stw	r2,-32524(gp)
	}

	/* ... and that the priority of this task has been disinherited to
	genqMUTEX_LOW_PRIORITY. */
	if( uxTaskPriorityGet( NULL ) != genqMUTEX_LOW_PRIORITY )
 1000fb0:	0009883a 	mov	r4,zero
 1000fb4:	10059480 	call	1005948 <uxTaskPriorityGet>
 1000fb8:	10000226 	beq	r2,zero,1000fc4 <prvTakeTwoMutexesReturnInSameOrder+0x150>
	{
		xErrorDetected = pdTRUE;
 1000fbc:	00800044 	movi	r2,1
 1000fc0:	d0a03d15 	stw	r2,-32524(gp)
	}
}
 1000fc4:	0001883a 	nop
 1000fc8:	e037883a 	mov	sp,fp
 1000fcc:	dfc00117 	ldw	ra,4(sp)
 1000fd0:	df000017 	ldw	fp,0(sp)
 1000fd4:	dec00204 	addi	sp,sp,8
 1000fd8:	f800283a 	ret

01000fdc <prvLowPriorityMutexTask>:
/*-----------------------------------------------------------*/

static void prvLowPriorityMutexTask( void *pvParameters )
{
 1000fdc:	defffb04 	addi	sp,sp,-20
 1000fe0:	dfc00415 	stw	ra,16(sp)
 1000fe4:	df000315 	stw	fp,12(sp)
 1000fe8:	df000304 	addi	fp,sp,12
 1000fec:	e13fff15 	stw	r4,-4(fp)
SemaphoreHandle_t xMutex = ( SemaphoreHandle_t ) pvParameters, xLocalMutex;
 1000ff0:	e0bfff17 	ldw	r2,-4(fp)
 1000ff4:	e0bffd15 	stw	r2,-12(fp)
		/* Queue a message for printing to say the task has started. */
		vPrintDisplayMessage( &pcTaskStartMsg );
	#endif

	/* The local mutex is used to check the 'mutexs held' count. */
	xLocalMutex = xSemaphoreCreateMutex();
 1000ff8:	01000044 	movi	r4,1
 1000ffc:	10045200 	call	1004520 <xQueueCreateMutex>
 1001000:	e0bffe15 	stw	r2,-8(fp)
	for( ;; )
	{
		/* The first tests exercise the priority inheritance when two mutexes
		are taken then returned in a different order to which they were
		taken. */
		prvTakeTwoMutexesReturnInDifferentOrder( xMutex, xLocalMutex );
 1001004:	e17ffe17 	ldw	r5,-8(fp)
 1001008:	e13ffd17 	ldw	r4,-12(fp)
 100100c:	1000cd80 	call	1000cd8 <prvTakeTwoMutexesReturnInDifferentOrder>

		/* Just to show this task is still running. */
		ulLoopCounter2++;
 1001010:	d0a03f17 	ldw	r2,-32516(gp)
 1001014:	10800044 	addi	r2,r2,1
 1001018:	d0a03f15 	stw	r2,-32516(gp)
			taskYIELD();
		#endif

		/* The second tests exercise the priority inheritance when two mutexes
		are taken then returned in the same order in which they were taken. */
		prvTakeTwoMutexesReturnInSameOrder( xMutex, xLocalMutex );
 100101c:	e17ffe17 	ldw	r5,-8(fp)
 1001020:	e13ffd17 	ldw	r4,-12(fp)
 1001024:	1000e740 	call	1000e74 <prvTakeTwoMutexesReturnInSameOrder>

		/* Just to show this task is still running. */
		ulLoopCounter2++;
 1001028:	d0a03f17 	ldw	r2,-32516(gp)
 100102c:	10800044 	addi	r2,r2,1
 1001030:	d0a03f15 	stw	r2,-32516(gp)

		#if configUSE_PREEMPTION == 0
			taskYIELD();
		#endif
	}
 1001034:	003ff306 	br	1001004 <__alt_data_end+0xff801004>

01001038 <prvMediumPriorityMutexTask>:
}
/*-----------------------------------------------------------*/

static void prvMediumPriorityMutexTask( void *pvParameters )
{
 1001038:	defffd04 	addi	sp,sp,-12
 100103c:	dfc00215 	stw	ra,8(sp)
 1001040:	df000115 	stw	fp,4(sp)
 1001044:	df000104 	addi	fp,sp,4
 1001048:	e13fff15 	stw	r4,-4(fp)

	for( ;; )
	{
		/* The medium priority task starts by suspending itself.  The low
		priority task will unsuspend this task when required. */
		vTaskSuspend( NULL );
 100104c:	0009883a 	mov	r4,zero
 1001050:	1005ba40 	call	1005ba4 <vTaskSuspend>

		/* When this task unsuspends all it does is increment the guarded
		variable, this is so the low priority task knows that it has
		executed. */
		ulGuardedVariable++;
 1001054:	d0a04017 	ldw	r2,-32512(gp)
 1001058:	10800044 	addi	r2,r2,1
 100105c:	d0a04015 	stw	r2,-32512(gp)
	}
 1001060:	003ffa06 	br	100104c <__alt_data_end+0xff80104c>

01001064 <prvHighPriorityMutexTask>:
}
/*-----------------------------------------------------------*/

static void prvHighPriorityMutexTask( void *pvParameters )
{
 1001064:	defffc04 	addi	sp,sp,-16
 1001068:	dfc00315 	stw	ra,12(sp)
 100106c:	df000215 	stw	fp,8(sp)
 1001070:	df000204 	addi	fp,sp,8
 1001074:	e13fff15 	stw	r4,-4(fp)
SemaphoreHandle_t xMutex = ( SemaphoreHandle_t ) pvParameters;
 1001078:	e0bfff17 	ldw	r2,-4(fp)
 100107c:	e0bffe15 	stw	r2,-8(fp)

	for( ;; )
	{
		/* The high priority task starts by suspending itself.  The low
		priority task will unsuspend this task when required. */
		vTaskSuspend( NULL );
 1001080:	0009883a 	mov	r4,zero
 1001084:	1005ba40 	call	1005ba4 <vTaskSuspend>

		/* When this task unsuspends all it does is attempt to obtain
		the mutex.  It should find the mutex is not available so a
		block time is specified. */
		if( xSemaphoreTake( xMutex, portMAX_DELAY ) != pdPASS )
 1001088:	000f883a 	mov	r7,zero
 100108c:	01bfffc4 	movi	r6,-1
 1001090:	000b883a 	mov	r5,zero
 1001094:	e13ffe17 	ldw	r4,-8(fp)
 1001098:	1004a800 	call	1004a80 <xQueueGenericReceive>
 100109c:	10800060 	cmpeqi	r2,r2,1
 10010a0:	1000021e 	bne	r2,zero,10010ac <prvHighPriorityMutexTask+0x48>
		{
			xErrorDetected = pdTRUE;
 10010a4:	00800044 	movi	r2,1
 10010a8:	d0a03d15 	stw	r2,-32524(gp)
		}

		/* When the mutex is eventually obtained it is just given back before
		returning to suspend ready for the next cycle. */
		if( xSemaphoreGive( xMutex ) != pdPASS )
 10010ac:	000f883a 	mov	r7,zero
 10010b0:	000d883a 	mov	r6,zero
 10010b4:	000b883a 	mov	r5,zero
 10010b8:	e13ffe17 	ldw	r4,-8(fp)
 10010bc:	10047080 	call	1004708 <xQueueGenericSend>
 10010c0:	10800060 	cmpeqi	r2,r2,1
 10010c4:	103fee1e 	bne	r2,zero,1001080 <__alt_data_end+0xff801080>
		{
			xErrorDetected = pdTRUE;
 10010c8:	00800044 	movi	r2,1
 10010cc:	d0a03d15 	stw	r2,-32524(gp)
		}
	}
 10010d0:	003feb06 	br	1001080 <__alt_data_end+0xff801080>

010010d4 <xAreGenericQueueTasksStillRunning>:
/*-----------------------------------------------------------*/


/* This is called to check that all the created tasks are still running. */
BaseType_t xAreGenericQueueTasksStillRunning( void )
{
 10010d4:	deffff04 	addi	sp,sp,-4
 10010d8:	df000015 	stw	fp,0(sp)
 10010dc:	d839883a 	mov	fp,sp
static uint32_t ulLastLoopCounter = 0, ulLastLoopCounter2 = 0;

	/* If the demo task is still running then we expect the loop counters to
	have incremented since this function was last called. */
	if( ulLastLoopCounter == ulLoopCounter )
 10010e0:	d0e04317 	ldw	r3,-32500(gp)
 10010e4:	d0a03e17 	ldw	r2,-32520(gp)
 10010e8:	1880021e 	bne	r3,r2,10010f4 <xAreGenericQueueTasksStillRunning+0x20>
	{
		xErrorDetected = pdTRUE;
 10010ec:	00800044 	movi	r2,1
 10010f0:	d0a03d15 	stw	r2,-32524(gp)
	}

	if( ulLastLoopCounter2 == ulLoopCounter2 )
 10010f4:	d0e04417 	ldw	r3,-32496(gp)
 10010f8:	d0a03f17 	ldw	r2,-32516(gp)
 10010fc:	1880021e 	bne	r3,r2,1001108 <xAreGenericQueueTasksStillRunning+0x34>
	{
		xErrorDetected = pdTRUE;
 1001100:	00800044 	movi	r2,1
 1001104:	d0a03d15 	stw	r2,-32524(gp)
	}

	ulLastLoopCounter = ulLoopCounter;
 1001108:	d0a03e17 	ldw	r2,-32520(gp)
 100110c:	d0a04315 	stw	r2,-32500(gp)
	ulLastLoopCounter2 = ulLoopCounter2;
 1001110:	d0a03f17 	ldw	r2,-32516(gp)
 1001114:	d0a04415 	stw	r2,-32496(gp)

	/* Errors detected in the task itself will have latched xErrorDetected
	to true. */

	return ( BaseType_t ) !xErrorDetected;
 1001118:	d0a03d17 	ldw	r2,-32524(gp)
 100111c:	1005003a 	cmpeq	r2,r2,zero
 1001120:	10803fcc 	andi	r2,r2,255
}
 1001124:	e037883a 	mov	sp,fp
 1001128:	df000017 	ldw	fp,0(sp)
 100112c:	dec00104 	addi	sp,sp,4
 1001130:	f800283a 	ret

01001134 <vStartPolledQueueTasks>:
static volatile BaseType_t xPollingConsumerCount = pollqINITIAL_VALUE, xPollingProducerCount = pollqINITIAL_VALUE;

/*-----------------------------------------------------------*/

void vStartPolledQueueTasks( UBaseType_t uxPriority )
{
 1001134:	defffb04 	addi	sp,sp,-20
 1001138:	dfc00415 	stw	ra,16(sp)
 100113c:	df000315 	stw	fp,12(sp)
 1001140:	df000304 	addi	fp,sp,12
 1001144:	e13fff15 	stw	r4,-4(fp)
static QueueHandle_t xPolledQueue;

	/* Create the queue used by the producer and consumer. */
	xPolledQueue = xQueueCreate( pollqQUEUE_SIZE, ( UBaseType_t ) sizeof( uint16_t ) );
 1001148:	000d883a 	mov	r6,zero
 100114c:	01400084 	movi	r5,2
 1001150:	01000284 	movi	r4,10
 1001154:	100439c0 	call	100439c <xQueueGenericCreate>
 1001158:	d0a04715 	stw	r2,-32484(gp)

	if( xPolledQueue != NULL )
 100115c:	d0a04717 	ldw	r2,-32484(gp)
 1001160:	10001426 	beq	r2,zero,10011b4 <vStartPolledQueueTasks+0x80>
		by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is
		defined to be less than 1. */
		vQueueAddToRegistry( xPolledQueue, "Poll_Test_Queue" );

		/* Spawn the producer and consumer. */
		xTaskCreate( vPolledQueueConsumer, "QConsNB", pollqSTACK_SIZE, ( void * ) &xPolledQueue, uxPriority, ( TaskHandle_t * ) NULL );
 1001164:	d8000115 	stw	zero,4(sp)
 1001168:	e0bfff17 	ldw	r2,-4(fp)
 100116c:	d8800015 	stw	r2,0(sp)
 1001170:	d1e04704 	addi	r7,gp,-32484
 1001174:	01810004 	movi	r6,1024
 1001178:	014040b4 	movhi	r5,258
 100117c:	2969e404 	addi	r5,r5,-22640
 1001180:	01004034 	movhi	r4,256
 1001184:	21049c04 	addi	r4,r4,4720
 1001188:	10053600 	call	1005360 <xTaskCreate>
		xTaskCreate( vPolledQueueProducer, "QProdNB", pollqSTACK_SIZE, ( void * ) &xPolledQueue, uxPriority, ( TaskHandle_t * ) NULL );
 100118c:	d8000115 	stw	zero,4(sp)
 1001190:	e0bfff17 	ldw	r2,-4(fp)
 1001194:	d8800015 	stw	r2,0(sp)
 1001198:	d1e04704 	addi	r7,gp,-32484
 100119c:	01810004 	movi	r6,1024
 10011a0:	014040b4 	movhi	r5,258
 10011a4:	2969e604 	addi	r5,r5,-22632
 10011a8:	01004034 	movhi	r4,256
 10011ac:	21047304 	addi	r4,r4,4556
 10011b0:	10053600 	call	1005360 <xTaskCreate>
	}
}
 10011b4:	0001883a 	nop
 10011b8:	e037883a 	mov	sp,fp
 10011bc:	dfc00117 	ldw	ra,4(sp)
 10011c0:	df000017 	ldw	fp,0(sp)
 10011c4:	dec00204 	addi	sp,sp,8
 10011c8:	f800283a 	ret

010011cc <vPolledQueueProducer>:
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueProducer, pvParameters )
{
 10011cc:	defffa04 	addi	sp,sp,-24
 10011d0:	dfc00515 	stw	ra,20(sp)
 10011d4:	df000415 	stw	fp,16(sp)
 10011d8:	df000404 	addi	fp,sp,16
 10011dc:	e13fff15 	stw	r4,-4(fp)
uint16_t usValue = ( uint16_t ) 0;
 10011e0:	e03ffe0d 	sth	zero,-8(fp)
BaseType_t xError = pdFALSE, xLoop;
 10011e4:	e03ffc15 	stw	zero,-16(fp)

	for( ;; )
	{
		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
 10011e8:	e03ffd15 	stw	zero,-12(fp)
 10011ec:	00001a06 	br	1001258 <vPolledQueueProducer+0x8c>
		{
			/* Send an incrementing number on the queue without blocking. */
			if( xQueueSend( *( ( QueueHandle_t * ) pvParameters ), ( void * ) &usValue, pollqNO_DELAY ) != pdPASS )
 10011f0:	e0bfff17 	ldw	r2,-4(fp)
 10011f4:	10800017 	ldw	r2,0(r2)
 10011f8:	e0fffe04 	addi	r3,fp,-8
 10011fc:	000f883a 	mov	r7,zero
 1001200:	000d883a 	mov	r6,zero
 1001204:	180b883a 	mov	r5,r3
 1001208:	1009883a 	mov	r4,r2
 100120c:	10047080 	call	1004708 <xQueueGenericSend>
 1001210:	10800060 	cmpeqi	r2,r2,1
 1001214:	1000031e 	bne	r2,zero,1001224 <vPolledQueueProducer+0x58>
			{
				/* We should never find the queue full so if we get here there
				has been an error. */
				xError = pdTRUE;
 1001218:	00800044 	movi	r2,1
 100121c:	e0bffc15 	stw	r2,-16(fp)
 1001220:	00000a06 	br	100124c <vPolledQueueProducer+0x80>
			}
			else
			{
				if( xError == pdFALSE )
 1001224:	e0bffc17 	ldw	r2,-16(fp)
 1001228:	1000051e 	bne	r2,zero,1001240 <vPolledQueueProducer+0x74>
				{
					/* If an error has ever been recorded we stop incrementing the
					check variable. */
					portENTER_CRITICAL();
 100122c:	1006d680 	call	1006d68 <vTaskEnterCritical>
						xPollingProducerCount++;
 1001230:	d0a04617 	ldw	r2,-32488(gp)
 1001234:	10800044 	addi	r2,r2,1
 1001238:	d0a04615 	stw	r2,-32488(gp)
					portEXIT_CRITICAL();
 100123c:	1006dbc0 	call	1006dbc <vTaskExitCritical>
				}

				/* Update the value we are going to post next time around. */
				usValue++;
 1001240:	e0bffe0b 	ldhu	r2,-8(fp)
 1001244:	10800044 	addi	r2,r2,1
 1001248:	e0bffe0d 	sth	r2,-8(fp)
uint16_t usValue = ( uint16_t ) 0;
BaseType_t xError = pdFALSE, xLoop;

	for( ;; )
	{
		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
 100124c:	e0bffd17 	ldw	r2,-12(fp)
 1001250:	10800044 	addi	r2,r2,1
 1001254:	e0bffd15 	stw	r2,-12(fp)
 1001258:	e0bffd17 	ldw	r2,-12(fp)
 100125c:	108000d0 	cmplti	r2,r2,3
 1001260:	103fe31e 	bne	r2,zero,10011f0 <__alt_data_end+0xff8011f0>
			}
		}

		/* Wait before we start posting again to ensure the consumer runs and
		empties the queue. */
		vTaskDelay( pollqPRODUCER_DELAY );
 1001264:	01003204 	movi	r4,200
 1001268:	10058ec0 	call	10058ec <vTaskDelay>
	}
 100126c:	003fde06 	br	10011e8 <__alt_data_end+0xff8011e8>

01001270 <vPolledQueueConsumer>:
}  /*lint !e818 Function prototype must conform to API. */
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueConsumer, pvParameters )
{
 1001270:	defffa04 	addi	sp,sp,-24
 1001274:	dfc00515 	stw	ra,20(sp)
 1001278:	df000415 	stw	fp,16(sp)
 100127c:	df000404 	addi	fp,sp,16
 1001280:	e13fff15 	stw	r4,-4(fp)
uint16_t usData, usExpectedValue = ( uint16_t ) 0;
 1001284:	e03ffc0d 	sth	zero,-16(fp)
BaseType_t xError = pdFALSE;
 1001288:	e03ffd15 	stw	zero,-12(fp)

	for( ;; )
	{
		/* Loop until the queue is empty. */
		while( uxQueueMessagesWaiting( *( ( QueueHandle_t * ) pvParameters ) ) )
 100128c:	00001d06 	br	1001304 <vPolledQueueConsumer+0x94>
		{
			if( xQueueReceive( *( ( QueueHandle_t * ) pvParameters ), &usData, pollqNO_DELAY ) == pdPASS )
 1001290:	e0bfff17 	ldw	r2,-4(fp)
 1001294:	10800017 	ldw	r2,0(r2)
 1001298:	e0fffe04 	addi	r3,fp,-8
 100129c:	000f883a 	mov	r7,zero
 10012a0:	000d883a 	mov	r6,zero
 10012a4:	180b883a 	mov	r5,r3
 10012a8:	1009883a 	mov	r4,r2
 10012ac:	1004a800 	call	1004a80 <xQueueGenericReceive>
 10012b0:	10800058 	cmpnei	r2,r2,1
 10012b4:	1000131e 	bne	r2,zero,1001304 <vPolledQueueConsumer+0x94>
			{
				if( usData != usExpectedValue )
 10012b8:	e0bffe0b 	ldhu	r2,-8(fp)
 10012bc:	10ffffcc 	andi	r3,r2,65535
 10012c0:	e0bffc0b 	ldhu	r2,-16(fp)
 10012c4:	18800526 	beq	r3,r2,10012dc <vPolledQueueConsumer+0x6c>
				{
					/* This is not what we expected to receive so an error has
					occurred. */
					xError = pdTRUE;
 10012c8:	00800044 	movi	r2,1
 10012cc:	e0bffd15 	stw	r2,-12(fp)

					/* Catch-up to the value we received so our next expected
					value should again be correct. */
					usExpectedValue = usData;
 10012d0:	e0bffe0b 	ldhu	r2,-8(fp)
 10012d4:	e0bffc0d 	sth	r2,-16(fp)
 10012d8:	00000706 	br	10012f8 <vPolledQueueConsumer+0x88>
				}
				else
				{
					if( xError == pdFALSE )
 10012dc:	e0bffd17 	ldw	r2,-12(fp)
 10012e0:	1000051e 	bne	r2,zero,10012f8 <vPolledQueueConsumer+0x88>
					{
						/* Only increment the check variable if no errors have
						occurred. */
						portENTER_CRITICAL();
 10012e4:	1006d680 	call	1006d68 <vTaskEnterCritical>
							xPollingConsumerCount++;
 10012e8:	d0a04517 	ldw	r2,-32492(gp)
 10012ec:	10800044 	addi	r2,r2,1
 10012f0:	d0a04515 	stw	r2,-32492(gp)
						portEXIT_CRITICAL();
 10012f4:	1006dbc0 	call	1006dbc <vTaskExitCritical>
					}
				}

				/* Next time round we would expect the number to be one higher. */
				usExpectedValue++;
 10012f8:	e0bffc0b 	ldhu	r2,-16(fp)
 10012fc:	10800044 	addi	r2,r2,1
 1001300:	e0bffc0d 	sth	r2,-16(fp)
BaseType_t xError = pdFALSE;

	for( ;; )
	{
		/* Loop until the queue is empty. */
		while( uxQueueMessagesWaiting( *( ( QueueHandle_t * ) pvParameters ) ) )
 1001304:	e0bfff17 	ldw	r2,-4(fp)
 1001308:	10800017 	ldw	r2,0(r2)
 100130c:	1009883a 	mov	r4,r2
 1001310:	1004e140 	call	1004e14 <uxQueueMessagesWaiting>
 1001314:	103fde1e 	bne	r2,zero,1001290 <__alt_data_end+0xff801290>
			}
		}

		/* Now the queue is empty we block, allowing the producer to place more
		items in the queue. */
		vTaskDelay( pollqCONSUMER_DELAY );
 1001318:	01002d04 	movi	r4,180
 100131c:	10058ec0 	call	10058ec <vTaskDelay>
	}
 1001320:	003fda06 	br	100128c <__alt_data_end+0xff80128c>

01001324 <xArePollingQueuesStillRunning>:
} /*lint !e818 Function prototype must conform to API. */
/*-----------------------------------------------------------*/

/* This is called to check that all the created tasks are still running with no errors. */
BaseType_t xArePollingQueuesStillRunning( void )
{
 1001324:	defffe04 	addi	sp,sp,-8
 1001328:	df000115 	stw	fp,4(sp)
 100132c:	df000104 	addi	fp,sp,4

	/* Check both the consumer and producer poll count to check they have both
	been changed since out last trip round.  We do not need a critical section
	around the check variables as this is called from a higher priority than
	the other tasks that access the same variables. */
	if( ( xPollingConsumerCount == pollqINITIAL_VALUE ) ||
 1001330:	d0a04517 	ldw	r2,-32492(gp)
 1001334:	10000226 	beq	r2,zero,1001340 <xArePollingQueuesStillRunning+0x1c>
		( xPollingProducerCount == pollqINITIAL_VALUE )
 1001338:	d0a04617 	ldw	r2,-32488(gp)

	/* Check both the consumer and producer poll count to check they have both
	been changed since out last trip round.  We do not need a critical section
	around the check variables as this is called from a higher priority than
	the other tasks that access the same variables. */
	if( ( xPollingConsumerCount == pollqINITIAL_VALUE ) ||
 100133c:	1000021e 	bne	r2,zero,1001348 <xArePollingQueuesStillRunning+0x24>
		( xPollingProducerCount == pollqINITIAL_VALUE )
	  )
	{
		xReturn = pdFALSE;
 1001340:	e03fff15 	stw	zero,-4(fp)
 1001344:	00000206 	br	1001350 <xArePollingQueuesStillRunning+0x2c>
	}
	else
	{
		xReturn = pdTRUE;
 1001348:	00800044 	movi	r2,1
 100134c:	e0bfff15 	stw	r2,-4(fp)
	}

	/* Set the check variables back down so we know if they have been
	incremented the next time around. */
	xPollingConsumerCount = pollqINITIAL_VALUE;
 1001350:	d0204515 	stw	zero,-32492(gp)
	xPollingProducerCount = pollqINITIAL_VALUE;
 1001354:	d0204615 	stw	zero,-32488(gp)

	return xReturn;
 1001358:	e0bfff17 	ldw	r2,-4(fp)
}
 100135c:	e037883a 	mov	sp,fp
 1001360:	df000017 	ldw	fp,0(sp)
 1001364:	dec00104 	addi	sp,sp,4
 1001368:	f800283a 	ret

0100136c <vStartQueuePeekTasks>:
/* Handles to the test tasks. */
TaskHandle_t xMediumPriorityTask, xHighPriorityTask, xHighestPriorityTask;
/*-----------------------------------------------------------*/

void vStartQueuePeekTasks( void )
{
 100136c:	defffb04 	addi	sp,sp,-20
 1001370:	dfc00415 	stw	ra,16(sp)
 1001374:	df000315 	stw	fp,12(sp)
 1001378:	df000304 	addi	fp,sp,12
QueueHandle_t xQueue;

	/* Create the queue that we are going to use for the test/demo. */
	xQueue = xQueueCreate( qpeekQUEUE_LENGTH, sizeof( uint32_t ) );
 100137c:	000d883a 	mov	r6,zero
 1001380:	01400104 	movi	r5,4
 1001384:	01000144 	movi	r4,5
 1001388:	100439c0 	call	100439c <xQueueGenericCreate>
 100138c:	e0bfff15 	stw	r2,-4(fp)

	if( xQueue != NULL )
 1001390:	e0bfff17 	ldw	r2,-4(fp)
 1001394:	10002a26 	beq	r2,zero,1001440 <vStartQueuePeekTasks+0xd4>
		vQueueAddToRegistry( xQueue, "QPeek_Test_Queue" );

		/* Create the demo tasks and pass it the queue just created.  We are
		passing the queue handle by value so it does not matter that it is declared
		on the stack here. */
		xTaskCreate( prvLowPriorityPeekTask, "PeekL", configMINIMAL_STACK_SIZE, ( void * ) xQueue, qpeekLOW_PRIORITY, NULL );
 1001398:	d8000115 	stw	zero,4(sp)
 100139c:	d8000015 	stw	zero,0(sp)
 10013a0:	e1ffff17 	ldw	r7,-4(fp)
 10013a4:	01810004 	movi	r6,1024
 10013a8:	014040b4 	movhi	r5,258
 10013ac:	2969e804 	addi	r5,r5,-22624
 10013b0:	01004034 	movhi	r4,256
 10013b4:	2105c404 	addi	r4,r4,5904
 10013b8:	10053600 	call	1005360 <xTaskCreate>
		xTaskCreate( prvMediumPriorityPeekTask, "PeekM", configMINIMAL_STACK_SIZE, ( void * ) xQueue, qpeekMEDIUM_PRIORITY, &xMediumPriorityTask );
 10013bc:	d0a04c04 	addi	r2,gp,-32464
 10013c0:	d8800115 	stw	r2,4(sp)
 10013c4:	00800044 	movi	r2,1
 10013c8:	d8800015 	stw	r2,0(sp)
 10013cc:	e1ffff17 	ldw	r7,-4(fp)
 10013d0:	01810004 	movi	r6,1024
 10013d4:	014040b4 	movhi	r5,258
 10013d8:	2969ea04 	addi	r5,r5,-22616
 10013dc:	01004034 	movhi	r4,256
 10013e0:	2105a104 	addi	r4,r4,5764
 10013e4:	10053600 	call	1005360 <xTaskCreate>
		xTaskCreate( prvHighPriorityPeekTask, "PeekH1", configMINIMAL_STACK_SIZE, ( void * ) xQueue, qpeekHIGH_PRIORITY, &xHighPriorityTask );
 10013e8:	d0a04b04 	addi	r2,gp,-32468
 10013ec:	d8800115 	stw	r2,4(sp)
 10013f0:	00800084 	movi	r2,2
 10013f4:	d8800015 	stw	r2,0(sp)
 10013f8:	e1ffff17 	ldw	r7,-4(fp)
 10013fc:	01810004 	movi	r6,1024
 1001400:	014040b4 	movhi	r5,258
 1001404:	2969ec04 	addi	r5,r5,-22608
 1001408:	01004034 	movhi	r4,256
 100140c:	21056f04 	addi	r4,r4,5564
 1001410:	10053600 	call	1005360 <xTaskCreate>
		xTaskCreate( prvHighestPriorityPeekTask, "PeekH2", configMINIMAL_STACK_SIZE, ( void * ) xQueue, qpeekHIGHEST_PRIORITY, &xHighestPriorityTask );
 1001414:	d0a04d04 	addi	r2,gp,-32460
 1001418:	d8800115 	stw	r2,4(sp)
 100141c:	008000c4 	movi	r2,3
 1001420:	d8800015 	stw	r2,0(sp)
 1001424:	e1ffff17 	ldw	r7,-4(fp)
 1001428:	01810004 	movi	r6,1024
 100142c:	014040b4 	movhi	r5,258
 1001430:	2969ee04 	addi	r5,r5,-22600
 1001434:	01004034 	movhi	r4,256
 1001438:	21051604 	addi	r4,r4,5208
 100143c:	10053600 	call	1005360 <xTaskCreate>
	}
}
 1001440:	0001883a 	nop
 1001444:	e037883a 	mov	sp,fp
 1001448:	dfc00117 	ldw	ra,4(sp)
 100144c:	df000017 	ldw	fp,0(sp)
 1001450:	dec00204 	addi	sp,sp,8
 1001454:	f800283a 	ret

01001458 <prvHighestPriorityPeekTask>:
/*-----------------------------------------------------------*/

static void prvHighestPriorityPeekTask( void *pvParameters )
{
 1001458:	defffb04 	addi	sp,sp,-20
 100145c:	dfc00415 	stw	ra,16(sp)
 1001460:	df000315 	stw	fp,12(sp)
 1001464:	df000304 	addi	fp,sp,12
 1001468:	e13fff15 	stw	r4,-4(fp)
QueueHandle_t xQueue = ( QueueHandle_t ) pvParameters;
 100146c:	e0bfff17 	ldw	r2,-4(fp)
 1001470:	e0bffd15 	stw	r2,-12(fp)

	for( ;; )
	{
		/* Try peeking from the queue.  The queue should be empty so we will
		block, allowing the high priority task to execute. */
		if( xQueuePeek( xQueue, &ulValue, portMAX_DELAY ) != pdPASS )
 1001474:	e0bffe04 	addi	r2,fp,-8
 1001478:	01c00044 	movi	r7,1
 100147c:	01bfffc4 	movi	r6,-1
 1001480:	100b883a 	mov	r5,r2
 1001484:	e13ffd17 	ldw	r4,-12(fp)
 1001488:	1004a800 	call	1004a80 <xQueueGenericReceive>
 100148c:	10800060 	cmpeqi	r2,r2,1
 1001490:	1000021e 	bne	r2,zero,100149c <prvHighestPriorityPeekTask+0x44>
		{
			/* We expected to have received something by the time we unblock. */
			xErrorDetected = pdTRUE;
 1001494:	00800044 	movi	r2,1
 1001498:	d0a04815 	stw	r2,-32480(gp)
		be blocked on the queue.  We unblocked because the low priority task
		wrote a value to the queue, which we should have peeked.  Peeking the
		data (rather than receiving it) will leave the data on the queue, so
		the high priority task should then have also been unblocked, but not
		yet executed. */
		if( ulValue != 0x11223344 )
 100149c:	e0fffe17 	ldw	r3,-8(fp)
 10014a0:	008448b4 	movhi	r2,4386
 10014a4:	108cd104 	addi	r2,r2,13124
 10014a8:	18800226 	beq	r3,r2,10014b4 <prvHighestPriorityPeekTask+0x5c>
		{
			/* We did not receive the expected value. */
			xErrorDetected = pdTRUE;
 10014ac:	00800044 	movi	r2,1
 10014b0:	d0a04815 	stw	r2,-32480(gp)
		}

		if( uxQueueMessagesWaiting( xQueue ) != 1 )
 10014b4:	e13ffd17 	ldw	r4,-12(fp)
 10014b8:	1004e140 	call	1004e14 <uxQueueMessagesWaiting>
 10014bc:	10800060 	cmpeqi	r2,r2,1
 10014c0:	1000021e 	bne	r2,zero,10014cc <prvHighestPriorityPeekTask+0x74>
		{
			/* The message should have been left on the queue. */
			xErrorDetected = pdTRUE;
 10014c4:	00800044 	movi	r2,1
 10014c8:	d0a04815 	stw	r2,-32480(gp)
		}

		/* Now we are going to actually receive the data, so when the high
		priority task runs it will find the queue empty and return to the
		blocked state. */
		ulValue = 0;
 10014cc:	e03ffe15 	stw	zero,-8(fp)
		if( xQueueReceive( xQueue, &ulValue, qpeekNO_BLOCK ) != pdPASS )
 10014d0:	e0bffe04 	addi	r2,fp,-8
 10014d4:	000f883a 	mov	r7,zero
 10014d8:	000d883a 	mov	r6,zero
 10014dc:	100b883a 	mov	r5,r2
 10014e0:	e13ffd17 	ldw	r4,-12(fp)
 10014e4:	1004a800 	call	1004a80 <xQueueGenericReceive>
 10014e8:	10800060 	cmpeqi	r2,r2,1
 10014ec:	1000021e 	bne	r2,zero,10014f8 <prvHighestPriorityPeekTask+0xa0>
		{
			/* We expected to receive the value. */
			xErrorDetected = pdTRUE;
 10014f0:	00800044 	movi	r2,1
 10014f4:	d0a04815 	stw	r2,-32480(gp)
		}

		if( ulValue != 0x11223344 )
 10014f8:	e0fffe17 	ldw	r3,-8(fp)
 10014fc:	008448b4 	movhi	r2,4386
 1001500:	108cd104 	addi	r2,r2,13124
 1001504:	18800226 	beq	r3,r2,1001510 <prvHighestPriorityPeekTask+0xb8>
		{
			/* We did not receive the expected value - which should have been
			the same value as was peeked. */
			xErrorDetected = pdTRUE;
 1001508:	00800044 	movi	r2,1
 100150c:	d0a04815 	stw	r2,-32480(gp)
		}

		/* Now we will block again as the queue is once more empty.  The low
		priority task can then execute again. */
		if( xQueuePeek( xQueue, &ulValue, portMAX_DELAY ) != pdPASS )
 1001510:	e0bffe04 	addi	r2,fp,-8
 1001514:	01c00044 	movi	r7,1
 1001518:	01bfffc4 	movi	r6,-1
 100151c:	100b883a 	mov	r5,r2
 1001520:	e13ffd17 	ldw	r4,-12(fp)
 1001524:	1004a800 	call	1004a80 <xQueueGenericReceive>
 1001528:	10800060 	cmpeqi	r2,r2,1
 100152c:	1000021e 	bne	r2,zero,1001538 <prvHighestPriorityPeekTask+0xe0>
		{
			/* We expected to have received something by the time we unblock. */
			xErrorDetected = pdTRUE;
 1001530:	00800044 	movi	r2,1
 1001534:	d0a04815 	stw	r2,-32480(gp)
		}

		/* When we get here the low priority task should have again written to the
		queue. */
		if( ulValue != 0x01234567 )
 1001538:	e0fffe17 	ldw	r3,-8(fp)
 100153c:	008048f4 	movhi	r2,291
 1001540:	109159c4 	addi	r2,r2,17767
 1001544:	18800226 	beq	r3,r2,1001550 <prvHighestPriorityPeekTask+0xf8>
		{
			/* We did not receive the expected value. */
			xErrorDetected = pdTRUE;
 1001548:	00800044 	movi	r2,1
 100154c:	d0a04815 	stw	r2,-32480(gp)
		}

		if( uxQueueMessagesWaiting( xQueue ) != 1 )
 1001550:	e13ffd17 	ldw	r4,-12(fp)
 1001554:	1004e140 	call	1004e14 <uxQueueMessagesWaiting>
 1001558:	10800060 	cmpeqi	r2,r2,1
 100155c:	1000021e 	bne	r2,zero,1001568 <prvHighestPriorityPeekTask+0x110>
		{
			/* The message should have been left on the queue. */
			xErrorDetected = pdTRUE;
 1001560:	00800044 	movi	r2,1
 1001564:	d0a04815 	stw	r2,-32480(gp)

		/* We only peeked the data, so suspending ourselves now should enable
		the high priority task to also peek the data.  The high priority task
		will have been unblocked when we peeked the data as we left the data
		in the queue. */
		vTaskSuspend( NULL );
 1001568:	0009883a 	mov	r4,zero
 100156c:	1005ba40 	call	1005ba4 <vTaskSuspend>


		/* This time we are going to do the same as the above test, but the
		high priority task is going to receive the data, rather than peek it.
		This means that the medium priority task should never peek the value. */
		if( xQueuePeek( xQueue, &ulValue, portMAX_DELAY ) != pdPASS )
 1001570:	e0bffe04 	addi	r2,fp,-8
 1001574:	01c00044 	movi	r7,1
 1001578:	01bfffc4 	movi	r6,-1
 100157c:	100b883a 	mov	r5,r2
 1001580:	e13ffd17 	ldw	r4,-12(fp)
 1001584:	1004a800 	call	1004a80 <xQueueGenericReceive>
 1001588:	10800060 	cmpeqi	r2,r2,1
 100158c:	1000021e 	bne	r2,zero,1001598 <prvHighestPriorityPeekTask+0x140>
		{
			xErrorDetected = pdTRUE;
 1001590:	00800044 	movi	r2,1
 1001594:	d0a04815 	stw	r2,-32480(gp)
		}

		if( ulValue != 0xaabbaabb )
 1001598:	e0fffe17 	ldw	r3,-8(fp)
 100159c:	00aaaf34 	movhi	r2,43708
 10015a0:	10aaaec4 	addi	r2,r2,-21829
 10015a4:	18800226 	beq	r3,r2,10015b0 <prvHighestPriorityPeekTask+0x158>
		{
			xErrorDetected = pdTRUE;
 10015a8:	00800044 	movi	r2,1
 10015ac:	d0a04815 	stw	r2,-32480(gp)
		}

		vTaskSuspend( NULL );
 10015b0:	0009883a 	mov	r4,zero
 10015b4:	1005ba40 	call	1005ba4 <vTaskSuspend>
	}
 10015b8:	003fae06 	br	1001474 <__alt_data_end+0xff801474>

010015bc <prvHighPriorityPeekTask>:
}
/*-----------------------------------------------------------*/

static void prvHighPriorityPeekTask( void *pvParameters )
{
 10015bc:	defffb04 	addi	sp,sp,-20
 10015c0:	dfc00415 	stw	ra,16(sp)
 10015c4:	df000315 	stw	fp,12(sp)
 10015c8:	df000304 	addi	fp,sp,12
 10015cc:	e13fff15 	stw	r4,-4(fp)
QueueHandle_t xQueue = ( QueueHandle_t ) pvParameters;
 10015d0:	e0bfff17 	ldw	r2,-4(fp)
 10015d4:	e0bffd15 	stw	r2,-12(fp)
	for( ;; )
	{
		/* Try peeking from the queue.  The queue should be empty so we will
		block, allowing the medium priority task to execute.  Both the high
		and highest priority tasks will then be blocked on the queue. */
		if( xQueuePeek( xQueue, &ulValue, portMAX_DELAY ) != pdPASS )
 10015d8:	e0bffe04 	addi	r2,fp,-8
 10015dc:	01c00044 	movi	r7,1
 10015e0:	01bfffc4 	movi	r6,-1
 10015e4:	100b883a 	mov	r5,r2
 10015e8:	e13ffd17 	ldw	r4,-12(fp)
 10015ec:	1004a800 	call	1004a80 <xQueueGenericReceive>
 10015f0:	10800060 	cmpeqi	r2,r2,1
 10015f4:	1000021e 	bne	r2,zero,1001600 <prvHighPriorityPeekTask+0x44>
		{
			/* We expected to have received something by the time we unblock. */
			xErrorDetected = pdTRUE;
 10015f8:	00800044 	movi	r2,1
 10015fc:	d0a04815 	stw	r2,-32480(gp)
		}

		/* When we get here the highest priority task should have peeked the data
		(unblocking this task) then suspended (allowing this task to also peek
		the data). */
		if( ulValue != 0x01234567 )
 1001600:	e0fffe17 	ldw	r3,-8(fp)
 1001604:	008048f4 	movhi	r2,291
 1001608:	109159c4 	addi	r2,r2,17767
 100160c:	18800226 	beq	r3,r2,1001618 <prvHighPriorityPeekTask+0x5c>
		{
			/* We did not receive the expected value. */
			xErrorDetected = pdTRUE;
 1001610:	00800044 	movi	r2,1
 1001614:	d0a04815 	stw	r2,-32480(gp)
		}

		if( uxQueueMessagesWaiting( xQueue ) != 1 )
 1001618:	e13ffd17 	ldw	r4,-12(fp)
 100161c:	1004e140 	call	1004e14 <uxQueueMessagesWaiting>
 1001620:	10800060 	cmpeqi	r2,r2,1
 1001624:	1000021e 	bne	r2,zero,1001630 <prvHighPriorityPeekTask+0x74>
		{
			/* The message should have been left on the queue. */
			xErrorDetected = pdTRUE;
 1001628:	00800044 	movi	r2,1
 100162c:	d0a04815 	stw	r2,-32480(gp)

		/* We only peeked the data, so suspending ourselves now should enable
		the medium priority task to also peek the data.  The medium priority task
		will have been unblocked when we peeked the data as we left the data
		in the queue. */
		vTaskSuspend( NULL );
 1001630:	0009883a 	mov	r4,zero
 1001634:	1005ba40 	call	1005ba4 <vTaskSuspend>


		/* This time we are going actually receive the value, so the medium
		priority task will never peek the data - we removed it from the queue. */
		if( xQueueReceive( xQueue, &ulValue, portMAX_DELAY ) != pdPASS )
 1001638:	e0bffe04 	addi	r2,fp,-8
 100163c:	000f883a 	mov	r7,zero
 1001640:	01bfffc4 	movi	r6,-1
 1001644:	100b883a 	mov	r5,r2
 1001648:	e13ffd17 	ldw	r4,-12(fp)
 100164c:	1004a800 	call	1004a80 <xQueueGenericReceive>
 1001650:	10800060 	cmpeqi	r2,r2,1
 1001654:	1000021e 	bne	r2,zero,1001660 <prvHighPriorityPeekTask+0xa4>
		{
			xErrorDetected = pdTRUE;
 1001658:	00800044 	movi	r2,1
 100165c:	d0a04815 	stw	r2,-32480(gp)
		}

		if( ulValue != 0xaabbaabb )
 1001660:	e0fffe17 	ldw	r3,-8(fp)
 1001664:	00aaaf34 	movhi	r2,43708
 1001668:	10aaaec4 	addi	r2,r2,-21829
 100166c:	18800226 	beq	r3,r2,1001678 <prvHighPriorityPeekTask+0xbc>
		{
			xErrorDetected = pdTRUE;
 1001670:	00800044 	movi	r2,1
 1001674:	d0a04815 	stw	r2,-32480(gp)
		}

		vTaskSuspend( NULL );
 1001678:	0009883a 	mov	r4,zero
 100167c:	1005ba40 	call	1005ba4 <vTaskSuspend>
	}
 1001680:	003fd506 	br	10015d8 <__alt_data_end+0xff8015d8>

01001684 <prvMediumPriorityPeekTask>:
}
/*-----------------------------------------------------------*/

static void prvMediumPriorityPeekTask( void *pvParameters )
{
 1001684:	defffb04 	addi	sp,sp,-20
 1001688:	dfc00415 	stw	ra,16(sp)
 100168c:	df000315 	stw	fp,12(sp)
 1001690:	df000304 	addi	fp,sp,12
 1001694:	e13fff15 	stw	r4,-4(fp)
QueueHandle_t xQueue = ( QueueHandle_t ) pvParameters;
 1001698:	e0bfff17 	ldw	r2,-4(fp)
 100169c:	e0bffd15 	stw	r2,-12(fp)
	for( ;; )
	{
		/* Try peeking from the queue.  The queue should be empty so we will
		block, allowing the low priority task to execute.  The highest, high
		and medium priority tasks will then all be blocked on the queue. */
		if( xQueuePeek( xQueue, &ulValue, portMAX_DELAY ) != pdPASS )
 10016a0:	e0bffe04 	addi	r2,fp,-8
 10016a4:	01c00044 	movi	r7,1
 10016a8:	01bfffc4 	movi	r6,-1
 10016ac:	100b883a 	mov	r5,r2
 10016b0:	e13ffd17 	ldw	r4,-12(fp)
 10016b4:	1004a800 	call	1004a80 <xQueueGenericReceive>
 10016b8:	10800060 	cmpeqi	r2,r2,1
 10016bc:	1000021e 	bne	r2,zero,10016c8 <prvMediumPriorityPeekTask+0x44>
		{
			/* We expected to have received something by the time we unblock. */
			xErrorDetected = pdTRUE;
 10016c0:	00800044 	movi	r2,1
 10016c4:	d0a04815 	stw	r2,-32480(gp)
		}

		/* When we get here the high priority task should have peeked the data
		(unblocking this task) then suspended (allowing this task to also peek
		the data). */
		if( ulValue != 0x01234567 )
 10016c8:	e0fffe17 	ldw	r3,-8(fp)
 10016cc:	008048f4 	movhi	r2,291
 10016d0:	109159c4 	addi	r2,r2,17767
 10016d4:	18800226 	beq	r3,r2,10016e0 <prvMediumPriorityPeekTask+0x5c>
		{
			/* We did not receive the expected value. */
			xErrorDetected = pdTRUE;
 10016d8:	00800044 	movi	r2,1
 10016dc:	d0a04815 	stw	r2,-32480(gp)
		}

		if( uxQueueMessagesWaiting( xQueue ) != 1 )
 10016e0:	e13ffd17 	ldw	r4,-12(fp)
 10016e4:	1004e140 	call	1004e14 <uxQueueMessagesWaiting>
 10016e8:	10800060 	cmpeqi	r2,r2,1
 10016ec:	1000021e 	bne	r2,zero,10016f8 <prvMediumPriorityPeekTask+0x74>
		{
			/* The message should have been left on the queue. */
			xErrorDetected = pdTRUE;
 10016f0:	00800044 	movi	r2,1
 10016f4:	d0a04815 	stw	r2,-32480(gp)
		}

		/* Just so we know the test is still running. */
		ulLoopCounter++;
 10016f8:	d0a04917 	ldw	r2,-32476(gp)
 10016fc:	10800044 	addi	r2,r2,1
 1001700:	d0a04915 	stw	r2,-32476(gp)

		/* Now we can suspend ourselves so the low priority task can execute
		again. */
		vTaskSuspend( NULL );
 1001704:	0009883a 	mov	r4,zero
 1001708:	1005ba40 	call	1005ba4 <vTaskSuspend>
	}
 100170c:	003fe406 	br	10016a0 <__alt_data_end+0xff8016a0>

01001710 <prvLowPriorityPeekTask>:
}
/*-----------------------------------------------------------*/

static void prvLowPriorityPeekTask( void *pvParameters )
{
 1001710:	defffb04 	addi	sp,sp,-20
 1001714:	dfc00415 	stw	ra,16(sp)
 1001718:	df000315 	stw	fp,12(sp)
 100171c:	df000304 	addi	fp,sp,12
 1001720:	e13fff15 	stw	r4,-4(fp)
QueueHandle_t xQueue = ( QueueHandle_t ) pvParameters;
 1001724:	e0bfff17 	ldw	r2,-4(fp)
 1001728:	e0bffd15 	stw	r2,-12(fp)

	for( ;; )
	{
		/* Write some data to the queue.  This should unblock the highest
		priority task that is waiting to peek data from the queue. */
		ulValue = 0x11223344;
 100172c:	008448b4 	movhi	r2,4386
 1001730:	108cd104 	addi	r2,r2,13124
 1001734:	e0bffe15 	stw	r2,-8(fp)
		if( xQueueSendToBack( xQueue, &ulValue, qpeekNO_BLOCK ) != pdPASS )
 1001738:	e0bffe04 	addi	r2,fp,-8
 100173c:	000f883a 	mov	r7,zero
 1001740:	000d883a 	mov	r6,zero
 1001744:	100b883a 	mov	r5,r2
 1001748:	e13ffd17 	ldw	r4,-12(fp)
 100174c:	10047080 	call	1004708 <xQueueGenericSend>
 1001750:	10800060 	cmpeqi	r2,r2,1
 1001754:	1000021e 	bne	r2,zero,1001760 <prvLowPriorityPeekTask+0x50>
		{
			/* We were expecting the queue to be empty so we should not of
			had a problem writing to the queue. */
			xErrorDetected = pdTRUE;
 1001758:	00800044 	movi	r2,1
 100175c:	d0a04815 	stw	r2,-32480(gp)
			taskYIELD();
		#endif

		/* By the time we get here the data should have been removed from
		the queue. */
		if( uxQueueMessagesWaiting( xQueue ) != 0 )
 1001760:	e13ffd17 	ldw	r4,-12(fp)
 1001764:	1004e140 	call	1004e14 <uxQueueMessagesWaiting>
 1001768:	10000226 	beq	r2,zero,1001774 <prvLowPriorityPeekTask+0x64>
		{
			xErrorDetected = pdTRUE;
 100176c:	00800044 	movi	r2,1
 1001770:	d0a04815 	stw	r2,-32480(gp)
		}

		/* Write another value to the queue, again waking the highest priority
		task that is blocked on the queue. */
		ulValue = 0x01234567;
 1001774:	008048f4 	movhi	r2,291
 1001778:	109159c4 	addi	r2,r2,17767
 100177c:	e0bffe15 	stw	r2,-8(fp)
		if( xQueueSendToBack( xQueue, &ulValue, qpeekNO_BLOCK ) != pdPASS )
 1001780:	e0bffe04 	addi	r2,fp,-8
 1001784:	000f883a 	mov	r7,zero
 1001788:	000d883a 	mov	r6,zero
 100178c:	100b883a 	mov	r5,r2
 1001790:	e13ffd17 	ldw	r4,-12(fp)
 1001794:	10047080 	call	1004708 <xQueueGenericSend>
 1001798:	10800060 	cmpeqi	r2,r2,1
 100179c:	1000021e 	bne	r2,zero,10017a8 <prvLowPriorityPeekTask+0x98>
		{
			/* We were expecting the queue to be empty so we should not of
			had a problem writing to the queue. */
			xErrorDetected = pdTRUE;
 10017a0:	00800044 	movi	r2,1
 10017a4:	d0a04815 	stw	r2,-32480(gp)
			taskYIELD();
		#endif

		/* All the other tasks should now have successfully peeked the data.
		The data is still in the queue so we should be able to receive it. */
		ulValue = 0;
 10017a8:	e03ffe15 	stw	zero,-8(fp)
		if( xQueueReceive( xQueue, &ulValue, qpeekNO_BLOCK ) != pdPASS )
 10017ac:	e0bffe04 	addi	r2,fp,-8
 10017b0:	000f883a 	mov	r7,zero
 10017b4:	000d883a 	mov	r6,zero
 10017b8:	100b883a 	mov	r5,r2
 10017bc:	e13ffd17 	ldw	r4,-12(fp)
 10017c0:	1004a800 	call	1004a80 <xQueueGenericReceive>
 10017c4:	10800060 	cmpeqi	r2,r2,1
 10017c8:	1000021e 	bne	r2,zero,10017d4 <prvLowPriorityPeekTask+0xc4>
		{
			/* We expected to receive the data. */
			xErrorDetected = pdTRUE;
 10017cc:	00800044 	movi	r2,1
 10017d0:	d0a04815 	stw	r2,-32480(gp)
			/* We did not receive the expected value. */
		}

		/* Lets just delay a while as this is an intensive test as we don't
		want to starve other tests of processing time. */
		vTaskDelay( qpeekSHORT_DELAY );
 10017d4:	01000284 	movi	r4,10
 10017d8:	10058ec0 	call	10058ec <vTaskDelay>
		/* Unsuspend the other tasks so we can repeat the test - this time
		however not all the other tasks will peek the data as the high
		priority task is actually going to remove it from the queue.  Send
		to front is used just to be different.  As the queue is empty it
		makes no difference to the result. */
		vTaskResume( xMediumPriorityTask );
 10017dc:	d0a04c17 	ldw	r2,-32464(gp)
 10017e0:	1009883a 	mov	r4,r2
 10017e4:	1005d180 	call	1005d18 <vTaskResume>
		vTaskResume( xHighPriorityTask );
 10017e8:	d0a04b17 	ldw	r2,-32468(gp)
 10017ec:	1009883a 	mov	r4,r2
 10017f0:	1005d180 	call	1005d18 <vTaskResume>
		vTaskResume( xHighestPriorityTask );
 10017f4:	d0a04d17 	ldw	r2,-32460(gp)
 10017f8:	1009883a 	mov	r4,r2
 10017fc:	1005d180 	call	1005d18 <vTaskResume>

		#if( configUSE_PREEMPTION == 0 )
			taskYIELD();
		#endif

		ulValue = 0xaabbaabb;
 1001800:	00aaaf34 	movhi	r2,43708
 1001804:	10aaaec4 	addi	r2,r2,-21829
 1001808:	e0bffe15 	stw	r2,-8(fp)
		if( xQueueSendToFront( xQueue, &ulValue, qpeekNO_BLOCK ) != pdPASS )
 100180c:	e0bffe04 	addi	r2,fp,-8
 1001810:	01c00044 	movi	r7,1
 1001814:	000d883a 	mov	r6,zero
 1001818:	100b883a 	mov	r5,r2
 100181c:	e13ffd17 	ldw	r4,-12(fp)
 1001820:	10047080 	call	1004708 <xQueueGenericSend>
 1001824:	10800060 	cmpeqi	r2,r2,1
 1001828:	1000021e 	bne	r2,zero,1001834 <prvLowPriorityPeekTask+0x124>
		{
			/* We were expecting the queue to be empty so we should not of
			had a problem writing to the queue. */
			xErrorDetected = pdTRUE;
 100182c:	00800044 	movi	r2,1
 1001830:	d0a04815 	stw	r2,-32480(gp)
			taskYIELD();
		#endif

		/* This time we should find that the queue is empty.  The high priority
		task actually removed the data rather than just peeking it. */
		if( xQueuePeek( xQueue, &ulValue, qpeekNO_BLOCK ) != errQUEUE_EMPTY )
 1001834:	e0bffe04 	addi	r2,fp,-8
 1001838:	01c00044 	movi	r7,1
 100183c:	000d883a 	mov	r6,zero
 1001840:	100b883a 	mov	r5,r2
 1001844:	e13ffd17 	ldw	r4,-12(fp)
 1001848:	1004a800 	call	1004a80 <xQueueGenericReceive>
 100184c:	10000226 	beq	r2,zero,1001858 <prvLowPriorityPeekTask+0x148>
		{
			/* We expected to receive the data. */
			xErrorDetected = pdTRUE;
 1001850:	00800044 	movi	r2,1
 1001854:	d0a04815 	stw	r2,-32480(gp)
		}

		/* Unsuspend the highest and high priority tasks so we can go back
		and repeat the whole thing.  The medium priority task should not be
		suspended as it was not able to peek the data in this last case. */
		vTaskResume( xHighPriorityTask );
 1001858:	d0a04b17 	ldw	r2,-32468(gp)
 100185c:	1009883a 	mov	r4,r2
 1001860:	1005d180 	call	1005d18 <vTaskResume>
		vTaskResume( xHighestPriorityTask );
 1001864:	d0a04d17 	ldw	r2,-32460(gp)
 1001868:	1009883a 	mov	r4,r2
 100186c:	1005d180 	call	1005d18 <vTaskResume>

		/* Lets just delay a while as this is an intensive test as we don't
		want to starve other tests of processing time. */
		vTaskDelay( qpeekSHORT_DELAY );
 1001870:	01000284 	movi	r4,10
 1001874:	10058ec0 	call	10058ec <vTaskDelay>
	}
 1001878:	003fac06 	br	100172c <__alt_data_end+0xff80172c>

0100187c <xAreQueuePeekTasksStillRunning>:
}
/*-----------------------------------------------------------*/

/* This is called to check that all the created tasks are still running. */
BaseType_t xAreQueuePeekTasksStillRunning( void )
{
 100187c:	deffff04 	addi	sp,sp,-4
 1001880:	df000015 	stw	fp,0(sp)
 1001884:	d839883a 	mov	fp,sp
static uint32_t ulLastLoopCounter = 0;

	/* If the demo task is still running then we expect the loopcounter to
	have incremented since this function was last called. */
	if( ulLastLoopCounter == ulLoopCounter )
 1001888:	d0e04a17 	ldw	r3,-32472(gp)
 100188c:	d0a04917 	ldw	r2,-32476(gp)
 1001890:	1880021e 	bne	r3,r2,100189c <xAreQueuePeekTasksStillRunning+0x20>
	{
		xErrorDetected = pdTRUE;
 1001894:	00800044 	movi	r2,1
 1001898:	d0a04815 	stw	r2,-32480(gp)
	}

	ulLastLoopCounter = ulLoopCounter;
 100189c:	d0a04917 	ldw	r2,-32476(gp)
 10018a0:	d0a04a15 	stw	r2,-32472(gp)

	/* Errors detected in the task itself will have latched xErrorDetected
	to true. */

	return ( BaseType_t ) !xErrorDetected;
 10018a4:	d0a04817 	ldw	r2,-32480(gp)
 10018a8:	1005003a 	cmpeq	r2,r2,zero
 10018ac:	10803fcc 	andi	r2,r2,255
}
 10018b0:	e037883a 	mov	sp,fp
 10018b4:	df000017 	ldw	fp,0(sp)
 10018b8:	dec00104 	addi	sp,sp,4
 10018bc:	f800283a 	ret

010018c0 <vCreateBlockTimeTasks>:
static volatile UBaseType_t xRunIndicator;

/*-----------------------------------------------------------*/

void vCreateBlockTimeTasks( void )
{
 10018c0:	defffc04 	addi	sp,sp,-16
 10018c4:	dfc00315 	stw	ra,12(sp)
 10018c8:	df000215 	stw	fp,8(sp)
 10018cc:	df000204 	addi	fp,sp,8
	/* Create the queue on which the two tasks block. */
	xTestQueue = xQueueCreate( bktQUEUE_LENGTH, sizeof( BaseType_t ) );
 10018d0:	000d883a 	mov	r6,zero
 10018d4:	01400104 	movi	r5,4
 10018d8:	01000144 	movi	r4,5
 10018dc:	100439c0 	call	100439c <xQueueGenericCreate>
 10018e0:	d0a04e15 	stw	r2,-32456(gp)

	if( xTestQueue != NULL )
 10018e4:	d0a04e17 	ldw	r2,-32456(gp)
 10018e8:	10001526 	beq	r2,zero,1001940 <vCreateBlockTimeTasks+0x80>
		removed by the pre-processor if configQUEUE_REGISTRY_SIZE is not
		defined or is defined to be less than 1. */
		vQueueAddToRegistry( xTestQueue, "Block_Time_Queue" );

		/* Create the two test tasks. */
		xTaskCreate( vPrimaryBlockTimeTestTask, "BTest1", configMINIMAL_STACK_SIZE, NULL, bktPRIMARY_PRIORITY, NULL );
 10018ec:	d8000115 	stw	zero,4(sp)
 10018f0:	00800084 	movi	r2,2
 10018f4:	d8800015 	stw	r2,0(sp)
 10018f8:	000f883a 	mov	r7,zero
 10018fc:	01810004 	movi	r6,1024
 1001900:	014040b4 	movhi	r5,258
 1001904:	2969f004 	addi	r5,r5,-22592
 1001908:	01004034 	movhi	r4,256
 100190c:	21065604 	addi	r4,r4,6488
 1001910:	10053600 	call	1005360 <xTaskCreate>
		xTaskCreate( vSecondaryBlockTimeTestTask, "BTest2", configMINIMAL_STACK_SIZE, NULL, bktSECONDARY_PRIORITY, &xSecondary );
 1001914:	d0a04f04 	addi	r2,gp,-32452
 1001918:	d8800115 	stw	r2,4(sp)
 100191c:	00800044 	movi	r2,1
 1001920:	d8800015 	stw	r2,0(sp)
 1001924:	000f883a 	mov	r7,zero
 1001928:	01810004 	movi	r6,1024
 100192c:	014040b4 	movhi	r5,258
 1001930:	2969f204 	addi	r5,r5,-22584
 1001934:	01004034 	movhi	r4,256
 1001938:	21076004 	addi	r4,r4,7552
 100193c:	10053600 	call	1005360 <xTaskCreate>
	}
}
 1001940:	0001883a 	nop
 1001944:	e037883a 	mov	sp,fp
 1001948:	dfc00117 	ldw	ra,4(sp)
 100194c:	df000017 	ldw	fp,0(sp)
 1001950:	dec00204 	addi	sp,sp,8
 1001954:	f800283a 	ret

01001958 <vPrimaryBlockTimeTestTask>:
/*-----------------------------------------------------------*/

static void vPrimaryBlockTimeTestTask( void *pvParameters )
{
 1001958:	defff804 	addi	sp,sp,-32
 100195c:	dfc00715 	stw	ra,28(sp)
 1001960:	df000615 	stw	fp,24(sp)
 1001964:	df000604 	addi	fp,sp,24
 1001968:	e13fff15 	stw	r4,-4(fp)
	{
		/*********************************************************************
		Test 0

		Basic vTaskDelay() and vTaskDelayUntil() tests. */
		prvBasicDelayTests();
 100196c:	1001eb00 	call	1001eb0 <prvBasicDelayTests>

		/*********************************************************************
		Test 1

		Simple block time wakeup test on queue receives. */
		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 1001970:	e03ffd15 	stw	zero,-12(fp)
 1001974:	00002306 	br	1001a04 <vPrimaryBlockTimeTestTask+0xac>
		{
			/* The queue is empty. Attempt to read from the queue using a block
			time.  When we wake, ensure the delta in time is as expected. */
			xTimeToBlock = ( TickType_t ) ( bktPRIMARY_BLOCK_TIME << xItem );
 1001978:	e0bffd17 	ldw	r2,-12(fp)
 100197c:	00c00284 	movi	r3,10
 1001980:	1884983a 	sll	r2,r3,r2
 1001984:	e0bffa15 	stw	r2,-24(fp)

			xTimeWhenBlocking = xTaskGetTickCount();
 1001988:	10061200 	call	1006120 <xTaskGetTickCount>
 100198c:	e0bffb15 	stw	r2,-20(fp)

			/* We should unblock after xTimeToBlock having not received
			anything on the queue. */
			if( xQueueReceive( xTestQueue, &xData, xTimeToBlock ) != errQUEUE_EMPTY )
 1001990:	d0a04e17 	ldw	r2,-32456(gp)
 1001994:	e0fffe04 	addi	r3,fp,-8
 1001998:	000f883a 	mov	r7,zero
 100199c:	e1bffa17 	ldw	r6,-24(fp)
 10019a0:	180b883a 	mov	r5,r3
 10019a4:	1009883a 	mov	r4,r2
 10019a8:	1004a800 	call	1004a80 <xQueueGenericReceive>
 10019ac:	10000226 	beq	r2,zero,10019b8 <vPrimaryBlockTimeTestTask+0x60>
			{
				xErrorOccurred = pdTRUE;
 10019b0:	00800044 	movi	r2,1
 10019b4:	d0a05215 	stw	r2,-32440(gp)
			}

			/* How long were we blocked for? */
			xBlockedTime = xTaskGetTickCount() - xTimeWhenBlocking;
 10019b8:	10061200 	call	1006120 <xTaskGetTickCount>
 10019bc:	1007883a 	mov	r3,r2
 10019c0:	e0bffb17 	ldw	r2,-20(fp)
 10019c4:	1885c83a 	sub	r2,r3,r2
 10019c8:	e0bffc15 	stw	r2,-16(fp)

			if( xBlockedTime < xTimeToBlock )
 10019cc:	e0fffc17 	ldw	r3,-16(fp)
 10019d0:	e0bffa17 	ldw	r2,-24(fp)
 10019d4:	1880022e 	bgeu	r3,r2,10019e0 <vPrimaryBlockTimeTestTask+0x88>
			{
				/* Should not have blocked for less than we requested. */
				xErrorOccurred = pdTRUE;
 10019d8:	00800044 	movi	r2,1
 10019dc:	d0a05215 	stw	r2,-32440(gp)
			}

			if( xBlockedTime > ( xTimeToBlock + bktALLOWABLE_MARGIN ) )
 10019e0:	e0bffa17 	ldw	r2,-24(fp)
 10019e4:	10c003c4 	addi	r3,r2,15
 10019e8:	e0bffc17 	ldw	r2,-16(fp)
 10019ec:	1880022e 	bgeu	r3,r2,10019f8 <vPrimaryBlockTimeTestTask+0xa0>
			{
				/* Should not have blocked for longer than we requested,
				although we would not necessarily run as soon as we were
				unblocked so a margin is allowed. */
				xErrorOccurred = pdTRUE;
 10019f0:	00800044 	movi	r2,1
 10019f4:	d0a05215 	stw	r2,-32440(gp)

		/*********************************************************************
		Test 1

		Simple block time wakeup test on queue receives. */
		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 10019f8:	e0bffd17 	ldw	r2,-12(fp)
 10019fc:	10800044 	addi	r2,r2,1
 1001a00:	e0bffd15 	stw	r2,-12(fp)
 1001a04:	e0bffd17 	ldw	r2,-12(fp)
 1001a08:	10800150 	cmplti	r2,r2,5
 1001a0c:	103fda1e 	bne	r2,zero,1001978 <__alt_data_end+0xff801978>
		Test 2

		Simple block time wakeup test on queue sends.

		First fill the queue.  It should be empty so all sends should pass. */
		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 1001a10:	e03ffd15 	stw	zero,-12(fp)
 1001a14:	00000e06 	br	1001a50 <vPrimaryBlockTimeTestTask+0xf8>
		{
			if( xQueueSend( xTestQueue, &xItem, bktDONT_BLOCK ) != pdPASS )
 1001a18:	d0a04e17 	ldw	r2,-32456(gp)
 1001a1c:	e0fffd04 	addi	r3,fp,-12
 1001a20:	000f883a 	mov	r7,zero
 1001a24:	000d883a 	mov	r6,zero
 1001a28:	180b883a 	mov	r5,r3
 1001a2c:	1009883a 	mov	r4,r2
 1001a30:	10047080 	call	1004708 <xQueueGenericSend>
 1001a34:	10800060 	cmpeqi	r2,r2,1
 1001a38:	1000021e 	bne	r2,zero,1001a44 <vPrimaryBlockTimeTestTask+0xec>
			{
				xErrorOccurred = pdTRUE;
 1001a3c:	00800044 	movi	r2,1
 1001a40:	d0a05215 	stw	r2,-32440(gp)
		Test 2

		Simple block time wakeup test on queue sends.

		First fill the queue.  It should be empty so all sends should pass. */
		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 1001a44:	e0bffd17 	ldw	r2,-12(fp)
 1001a48:	10800044 	addi	r2,r2,1
 1001a4c:	e0bffd15 	stw	r2,-12(fp)
 1001a50:	e0bffd17 	ldw	r2,-12(fp)
 1001a54:	10800150 	cmplti	r2,r2,5
 1001a58:	103fef1e 	bne	r2,zero,1001a18 <__alt_data_end+0xff801a18>
			#if configUSE_PREEMPTION == 0
				taskYIELD();
			#endif
		}

		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 1001a5c:	e03ffd15 	stw	zero,-12(fp)
 1001a60:	00002306 	br	1001af0 <vPrimaryBlockTimeTestTask+0x198>
		{
			/* The queue is full. Attempt to write to the queue using a block
			time.  When we wake, ensure the delta in time is as expected. */
			xTimeToBlock = ( TickType_t ) ( bktPRIMARY_BLOCK_TIME << xItem );
 1001a64:	e0bffd17 	ldw	r2,-12(fp)
 1001a68:	00c00284 	movi	r3,10
 1001a6c:	1884983a 	sll	r2,r3,r2
 1001a70:	e0bffa15 	stw	r2,-24(fp)

			xTimeWhenBlocking = xTaskGetTickCount();
 1001a74:	10061200 	call	1006120 <xTaskGetTickCount>
 1001a78:	e0bffb15 	stw	r2,-20(fp)

			/* We should unblock after xTimeToBlock having not received
			anything on the queue. */
			if( xQueueSend( xTestQueue, &xItem, xTimeToBlock ) != errQUEUE_FULL )
 1001a7c:	d0a04e17 	ldw	r2,-32456(gp)
 1001a80:	e0fffd04 	addi	r3,fp,-12
 1001a84:	000f883a 	mov	r7,zero
 1001a88:	e1bffa17 	ldw	r6,-24(fp)
 1001a8c:	180b883a 	mov	r5,r3
 1001a90:	1009883a 	mov	r4,r2
 1001a94:	10047080 	call	1004708 <xQueueGenericSend>
 1001a98:	10000226 	beq	r2,zero,1001aa4 <vPrimaryBlockTimeTestTask+0x14c>
			{
				xErrorOccurred = pdTRUE;
 1001a9c:	00800044 	movi	r2,1
 1001aa0:	d0a05215 	stw	r2,-32440(gp)
			}

			/* How long were we blocked for? */
			xBlockedTime = xTaskGetTickCount() - xTimeWhenBlocking;
 1001aa4:	10061200 	call	1006120 <xTaskGetTickCount>
 1001aa8:	1007883a 	mov	r3,r2
 1001aac:	e0bffb17 	ldw	r2,-20(fp)
 1001ab0:	1885c83a 	sub	r2,r3,r2
 1001ab4:	e0bffc15 	stw	r2,-16(fp)

			if( xBlockedTime < xTimeToBlock )
 1001ab8:	e0fffc17 	ldw	r3,-16(fp)
 1001abc:	e0bffa17 	ldw	r2,-24(fp)
 1001ac0:	1880022e 	bgeu	r3,r2,1001acc <vPrimaryBlockTimeTestTask+0x174>
			{
				/* Should not have blocked for less than we requested. */
				xErrorOccurred = pdTRUE;
 1001ac4:	00800044 	movi	r2,1
 1001ac8:	d0a05215 	stw	r2,-32440(gp)
			}

			if( xBlockedTime > ( xTimeToBlock + bktALLOWABLE_MARGIN ) )
 1001acc:	e0bffa17 	ldw	r2,-24(fp)
 1001ad0:	10c003c4 	addi	r3,r2,15
 1001ad4:	e0bffc17 	ldw	r2,-16(fp)
 1001ad8:	1880022e 	bgeu	r3,r2,1001ae4 <vPrimaryBlockTimeTestTask+0x18c>
			{
				/* Should not have blocked for longer than we requested,
				although we would not necessarily run as soon as we were
				unblocked so a margin is allowed. */
				xErrorOccurred = pdTRUE;
 1001adc:	00800044 	movi	r2,1
 1001ae0:	d0a05215 	stw	r2,-32440(gp)
			#if configUSE_PREEMPTION == 0
				taskYIELD();
			#endif
		}

		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 1001ae4:	e0bffd17 	ldw	r2,-12(fp)
 1001ae8:	10800044 	addi	r2,r2,1
 1001aec:	e0bffd15 	stw	r2,-12(fp)
 1001af0:	e0bffd17 	ldw	r2,-12(fp)
 1001af4:	10800150 	cmplti	r2,r2,5
 1001af8:	103fda1e 	bne	r2,zero,1001a64 <__alt_data_end+0xff801a64>
		recognise that its block time has not expired and return to block for
		the remains of its block time.

		Wake the other task so it blocks attempting to post to the already
		full queue. */
		xRunIndicator = 0;
 1001afc:	d0205315 	stw	zero,-32436(gp)
		vTaskResume( xSecondary );
 1001b00:	d0a04f17 	ldw	r2,-32452(gp)
 1001b04:	1009883a 	mov	r4,r2
 1001b08:	1005d180 	call	1005d18 <vTaskResume>

		/* We need to wait a little to ensure the other task executes. */
		while( xRunIndicator != bktRUN_INDICATOR )
 1001b0c:	00000206 	br	1001b18 <vPrimaryBlockTimeTestTask+0x1c0>
		{
			/* The other task has not yet executed. */
			vTaskDelay( bktSHORT_WAIT );
 1001b10:	01000504 	movi	r4,20
 1001b14:	10058ec0 	call	10058ec <vTaskDelay>
		full queue. */
		xRunIndicator = 0;
		vTaskResume( xSecondary );

		/* We need to wait a little to ensure the other task executes. */
		while( xRunIndicator != bktRUN_INDICATOR )
 1001b18:	d0a05317 	ldw	r2,-32436(gp)
 1001b1c:	10801558 	cmpnei	r2,r2,85
 1001b20:	103ffb1e 	bne	r2,zero,1001b10 <__alt_data_end+0xff801b10>
		{
			/* The other task has not yet executed. */
			vTaskDelay( bktSHORT_WAIT );
		}
		/* Make sure the other task is blocked on the queue. */
		vTaskDelay( bktSHORT_WAIT );
 1001b24:	01000504 	movi	r4,20
 1001b28:	10058ec0 	call	10058ec <vTaskDelay>
		xRunIndicator = 0;
 1001b2c:	d0205315 	stw	zero,-32436(gp)

		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 1001b30:	e03ffd15 	stw	zero,-12(fp)
 1001b34:	00002b06 	br	1001be4 <vPrimaryBlockTimeTestTask+0x28c>
		{
			/* Now when we make space on the queue the other task should wake
			but not execute as this task has higher priority. */
			if( xQueueReceive( xTestQueue, &xData, bktDONT_BLOCK ) != pdPASS )
 1001b38:	d0a04e17 	ldw	r2,-32456(gp)
 1001b3c:	e0fffe04 	addi	r3,fp,-8
 1001b40:	000f883a 	mov	r7,zero
 1001b44:	000d883a 	mov	r6,zero
 1001b48:	180b883a 	mov	r5,r3
 1001b4c:	1009883a 	mov	r4,r2
 1001b50:	1004a800 	call	1004a80 <xQueueGenericReceive>
 1001b54:	10800060 	cmpeqi	r2,r2,1
 1001b58:	1000021e 	bne	r2,zero,1001b64 <vPrimaryBlockTimeTestTask+0x20c>
			{
				xErrorOccurred = pdTRUE;
 1001b5c:	00800044 	movi	r2,1
 1001b60:	d0a05215 	stw	r2,-32440(gp)
			}

			/* Now fill the queue again before the other task gets a chance to
			execute.  If the other task had executed we would find the queue
			full ourselves, and the other task have set xRunIndicator. */
			if( xQueueSend( xTestQueue, &xItem, bktDONT_BLOCK ) != pdPASS )
 1001b64:	d0a04e17 	ldw	r2,-32456(gp)
 1001b68:	e0fffd04 	addi	r3,fp,-12
 1001b6c:	000f883a 	mov	r7,zero
 1001b70:	000d883a 	mov	r6,zero
 1001b74:	180b883a 	mov	r5,r3
 1001b78:	1009883a 	mov	r4,r2
 1001b7c:	10047080 	call	1004708 <xQueueGenericSend>
 1001b80:	10800060 	cmpeqi	r2,r2,1
 1001b84:	1000021e 	bne	r2,zero,1001b90 <vPrimaryBlockTimeTestTask+0x238>
			{
				xErrorOccurred = pdTRUE;
 1001b88:	00800044 	movi	r2,1
 1001b8c:	d0a05215 	stw	r2,-32440(gp)
			}

			if( xRunIndicator == bktRUN_INDICATOR )
 1001b90:	d0a05317 	ldw	r2,-32436(gp)
 1001b94:	10801558 	cmpnei	r2,r2,85
 1001b98:	1000021e 	bne	r2,zero,1001ba4 <vPrimaryBlockTimeTestTask+0x24c>
			{
				/* The other task should not have executed. */
				xErrorOccurred = pdTRUE;
 1001b9c:	00800044 	movi	r2,1
 1001ba0:	d0a05215 	stw	r2,-32440(gp)
			}

			/* Raise the priority of the other task so it executes and blocks
			on the queue again. */
			vTaskPrioritySet( xSecondary, bktPRIMARY_PRIORITY + 2 );
 1001ba4:	d0a04f17 	ldw	r2,-32452(gp)
 1001ba8:	01400104 	movi	r5,4
 1001bac:	1009883a 	mov	r4,r2
 1001bb0:	10059ec0 	call	10059ec <vTaskPrioritySet>

			/* The other task should now have re-blocked without exiting the
			queue function. */
			if( xRunIndicator == bktRUN_INDICATOR )
 1001bb4:	d0a05317 	ldw	r2,-32436(gp)
 1001bb8:	10801558 	cmpnei	r2,r2,85
 1001bbc:	1000021e 	bne	r2,zero,1001bc8 <vPrimaryBlockTimeTestTask+0x270>
			{
				/* The other task should not have executed outside of the
				queue function. */
				xErrorOccurred = pdTRUE;
 1001bc0:	00800044 	movi	r2,1
 1001bc4:	d0a05215 	stw	r2,-32440(gp)
			}

			/* Set the priority back down. */
			vTaskPrioritySet( xSecondary, bktSECONDARY_PRIORITY );
 1001bc8:	d0a04f17 	ldw	r2,-32452(gp)
 1001bcc:	01400044 	movi	r5,1
 1001bd0:	1009883a 	mov	r4,r2
 1001bd4:	10059ec0 	call	10059ec <vTaskPrioritySet>
		}
		/* Make sure the other task is blocked on the queue. */
		vTaskDelay( bktSHORT_WAIT );
		xRunIndicator = 0;

		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 1001bd8:	e0bffd17 	ldw	r2,-12(fp)
 1001bdc:	10800044 	addi	r2,r2,1
 1001be0:	e0bffd15 	stw	r2,-12(fp)
 1001be4:	e0bffd17 	ldw	r2,-12(fp)
 1001be8:	10800150 	cmplti	r2,r2,5
 1001bec:	103fd21e 	bne	r2,zero,1001b38 <__alt_data_end+0xff801b38>
			vTaskPrioritySet( xSecondary, bktSECONDARY_PRIORITY );
		}

		/* Let the other task timeout.  When it unblockes it will check that it
		unblocked at the correct time, then suspend itself. */
		while( xRunIndicator != bktRUN_INDICATOR )
 1001bf0:	00000206 	br	1001bfc <vPrimaryBlockTimeTestTask+0x2a4>
		{
			vTaskDelay( bktSHORT_WAIT );
 1001bf4:	01000504 	movi	r4,20
 1001bf8:	10058ec0 	call	10058ec <vTaskDelay>
			vTaskPrioritySet( xSecondary, bktSECONDARY_PRIORITY );
		}

		/* Let the other task timeout.  When it unblockes it will check that it
		unblocked at the correct time, then suspend itself. */
		while( xRunIndicator != bktRUN_INDICATOR )
 1001bfc:	d0a05317 	ldw	r2,-32436(gp)
 1001c00:	10801558 	cmpnei	r2,r2,85
 1001c04:	103ffb1e 	bne	r2,zero,1001bf4 <__alt_data_end+0xff801bf4>
		{
			vTaskDelay( bktSHORT_WAIT );
		}
		vTaskDelay( bktSHORT_WAIT );
 1001c08:	01000504 	movi	r4,20
 1001c0c:	10058ec0 	call	10058ec <vTaskDelay>
		xRunIndicator = 0;
 1001c10:	d0205315 	stw	zero,-32436(gp)

		As per test 3 - but with the send and receive the other way around.
		The other task blocks attempting to read from the queue.

		Empty the queue.  We should find that it is full. */
		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 1001c14:	e03ffd15 	stw	zero,-12(fp)
 1001c18:	00000e06 	br	1001c54 <vPrimaryBlockTimeTestTask+0x2fc>
		{
			if( xQueueReceive( xTestQueue, &xData, bktDONT_BLOCK ) != pdPASS )
 1001c1c:	d0a04e17 	ldw	r2,-32456(gp)
 1001c20:	e0fffe04 	addi	r3,fp,-8
 1001c24:	000f883a 	mov	r7,zero
 1001c28:	000d883a 	mov	r6,zero
 1001c2c:	180b883a 	mov	r5,r3
 1001c30:	1009883a 	mov	r4,r2
 1001c34:	1004a800 	call	1004a80 <xQueueGenericReceive>
 1001c38:	10800060 	cmpeqi	r2,r2,1
 1001c3c:	1000021e 	bne	r2,zero,1001c48 <vPrimaryBlockTimeTestTask+0x2f0>
			{
				xErrorOccurred = pdTRUE;
 1001c40:	00800044 	movi	r2,1
 1001c44:	d0a05215 	stw	r2,-32440(gp)

		As per test 3 - but with the send and receive the other way around.
		The other task blocks attempting to read from the queue.

		Empty the queue.  We should find that it is full. */
		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 1001c48:	e0bffd17 	ldw	r2,-12(fp)
 1001c4c:	10800044 	addi	r2,r2,1
 1001c50:	e0bffd15 	stw	r2,-12(fp)
 1001c54:	e0bffd17 	ldw	r2,-12(fp)
 1001c58:	10800150 	cmplti	r2,r2,5
 1001c5c:	103fef1e 	bne	r2,zero,1001c1c <__alt_data_end+0xff801c1c>
			}
		}

		/* Wake the other task so it blocks attempting to read from  the
		already	empty queue. */
		vTaskResume( xSecondary );
 1001c60:	d0a04f17 	ldw	r2,-32452(gp)
 1001c64:	1009883a 	mov	r4,r2
 1001c68:	1005d180 	call	1005d18 <vTaskResume>

		/* We need to wait a little to ensure the other task executes. */
		while( xRunIndicator != bktRUN_INDICATOR )
 1001c6c:	00000206 	br	1001c78 <vPrimaryBlockTimeTestTask+0x320>
		{
			vTaskDelay( bktSHORT_WAIT );
 1001c70:	01000504 	movi	r4,20
 1001c74:	10058ec0 	call	10058ec <vTaskDelay>
		/* Wake the other task so it blocks attempting to read from  the
		already	empty queue. */
		vTaskResume( xSecondary );

		/* We need to wait a little to ensure the other task executes. */
		while( xRunIndicator != bktRUN_INDICATOR )
 1001c78:	d0a05317 	ldw	r2,-32436(gp)
 1001c7c:	10801558 	cmpnei	r2,r2,85
 1001c80:	103ffb1e 	bne	r2,zero,1001c70 <__alt_data_end+0xff801c70>
		{
			vTaskDelay( bktSHORT_WAIT );
		}
		vTaskDelay( bktSHORT_WAIT );
 1001c84:	01000504 	movi	r4,20
 1001c88:	10058ec0 	call	10058ec <vTaskDelay>
		xRunIndicator = 0;
 1001c8c:	d0205315 	stw	zero,-32436(gp)

		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 1001c90:	e03ffd15 	stw	zero,-12(fp)
 1001c94:	00002b06 	br	1001d44 <vPrimaryBlockTimeTestTask+0x3ec>
		{
			/* Now when we place an item on the queue the other task should
			wake but not execute as this task has higher priority. */
			if( xQueueSend( xTestQueue, &xItem, bktDONT_BLOCK ) != pdPASS )
 1001c98:	d0a04e17 	ldw	r2,-32456(gp)
 1001c9c:	e0fffd04 	addi	r3,fp,-12
 1001ca0:	000f883a 	mov	r7,zero
 1001ca4:	000d883a 	mov	r6,zero
 1001ca8:	180b883a 	mov	r5,r3
 1001cac:	1009883a 	mov	r4,r2
 1001cb0:	10047080 	call	1004708 <xQueueGenericSend>
 1001cb4:	10800060 	cmpeqi	r2,r2,1
 1001cb8:	1000021e 	bne	r2,zero,1001cc4 <vPrimaryBlockTimeTestTask+0x36c>
			{
				xErrorOccurred = pdTRUE;
 1001cbc:	00800044 	movi	r2,1
 1001cc0:	d0a05215 	stw	r2,-32440(gp)
			}

			/* Now empty the queue again before the other task gets a chance to
			execute.  If the other task had executed we would find the queue
			empty ourselves, and the other task would be suspended. */
			if( xQueueReceive( xTestQueue, &xData, bktDONT_BLOCK ) != pdPASS )
 1001cc4:	d0a04e17 	ldw	r2,-32456(gp)
 1001cc8:	e0fffe04 	addi	r3,fp,-8
 1001ccc:	000f883a 	mov	r7,zero
 1001cd0:	000d883a 	mov	r6,zero
 1001cd4:	180b883a 	mov	r5,r3
 1001cd8:	1009883a 	mov	r4,r2
 1001cdc:	1004a800 	call	1004a80 <xQueueGenericReceive>
 1001ce0:	10800060 	cmpeqi	r2,r2,1
 1001ce4:	1000021e 	bne	r2,zero,1001cf0 <vPrimaryBlockTimeTestTask+0x398>
			{
				xErrorOccurred = pdTRUE;
 1001ce8:	00800044 	movi	r2,1
 1001cec:	d0a05215 	stw	r2,-32440(gp)
			}

			if( xRunIndicator == bktRUN_INDICATOR )
 1001cf0:	d0a05317 	ldw	r2,-32436(gp)
 1001cf4:	10801558 	cmpnei	r2,r2,85
 1001cf8:	1000021e 	bne	r2,zero,1001d04 <vPrimaryBlockTimeTestTask+0x3ac>
			{
				/* The other task should not have executed. */
				xErrorOccurred = pdTRUE;
 1001cfc:	00800044 	movi	r2,1
 1001d00:	d0a05215 	stw	r2,-32440(gp)
			}

			/* Raise the priority of the other task so it executes and blocks
			on the queue again. */
			vTaskPrioritySet( xSecondary, bktPRIMARY_PRIORITY + 2 );
 1001d04:	d0a04f17 	ldw	r2,-32452(gp)
 1001d08:	01400104 	movi	r5,4
 1001d0c:	1009883a 	mov	r4,r2
 1001d10:	10059ec0 	call	10059ec <vTaskPrioritySet>

			/* The other task should now have re-blocked without exiting the
			queue function. */
			if( xRunIndicator == bktRUN_INDICATOR )
 1001d14:	d0a05317 	ldw	r2,-32436(gp)
 1001d18:	10801558 	cmpnei	r2,r2,85
 1001d1c:	1000021e 	bne	r2,zero,1001d28 <vPrimaryBlockTimeTestTask+0x3d0>
			{
				/* The other task should not have executed outside of the
				queue function. */
				xErrorOccurred = pdTRUE;
 1001d20:	00800044 	movi	r2,1
 1001d24:	d0a05215 	stw	r2,-32440(gp)
			}
			vTaskPrioritySet( xSecondary, bktSECONDARY_PRIORITY );
 1001d28:	d0a04f17 	ldw	r2,-32452(gp)
 1001d2c:	01400044 	movi	r5,1
 1001d30:	1009883a 	mov	r4,r2
 1001d34:	10059ec0 	call	10059ec <vTaskPrioritySet>
			vTaskDelay( bktSHORT_WAIT );
		}
		vTaskDelay( bktSHORT_WAIT );
		xRunIndicator = 0;

		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
 1001d38:	e0bffd17 	ldw	r2,-12(fp)
 1001d3c:	10800044 	addi	r2,r2,1
 1001d40:	e0bffd15 	stw	r2,-12(fp)
 1001d44:	e0bffd17 	ldw	r2,-12(fp)
 1001d48:	10800150 	cmplti	r2,r2,5
 1001d4c:	103fd21e 	bne	r2,zero,1001c98 <__alt_data_end+0xff801c98>
			vTaskPrioritySet( xSecondary, bktSECONDARY_PRIORITY );
		}

		/* Let the other task timeout.  When it unblockes it will check that it
		unblocked at the correct time, then suspend itself. */
		while( xRunIndicator != bktRUN_INDICATOR )
 1001d50:	00000206 	br	1001d5c <vPrimaryBlockTimeTestTask+0x404>
		{
			vTaskDelay( bktSHORT_WAIT );
 1001d54:	01000504 	movi	r4,20
 1001d58:	10058ec0 	call	10058ec <vTaskDelay>
			vTaskPrioritySet( xSecondary, bktSECONDARY_PRIORITY );
		}

		/* Let the other task timeout.  When it unblockes it will check that it
		unblocked at the correct time, then suspend itself. */
		while( xRunIndicator != bktRUN_INDICATOR )
 1001d5c:	d0a05317 	ldw	r2,-32436(gp)
 1001d60:	10801558 	cmpnei	r2,r2,85
 1001d64:	103ffb1e 	bne	r2,zero,1001d54 <__alt_data_end+0xff801d54>
		{
			vTaskDelay( bktSHORT_WAIT );
		}
		vTaskDelay( bktSHORT_WAIT );
 1001d68:	01000504 	movi	r4,20
 1001d6c:	10058ec0 	call	10058ec <vTaskDelay>

		xPrimaryCycles++;
 1001d70:	d0a05017 	ldw	r2,-32448(gp)
 1001d74:	10800044 	addi	r2,r2,1
 1001d78:	d0a05015 	stw	r2,-32448(gp)
	}
 1001d7c:	003efb06 	br	100196c <__alt_data_end+0xff80196c>

01001d80 <vSecondaryBlockTimeTestTask>:
}
/*-----------------------------------------------------------*/

static void vSecondaryBlockTimeTestTask( void *pvParameters )
{
 1001d80:	defffa04 	addi	sp,sp,-24
 1001d84:	dfc00515 	stw	ra,20(sp)
 1001d88:	df000415 	stw	fp,16(sp)
 1001d8c:	df000404 	addi	fp,sp,16
 1001d90:	e13fff15 	stw	r4,-4(fp)
	{
		/*********************************************************************
		Test 0, 1 and 2

		This task does not participate in these tests. */
		vTaskSuspend( NULL );
 1001d94:	0009883a 	mov	r4,zero
 1001d98:	1005ba40 	call	1005ba4 <vTaskSuspend>
		Test 3

		The first thing we do is attempt to read from the queue.  It should be
		full so we block.  Note the time before we block so we can check the
		wake time is as per that expected. */
		xTimeWhenBlocking = xTaskGetTickCount();
 1001d9c:	10061200 	call	1006120 <xTaskGetTickCount>
 1001da0:	e0bffc15 	stw	r2,-16(fp)

		/* We should unblock after bktTIME_TO_BLOCK having not sent anything to
		the queue. */
		xData = 0;
 1001da4:	e03ffe15 	stw	zero,-8(fp)
		xRunIndicator = bktRUN_INDICATOR;
 1001da8:	00801544 	movi	r2,85
 1001dac:	d0a05315 	stw	r2,-32436(gp)
		if( xQueueSend( xTestQueue, &xData, bktTIME_TO_BLOCK ) != errQUEUE_FULL )
 1001db0:	d0a04e17 	ldw	r2,-32456(gp)
 1001db4:	e0fffe04 	addi	r3,fp,-8
 1001db8:	000f883a 	mov	r7,zero
 1001dbc:	01802bc4 	movi	r6,175
 1001dc0:	180b883a 	mov	r5,r3
 1001dc4:	1009883a 	mov	r4,r2
 1001dc8:	10047080 	call	1004708 <xQueueGenericSend>
 1001dcc:	10000226 	beq	r2,zero,1001dd8 <vSecondaryBlockTimeTestTask+0x58>
		{
			xErrorOccurred = pdTRUE;
 1001dd0:	00800044 	movi	r2,1
 1001dd4:	d0a05215 	stw	r2,-32440(gp)
		}

		/* How long were we inside the send function? */
		xBlockedTime = xTaskGetTickCount() - xTimeWhenBlocking;
 1001dd8:	10061200 	call	1006120 <xTaskGetTickCount>
 1001ddc:	1007883a 	mov	r3,r2
 1001de0:	e0bffc17 	ldw	r2,-16(fp)
 1001de4:	1885c83a 	sub	r2,r3,r2
 1001de8:	e0bffd15 	stw	r2,-12(fp)

		/* We should not have blocked for less time than bktTIME_TO_BLOCK. */
		if( xBlockedTime < bktTIME_TO_BLOCK )
 1001dec:	e0bffd17 	ldw	r2,-12(fp)
 1001df0:	10802be8 	cmpgeui	r2,r2,175
 1001df4:	1000021e 	bne	r2,zero,1001e00 <vSecondaryBlockTimeTestTask+0x80>
		{
			xErrorOccurred = pdTRUE;
 1001df8:	00800044 	movi	r2,1
 1001dfc:	d0a05215 	stw	r2,-32440(gp)
		}

		/* We should of not blocked for much longer than bktALLOWABLE_MARGIN
		either.  A margin is permitted as we would not necessarily run as
		soon as we unblocked. */
		if( xBlockedTime > ( bktTIME_TO_BLOCK + bktALLOWABLE_MARGIN ) )
 1001e00:	e0bffd17 	ldw	r2,-12(fp)
 1001e04:	10802ff0 	cmpltui	r2,r2,191
 1001e08:	1000021e 	bne	r2,zero,1001e14 <vSecondaryBlockTimeTestTask+0x94>
		{
			xErrorOccurred = pdTRUE;
 1001e0c:	00800044 	movi	r2,1
 1001e10:	d0a05215 	stw	r2,-32440(gp)
		}

		/* Suspend ready for test 3. */
		xRunIndicator = bktRUN_INDICATOR;
 1001e14:	00801544 	movi	r2,85
 1001e18:	d0a05315 	stw	r2,-32436(gp)
		vTaskSuspend( NULL );
 1001e1c:	0009883a 	mov	r4,zero
 1001e20:	1005ba40 	call	1005ba4 <vTaskSuspend>

		/*********************************************************************
        Test 4

		As per test three, but with the send and receive reversed. */
		xTimeWhenBlocking = xTaskGetTickCount();
 1001e24:	10061200 	call	1006120 <xTaskGetTickCount>
 1001e28:	e0bffc15 	stw	r2,-16(fp)

		/* We should unblock after bktTIME_TO_BLOCK having not received
		anything on the queue. */
		xRunIndicator = bktRUN_INDICATOR;
 1001e2c:	00801544 	movi	r2,85
 1001e30:	d0a05315 	stw	r2,-32436(gp)
		if( xQueueReceive( xTestQueue, &xData, bktTIME_TO_BLOCK ) != errQUEUE_EMPTY )
 1001e34:	d0a04e17 	ldw	r2,-32456(gp)
 1001e38:	e0fffe04 	addi	r3,fp,-8
 1001e3c:	000f883a 	mov	r7,zero
 1001e40:	01802bc4 	movi	r6,175
 1001e44:	180b883a 	mov	r5,r3
 1001e48:	1009883a 	mov	r4,r2
 1001e4c:	1004a800 	call	1004a80 <xQueueGenericReceive>
 1001e50:	10000226 	beq	r2,zero,1001e5c <vSecondaryBlockTimeTestTask+0xdc>
		{
			xErrorOccurred = pdTRUE;
 1001e54:	00800044 	movi	r2,1
 1001e58:	d0a05215 	stw	r2,-32440(gp)
		}

		xBlockedTime = xTaskGetTickCount() - xTimeWhenBlocking;
 1001e5c:	10061200 	call	1006120 <xTaskGetTickCount>
 1001e60:	1007883a 	mov	r3,r2
 1001e64:	e0bffc17 	ldw	r2,-16(fp)
 1001e68:	1885c83a 	sub	r2,r3,r2
 1001e6c:	e0bffd15 	stw	r2,-12(fp)

		/* We should not have blocked for less time than bktTIME_TO_BLOCK. */
		if( xBlockedTime < bktTIME_TO_BLOCK )
 1001e70:	e0bffd17 	ldw	r2,-12(fp)
 1001e74:	10802be8 	cmpgeui	r2,r2,175
 1001e78:	1000021e 	bne	r2,zero,1001e84 <vSecondaryBlockTimeTestTask+0x104>
		{
			xErrorOccurred = pdTRUE;
 1001e7c:	00800044 	movi	r2,1
 1001e80:	d0a05215 	stw	r2,-32440(gp)
		}

		/* We should of not blocked for much longer than bktALLOWABLE_MARGIN
		either.  A margin is permitted as we would not necessarily run as soon
		as we unblocked. */
		if( xBlockedTime > ( bktTIME_TO_BLOCK + bktALLOWABLE_MARGIN ) )
 1001e84:	e0bffd17 	ldw	r2,-12(fp)
 1001e88:	10802ff0 	cmpltui	r2,r2,191
 1001e8c:	1000021e 	bne	r2,zero,1001e98 <vSecondaryBlockTimeTestTask+0x118>
		{
			xErrorOccurred = pdTRUE;
 1001e90:	00800044 	movi	r2,1
 1001e94:	d0a05215 	stw	r2,-32440(gp)
		}

		xRunIndicator = bktRUN_INDICATOR;
 1001e98:	00801544 	movi	r2,85
 1001e9c:	d0a05315 	stw	r2,-32436(gp)

		xSecondaryCycles++;
 1001ea0:	d0a05117 	ldw	r2,-32444(gp)
 1001ea4:	10800044 	addi	r2,r2,1
 1001ea8:	d0a05115 	stw	r2,-32444(gp)
	}
 1001eac:	003fb906 	br	1001d94 <__alt_data_end+0xff801d94>

01001eb0 <prvBasicDelayTests>:
}
/*-----------------------------------------------------------*/

static void prvBasicDelayTests( void )
{
 1001eb0:	defff604 	addi	sp,sp,-40
 1001eb4:	dfc00915 	stw	ra,36(sp)
 1001eb8:	df000815 	stw	fp,32(sp)
 1001ebc:	df000804 	addi	fp,sp,32
TickType_t xPreTime, xPostTime, x, xLastUnblockTime, xExpectedUnblockTime;
const TickType_t xPeriod = 75, xCycles = 5, xAllowableMargin = ( bktALLOWABLE_MARGIN >> 1 );
 1001ec0:	008012c4 	movi	r2,75
 1001ec4:	e0bff915 	stw	r2,-28(fp)
 1001ec8:	00800144 	movi	r2,5
 1001ecc:	e0bffa15 	stw	r2,-24(fp)
 1001ed0:	008001c4 	movi	r2,7
 1001ed4:	e0bffb15 	stw	r2,-20(fp)

	/* Temporarily increase priority so the timing is more accurate, but not so
	high as to disrupt the timer tests. */
	vTaskPrioritySet( NULL, configTIMER_TASK_PRIORITY - 1 );
 1001ed8:	014000c4 	movi	r5,3
 1001edc:	0009883a 	mov	r4,zero
 1001ee0:	10059ec0 	call	10059ec <vTaskPrioritySet>

	/* Crude check to too that vTaskDelay() blocks for the expected period. */
	xPreTime = xTaskGetTickCount();
 1001ee4:	10061200 	call	1006120 <xTaskGetTickCount>
 1001ee8:	e0bffc15 	stw	r2,-16(fp)
	vTaskDelay( bktTIME_TO_BLOCK );
 1001eec:	01002bc4 	movi	r4,175
 1001ef0:	10058ec0 	call	10058ec <vTaskDelay>
	xPostTime = xTaskGetTickCount();
 1001ef4:	10061200 	call	1006120 <xTaskGetTickCount>
 1001ef8:	e0bffd15 	stw	r2,-12(fp)

	/* The priority is higher, so the allowable margin is halved when compared
	to the other tests in this file. */
	if( ( xPostTime - xPreTime ) > ( bktTIME_TO_BLOCK + xAllowableMargin ) )
 1001efc:	e0fffd17 	ldw	r3,-12(fp)
 1001f00:	e0bffc17 	ldw	r2,-16(fp)
 1001f04:	1885c83a 	sub	r2,r3,r2
 1001f08:	e0fffb17 	ldw	r3,-20(fp)
 1001f0c:	18c02bc4 	addi	r3,r3,175
 1001f10:	1880022e 	bgeu	r3,r2,1001f1c <prvBasicDelayTests+0x6c>
	{
		xErrorOccurred = pdTRUE;
 1001f14:	00800044 	movi	r2,1
 1001f18:	d0a05215 	stw	r2,-32440(gp)
	}

	/* Now crude tests to check the vTaskDelayUntil() functionality. */
	xPostTime = xTaskGetTickCount();
 1001f1c:	10061200 	call	1006120 <xTaskGetTickCount>
 1001f20:	e0bffd15 	stw	r2,-12(fp)
	xLastUnblockTime = xPostTime;
 1001f24:	e0bffd17 	ldw	r2,-12(fp)
 1001f28:	e0bfff15 	stw	r2,-4(fp)

	for( x = 0; x < xCycles; x++ )
 1001f2c:	e03ff815 	stw	zero,-32(fp)
 1001f30:	00001906 	br	1001f98 <prvBasicDelayTests+0xe8>
	{
		/* Calculate the next expected unblock time from the time taken before
		this loop was entered. */
		xExpectedUnblockTime = xPostTime + ( x * xPeriod );
 1001f34:	e0fff817 	ldw	r3,-32(fp)
 1001f38:	e0bff917 	ldw	r2,-28(fp)
 1001f3c:	1887383a 	mul	r3,r3,r2
 1001f40:	e0bffd17 	ldw	r2,-12(fp)
 1001f44:	1885883a 	add	r2,r3,r2
 1001f48:	e0bffe15 	stw	r2,-8(fp)

		vTaskDelayUntil( &xLastUnblockTime, xPeriod );
 1001f4c:	e0bfff04 	addi	r2,fp,-4
 1001f50:	e17ff917 	ldw	r5,-28(fp)
 1001f54:	1009883a 	mov	r4,r2
 1001f58:	10057fc0 	call	10057fc <vTaskDelayUntil>

		if( ( xTaskGetTickCount() - xExpectedUnblockTime ) > ( bktTIME_TO_BLOCK + xAllowableMargin ) )
 1001f5c:	10061200 	call	1006120 <xTaskGetTickCount>
 1001f60:	1007883a 	mov	r3,r2
 1001f64:	e0bffe17 	ldw	r2,-8(fp)
 1001f68:	1885c83a 	sub	r2,r3,r2
 1001f6c:	e0fffb17 	ldw	r3,-20(fp)
 1001f70:	18c02bc4 	addi	r3,r3,175
 1001f74:	1880022e 	bgeu	r3,r2,1001f80 <prvBasicDelayTests+0xd0>
		{
			xErrorOccurred = pdTRUE;
 1001f78:	00800044 	movi	r2,1
 1001f7c:	d0a05215 	stw	r2,-32440(gp)
		}

		xPrimaryCycles++;
 1001f80:	d0a05017 	ldw	r2,-32448(gp)
 1001f84:	10800044 	addi	r2,r2,1
 1001f88:	d0a05015 	stw	r2,-32448(gp)

	/* Now crude tests to check the vTaskDelayUntil() functionality. */
	xPostTime = xTaskGetTickCount();
	xLastUnblockTime = xPostTime;

	for( x = 0; x < xCycles; x++ )
 1001f8c:	e0bff817 	ldw	r2,-32(fp)
 1001f90:	10800044 	addi	r2,r2,1
 1001f94:	e0bff815 	stw	r2,-32(fp)
 1001f98:	e0fff817 	ldw	r3,-32(fp)
 1001f9c:	e0bffa17 	ldw	r2,-24(fp)
 1001fa0:	18bfe436 	bltu	r3,r2,1001f34 <__alt_data_end+0xff801f34>

		xPrimaryCycles++;
	}

	/* Reset to the original task priority ready for the other tests. */
	vTaskPrioritySet( NULL, bktPRIMARY_PRIORITY );
 1001fa4:	01400084 	movi	r5,2
 1001fa8:	0009883a 	mov	r4,zero
 1001fac:	10059ec0 	call	10059ec <vTaskPrioritySet>
}
 1001fb0:	0001883a 	nop
 1001fb4:	e037883a 	mov	sp,fp
 1001fb8:	dfc00117 	ldw	ra,4(sp)
 1001fbc:	df000017 	ldw	fp,0(sp)
 1001fc0:	dec00204 	addi	sp,sp,8
 1001fc4:	f800283a 	ret

01001fc8 <xAreBlockTimeTestTasksStillRunning>:
/*-----------------------------------------------------------*/

BaseType_t xAreBlockTimeTestTasksStillRunning( void )
{
 1001fc8:	defffe04 	addi	sp,sp,-8
 1001fcc:	df000115 	stw	fp,4(sp)
 1001fd0:	df000104 	addi	fp,sp,4
static BaseType_t xLastPrimaryCycleCount = 0, xLastSecondaryCycleCount = 0;
BaseType_t xReturn = pdPASS;
 1001fd4:	00800044 	movi	r2,1
 1001fd8:	e0bfff15 	stw	r2,-4(fp)

	/* Have both tasks performed at least one cycle since this function was
	last called? */
	if( xPrimaryCycles == xLastPrimaryCycleCount )
 1001fdc:	d0e05017 	ldw	r3,-32448(gp)
 1001fe0:	d0a05417 	ldw	r2,-32432(gp)
 1001fe4:	1880011e 	bne	r3,r2,1001fec <xAreBlockTimeTestTasksStillRunning+0x24>
	{
		xReturn = pdFAIL;
 1001fe8:	e03fff15 	stw	zero,-4(fp)
	}

	if( xSecondaryCycles == xLastSecondaryCycleCount )
 1001fec:	d0e05117 	ldw	r3,-32444(gp)
 1001ff0:	d0a05517 	ldw	r2,-32428(gp)
 1001ff4:	1880011e 	bne	r3,r2,1001ffc <xAreBlockTimeTestTasksStillRunning+0x34>
	{
		xReturn = pdFAIL;
 1001ff8:	e03fff15 	stw	zero,-4(fp)
	}

	if( xErrorOccurred == pdTRUE )
 1001ffc:	d0a05217 	ldw	r2,-32440(gp)
 1002000:	10800058 	cmpnei	r2,r2,1
 1002004:	1000011e 	bne	r2,zero,100200c <xAreBlockTimeTestTasksStillRunning+0x44>
	{
		xReturn = pdFAIL;
 1002008:	e03fff15 	stw	zero,-4(fp)
	}

	xLastSecondaryCycleCount = xSecondaryCycles;
 100200c:	d0a05117 	ldw	r2,-32444(gp)
 1002010:	d0a05515 	stw	r2,-32428(gp)
	xLastPrimaryCycleCount = xPrimaryCycles;
 1002014:	d0a05017 	ldw	r2,-32448(gp)
 1002018:	d0a05415 	stw	r2,-32432(gp)

	return xReturn;
 100201c:	e0bfff17 	ldw	r2,-4(fp)
}
 1002020:	e037883a 	mov	sp,fp
 1002024:	df000017 	ldw	fp,0(sp)
 1002028:	dec00104 	addi	sp,sp,4
 100202c:	f800283a 	ret

01002030 <vAltStartComTestTasks>:
static volatile UBaseType_t uxRxLoops = comINITIAL_RX_COUNT_VALUE;

/*-----------------------------------------------------------*/

void vAltStartComTestTasks( UBaseType_t uxPriority, uint32_t ulBaudRate, UBaseType_t uxLED )
{
 1002030:	defff904 	addi	sp,sp,-28
 1002034:	dfc00615 	stw	ra,24(sp)
 1002038:	df000515 	stw	fp,20(sp)
 100203c:	df000504 	addi	fp,sp,20
 1002040:	e13ffd15 	stw	r4,-12(fp)
 1002044:	e17ffe15 	stw	r5,-8(fp)
 1002048:	e1bfff15 	stw	r6,-4(fp)
	/* Initialise the com port then spawn the Rx and Tx tasks. */
	uxBaseLED = uxLED;
 100204c:	e0bfff17 	ldw	r2,-4(fp)
 1002050:	d0a05715 	stw	r2,-32420(gp)
	xSerialPortInitMinimal( ulBaudRate, comBUFFER_LEN );
 1002054:	01400604 	movi	r5,24
 1002058:	e13ffe17 	ldw	r4,-8(fp)
 100205c:	10076440 	call	1007644 <xSerialPortInitMinimal>

	/* The Tx task is spawned with a lower priority than the Rx task. */
	xTaskCreate( vComTxTask, "COMTx", comSTACK_SIZE, NULL, uxPriority - 1, ( TaskHandle_t * ) NULL );
 1002060:	e0bffd17 	ldw	r2,-12(fp)
 1002064:	10bfffc4 	addi	r2,r2,-1
 1002068:	d8000115 	stw	zero,4(sp)
 100206c:	d8800015 	stw	r2,0(sp)
 1002070:	000f883a 	mov	r7,zero
 1002074:	01810004 	movi	r6,1024
 1002078:	014040b4 	movhi	r5,258
 100207c:	2969f404 	addi	r5,r5,-22576
 1002080:	01004034 	movhi	r4,256
 1002084:	21083304 	addi	r4,r4,8396
 1002088:	10053600 	call	1005360 <xTaskCreate>
	xTaskCreate( vComRxTask, "COMRx", comSTACK_SIZE, NULL, uxPriority, ( TaskHandle_t * ) NULL );
 100208c:	d8000115 	stw	zero,4(sp)
 1002090:	e0bffd17 	ldw	r2,-12(fp)
 1002094:	d8800015 	stw	r2,0(sp)
 1002098:	000f883a 	mov	r7,zero
 100209c:	01810004 	movi	r6,1024
 10020a0:	014040b4 	movhi	r5,258
 10020a4:	2969f604 	addi	r5,r5,-22568
 10020a8:	01004034 	movhi	r4,256
 10020ac:	21086004 	addi	r4,r4,8576
 10020b0:	10053600 	call	1005360 <xTaskCreate>
}
 10020b4:	0001883a 	nop
 10020b8:	e037883a 	mov	sp,fp
 10020bc:	dfc00117 	ldw	ra,4(sp)
 10020c0:	df000017 	ldw	fp,0(sp)
 10020c4:	dec00204 	addi	sp,sp,8
 10020c8:	f800283a 	ret

010020cc <vComTxTask>:
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vComTxTask, pvParameters )
{
 10020cc:	defffb04 	addi	sp,sp,-20
 10020d0:	dfc00415 	stw	ra,16(sp)
 10020d4:	df000315 	stw	fp,12(sp)
 10020d8:	df000304 	addi	fp,sp,12
 10020dc:	e13fff15 	stw	r4,-4(fp)

	for( ;; )
	{
		/* Simply transmit a sequence of characters from comFIRST_BYTE to
		comLAST_BYTE. */
		for( cByteToSend = comFIRST_BYTE; cByteToSend <= comLAST_BYTE; cByteToSend++ )
 10020e0:	00801044 	movi	r2,65
 10020e4:	e0bffd05 	stb	r2,-12(fp)
 10020e8:	00000e06 	br	1002124 <vComTxTask+0x58>
		{
			if( xSerialPutChar( xPort, cByteToSend, comNO_BLOCK ) == pdPASS )
 10020ec:	d0a05617 	ldw	r2,-32424(gp)
 10020f0:	e0fffd07 	ldb	r3,-12(fp)
 10020f4:	000d883a 	mov	r6,zero
 10020f8:	180b883a 	mov	r5,r3
 10020fc:	1009883a 	mov	r4,r2
 1002100:	10077900 	call	1007790 <xSerialPutChar>
 1002104:	10800058 	cmpnei	r2,r2,1
 1002108:	1000031e 	bne	r2,zero,1002118 <vComTxTask+0x4c>
			{
				vParTestToggleLED( uxBaseLED + comTX_LED_OFFSET );
 100210c:	d0a05717 	ldw	r2,-32420(gp)
 1002110:	1009883a 	mov	r4,r2
 1002114:	10037b80 	call	10037b8 <vParTestToggleLED>

	for( ;; )
	{
		/* Simply transmit a sequence of characters from comFIRST_BYTE to
		comLAST_BYTE. */
		for( cByteToSend = comFIRST_BYTE; cByteToSend <= comLAST_BYTE; cByteToSend++ )
 1002118:	e0bffd03 	ldbu	r2,-12(fp)
 100211c:	10800044 	addi	r2,r2,1
 1002120:	e0bffd05 	stb	r2,-12(fp)
 1002124:	e0bffd07 	ldb	r2,-12(fp)
 1002128:	10801650 	cmplti	r2,r2,89
 100212c:	103fef1e 	bne	r2,zero,10020ec <__alt_data_end+0xff8020ec>
				vParTestToggleLED( uxBaseLED + comTX_LED_OFFSET );
			}
		}

		/* Turn the LED off while we are not doing anything. */
		vParTestSetLED( uxBaseLED + comTX_LED_OFFSET, pdFALSE );
 1002130:	d0a05717 	ldw	r2,-32420(gp)
 1002134:	000b883a 	mov	r5,zero
 1002138:	1009883a 	mov	r4,r2
 100213c:	100372c0 	call	100372c <vParTestSetLED>

		/* We have posted all the characters in the string - wait before
		re-sending.  Wait a pseudo-random time as this will provide a better
		test. */
		xTimeToWait = xTaskGetTickCount() + comOFFSET_TIME;
 1002140:	10061200 	call	1006120 <xTaskGetTickCount>
 1002144:	108000c4 	addi	r2,r2,3
 1002148:	e0bffe15 	stw	r2,-8(fp)

		/* Make sure we don't wait too long... */
		xTimeToWait %= comTX_MAX_BLOCK_TIME;
 100214c:	e0bffe17 	ldw	r2,-8(fp)
 1002150:	01402584 	movi	r5,150
 1002154:	1009883a 	mov	r4,r2
 1002158:	10098080 	call	1009808 <__umodsi3>
 100215c:	e0bffe15 	stw	r2,-8(fp)

		/* ...but we do want to wait. */
		if( xTimeToWait < comTX_MIN_BLOCK_TIME )
 1002160:	e0bffe17 	ldw	r2,-8(fp)
 1002164:	10800ca8 	cmpgeui	r2,r2,50
 1002168:	1000021e 	bne	r2,zero,1002174 <vComTxTask+0xa8>
		{
			xTimeToWait = comTX_MIN_BLOCK_TIME;
 100216c:	00800c84 	movi	r2,50
 1002170:	e0bffe15 	stw	r2,-8(fp)
		}

		vTaskDelay( xTimeToWait );
 1002174:	e13ffe17 	ldw	r4,-8(fp)
 1002178:	10058ec0 	call	10058ec <vTaskDelay>
	}
 100217c:	003fd806 	br	10020e0 <__alt_data_end+0xff8020e0>

01002180 <vComRxTask>:
} /*lint !e715 !e818 pvParameters is required for a task function even if it is not referenced. */
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vComRxTask, pvParameters )
{
 1002180:	defff904 	addi	sp,sp,-28
 1002184:	dfc00615 	stw	ra,24(sp)
 1002188:	df000515 	stw	fp,20(sp)
 100218c:	df000504 	addi	fp,sp,20
 1002190:	e13fff15 	stw	r4,-4(fp)
signed char cExpectedByte, cByteRxed;
BaseType_t xResyncRequired = pdFALSE, xErrorOccurred = pdFALSE;
 1002194:	e03ffc15 	stw	zero,-16(fp)
 1002198:	e03ffd15 	stw	zero,-12(fp)

	for( ;; )
	{
		/* We expect to receive the characters from comFIRST_BYTE to
		comLAST_BYTE in an incrementing order.  Loop to receive each byte. */
		for( cExpectedByte = comFIRST_BYTE; cExpectedByte <= comLAST_BYTE; cExpectedByte++ )
 100219c:	00801044 	movi	r2,65
 10021a0:	e0bffb05 	stb	r2,-20(fp)
 10021a4:	00001806 	br	1002208 <vComRxTask+0x88>
		{
			/* Block on the queue that contains received bytes until a byte is
			available. */
			if( xSerialGetChar( xPort, &cByteRxed, comRX_BLOCK_TIME ) )
 10021a8:	d0a05617 	ldw	r2,-32424(gp)
 10021ac:	e0fffe04 	addi	r3,fp,-8
 10021b0:	01bfffd4 	movui	r6,65535
 10021b4:	180b883a 	mov	r5,r3
 10021b8:	1009883a 	mov	r4,r2
 10021bc:	100771c0 	call	100771c <xSerialGetChar>
 10021c0:	10000e26 	beq	r2,zero,10021fc <vComRxTask+0x7c>
			{
				/* Was this the byte we were expecting?  If so, toggle the LED,
				otherwise we are out on sync and should break out of the loop
				until the expected character sequence is about to restart. */
				if( cByteRxed == cExpectedByte )
 10021c4:	e0bffe03 	ldbu	r2,-8(fp)
 10021c8:	10c03fcc 	andi	r3,r2,255
 10021cc:	18c0201c 	xori	r3,r3,128
 10021d0:	18ffe004 	addi	r3,r3,-128
 10021d4:	e0bffb07 	ldb	r2,-20(fp)
 10021d8:	1880051e 	bne	r3,r2,10021f0 <vComRxTask+0x70>
				{
					vParTestToggleLED( uxBaseLED + comRX_LED_OFFSET );
 10021dc:	d0a05717 	ldw	r2,-32420(gp)
 10021e0:	10800044 	addi	r2,r2,1
 10021e4:	1009883a 	mov	r4,r2
 10021e8:	10037b80 	call	10037b8 <vParTestToggleLED>
 10021ec:	00000306 	br	10021fc <vComRxTask+0x7c>
				}
				else
				{
					xResyncRequired = pdTRUE;
 10021f0:	00800044 	movi	r2,1
 10021f4:	e0bffc15 	stw	r2,-16(fp)
					break; /*lint !e960 Non-switch break allowed. */
 10021f8:	00000606 	br	1002214 <vComRxTask+0x94>

	for( ;; )
	{
		/* We expect to receive the characters from comFIRST_BYTE to
		comLAST_BYTE in an incrementing order.  Loop to receive each byte. */
		for( cExpectedByte = comFIRST_BYTE; cExpectedByte <= comLAST_BYTE; cExpectedByte++ )
 10021fc:	e0bffb03 	ldbu	r2,-20(fp)
 1002200:	10800044 	addi	r2,r2,1
 1002204:	e0bffb05 	stb	r2,-20(fp)
 1002208:	e0bffb07 	ldb	r2,-20(fp)
 100220c:	10801650 	cmplti	r2,r2,89
 1002210:	103fe51e 	bne	r2,zero,10021a8 <__alt_data_end+0xff8021a8>
				}
			}
		}

		/* Turn the LED off while we are not doing anything. */
		vParTestSetLED( uxBaseLED + comRX_LED_OFFSET, pdFALSE );
 1002214:	d0a05717 	ldw	r2,-32420(gp)
 1002218:	10800044 	addi	r2,r2,1
 100221c:	000b883a 	mov	r5,zero
 1002220:	1009883a 	mov	r4,r2
 1002224:	100372c0 	call	100372c <vParTestSetLED>

		/* Did we break out of the loop because the characters were received in
		an unexpected order?  If so wait here until the character sequence is
		about to restart. */
		if( xResyncRequired == pdTRUE )
 1002228:	e0bffc17 	ldw	r2,-16(fp)
 100222c:	10800058 	cmpnei	r2,r2,1
 1002230:	1000121e 	bne	r2,zero,100227c <vComRxTask+0xfc>
		{
			while( cByteRxed != comLAST_BYTE )
 1002234:	00000606 	br	1002250 <vComRxTask+0xd0>
			{
				/* Block until the next char is available. */
				xSerialGetChar( xPort, &cByteRxed, comRX_BLOCK_TIME );
 1002238:	d0a05617 	ldw	r2,-32424(gp)
 100223c:	e0fffe04 	addi	r3,fp,-8
 1002240:	01bfffd4 	movui	r6,65535
 1002244:	180b883a 	mov	r5,r3
 1002248:	1009883a 	mov	r4,r2
 100224c:	100771c0 	call	100771c <xSerialGetChar>
		/* Did we break out of the loop because the characters were received in
		an unexpected order?  If so wait here until the character sequence is
		about to restart. */
		if( xResyncRequired == pdTRUE )
		{
			while( cByteRxed != comLAST_BYTE )
 1002250:	e0bffe03 	ldbu	r2,-8(fp)
 1002254:	10803fcc 	andi	r2,r2,255
 1002258:	1080201c 	xori	r2,r2,128
 100225c:	10bfe004 	addi	r2,r2,-128
 1002260:	10801618 	cmpnei	r2,r2,88
 1002264:	103ff41e 	bne	r2,zero,1002238 <__alt_data_end+0xff802238>

			/* Note that an error occurred which caused us to have to resync.
			We use this to stop incrementing the loop counter so
			sAreComTestTasksStillRunning() will return false - indicating an
			error. */
			xErrorOccurred++;
 1002268:	e0bffd17 	ldw	r2,-12(fp)
 100226c:	10800044 	addi	r2,r2,1
 1002270:	e0bffd15 	stw	r2,-12(fp)

			/* We have now resynced with the Tx task and can continue. */
			xResyncRequired = pdFALSE;
 1002274:	e03ffc15 	stw	zero,-16(fp)
 1002278:	003fc806 	br	100219c <__alt_data_end+0xff80219c>
		}
		else
		{
			if( xErrorOccurred < comTOTAL_PERMISSIBLE_ERRORS )
 100227c:	e0bffd17 	ldw	r2,-12(fp)
 1002280:	10800088 	cmpgei	r2,r2,2
 1002284:	103fc51e 	bne	r2,zero,100219c <__alt_data_end+0xff80219c>
				occurring (i.e. an unexpected character being received) will
				prevent this counter being incremented for the rest of the
				execution.   Don't worry about mutual exclusion on this
				variable - it doesn't really matter as we just want it
				to change. */
				uxRxLoops++;
 1002288:	d0a05817 	ldw	r2,-32416(gp)
 100228c:	10800044 	addi	r2,r2,1
 1002290:	d0a05815 	stw	r2,-32416(gp)
			}
		}
	}
 1002294:	003fc106 	br	100219c <__alt_data_end+0xff80219c>

01002298 <xAreComTestTasksStillRunning>:
} /*lint !e715 !e818 pvParameters is required for a task function even if it is not referenced. */
/*-----------------------------------------------------------*/

BaseType_t xAreComTestTasksStillRunning( void )
{
 1002298:	defffe04 	addi	sp,sp,-8
 100229c:	df000115 	stw	fp,4(sp)
 10022a0:	df000104 	addi	fp,sp,4
BaseType_t xReturn;

	/* If the count of successful reception loops has not changed than at
	some time an error occurred (i.e. a character was received out of sequence)
	and we will return false. */
	if( uxRxLoops == comINITIAL_RX_COUNT_VALUE )
 10022a4:	d0a05817 	ldw	r2,-32416(gp)
 10022a8:	1000021e 	bne	r2,zero,10022b4 <xAreComTestTasksStillRunning+0x1c>
	{
		xReturn = pdFALSE;
 10022ac:	e03fff15 	stw	zero,-4(fp)
 10022b0:	00000206 	br	10022bc <xAreComTestTasksStillRunning+0x24>
	}
	else
	{
		xReturn = pdTRUE;
 10022b4:	00800044 	movi	r2,1
 10022b8:	e0bfff15 	stw	r2,-4(fp)
	}

	/* Reset the count of successful Rx loops.  When this function is called
	again we expect this to have been incremented. */
	uxRxLoops = comINITIAL_RX_COUNT_VALUE;
 10022bc:	d0205815 	stw	zero,-32416(gp)

	return xReturn;
 10022c0:	e0bfff17 	ldw	r2,-4(fp)
}
 10022c4:	e037883a 	mov	sp,fp
 10022c8:	df000017 	ldw	fp,0(sp)
 10022cc:	dec00104 	addi	sp,sp,4
 10022d0:	f800283a 	ret

010022d4 <vStartCountingSemaphoreTasks>:
static volatile xCountSemStruct xParameters[ countNUM_TEST_TASKS ];

/*-----------------------------------------------------------*/

void vStartCountingSemaphoreTasks( void )
{
 10022d4:	defffc04 	addi	sp,sp,-16
 10022d8:	dfc00315 	stw	ra,12(sp)
 10022dc:	df000215 	stw	fp,8(sp)
 10022e0:	df000204 	addi	fp,sp,8
	/* Create the semaphores that we are going to use for the test/demo.  The
	first should be created such that it starts at its maximum count value,
	the second should be created such that it starts with a count value of zero. */
	xParameters[ 0 ].xSemaphore = xSemaphoreCreateCounting( countMAX_COUNT_VALUE, countMAX_COUNT_VALUE );
 10022e4:	01403204 	movi	r5,200
 10022e8:	01003204 	movi	r4,200
 10022ec:	10046b00 	call	10046b0 <xQueueCreateCountingSemaphore>
 10022f0:	1007883a 	mov	r3,r2
 10022f4:	008040b4 	movhi	r2,258
 10022f8:	10b42e04 	addi	r2,r2,-12104
 10022fc:	10c00015 	stw	r3,0(r2)
	xParameters[ 0 ].uxExpectedStartCount = countSTART_AT_MAX_COUNT;
 1002300:	008040b4 	movhi	r2,258
 1002304:	10b42e04 	addi	r2,r2,-12104
 1002308:	00c02a84 	movi	r3,170
 100230c:	10c00115 	stw	r3,4(r2)
	xParameters[ 0 ].uxLoopCounter = 0;
 1002310:	008040b4 	movhi	r2,258
 1002314:	10b42e04 	addi	r2,r2,-12104
 1002318:	10000215 	stw	zero,8(r2)

	xParameters[ 1 ].xSemaphore = xSemaphoreCreateCounting( countMAX_COUNT_VALUE, 0 );
 100231c:	000b883a 	mov	r5,zero
 1002320:	01003204 	movi	r4,200
 1002324:	10046b00 	call	10046b0 <xQueueCreateCountingSemaphore>
 1002328:	1007883a 	mov	r3,r2
 100232c:	008040b4 	movhi	r2,258
 1002330:	10b42e04 	addi	r2,r2,-12104
 1002334:	10c00315 	stw	r3,12(r2)
	xParameters[ 1 ].uxExpectedStartCount = 0;
 1002338:	008040b4 	movhi	r2,258
 100233c:	10b42e04 	addi	r2,r2,-12104
 1002340:	10000415 	stw	zero,16(r2)
	xParameters[ 1 ].uxLoopCounter = 0;
 1002344:	008040b4 	movhi	r2,258
 1002348:	10b42e04 	addi	r2,r2,-12104
 100234c:	10000515 	stw	zero,20(r2)

	/* Were the semaphores created? */
	if( ( xParameters[ 0 ].xSemaphore != NULL ) || ( xParameters[ 1 ].xSemaphore != NULL ) )
 1002350:	008040b4 	movhi	r2,258
 1002354:	10b42e04 	addi	r2,r2,-12104
 1002358:	10800017 	ldw	r2,0(r2)
 100235c:	1000041e 	bne	r2,zero,1002370 <vStartCountingSemaphoreTasks+0x9c>
 1002360:	008040b4 	movhi	r2,258
 1002364:	10b42e04 	addi	r2,r2,-12104
 1002368:	10800317 	ldw	r2,12(r2)
 100236c:	10001426 	beq	r2,zero,10023c0 <vStartCountingSemaphoreTasks+0xec>
		defined or is defined to be less than 1. */
		vQueueAddToRegistry( ( QueueHandle_t ) xParameters[ 0 ].xSemaphore, "Counting_Sem_1" );
		vQueueAddToRegistry( ( QueueHandle_t ) xParameters[ 1 ].xSemaphore, "Counting_Sem_2" );

		/* Create the demo tasks, passing in the semaphore to use as the parameter. */
		xTaskCreate( prvCountingSemaphoreTask, "CNT1", configMINIMAL_STACK_SIZE, ( void * ) &( xParameters[ 0 ] ), tskIDLE_PRIORITY, NULL );
 1002370:	d8000115 	stw	zero,4(sp)
 1002374:	d8000015 	stw	zero,0(sp)
 1002378:	01c040b4 	movhi	r7,258
 100237c:	39f42e04 	addi	r7,r7,-12104
 1002380:	01810004 	movi	r6,1024
 1002384:	014040b4 	movhi	r5,258
 1002388:	2969f804 	addi	r5,r5,-22560
 100238c:	01004034 	movhi	r4,256
 1002390:	21095e04 	addi	r4,r4,9592
 1002394:	10053600 	call	1005360 <xTaskCreate>
		xTaskCreate( prvCountingSemaphoreTask, "CNT2", configMINIMAL_STACK_SIZE, ( void * ) &( xParameters[ 1 ] ), tskIDLE_PRIORITY, NULL );
 1002398:	d8000115 	stw	zero,4(sp)
 100239c:	d8000015 	stw	zero,0(sp)
 10023a0:	01c040b4 	movhi	r7,258
 10023a4:	39f43104 	addi	r7,r7,-12092
 10023a8:	01810004 	movi	r6,1024
 10023ac:	014040b4 	movhi	r5,258
 10023b0:	2969fa04 	addi	r5,r5,-22552
 10023b4:	01004034 	movhi	r4,256
 10023b8:	21095e04 	addi	r4,r4,9592
 10023bc:	10053600 	call	1005360 <xTaskCreate>
	}
}
 10023c0:	0001883a 	nop
 10023c4:	e037883a 	mov	sp,fp
 10023c8:	dfc00117 	ldw	ra,4(sp)
 10023cc:	df000017 	ldw	fp,0(sp)
 10023d0:	dec00204 	addi	sp,sp,8
 10023d4:	f800283a 	ret

010023d8 <prvDecrementSemaphoreCount>:
/*-----------------------------------------------------------*/

static void prvDecrementSemaphoreCount( SemaphoreHandle_t xSemaphore, UBaseType_t *puxLoopCounter )
{
 10023d8:	defffb04 	addi	sp,sp,-20
 10023dc:	dfc00415 	stw	ra,16(sp)
 10023e0:	df000315 	stw	fp,12(sp)
 10023e4:	df000304 	addi	fp,sp,12
 10023e8:	e13ffe15 	stw	r4,-8(fp)
 10023ec:	e17fff15 	stw	r5,-4(fp)
UBaseType_t ux;

	/* If the semaphore count is at its maximum then we should not be able to
	'give' the semaphore. */
	if( xSemaphoreGive( xSemaphore ) == pdPASS )
 10023f0:	000f883a 	mov	r7,zero
 10023f4:	000d883a 	mov	r6,zero
 10023f8:	000b883a 	mov	r5,zero
 10023fc:	e13ffe17 	ldw	r4,-8(fp)
 1002400:	10047080 	call	1004708 <xQueueGenericSend>
 1002404:	10800058 	cmpnei	r2,r2,1
 1002408:	1000021e 	bne	r2,zero,1002414 <prvDecrementSemaphoreCount+0x3c>
	{
		xErrorDetected = pdTRUE;
 100240c:	00800044 	movi	r2,1
 1002410:	d0a05915 	stw	r2,-32412(gp)
	}

	/* We should be able to 'take' the semaphore countMAX_COUNT_VALUE times. */
	for( ux = 0; ux < countMAX_COUNT_VALUE; ux++ )
 1002414:	e03ffd15 	stw	zero,-12(fp)
 1002418:	00001106 	br	1002460 <prvDecrementSemaphoreCount+0x88>
	{
		configASSERT( uxSemaphoreGetCount( xSemaphore ) == ( countMAX_COUNT_VALUE - ux ) );

		if( xSemaphoreTake( xSemaphore, countDONT_BLOCK ) != pdPASS )
 100241c:	000f883a 	mov	r7,zero
 1002420:	000d883a 	mov	r6,zero
 1002424:	000b883a 	mov	r5,zero
 1002428:	e13ffe17 	ldw	r4,-8(fp)
 100242c:	1004a800 	call	1004a80 <xQueueGenericReceive>
 1002430:	10800060 	cmpeqi	r2,r2,1
 1002434:	1000021e 	bne	r2,zero,1002440 <prvDecrementSemaphoreCount+0x68>
		{
			/* We expected to be able to take the semaphore. */
			xErrorDetected = pdTRUE;
 1002438:	00800044 	movi	r2,1
 100243c:	d0a05915 	stw	r2,-32412(gp)
		}

		( *puxLoopCounter )++;
 1002440:	e0bfff17 	ldw	r2,-4(fp)
 1002444:	10800017 	ldw	r2,0(r2)
 1002448:	10c00044 	addi	r3,r2,1
 100244c:	e0bfff17 	ldw	r2,-4(fp)
 1002450:	10c00015 	stw	r3,0(r2)
	{
		xErrorDetected = pdTRUE;
	}

	/* We should be able to 'take' the semaphore countMAX_COUNT_VALUE times. */
	for( ux = 0; ux < countMAX_COUNT_VALUE; ux++ )
 1002454:	e0bffd17 	ldw	r2,-12(fp)
 1002458:	10800044 	addi	r2,r2,1
 100245c:	e0bffd15 	stw	r2,-12(fp)
 1002460:	e0bffd17 	ldw	r2,-12(fp)
 1002464:	10803230 	cmpltui	r2,r2,200
 1002468:	103fec1e 	bne	r2,zero,100241c <__alt_data_end+0xff80241c>
	#endif

	/* If the semaphore count is zero then we should not be able to	'take'
	the semaphore. */
	configASSERT( uxSemaphoreGetCount( xSemaphore ) == 0 );
	if( xSemaphoreTake( xSemaphore, countDONT_BLOCK ) == pdPASS )
 100246c:	000f883a 	mov	r7,zero
 1002470:	000d883a 	mov	r6,zero
 1002474:	000b883a 	mov	r5,zero
 1002478:	e13ffe17 	ldw	r4,-8(fp)
 100247c:	1004a800 	call	1004a80 <xQueueGenericReceive>
 1002480:	10800058 	cmpnei	r2,r2,1
 1002484:	1000021e 	bne	r2,zero,1002490 <prvDecrementSemaphoreCount+0xb8>
	{
		xErrorDetected = pdTRUE;
 1002488:	00800044 	movi	r2,1
 100248c:	d0a05915 	stw	r2,-32412(gp)
	}
}
 1002490:	0001883a 	nop
 1002494:	e037883a 	mov	sp,fp
 1002498:	dfc00117 	ldw	ra,4(sp)
 100249c:	df000017 	ldw	fp,0(sp)
 10024a0:	dec00204 	addi	sp,sp,8
 10024a4:	f800283a 	ret

010024a8 <prvIncrementSemaphoreCount>:
/*-----------------------------------------------------------*/

static void prvIncrementSemaphoreCount( SemaphoreHandle_t xSemaphore, UBaseType_t *puxLoopCounter )
{
 10024a8:	defffb04 	addi	sp,sp,-20
 10024ac:	dfc00415 	stw	ra,16(sp)
 10024b0:	df000315 	stw	fp,12(sp)
 10024b4:	df000304 	addi	fp,sp,12
 10024b8:	e13ffe15 	stw	r4,-8(fp)
 10024bc:	e17fff15 	stw	r5,-4(fp)
UBaseType_t ux;

	/* If the semaphore count is zero then we should not be able to	'take'
	the semaphore. */
	if( xSemaphoreTake( xSemaphore, countDONT_BLOCK ) == pdPASS )
 10024c0:	000f883a 	mov	r7,zero
 10024c4:	000d883a 	mov	r6,zero
 10024c8:	000b883a 	mov	r5,zero
 10024cc:	e13ffe17 	ldw	r4,-8(fp)
 10024d0:	1004a800 	call	1004a80 <xQueueGenericReceive>
 10024d4:	10800058 	cmpnei	r2,r2,1
 10024d8:	1000021e 	bne	r2,zero,10024e4 <prvIncrementSemaphoreCount+0x3c>
	{
		xErrorDetected = pdTRUE;
 10024dc:	00800044 	movi	r2,1
 10024e0:	d0a05915 	stw	r2,-32412(gp)
	}

	/* We should be able to 'give' the semaphore countMAX_COUNT_VALUE times. */
	for( ux = 0; ux < countMAX_COUNT_VALUE; ux++ )
 10024e4:	e03ffd15 	stw	zero,-12(fp)
 10024e8:	00001106 	br	1002530 <prvIncrementSemaphoreCount+0x88>
	{
		configASSERT( uxSemaphoreGetCount( xSemaphore ) == ux );

		if( xSemaphoreGive( xSemaphore ) != pdPASS )
 10024ec:	000f883a 	mov	r7,zero
 10024f0:	000d883a 	mov	r6,zero
 10024f4:	000b883a 	mov	r5,zero
 10024f8:	e13ffe17 	ldw	r4,-8(fp)
 10024fc:	10047080 	call	1004708 <xQueueGenericSend>
 1002500:	10800060 	cmpeqi	r2,r2,1
 1002504:	1000021e 	bne	r2,zero,1002510 <prvIncrementSemaphoreCount+0x68>
		{
			/* We expected to be able to take the semaphore. */
			xErrorDetected = pdTRUE;
 1002508:	00800044 	movi	r2,1
 100250c:	d0a05915 	stw	r2,-32412(gp)
		}

		( *puxLoopCounter )++;
 1002510:	e0bfff17 	ldw	r2,-4(fp)
 1002514:	10800017 	ldw	r2,0(r2)
 1002518:	10c00044 	addi	r3,r2,1
 100251c:	e0bfff17 	ldw	r2,-4(fp)
 1002520:	10c00015 	stw	r3,0(r2)
	{
		xErrorDetected = pdTRUE;
	}

	/* We should be able to 'give' the semaphore countMAX_COUNT_VALUE times. */
	for( ux = 0; ux < countMAX_COUNT_VALUE; ux++ )
 1002524:	e0bffd17 	ldw	r2,-12(fp)
 1002528:	10800044 	addi	r2,r2,1
 100252c:	e0bffd15 	stw	r2,-12(fp)
 1002530:	e0bffd17 	ldw	r2,-12(fp)
 1002534:	10803230 	cmpltui	r2,r2,200
 1002538:	103fec1e 	bne	r2,zero,10024ec <__alt_data_end+0xff8024ec>
		taskYIELD();
	#endif

	/* If the semaphore count is at its maximum then we should not be able to
	'give' the semaphore. */
	if( xSemaphoreGive( xSemaphore ) == pdPASS )
 100253c:	000f883a 	mov	r7,zero
 1002540:	000d883a 	mov	r6,zero
 1002544:	000b883a 	mov	r5,zero
 1002548:	e13ffe17 	ldw	r4,-8(fp)
 100254c:	10047080 	call	1004708 <xQueueGenericSend>
 1002550:	10800058 	cmpnei	r2,r2,1
 1002554:	1000021e 	bne	r2,zero,1002560 <prvIncrementSemaphoreCount+0xb8>
	{
		xErrorDetected = pdTRUE;
 1002558:	00800044 	movi	r2,1
 100255c:	d0a05915 	stw	r2,-32412(gp)
	}
}
 1002560:	0001883a 	nop
 1002564:	e037883a 	mov	sp,fp
 1002568:	dfc00117 	ldw	ra,4(sp)
 100256c:	df000017 	ldw	fp,0(sp)
 1002570:	dec00204 	addi	sp,sp,8
 1002574:	f800283a 	ret

01002578 <prvCountingSemaphoreTask>:
/*-----------------------------------------------------------*/

static void prvCountingSemaphoreTask( void *pvParameters )
{
 1002578:	defffc04 	addi	sp,sp,-16
 100257c:	dfc00315 	stw	ra,12(sp)
 1002580:	df000215 	stw	fp,8(sp)
 1002584:	df000204 	addi	fp,sp,8
 1002588:	e13fff15 	stw	r4,-4(fp)
		/* Queue a message for printing to say the task has started. */
		vPrintDisplayMessage( &pcTaskStartMsg );
	#endif

	/* The semaphore to be used was passed as the parameter. */
	pxParameter = ( xCountSemStruct * ) pvParameters;
 100258c:	e0bfff17 	ldw	r2,-4(fp)
 1002590:	e0bffe15 	stw	r2,-8(fp)

	/* Did we expect to find the semaphore already at its max count value, or
	at zero? */
	if( pxParameter->uxExpectedStartCount == countSTART_AT_MAX_COUNT )
 1002594:	e0bffe17 	ldw	r2,-8(fp)
 1002598:	10800117 	ldw	r2,4(r2)
 100259c:	10802a98 	cmpnei	r2,r2,170
 10025a0:	1000071e 	bne	r2,zero,10025c0 <prvCountingSemaphoreTask+0x48>
	{
		prvDecrementSemaphoreCount( pxParameter->xSemaphore, &( pxParameter->uxLoopCounter ) );
 10025a4:	e0bffe17 	ldw	r2,-8(fp)
 10025a8:	10c00017 	ldw	r3,0(r2)
 10025ac:	e0bffe17 	ldw	r2,-8(fp)
 10025b0:	10800204 	addi	r2,r2,8
 10025b4:	100b883a 	mov	r5,r2
 10025b8:	1809883a 	mov	r4,r3
 10025bc:	10023d80 	call	10023d8 <prvDecrementSemaphoreCount>
	}

	/* Now we expect the semaphore count to be 0, so this time there is an
	error if we can take the semaphore. */
	if( xSemaphoreTake( pxParameter->xSemaphore, 0 ) == pdPASS )
 10025c0:	e0bffe17 	ldw	r2,-8(fp)
 10025c4:	10800017 	ldw	r2,0(r2)
 10025c8:	000f883a 	mov	r7,zero
 10025cc:	000d883a 	mov	r6,zero
 10025d0:	000b883a 	mov	r5,zero
 10025d4:	1009883a 	mov	r4,r2
 10025d8:	1004a800 	call	1004a80 <xQueueGenericReceive>
 10025dc:	10800058 	cmpnei	r2,r2,1
 10025e0:	1000021e 	bne	r2,zero,10025ec <prvCountingSemaphoreTask+0x74>
	{
		xErrorDetected = pdTRUE;
 10025e4:	00800044 	movi	r2,1
 10025e8:	d0a05915 	stw	r2,-32412(gp)
	}

	for( ;; )
	{
		prvIncrementSemaphoreCount( pxParameter->xSemaphore, &( pxParameter->uxLoopCounter ) );
 10025ec:	e0bffe17 	ldw	r2,-8(fp)
 10025f0:	10c00017 	ldw	r3,0(r2)
 10025f4:	e0bffe17 	ldw	r2,-8(fp)
 10025f8:	10800204 	addi	r2,r2,8
 10025fc:	100b883a 	mov	r5,r2
 1002600:	1809883a 	mov	r4,r3
 1002604:	10024a80 	call	10024a8 <prvIncrementSemaphoreCount>
		prvDecrementSemaphoreCount( pxParameter->xSemaphore, &( pxParameter->uxLoopCounter ) );
 1002608:	e0bffe17 	ldw	r2,-8(fp)
 100260c:	10c00017 	ldw	r3,0(r2)
 1002610:	e0bffe17 	ldw	r2,-8(fp)
 1002614:	10800204 	addi	r2,r2,8
 1002618:	100b883a 	mov	r5,r2
 100261c:	1809883a 	mov	r4,r3
 1002620:	10023d80 	call	10023d8 <prvDecrementSemaphoreCount>
	}
 1002624:	003ff106 	br	10025ec <__alt_data_end+0xff8025ec>

01002628 <xAreCountingSemaphoreTasksStillRunning>:
}
/*-----------------------------------------------------------*/

BaseType_t xAreCountingSemaphoreTasksStillRunning( void )
{
 1002628:	defffe04 	addi	sp,sp,-8
 100262c:	df000115 	stw	fp,4(sp)
 1002630:	df000104 	addi	fp,sp,4
static UBaseType_t uxLastCount0 = 0, uxLastCount1 = 0;
BaseType_t xReturn = pdPASS;
 1002634:	00800044 	movi	r2,1
 1002638:	e0bfff15 	stw	r2,-4(fp)

	/* Return fail if any 'give' or 'take' did not result in the expected
	behaviour. */
	if( xErrorDetected != pdFALSE )
 100263c:	d0a05917 	ldw	r2,-32412(gp)
 1002640:	10000126 	beq	r2,zero,1002648 <xAreCountingSemaphoreTasksStillRunning+0x20>
	{
		xReturn = pdFAIL;
 1002644:	e03fff15 	stw	zero,-4(fp)
	}

	/* Return fail if either task is not still incrementing its loop counter. */
	if( uxLastCount0 == xParameters[ 0 ].uxLoopCounter )
 1002648:	008040b4 	movhi	r2,258
 100264c:	10b42e04 	addi	r2,r2,-12104
 1002650:	10c00217 	ldw	r3,8(r2)
 1002654:	d0a05a17 	ldw	r2,-32408(gp)
 1002658:	1880021e 	bne	r3,r2,1002664 <xAreCountingSemaphoreTasksStillRunning+0x3c>
	{
		xReturn = pdFAIL;
 100265c:	e03fff15 	stw	zero,-4(fp)
 1002660:	00000406 	br	1002674 <xAreCountingSemaphoreTasksStillRunning+0x4c>
	}
	else
	{
		uxLastCount0 = xParameters[ 0 ].uxLoopCounter;
 1002664:	008040b4 	movhi	r2,258
 1002668:	10b42e04 	addi	r2,r2,-12104
 100266c:	10800217 	ldw	r2,8(r2)
 1002670:	d0a05a15 	stw	r2,-32408(gp)
	}

	if( uxLastCount1 == xParameters[ 1 ].uxLoopCounter )
 1002674:	008040b4 	movhi	r2,258
 1002678:	10b42e04 	addi	r2,r2,-12104
 100267c:	10c00517 	ldw	r3,20(r2)
 1002680:	d0a05b17 	ldw	r2,-32404(gp)
 1002684:	1880021e 	bne	r3,r2,1002690 <xAreCountingSemaphoreTasksStillRunning+0x68>
	{
		xReturn = pdFAIL;
 1002688:	e03fff15 	stw	zero,-4(fp)
 100268c:	00000406 	br	10026a0 <xAreCountingSemaphoreTasksStillRunning+0x78>
	}
	else
	{
		uxLastCount1 = xParameters[ 1 ].uxLoopCounter;
 1002690:	008040b4 	movhi	r2,258
 1002694:	10b42e04 	addi	r2,r2,-12104
 1002698:	10800517 	ldw	r2,20(r2)
 100269c:	d0a05b15 	stw	r2,-32404(gp)
	}

	return xReturn;
 10026a0:	e0bfff17 	ldw	r2,-4(fp)
}
 10026a4:	e037883a 	mov	sp,fp
 10026a8:	df000017 	ldw	fp,0(sp)
 10026ac:	dec00104 	addi	sp,sp,4
 10026b0:	f800283a 	ret

010026b4 <vCreateSuicidalTasks>:
TaskHandle_t xCreatedTask;

/*-----------------------------------------------------------*/

void vCreateSuicidalTasks( UBaseType_t uxPriority )
{
 10026b4:	defffb04 	addi	sp,sp,-20
 10026b8:	dfc00415 	stw	ra,16(sp)
 10026bc:	df000315 	stw	fp,12(sp)
 10026c0:	df000304 	addi	fp,sp,12
 10026c4:	e13fff15 	stw	r4,-4(fp)
	xTaskCreate( vCreateTasks, "CREATOR", deathSTACK_SIZE, ( void * ) NULL, uxPriority, NULL );
 10026c8:	d8000115 	stw	zero,4(sp)
 10026cc:	e0bfff17 	ldw	r2,-4(fp)
 10026d0:	d8800015 	stw	r2,0(sp)
 10026d4:	000f883a 	mov	r7,zero
 10026d8:	01810f04 	movi	r6,1084
 10026dc:	014040b4 	movhi	r5,258
 10026e0:	2969fc04 	addi	r5,r5,-22544
 10026e4:	01004034 	movhi	r4,256
 10026e8:	2109e804 	addi	r4,r4,10144
 10026ec:	10053600 	call	1005360 <xTaskCreate>

	/* Record the number of tasks that are running now so we know if any of the
	suicidal tasks have failed to be killed. */
	uxTasksRunningAtStart = ( UBaseType_t ) uxTaskGetNumberOfTasks();
 10026f0:	10061740 	call	1006174 <uxTaskGetNumberOfTasks>
 10026f4:	d0a05d15 	stw	r2,-32396(gp)
	/* FreeRTOS.org versions before V3.0 started the idle-task as the very
	first task. The idle task was then already included in uxTasksRunningAtStart.
	From FreeRTOS V3.0 on, the idle task is started when the scheduler is
	started. Therefore the idle task is not yet accounted for. We correct
	this by increasing uxTasksRunningAtStart by 1. */
	uxTasksRunningAtStart++;
 10026f8:	d0a05d17 	ldw	r2,-32396(gp)
 10026fc:	10800044 	addi	r2,r2,1
 1002700:	d0a05d15 	stw	r2,-32396(gp)
	#if configUSE_TIMERS == 1
	{
		uxTasksRunningAtStart++;
	}
	#endif
}
 1002704:	0001883a 	nop
 1002708:	e037883a 	mov	sp,fp
 100270c:	dfc00117 	ldw	ra,4(sp)
 1002710:	df000017 	ldw	fp,0(sp)
 1002714:	dec00204 	addi	sp,sp,8
 1002718:	f800283a 	ret

0100271c <vSuicidalTask>:
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vSuicidalTask, pvParameters )
{
 100271c:	defff904 	addi	sp,sp,-28
 1002720:	dfc00615 	stw	ra,24(sp)
 1002724:	df000515 	stw	fp,20(sp)
 1002728:	df000504 	addi	fp,sp,20
 100272c:	e13fff15 	stw	r4,-4(fp)
volatile long l1, l2;
TaskHandle_t xTaskToKill;
const TickType_t xDelay = pdMS_TO_TICKS( ( TickType_t ) 200 );
 1002730:	00803204 	movi	r2,200
 1002734:	e0bffc15 	stw	r2,-16(fp)

	if( pvParameters != NULL )
 1002738:	e0bfff17 	ldw	r2,-4(fp)
 100273c:	10000426 	beq	r2,zero,1002750 <vSuicidalTask+0x34>
	{
		/* This task is periodically created four times.  Two created tasks are
		passed a handle to the other task so it can kill it before killing itself.
		The other task is passed in null. */
		xTaskToKill = *( TaskHandle_t* )pvParameters;
 1002740:	e0bfff17 	ldw	r2,-4(fp)
 1002744:	10800017 	ldw	r2,0(r2)
 1002748:	e0bffb15 	stw	r2,-20(fp)
 100274c:	00000106 	br	1002754 <vSuicidalTask+0x38>
	}
	else
	{
		xTaskToKill = NULL;
 1002750:	e03ffb15 	stw	zero,-20(fp)
	}

	for( ;; )
	{
		/* Do something random just to use some stack and registers. */
		l1 = 2;
 1002754:	00800084 	movi	r2,2
 1002758:	e0bffd15 	stw	r2,-12(fp)
		l2 = 89;
 100275c:	00801644 	movi	r2,89
 1002760:	e0bffe15 	stw	r2,-8(fp)
		l2 *= l1;
 1002764:	e0fffd17 	ldw	r3,-12(fp)
 1002768:	e0bffe17 	ldw	r2,-8(fp)
 100276c:	1885383a 	mul	r2,r3,r2
 1002770:	e0bffe15 	stw	r2,-8(fp)
		vTaskDelay( xDelay );
 1002774:	e13ffc17 	ldw	r4,-16(fp)
 1002778:	10058ec0 	call	10058ec <vTaskDelay>

		if( xTaskToKill != NULL )
 100277c:	e0bffb17 	ldw	r2,-20(fp)
 1002780:	103ff426 	beq	r2,zero,1002754 <__alt_data_end+0xff802754>
		{
			/* Make sure the other task has a go before we delete it. */
			vTaskDelay( ( TickType_t ) 0 );
 1002784:	0009883a 	mov	r4,zero
 1002788:	10058ec0 	call	10058ec <vTaskDelay>

			/* Kill the other task that was created by vCreateTasks(). */
			vTaskDelete( xTaskToKill );
 100278c:	e13ffb17 	ldw	r4,-20(fp)
 1002790:	10057140 	call	1005714 <vTaskDelete>

			/* Kill ourselves. */
			vTaskDelete( NULL );
 1002794:	0009883a 	mov	r4,zero
 1002798:	10057140 	call	1005714 <vTaskDelete>
		}
	}
 100279c:	003fed06 	br	1002754 <__alt_data_end+0xff802754>

010027a0 <vCreateTasks>:
}/*lint !e818 !e550 Function prototype must be as per standard for task functions. */
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vCreateTasks, pvParameters )
{
 10027a0:	defff904 	addi	sp,sp,-28
 10027a4:	dfc00615 	stw	ra,24(sp)
 10027a8:	df000515 	stw	fp,20(sp)
 10027ac:	df000504 	addi	fp,sp,20
 10027b0:	e13fff15 	stw	r4,-4(fp)
const TickType_t xDelay = pdMS_TO_TICKS( ( TickType_t ) 1000 );
 10027b4:	0080fa04 	movi	r2,1000
 10027b8:	e0bffd15 	stw	r2,-12(fp)
UBaseType_t uxPriority;

	/* Remove compiler warning about unused parameter. */
	( void ) pvParameters;

	uxPriority = uxTaskPriorityGet( NULL );
 10027bc:	0009883a 	mov	r4,zero
 10027c0:	10059480 	call	1005948 <uxTaskPriorityGet>
 10027c4:	e0bffe15 	stw	r2,-8(fp)

	for( ;; )
	{
		/* Just loop round, delaying then creating the four suicidal tasks. */
		vTaskDelay( xDelay );
 10027c8:	e13ffd17 	ldw	r4,-12(fp)
 10027cc:	10058ec0 	call	10058ec <vTaskDelay>

		xCreatedTask = NULL;
 10027d0:	d0205f15 	stw	zero,-32388(gp)

		xTaskCreate( vSuicidalTask, "SUICID1", configMINIMAL_STACK_SIZE, NULL, uxPriority, &xCreatedTask );
 10027d4:	d0a05f04 	addi	r2,gp,-32388
 10027d8:	d8800115 	stw	r2,4(sp)
 10027dc:	e0bffe17 	ldw	r2,-8(fp)
 10027e0:	d8800015 	stw	r2,0(sp)
 10027e4:	000f883a 	mov	r7,zero
 10027e8:	01810004 	movi	r6,1024
 10027ec:	014040b4 	movhi	r5,258
 10027f0:	2969fe04 	addi	r5,r5,-22536
 10027f4:	01004034 	movhi	r4,256
 10027f8:	2109c704 	addi	r4,r4,10012
 10027fc:	10053600 	call	1005360 <xTaskCreate>
		xTaskCreate( vSuicidalTask, "SUICID2", configMINIMAL_STACK_SIZE, &xCreatedTask, uxPriority, NULL );
 1002800:	d8000115 	stw	zero,4(sp)
 1002804:	e0bffe17 	ldw	r2,-8(fp)
 1002808:	d8800015 	stw	r2,0(sp)
 100280c:	d1e05f04 	addi	r7,gp,-32388
 1002810:	01810004 	movi	r6,1024
 1002814:	014040b4 	movhi	r5,258
 1002818:	296a0004 	addi	r5,r5,-22528
 100281c:	01004034 	movhi	r4,256
 1002820:	2109c704 	addi	r4,r4,10012
 1002824:	10053600 	call	1005360 <xTaskCreate>

		++usCreationCount;
 1002828:	d0a05c0b 	ldhu	r2,-32400(gp)
 100282c:	10800044 	addi	r2,r2,1
 1002830:	d0a05c0d 	sth	r2,-32400(gp)
	}
 1002834:	003fe406 	br	10027c8 <__alt_data_end+0xff8027c8>

01002838 <xIsCreateTaskStillRunning>:
/*-----------------------------------------------------------*/

/* This is called to check that the creator task is still running and that there
are not any more than four extra tasks. */
BaseType_t xIsCreateTaskStillRunning( void )
{
 1002838:	defffd04 	addi	sp,sp,-12
 100283c:	dfc00215 	stw	ra,8(sp)
 1002840:	df000115 	stw	fp,4(sp)
 1002844:	df000104 	addi	fp,sp,4
static uint16_t usLastCreationCount = 0xfff;
BaseType_t xReturn = pdTRUE;
 1002848:	00800044 	movi	r2,1
 100284c:	e0bfff15 	stw	r2,-4(fp)
static UBaseType_t uxTasksRunningNow;

	if( usLastCreationCount == usCreationCount )
 1002850:	d0e0010b 	ldhu	r3,-32764(gp)
 1002854:	d0a05c0b 	ldhu	r2,-32400(gp)
 1002858:	18ffffcc 	andi	r3,r3,65535
 100285c:	10bfffcc 	andi	r2,r2,65535
 1002860:	1880021e 	bne	r3,r2,100286c <xIsCreateTaskStillRunning+0x34>
	{
		xReturn = pdFALSE;
 1002864:	e03fff15 	stw	zero,-4(fp)
 1002868:	00000206 	br	1002874 <xIsCreateTaskStillRunning+0x3c>
	}
	else
	{
		usLastCreationCount = usCreationCount;
 100286c:	d0a05c0b 	ldhu	r2,-32400(gp)
 1002870:	d0a0010d 	sth	r2,-32764(gp)
	}

	uxTasksRunningNow = ( UBaseType_t ) uxTaskGetNumberOfTasks();
 1002874:	10061740 	call	1006174 <uxTaskGetNumberOfTasks>
 1002878:	d0a05e15 	stw	r2,-32392(gp)

	if( uxTasksRunningNow < uxTasksRunningAtStart )
 100287c:	d0e05e17 	ldw	r3,-32392(gp)
 1002880:	d0a05d17 	ldw	r2,-32396(gp)
 1002884:	1880022e 	bgeu	r3,r2,1002890 <xIsCreateTaskStillRunning+0x58>
	{
		xReturn = pdFALSE;
 1002888:	e03fff15 	stw	zero,-4(fp)
 100288c:	00000606 	br	10028a8 <xIsCreateTaskStillRunning+0x70>
	}
	else if( ( uxTasksRunningNow - uxTasksRunningAtStart ) > uxMaxNumberOfExtraTasksRunning )
 1002890:	d0e05e17 	ldw	r3,-32392(gp)
 1002894:	d0a05d17 	ldw	r2,-32396(gp)
 1002898:	1885c83a 	sub	r2,r3,r2
 100289c:	00c000c4 	movi	r3,3
 10028a0:	1880012e 	bgeu	r3,r2,10028a8 <xIsCreateTaskStillRunning+0x70>
	{
		xReturn = pdFALSE;
 10028a4:	e03fff15 	stw	zero,-4(fp)
	else
	{
		/* Everything is okay. */
	}

	return xReturn;
 10028a8:	e0bfff17 	ldw	r2,-4(fp)
}
 10028ac:	e037883a 	mov	sp,fp
 10028b0:	dfc00117 	ldw	ra,4(sp)
 10028b4:	df000017 	ldw	fp,0(sp)
 10028b8:	dec00204 	addi	sp,sp,8
 10028bc:	f800283a 	ret

010028c0 <vStartDynamicPriorityTasks>:
/*
 * Start the three tasks as described at the top of the file.
 * Note that the limited count task is given a higher priority.
 */
void vStartDynamicPriorityTasks( void )
{
 10028c0:	defffc04 	addi	sp,sp,-16
 10028c4:	dfc00315 	stw	ra,12(sp)
 10028c8:	df000215 	stw	fp,8(sp)
 10028cc:	df000204 	addi	fp,sp,8
	xSuspendedTestQueue = xQueueCreate( priSUSPENDED_QUEUE_LENGTH, sizeof( uint32_t ) );
 10028d0:	000d883a 	mov	r6,zero
 10028d4:	01400104 	movi	r5,4
 10028d8:	01000044 	movi	r4,1
 10028dc:	100439c0 	call	100439c <xQueueGenericCreate>
 10028e0:	d0a06a15 	stw	r2,-32344(gp)

	if( xSuspendedTestQueue != NULL )
 10028e4:	d0a06a17 	ldw	r2,-32344(gp)
 10028e8:	10003026 	beq	r2,zero,10029ac <vStartDynamicPriorityTasks+0xec>
		is not being used.  The call to vQueueAddToRegistry() will be removed
		by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is
		defined to be less than 1. */
		vQueueAddToRegistry( xSuspendedTestQueue, "Suspended_Test_Queue" );

		xTaskCreate( vContinuousIncrementTask, "CNT_INC", priSTACK_SIZE, ( void * ) &ulCounter, tskIDLE_PRIORITY, &xContinuousIncrementHandle );
 10028ec:	d0a06004 	addi	r2,gp,-32384
 10028f0:	d8800115 	stw	r2,4(sp)
 10028f4:	d8000015 	stw	zero,0(sp)
 10028f8:	d1e06204 	addi	r7,gp,-32376
 10028fc:	01810004 	movi	r6,1024
 1002900:	014040b4 	movhi	r5,258
 1002904:	296a0204 	addi	r5,r5,-22520
 1002908:	01004034 	movhi	r4,256
 100290c:	210a8604 	addi	r4,r4,10776
 1002910:	10053600 	call	1005360 <xTaskCreate>
		xTaskCreate( vLimitedIncrementTask, "LIM_INC", priSTACK_SIZE, ( void * ) &ulCounter, tskIDLE_PRIORITY + 1, &xLimitedIncrementHandle );
 1002914:	d0a06104 	addi	r2,gp,-32380
 1002918:	d8800115 	stw	r2,4(sp)
 100291c:	00800044 	movi	r2,1
 1002920:	d8800015 	stw	r2,0(sp)
 1002924:	d1e06204 	addi	r7,gp,-32376
 1002928:	01810004 	movi	r6,1024
 100292c:	014040b4 	movhi	r5,258
 1002930:	296a0404 	addi	r5,r5,-22512
 1002934:	01004034 	movhi	r4,256
 1002938:	210a7104 	addi	r4,r4,10692
 100293c:	10053600 	call	1005360 <xTaskCreate>
		xTaskCreate( vCounterControlTask, "C_CTRL", priSTACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
 1002940:	d8000115 	stw	zero,4(sp)
 1002944:	d8000015 	stw	zero,0(sp)
 1002948:	000f883a 	mov	r7,zero
 100294c:	01810004 	movi	r6,1024
 1002950:	014040b4 	movhi	r5,258
 1002954:	296a0604 	addi	r5,r5,-22504
 1002958:	01004034 	movhi	r4,256
 100295c:	210a9e04 	addi	r4,r4,10872
 1002960:	10053600 	call	1005360 <xTaskCreate>
		xTaskCreate( vQueueSendWhenSuspendedTask, "SUSP_TX", priSTACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
 1002964:	d8000115 	stw	zero,4(sp)
 1002968:	d8000015 	stw	zero,0(sp)
 100296c:	000f883a 	mov	r7,zero
 1002970:	01810004 	movi	r6,1024
 1002974:	014040b4 	movhi	r5,258
 1002978:	296a0804 	addi	r5,r5,-22496
 100297c:	01004034 	movhi	r4,256
 1002980:	210ad504 	addi	r4,r4,11092
 1002984:	10053600 	call	1005360 <xTaskCreate>
		xTaskCreate( vQueueReceiveWhenSuspendedTask, "SUSP_RX", priSTACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
 1002988:	d8000115 	stw	zero,4(sp)
 100298c:	d8000015 	stw	zero,0(sp)
 1002990:	000f883a 	mov	r7,zero
 1002994:	01810004 	movi	r6,1024
 1002998:	014040b4 	movhi	r5,258
 100299c:	296a0a04 	addi	r5,r5,-22488
 10029a0:	01004034 	movhi	r4,256
 10029a4:	210aec04 	addi	r4,r4,11184
 10029a8:	10053600 	call	1005360 <xTaskCreate>
	}
}
 10029ac:	0001883a 	nop
 10029b0:	e037883a 	mov	sp,fp
 10029b4:	dfc00117 	ldw	ra,4(sp)
 10029b8:	df000017 	ldw	fp,0(sp)
 10029bc:	dec00204 	addi	sp,sp,8
 10029c0:	f800283a 	ret

010029c4 <vLimitedIncrementTask>:
/*
 * Just loops around incrementing the shared variable until the limit has been
 * reached.  Once the limit has been reached it suspends itself.
 */
static portTASK_FUNCTION( vLimitedIncrementTask, pvParameters )
{
 10029c4:	defffc04 	addi	sp,sp,-16
 10029c8:	dfc00315 	stw	ra,12(sp)
 10029cc:	df000215 	stw	fp,8(sp)
 10029d0:	df000204 	addi	fp,sp,8
 10029d4:	e13fff15 	stw	r4,-4(fp)
uint32_t *pulCounter;

	/* Take a pointer to the shared variable from the parameters passed into
	the task. */
	pulCounter = ( uint32_t * ) pvParameters;
 10029d8:	e0bfff17 	ldw	r2,-4(fp)
 10029dc:	e0bffe15 	stw	r2,-8(fp)

	/* This will run before the control task, so the first thing it does is
	suspend - the control task will resume it when ready. */
	vTaskSuspend( NULL );
 10029e0:	0009883a 	mov	r4,zero
 10029e4:	1005ba40 	call	1005ba4 <vTaskSuspend>

	for( ;; )
	{
		/* Just count up to a value then suspend. */
		( *pulCounter )++;
 10029e8:	e0bffe17 	ldw	r2,-8(fp)
 10029ec:	10800017 	ldw	r2,0(r2)
 10029f0:	10c00044 	addi	r3,r2,1
 10029f4:	e0bffe17 	ldw	r2,-8(fp)
 10029f8:	10c00015 	stw	r3,0(r2)

		if( *pulCounter >= priMAX_COUNT )
 10029fc:	e0bffe17 	ldw	r2,-8(fp)
 1002a00:	10800017 	ldw	r2,0(r2)
 1002a04:	10803ff0 	cmpltui	r2,r2,255
 1002a08:	103ff71e 	bne	r2,zero,10029e8 <__alt_data_end+0xff8029e8>
		{
			vTaskSuspend( NULL );
 1002a0c:	0009883a 	mov	r4,zero
 1002a10:	1005ba40 	call	1005ba4 <vTaskSuspend>
		}
	}
 1002a14:	003ff406 	br	10029e8 <__alt_data_end+0xff8029e8>

01002a18 <vContinuousIncrementTask>:
/*
 * Just keep counting the shared variable up.  The control task will suspend
 * this task when it wants.
 */
static portTASK_FUNCTION( vContinuousIncrementTask, pvParameters )
{
 1002a18:	defffb04 	addi	sp,sp,-20
 1002a1c:	dfc00415 	stw	ra,16(sp)
 1002a20:	df000315 	stw	fp,12(sp)
 1002a24:	df000304 	addi	fp,sp,12
 1002a28:	e13fff15 	stw	r4,-4(fp)
volatile uint32_t *pulCounter;
UBaseType_t uxOurPriority;

	/* Take a pointer to the shared variable from the parameters passed into
	the task. */
	pulCounter = ( uint32_t * ) pvParameters;
 1002a2c:	e0bfff17 	ldw	r2,-4(fp)
 1002a30:	e0bffd15 	stw	r2,-12(fp)

	/* Query our priority so we can raise it when exclusive access to the
	shared variable is required. */
	uxOurPriority = uxTaskPriorityGet( NULL );
 1002a34:	0009883a 	mov	r4,zero
 1002a38:	10059480 	call	1005948 <uxTaskPriorityGet>
 1002a3c:	e0bffe15 	stw	r2,-8(fp)

	for( ;; )
	{
		/* Raise the priority above the controller task to ensure a context
		switch does not occur while the variable is being accessed. */
		vTaskPrioritySet( NULL, uxOurPriority + 1 );
 1002a40:	e0bffe17 	ldw	r2,-8(fp)
 1002a44:	10800044 	addi	r2,r2,1
 1002a48:	100b883a 	mov	r5,r2
 1002a4c:	0009883a 	mov	r4,zero
 1002a50:	10059ec0 	call	10059ec <vTaskPrioritySet>
		{
			configASSERT( ( uxTaskPriorityGet( NULL ) == ( uxOurPriority + 1 ) ) );
			( *pulCounter )++;
 1002a54:	e0bffd17 	ldw	r2,-12(fp)
 1002a58:	10800017 	ldw	r2,0(r2)
 1002a5c:	10c00044 	addi	r3,r2,1
 1002a60:	e0bffd17 	ldw	r2,-12(fp)
 1002a64:	10c00015 	stw	r3,0(r2)
		}
		vTaskPrioritySet( NULL, uxOurPriority );
 1002a68:	e17ffe17 	ldw	r5,-8(fp)
 1002a6c:	0009883a 	mov	r4,zero
 1002a70:	10059ec0 	call	10059ec <vTaskPrioritySet>
		#if( configUSE_PREEMPTION == 0 )
			taskYIELD();
		#endif

		configASSERT( ( uxTaskPriorityGet( NULL ) == uxOurPriority ) );
	}
 1002a74:	003ff206 	br	1002a40 <__alt_data_end+0xff802a40>

01002a78 <vCounterControlTask>:

/*
 * Controller task as described above.
 */
static portTASK_FUNCTION( vCounterControlTask, pvParameters )
{
 1002a78:	defffb04 	addi	sp,sp,-20
 1002a7c:	dfc00415 	stw	ra,16(sp)
 1002a80:	df000315 	stw	fp,12(sp)
 1002a84:	df000304 	addi	fp,sp,12
 1002a88:	e13fff15 	stw	r4,-4(fp)
uint32_t ulLastCounter;
short sLoops;
short sError = pdFALSE;
 1002a8c:	e03ffd8d 	sth	zero,-10(fp)
	( void ) pvParameters;

	for( ;; )
	{
		/* Start with the counter at zero. */
		ulCounter = ( uint32_t ) 0;
 1002a90:	d0206215 	stw	zero,-32376(gp)

		/* First section : */

		/* Check the continuous count task is running. */
		for( sLoops = 0; sLoops < priLOOPS; sLoops++ )
 1002a94:	e03ffd0d 	sth	zero,-12(fp)
 1002a98:	00001406 	br	1002aec <vCounterControlTask+0x74>
		{
			/* Suspend the continuous count task so we can take a mirror of the
			shared variable without risk of corruption.  This is not really
			needed as the other task raises its priority above this task's
			priority. */
			vTaskSuspend( xContinuousIncrementHandle );
 1002a9c:	d0a06017 	ldw	r2,-32384(gp)
 1002aa0:	1009883a 	mov	r4,r2
 1002aa4:	1005ba40 	call	1005ba4 <vTaskSuspend>
				{
					configASSERT( eTaskGetState( xContinuousIncrementHandle ) == eSuspended );
				}
				#endif /* INCLUDE_eTaskGetState */

				ulLastCounter = ulCounter;
 1002aa8:	d0a06217 	ldw	r2,-32376(gp)
 1002aac:	e0bffe15 	stw	r2,-8(fp)
			}
			vTaskResume( xContinuousIncrementHandle );
 1002ab0:	d0a06017 	ldw	r2,-32384(gp)
 1002ab4:	1009883a 	mov	r4,r2
 1002ab8:	1005d180 	call	1005d18 <vTaskResume>
				configASSERT( eTaskGetState( xContinuousIncrementHandle ) == eReady );
			}
			#endif /* INCLUDE_eTaskGetState */

			/* Now delay to ensure the other task has processor time. */
			vTaskDelay( priSLEEP_TIME );
 1002abc:	01002004 	movi	r4,128
 1002ac0:	10058ec0 	call	10058ec <vTaskDelay>

			/* Check the shared variable again.  This time to ensure mutual
			exclusion the whole scheduler will be locked.  This is just for
			demo purposes! */
			vTaskSuspendAll();
 1002ac4:	1005f9c0 	call	1005f9c <vTaskSuspendAll>
			{
				if( ulLastCounter == ulCounter )
 1002ac8:	d0a06217 	ldw	r2,-32376(gp)
 1002acc:	e0fffe17 	ldw	r3,-8(fp)
 1002ad0:	1880021e 	bne	r3,r2,1002adc <vCounterControlTask+0x64>
				{
					/* The shared variable has not changed.  There is a problem
					with the continuous count task so flag an error. */
					sError = pdTRUE;
 1002ad4:	00800044 	movi	r2,1
 1002ad8:	e0bffd8d 	sth	r2,-10(fp)
				}
			}
			xTaskResumeAll();
 1002adc:	1005fc80 	call	1005fc8 <xTaskResumeAll>
		ulCounter = ( uint32_t ) 0;

		/* First section : */

		/* Check the continuous count task is running. */
		for( sLoops = 0; sLoops < priLOOPS; sLoops++ )
 1002ae0:	e0bffd0b 	ldhu	r2,-12(fp)
 1002ae4:	10800044 	addi	r2,r2,1
 1002ae8:	e0bffd0d 	sth	r2,-12(fp)
 1002aec:	e0bffd0f 	ldh	r2,-12(fp)
 1002af0:	10800150 	cmplti	r2,r2,5
 1002af4:	103fe91e 	bne	r2,zero,1002a9c <__alt_data_end+0xff802a9c>

		/* Second section: */

		/* Suspend the continuous counter task so it stops accessing the shared
		variable. */
		vTaskSuspend( xContinuousIncrementHandle );
 1002af8:	d0a06017 	ldw	r2,-32384(gp)
 1002afc:	1009883a 	mov	r4,r2
 1002b00:	1005ba40 	call	1005ba4 <vTaskSuspend>

		/* Reset the variable. */
		ulCounter = ( uint32_t ) 0;
 1002b04:	d0206215 	stw	zero,-32376(gp)
		#endif /* INCLUDE_eTaskGetState */

		/* Resume the limited count task which has a higher priority than us.
		We should therefore not return from this call until the limited count
		task has suspended itself with a known value in the counter variable. */
		vTaskResume( xLimitedIncrementHandle );
 1002b08:	d0a06117 	ldw	r2,-32380(gp)
 1002b0c:	1009883a 	mov	r4,r2
 1002b10:	1005d180 	call	1005d18 <vTaskResume>
			configASSERT( eTaskGetState( xLimitedIncrementHandle ) == eSuspended );
		}
		#endif /* INCLUDE_eTaskGetState */

		/* Does the counter variable have the expected value? */
		if( ulCounter != priMAX_COUNT )
 1002b14:	d0a06217 	ldw	r2,-32376(gp)
 1002b18:	10803fe0 	cmpeqi	r2,r2,255
 1002b1c:	1000021e 	bne	r2,zero,1002b28 <vCounterControlTask+0xb0>
		{
			sError = pdTRUE;
 1002b20:	00800044 	movi	r2,1
 1002b24:	e0bffd8d 	sth	r2,-10(fp)
		}

		if( sError == pdFALSE )
 1002b28:	e0bffd8f 	ldh	r2,-10(fp)
 1002b2c:	1000051e 	bne	r2,zero,1002b44 <vCounterControlTask+0xcc>
		{
			/* If no errors have occurred then increment the check variable. */
			portENTER_CRITICAL();
 1002b30:	1006d680 	call	1006d68 <vTaskEnterCritical>
				usCheckVariable++;
 1002b34:	d0a0630b 	ldhu	r2,-32372(gp)
 1002b38:	10800044 	addi	r2,r2,1
 1002b3c:	d0a0630d 	sth	r2,-32372(gp)
			portEXIT_CRITICAL();
 1002b40:	1006dbc0 	call	1006dbc <vTaskExitCritical>
		}

		/* Resume the continuous count task and do it all again. */
		vTaskResume( xContinuousIncrementHandle );
 1002b44:	d0a06017 	ldw	r2,-32384(gp)
 1002b48:	1009883a 	mov	r4,r2
 1002b4c:	1005d180 	call	1005d18 <vTaskResume>

		#if( configUSE_PREEMPTION == 0 )
			taskYIELD();
		#endif
	}
 1002b50:	003fcf06 	br	1002a90 <__alt_data_end+0xff802a90>

01002b54 <vQueueSendWhenSuspendedTask>:
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vQueueSendWhenSuspendedTask, pvParameters )
{
 1002b54:	defffd04 	addi	sp,sp,-12
 1002b58:	dfc00215 	stw	ra,8(sp)
 1002b5c:	df000115 	stw	fp,4(sp)
 1002b60:	df000104 	addi	fp,sp,4
 1002b64:	e13fff15 	stw	r4,-4(fp)
	/* Just to stop warning messages. */
	( void ) pvParameters;

	for( ;; )
	{
		vTaskSuspendAll();
 1002b68:	1005f9c0 	call	1005f9c <vTaskSuspendAll>
		{
			/* We must not block while the scheduler is suspended! */
			if( xQueueSend( xSuspendedTestQueue, ( void * ) &ulValueToSend, priNO_BLOCK ) != pdTRUE )
 1002b6c:	d0a06a17 	ldw	r2,-32344(gp)
 1002b70:	000f883a 	mov	r7,zero
 1002b74:	000d883a 	mov	r6,zero
 1002b78:	d1606704 	addi	r5,gp,-32356
 1002b7c:	1009883a 	mov	r4,r2
 1002b80:	10047080 	call	1004708 <xQueueGenericSend>
 1002b84:	10800060 	cmpeqi	r2,r2,1
 1002b88:	1000021e 	bne	r2,zero,1002b94 <vQueueSendWhenSuspendedTask+0x40>
			{
				xSuspendedQueueSendError = pdTRUE;
 1002b8c:	00800044 	movi	r2,1
 1002b90:	d0a06415 	stw	r2,-32368(gp)
			}
		}
		xTaskResumeAll();
 1002b94:	1005fc80 	call	1005fc8 <xTaskResumeAll>

		vTaskDelay( priSLEEP_TIME );
 1002b98:	01002004 	movi	r4,128
 1002b9c:	10058ec0 	call	10058ec <vTaskDelay>

		++ulValueToSend;
 1002ba0:	d0a06717 	ldw	r2,-32356(gp)
 1002ba4:	10800044 	addi	r2,r2,1
 1002ba8:	d0a06715 	stw	r2,-32356(gp)
	}
 1002bac:	003fee06 	br	1002b68 <__alt_data_end+0xff802b68>

01002bb0 <vQueueReceiveWhenSuspendedTask>:
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vQueueReceiveWhenSuspendedTask, pvParameters )
{
 1002bb0:	defffb04 	addi	sp,sp,-20
 1002bb4:	dfc00415 	stw	ra,16(sp)
 1002bb8:	df000315 	stw	fp,12(sp)
 1002bbc:	df000304 	addi	fp,sp,12
 1002bc0:	e13fff15 	stw	r4,-4(fp)
			/* Suspending the scheduler here is fairly pointless and
			undesirable for a normal application.  It is done here purely
			to test the scheduler.  The inner xTaskResumeAll() should
			never return pdTRUE as the scheduler is still locked by the
			outer call. */
			vTaskSuspendAll();
 1002bc4:	1005f9c0 	call	1005f9c <vTaskSuspendAll>
			{
				vTaskSuspendAll();
 1002bc8:	1005f9c0 	call	1005f9c <vTaskSuspendAll>
				{
					xGotValue = xQueueReceive( xSuspendedTestQueue, ( void * ) &ulReceivedValue, priNO_BLOCK );
 1002bcc:	d0a06a17 	ldw	r2,-32344(gp)
 1002bd0:	e0fffe04 	addi	r3,fp,-8
 1002bd4:	000f883a 	mov	r7,zero
 1002bd8:	000d883a 	mov	r6,zero
 1002bdc:	180b883a 	mov	r5,r3
 1002be0:	1009883a 	mov	r4,r2
 1002be4:	1004a800 	call	1004a80 <xQueueGenericReceive>
 1002be8:	e0bffd15 	stw	r2,-12(fp)
				}
				if( xTaskResumeAll() != pdFALSE )
 1002bec:	1005fc80 	call	1005fc8 <xTaskResumeAll>
 1002bf0:	10000226 	beq	r2,zero,1002bfc <vQueueReceiveWhenSuspendedTask+0x4c>
				{
					xSuspendedQueueReceiveError = pdTRUE;
 1002bf4:	00800044 	movi	r2,1
 1002bf8:	d0a06515 	stw	r2,-32364(gp)
				}
			}
			xTaskResumeAll();
 1002bfc:	1005fc80 	call	1005fc8 <xTaskResumeAll>
			{
				taskYIELD();
			}
			#endif

		} while( xGotValue == pdFALSE );
 1002c00:	e0bffd17 	ldw	r2,-12(fp)
 1002c04:	103fef26 	beq	r2,zero,1002bc4 <__alt_data_end+0xff802bc4>

		if( ulReceivedValue != ulExpectedValue )
 1002c08:	e0fffe17 	ldw	r3,-8(fp)
 1002c0c:	d0a06617 	ldw	r2,-32360(gp)
 1002c10:	18800226 	beq	r3,r2,1002c1c <vQueueReceiveWhenSuspendedTask+0x6c>
		{
			xSuspendedQueueReceiveError = pdTRUE;
 1002c14:	00800044 	movi	r2,1
 1002c18:	d0a06515 	stw	r2,-32364(gp)
		}

		if( xSuspendedQueueReceiveError != pdTRUE )
 1002c1c:	d0a06517 	ldw	r2,-32364(gp)
 1002c20:	10800060 	cmpeqi	r2,r2,1
 1002c24:	103fe71e 	bne	r2,zero,1002bc4 <__alt_data_end+0xff802bc4>
		{
			/* Only increment the variable if an error has not occurred.  This
			allows xAreDynamicPriorityTasksStillRunning() to check for stalled
			tasks as well as explicit errors. */
			++ulExpectedValue;
 1002c28:	d0a06617 	ldw	r2,-32360(gp)
 1002c2c:	10800044 	addi	r2,r2,1
 1002c30:	d0a06615 	stw	r2,-32360(gp)
		}
	}
 1002c34:	003fe306 	br	1002bc4 <__alt_data_end+0xff802bc4>

01002c38 <xAreDynamicPriorityTasksStillRunning>:
}
/*-----------------------------------------------------------*/

/* Called to check that all the created tasks are still running without error. */
BaseType_t xAreDynamicPriorityTasksStillRunning( void )
{
 1002c38:	defffe04 	addi	sp,sp,-8
 1002c3c:	df000115 	stw	fp,4(sp)
 1002c40:	df000104 	addi	fp,sp,4
/* Keep a history of the check variables so we know if it has been incremented
since the last call. */
static uint16_t usLastTaskCheck = ( uint16_t ) 0;
static uint32_t ulLastExpectedValue = ( uint32_t ) 0U;
BaseType_t xReturn = pdTRUE;
 1002c44:	00800044 	movi	r2,1
 1002c48:	e0bfff15 	stw	r2,-4(fp)

	/* Check the tasks are still running by ensuring the check variable
	is still incrementing. */

	if( usCheckVariable == usLastTaskCheck )
 1002c4c:	d0e0630b 	ldhu	r3,-32372(gp)
 1002c50:	d0a0680b 	ldhu	r2,-32352(gp)
 1002c54:	18ffffcc 	andi	r3,r3,65535
 1002c58:	10bfffcc 	andi	r2,r2,65535
 1002c5c:	1880011e 	bne	r3,r2,1002c64 <xAreDynamicPriorityTasksStillRunning+0x2c>
	{
		/* The check has not incremented so an error exists. */
		xReturn = pdFALSE;
 1002c60:	e03fff15 	stw	zero,-4(fp)
	}

	if( ulExpectedValue == ulLastExpectedValue )
 1002c64:	d0e06617 	ldw	r3,-32360(gp)
 1002c68:	d0a06917 	ldw	r2,-32348(gp)
 1002c6c:	1880011e 	bne	r3,r2,1002c74 <xAreDynamicPriorityTasksStillRunning+0x3c>
	{
		/* The value being received by the queue receive task has not
		incremented so an error exists. */
		xReturn = pdFALSE;
 1002c70:	e03fff15 	stw	zero,-4(fp)
	}

	if( xSuspendedQueueSendError == pdTRUE )
 1002c74:	d0a06417 	ldw	r2,-32368(gp)
 1002c78:	10800058 	cmpnei	r2,r2,1
 1002c7c:	1000011e 	bne	r2,zero,1002c84 <xAreDynamicPriorityTasksStillRunning+0x4c>
	{
		xReturn = pdFALSE;
 1002c80:	e03fff15 	stw	zero,-4(fp)
	}

	if( xSuspendedQueueReceiveError == pdTRUE )
 1002c84:	d0a06517 	ldw	r2,-32364(gp)
 1002c88:	10800058 	cmpnei	r2,r2,1
 1002c8c:	1000011e 	bne	r2,zero,1002c94 <xAreDynamicPriorityTasksStillRunning+0x5c>
	{
		xReturn = pdFALSE;
 1002c90:	e03fff15 	stw	zero,-4(fp)
	}

	usLastTaskCheck = usCheckVariable;
 1002c94:	d0a0630b 	ldhu	r2,-32372(gp)
 1002c98:	d0a0680d 	sth	r2,-32352(gp)
	ulLastExpectedValue = ulExpectedValue;
 1002c9c:	d0a06617 	ldw	r2,-32360(gp)
 1002ca0:	d0a06915 	stw	r2,-32348(gp)

	return xReturn;
 1002ca4:	e0bfff17 	ldw	r2,-4(fp)
}
 1002ca8:	e037883a 	mov	sp,fp
 1002cac:	df000017 	ldw	fp,0(sp)
 1002cb0:	dec00104 	addi	sp,sp,4
 1002cb4:	f800283a 	ret

01002cb8 <vStartLEDFlashTasks>:
static portTASK_FUNCTION_PROTO( vLEDFlashTask, pvParameters );

/*-----------------------------------------------------------*/

void vStartLEDFlashTasks( UBaseType_t uxPriority )
{
 1002cb8:	defffa04 	addi	sp,sp,-24
 1002cbc:	dfc00515 	stw	ra,20(sp)
 1002cc0:	df000415 	stw	fp,16(sp)
 1002cc4:	df000404 	addi	fp,sp,16
 1002cc8:	e13fff15 	stw	r4,-4(fp)
BaseType_t xLEDTask;

	/* Create the three tasks. */
	for( xLEDTask = 0; xLEDTask < ledNUMBER_OF_LEDS; ++xLEDTask )
 1002ccc:	e03ffe15 	stw	zero,-8(fp)
 1002cd0:	00000d06 	br	1002d08 <vStartLEDFlashTasks+0x50>
	{
		/* Spawn the task. */
		xTaskCreate( vLEDFlashTask, "LEDx", ledSTACK_SIZE, NULL, uxPriority, ( TaskHandle_t * ) NULL );
 1002cd4:	d8000115 	stw	zero,4(sp)
 1002cd8:	e0bfff17 	ldw	r2,-4(fp)
 1002cdc:	d8800015 	stw	r2,0(sp)
 1002ce0:	000f883a 	mov	r7,zero
 1002ce4:	01810004 	movi	r6,1024
 1002ce8:	014040b4 	movhi	r5,258
 1002cec:	296a0c04 	addi	r5,r5,-22480
 1002cf0:	01004034 	movhi	r4,256
 1002cf4:	210b4b04 	addi	r4,r4,11564
 1002cf8:	10053600 	call	1005360 <xTaskCreate>
void vStartLEDFlashTasks( UBaseType_t uxPriority )
{
BaseType_t xLEDTask;

	/* Create the three tasks. */
	for( xLEDTask = 0; xLEDTask < ledNUMBER_OF_LEDS; ++xLEDTask )
 1002cfc:	e0bffe17 	ldw	r2,-8(fp)
 1002d00:	10800044 	addi	r2,r2,1
 1002d04:	e0bffe15 	stw	r2,-8(fp)
 1002d08:	e0bffe17 	ldw	r2,-8(fp)
 1002d0c:	108000d0 	cmplti	r2,r2,3
 1002d10:	103ff01e 	bne	r2,zero,1002cd4 <__alt_data_end+0xff802cd4>
	{
		/* Spawn the task. */
		xTaskCreate( vLEDFlashTask, "LEDx", ledSTACK_SIZE, NULL, uxPriority, ( TaskHandle_t * ) NULL );
	}
}
 1002d14:	0001883a 	nop
 1002d18:	e037883a 	mov	sp,fp
 1002d1c:	dfc00117 	ldw	ra,4(sp)
 1002d20:	df000017 	ldw	fp,0(sp)
 1002d24:	dec00204 	addi	sp,sp,8
 1002d28:	f800283a 	ret

01002d2c <vLEDFlashTask>:
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vLEDFlashTask, pvParameters )
{
 1002d2c:	defffa04 	addi	sp,sp,-24
 1002d30:	dfc00515 	stw	ra,20(sp)
 1002d34:	df000415 	stw	fp,16(sp)
 1002d38:	df000404 	addi	fp,sp,16
 1002d3c:	e13fff15 	stw	r4,-4(fp)

	/* The parameters are not used. */
	( void ) pvParameters;

	/* Calculate the LED and flash rate. */
	portENTER_CRITICAL();
 1002d40:	1006d680 	call	1006d68 <vTaskEnterCritical>
	{
		/* See which of the eight LED's we should use. */
		uxLED = uxFlashTaskNumber;
 1002d44:	d0a06b17 	ldw	r2,-32340(gp)
 1002d48:	e0bffc15 	stw	r2,-16(fp)

		/* Update so the next task uses the next LED. */
		uxFlashTaskNumber++;
 1002d4c:	d0a06b17 	ldw	r2,-32340(gp)
 1002d50:	10800044 	addi	r2,r2,1
 1002d54:	d0a06b15 	stw	r2,-32340(gp)
	}
	portEXIT_CRITICAL();
 1002d58:	1006dbc0 	call	1006dbc <vTaskExitCritical>

	xFlashRate = ledFLASH_RATE_BASE + ( ledFLASH_RATE_BASE * ( TickType_t ) uxLED );
 1002d5c:	e0bffc17 	ldw	r2,-16(fp)
 1002d60:	10800044 	addi	r2,r2,1
 1002d64:	10805364 	muli	r2,r2,333
 1002d68:	e0bffd15 	stw	r2,-12(fp)
	xFlashRate /= portTICK_PERIOD_MS;

	/* We will turn the LED on and off again in the delay period, so each
	delay is only half the total period. */
	xFlashRate /= ( TickType_t ) 2;
 1002d6c:	e0bffd17 	ldw	r2,-12(fp)
 1002d70:	1004d07a 	srli	r2,r2,1
 1002d74:	e0bffd15 	stw	r2,-12(fp)

	/* We need to initialise xLastFlashTime prior to the first call to 
	vTaskDelayUntil(). */
	xLastFlashTime = xTaskGetTickCount();
 1002d78:	10061200 	call	1006120 <xTaskGetTickCount>
 1002d7c:	e0bffe15 	stw	r2,-8(fp)

	for(;;)
	{
		/* Delay for half the flash period then turn the LED on. */
		vTaskDelayUntil( &xLastFlashTime, xFlashRate );
 1002d80:	e0bffe04 	addi	r2,fp,-8
 1002d84:	e17ffd17 	ldw	r5,-12(fp)
 1002d88:	1009883a 	mov	r4,r2
 1002d8c:	10057fc0 	call	10057fc <vTaskDelayUntil>
		vParTestToggleLED( uxLED );
 1002d90:	e13ffc17 	ldw	r4,-16(fp)
 1002d94:	10037b80 	call	10037b8 <vParTestToggleLED>

		/* Delay for half the flash period then turn the LED off. */
		vTaskDelayUntil( &xLastFlashTime, xFlashRate );
 1002d98:	e0bffe04 	addi	r2,fp,-8
 1002d9c:	e17ffd17 	ldw	r5,-12(fp)
 1002da0:	1009883a 	mov	r4,r2
 1002da4:	10057fc0 	call	10057fc <vTaskDelayUntil>
		vParTestToggleLED( uxLED );
 1002da8:	e13ffc17 	ldw	r4,-16(fp)
 1002dac:	10037b80 	call	10037b8 <vParTestToggleLED>
	}
 1002db0:	003ff306 	br	1002d80 <__alt_data_end+0xff802d80>

01002db4 <vStartIntegerMathTasks>:
static volatile BaseType_t xTaskCheck[ intgNUMBER_OF_TASKS ] = { ( BaseType_t ) pdFALSE };

/*-----------------------------------------------------------*/

void vStartIntegerMathTasks( UBaseType_t uxPriority )
{
 1002db4:	defffa04 	addi	sp,sp,-24
 1002db8:	dfc00515 	stw	ra,20(sp)
 1002dbc:	df000415 	stw	fp,16(sp)
 1002dc0:	df000404 	addi	fp,sp,16
 1002dc4:	e13fff15 	stw	r4,-4(fp)
short sTask;

	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
 1002dc8:	e03ffe0d 	sth	zero,-8(fp)
 1002dcc:	00001206 	br	1002e18 <vStartIntegerMathTasks+0x64>
	{
		xTaskCreate( vCompeteingIntMathTask, "IntMath", intgSTACK_SIZE, ( void * ) &( xTaskCheck[ sTask ] ), uxPriority, ( TaskHandle_t * ) NULL );
 1002dd0:	e0bffe0f 	ldh	r2,-8(fp)
 1002dd4:	1085883a 	add	r2,r2,r2
 1002dd8:	1087883a 	add	r3,r2,r2
 1002ddc:	d0a06c04 	addi	r2,gp,-32336
 1002de0:	1887883a 	add	r3,r3,r2
 1002de4:	d8000115 	stw	zero,4(sp)
 1002de8:	e0bfff17 	ldw	r2,-4(fp)
 1002dec:	d8800015 	stw	r2,0(sp)
 1002df0:	180f883a 	mov	r7,r3
 1002df4:	01810004 	movi	r6,1024
 1002df8:	014040b4 	movhi	r5,258
 1002dfc:	296a0e04 	addi	r5,r5,-22472
 1002e00:	01004034 	movhi	r4,256
 1002e04:	210b8e04 	addi	r4,r4,11832
 1002e08:	10053600 	call	1005360 <xTaskCreate>

void vStartIntegerMathTasks( UBaseType_t uxPriority )
{
short sTask;

	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
 1002e0c:	e0bffe0b 	ldhu	r2,-8(fp)
 1002e10:	10800044 	addi	r2,r2,1
 1002e14:	e0bffe0d 	sth	r2,-8(fp)
 1002e18:	e0bffe0f 	ldh	r2,-8(fp)
 1002e1c:	00bfec0e 	bge	zero,r2,1002dd0 <__alt_data_end+0xff802dd0>
	{
		xTaskCreate( vCompeteingIntMathTask, "IntMath", intgSTACK_SIZE, ( void * ) &( xTaskCheck[ sTask ] ), uxPriority, ( TaskHandle_t * ) NULL );
	}
}
 1002e20:	0001883a 	nop
 1002e24:	e037883a 	mov	sp,fp
 1002e28:	dfc00117 	ldw	ra,4(sp)
 1002e2c:	df000017 	ldw	fp,0(sp)
 1002e30:	dec00204 	addi	sp,sp,8
 1002e34:	f800283a 	ret

01002e38 <vCompeteingIntMathTask>:
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vCompeteingIntMathTask, pvParameters )
{
 1002e38:	defffa04 	addi	sp,sp,-24
 1002e3c:	dfc00515 	stw	ra,20(sp)
 1002e40:	df000415 	stw	fp,16(sp)
 1002e44:	df000404 	addi	fp,sp,16
 1002e48:	e13fff15 	stw	r4,-4(fp)
/* These variables are all effectively set to constants so they are volatile to
ensure the compiler does not just get rid of them. */
volatile long lValue;
short sError = pdFALSE;
 1002e4c:	e03ffc0d 	sth	zero,-16(fp)
volatile BaseType_t *pxTaskHasExecuted;

	/* Set a pointer to the variable we are going to set to true each
	iteration.  This is also a good test of the parameter passing mechanism
	within each port. */
	pxTaskHasExecuted = ( volatile BaseType_t * ) pvParameters;
 1002e50:	e0bfff17 	ldw	r2,-4(fp)
 1002e54:	e0bffd15 	stw	r2,-12(fp)
	/* Keep performing a calculation and checking the result against a constant. */
	for( ;; )
	{
		/* Perform the calculation.  This will store partial value in
		registers, resulting in a good test of the context switch mechanism. */
		lValue = intgCONST1;
 1002e58:	00801ec4 	movi	r2,123
 1002e5c:	e0bffe15 	stw	r2,-8(fp)
		lValue += intgCONST2;
 1002e60:	e0fffe17 	ldw	r3,-8(fp)
 1002e64:	00800134 	movhi	r2,4
 1002e68:	10a511c4 	addi	r2,r2,-27577
 1002e6c:	1885883a 	add	r2,r3,r2
 1002e70:	e0bffe15 	stw	r2,-8(fp)
			taskYIELD();
		}
		#endif

		/* Finish off the calculation. */
		lValue *= intgCONST3;
 1002e74:	e0bffe17 	ldw	r2,-8(fp)
 1002e78:	10bfff64 	muli	r2,r2,-3
 1002e7c:	e0bffe15 	stw	r2,-8(fp)
		lValue /= intgCONST4;
 1002e80:	e0bffe17 	ldw	r2,-8(fp)
 1002e84:	014001c4 	movi	r5,7
 1002e88:	1009883a 	mov	r4,r2
 1002e8c:	10096ac0 	call	10096ac <__divsi3>
 1002e90:	e0bffe15 	stw	r2,-8(fp)

		/* If the calculation is found to be incorrect we stop setting the 
		TaskHasExecuted variable so the check task can see an error has 
		occurred. */
		if( lValue != intgEXPECTED_ANSWER ) /*lint !e774 volatile used to prevent this being optimised out. */
 1002e94:	e0fffe17 	ldw	r3,-8(fp)
 1002e98:	00bfffb4 	movhi	r2,65534
 1002e9c:	109dc6c4 	addi	r2,r2,30491
 1002ea0:	18800226 	beq	r3,r2,1002eac <vCompeteingIntMathTask+0x74>
		{
			sError = pdTRUE;
 1002ea4:	00800044 	movi	r2,1
 1002ea8:	e0bffc0d 	sth	r2,-16(fp)
		}

		if( sError == pdFALSE )
 1002eac:	e0bffc0f 	ldh	r2,-16(fp)
 1002eb0:	103fe91e 	bne	r2,zero,1002e58 <__alt_data_end+0xff802e58>
		{
			/* We have not encountered any errors, so set the flag that show
			we are still executing.  This will be periodically cleared by
			the check task. */
			portENTER_CRITICAL();
 1002eb4:	1006d680 	call	1006d68 <vTaskEnterCritical>
				*pxTaskHasExecuted = pdTRUE;
 1002eb8:	e0bffd17 	ldw	r2,-12(fp)
 1002ebc:	00c00044 	movi	r3,1
 1002ec0:	10c00015 	stw	r3,0(r2)
			portEXIT_CRITICAL();
 1002ec4:	1006dbc0 	call	1006dbc <vTaskExitCritical>
		#if configUSE_PREEMPTION == 0
		{
			taskYIELD();
		}
		#endif
	}
 1002ec8:	003fe306 	br	1002e58 <__alt_data_end+0xff802e58>

01002ecc <xAreIntegerMathsTaskStillRunning>:
}
/*-----------------------------------------------------------*/

/* This is called to check that all the created tasks are still running. */
BaseType_t xAreIntegerMathsTaskStillRunning( void )
{
 1002ecc:	defffd04 	addi	sp,sp,-12
 1002ed0:	df000215 	stw	fp,8(sp)
 1002ed4:	df000204 	addi	fp,sp,8
BaseType_t xReturn = pdTRUE;
 1002ed8:	00800044 	movi	r2,1
 1002edc:	e0bffe15 	stw	r2,-8(fp)
short sTask;

	/* Check the maths tasks are still running by ensuring their check variables 
	are still being set to true. */
	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
 1002ee0:	e03fff0d 	sth	zero,-4(fp)
 1002ee4:	00001106 	br	1002f2c <xAreIntegerMathsTaskStillRunning+0x60>
	{
		if( xTaskCheck[ sTask ] == pdFALSE )
 1002ee8:	e0bfff0f 	ldh	r2,-4(fp)
 1002eec:	1085883a 	add	r2,r2,r2
 1002ef0:	1087883a 	add	r3,r2,r2
 1002ef4:	d0a06c04 	addi	r2,gp,-32336
 1002ef8:	1885883a 	add	r2,r3,r2
 1002efc:	10800017 	ldw	r2,0(r2)
 1002f00:	1000011e 	bne	r2,zero,1002f08 <xAreIntegerMathsTaskStillRunning+0x3c>
		{
			/* The check has not incremented so an error exists. */
			xReturn = pdFALSE;
 1002f04:	e03ffe15 	stw	zero,-8(fp)
		}

		/* Reset the check variable so we can tell if it has been set by
		the next time around. */
		xTaskCheck[ sTask ] = pdFALSE;
 1002f08:	e0bfff0f 	ldh	r2,-4(fp)
 1002f0c:	1085883a 	add	r2,r2,r2
 1002f10:	1087883a 	add	r3,r2,r2
 1002f14:	d0a06c04 	addi	r2,gp,-32336
 1002f18:	1885883a 	add	r2,r3,r2
 1002f1c:	10000015 	stw	zero,0(r2)
BaseType_t xReturn = pdTRUE;
short sTask;

	/* Check the maths tasks are still running by ensuring their check variables 
	are still being set to true. */
	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
 1002f20:	e0bfff0b 	ldhu	r2,-4(fp)
 1002f24:	10800044 	addi	r2,r2,1
 1002f28:	e0bfff0d 	sth	r2,-4(fp)
 1002f2c:	e0bfff0f 	ldh	r2,-4(fp)
 1002f30:	00bfed0e 	bge	zero,r2,1002ee8 <__alt_data_end+0xff802ee8>
		/* Reset the check variable so we can tell if it has been set by
		the next time around. */
		xTaskCheck[ sTask ] = pdFALSE;
	}

	return xReturn;
 1002f34:	e0bffe17 	ldw	r2,-8(fp)
}
 1002f38:	e037883a 	mov	sp,fp
 1002f3c:	df000017 	ldw	fp,0(sp)
 1002f40:	dec00104 	addi	sp,sp,4
 1002f44:	f800283a 	ret

01002f48 <vStartRecursiveMutexTasks>:
static TaskHandle_t xControllingTaskHandle, xBlockingTaskHandle;

/*-----------------------------------------------------------*/

void vStartRecursiveMutexTasks( void )
{
 1002f48:	defffc04 	addi	sp,sp,-16
 1002f4c:	dfc00315 	stw	ra,12(sp)
 1002f50:	df000215 	stw	fp,8(sp)
 1002f54:	df000204 	addi	fp,sp,8
	/* Just creates the mutex and the three tasks. */

	xMutex = xSemaphoreCreateRecursiveMutex();
 1002f58:	01000104 	movi	r4,4
 1002f5c:	10045200 	call	1004520 <xQueueCreateMutex>
 1002f60:	d0a06d15 	stw	r2,-32332(gp)

	if( xMutex != NULL )
 1002f64:	d0a06d17 	ldw	r2,-32332(gp)
 1002f68:	10001f26 	beq	r2,zero,1002fe8 <vStartRecursiveMutexTasks+0xa0>
		is not being used.  The call to vQueueAddToRegistry() will be removed
		by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is
		defined to be less than 1. */
		vQueueAddToRegistry( ( QueueHandle_t ) xMutex, "Recursive_Mutex" );

		xTaskCreate( prvRecursiveMutexControllingTask, "Rec1", configMINIMAL_STACK_SIZE, NULL, recmuCONTROLLING_TASK_PRIORITY, &xControllingTaskHandle );
 1002f6c:	d0a07404 	addi	r2,gp,-32304
 1002f70:	d8800115 	stw	r2,4(sp)
 1002f74:	00800084 	movi	r2,2
 1002f78:	d8800015 	stw	r2,0(sp)
 1002f7c:	000f883a 	mov	r7,zero
 1002f80:	01810004 	movi	r6,1024
 1002f84:	014040b4 	movhi	r5,258
 1002f88:	296a1004 	addi	r5,r5,-22464
 1002f8c:	01004034 	movhi	r4,256
 1002f90:	210c0004 	addi	r4,r4,12288
 1002f94:	10053600 	call	1005360 <xTaskCreate>
		xTaskCreate( prvRecursiveMutexBlockingTask, "Rec2", configMINIMAL_STACK_SIZE, NULL, recmuBLOCKING_TASK_PRIORITY, &xBlockingTaskHandle );
 1002f98:	d0a07504 	addi	r2,gp,-32300
 1002f9c:	d8800115 	stw	r2,4(sp)
 1002fa0:	00800044 	movi	r2,1
 1002fa4:	d8800015 	stw	r2,0(sp)
 1002fa8:	000f883a 	mov	r7,zero
 1002fac:	01810004 	movi	r6,1024
 1002fb0:	014040b4 	movhi	r5,258
 1002fb4:	296a1204 	addi	r5,r5,-22456
 1002fb8:	01004034 	movhi	r4,256
 1002fbc:	210c3f04 	addi	r4,r4,12540
 1002fc0:	10053600 	call	1005360 <xTaskCreate>
		xTaskCreate( prvRecursiveMutexPollingTask, "Rec3", configMINIMAL_STACK_SIZE, NULL, recmuPOLLING_TASK_PRIORITY, NULL );
 1002fc4:	d8000115 	stw	zero,4(sp)
 1002fc8:	d8000015 	stw	zero,0(sp)
 1002fcc:	000f883a 	mov	r7,zero
 1002fd0:	01810004 	movi	r6,1024
 1002fd4:	014040b4 	movhi	r5,258
 1002fd8:	296a1404 	addi	r5,r5,-22448
 1002fdc:	01004034 	movhi	r4,256
 1002fe0:	210c6904 	addi	r4,r4,12708
 1002fe4:	10053600 	call	1005360 <xTaskCreate>
	}
}
 1002fe8:	0001883a 	nop
 1002fec:	e037883a 	mov	sp,fp
 1002ff0:	dfc00117 	ldw	ra,4(sp)
 1002ff4:	df000017 	ldw	fp,0(sp)
 1002ff8:	dec00204 	addi	sp,sp,8
 1002ffc:	f800283a 	ret

01003000 <prvRecursiveMutexControllingTask>:
/*-----------------------------------------------------------*/

static void prvRecursiveMutexControllingTask( void *pvParameters )
{
 1003000:	defffc04 	addi	sp,sp,-16
 1003004:	dfc00315 	stw	ra,12(sp)
 1003008:	df000215 	stw	fp,8(sp)
 100300c:	df000204 	addi	fp,sp,8
 1003010:	e13fff15 	stw	r4,-4(fp)
	{
		/* Should not be able to 'give' the mutex, as we have not yet 'taken'
		it.   The first time through, the mutex will not have been used yet,
		subsequent times through, at this point the mutex will be held by the
		polling task. */
		if( xSemaphoreGiveRecursive( xMutex ) == pdPASS )
 1003014:	d0a06d17 	ldw	r2,-32332(gp)
 1003018:	1009883a 	mov	r4,r2
 100301c:	100457c0 	call	100457c <xQueueGiveMutexRecursive>
 1003020:	10800058 	cmpnei	r2,r2,1
 1003024:	1000021e 	bne	r2,zero,1003030 <prvRecursiveMutexControllingTask+0x30>
		{
			xErrorOccurred = pdTRUE;
 1003028:	00800044 	movi	r2,1
 100302c:	d0a06e15 	stw	r2,-32328(gp)
		}

		for( ux = 0; ux < recmuMAX_COUNT; ux++ )
 1003030:	e03ffe15 	stw	zero,-8(fp)
 1003034:	00000d06 	br	100306c <prvRecursiveMutexControllingTask+0x6c>
			at this point and this Take will cause the polling task to inherit
			the priority of this task.  In this case the block time must be
			long enough to ensure the polling task will execute again before the
			block time expires.  If the block time does expire then the error
			flag will be set here. */
			if( xSemaphoreTakeRecursive( xMutex, recmu15ms_DELAY ) != pdPASS )
 1003038:	d0a06d17 	ldw	r2,-32332(gp)
 100303c:	014003c4 	movi	r5,15
 1003040:	1009883a 	mov	r4,r2
 1003044:	100460c0 	call	100460c <xQueueTakeMutexRecursive>
 1003048:	10800060 	cmpeqi	r2,r2,1
 100304c:	1000021e 	bne	r2,zero,1003058 <prvRecursiveMutexControllingTask+0x58>
			{
				xErrorOccurred = pdTRUE;
 1003050:	00800044 	movi	r2,1
 1003054:	d0a06e15 	stw	r2,-32328(gp)

			/* Ensure the other task attempting to access the mutex (and the
			other demo tasks) are able to execute to ensure they either block
			(where a block time is specified) or return an error (where no
			block time is specified) as the mutex is held by this task. */
			vTaskDelay( recmuSHORT_DELAY );
 1003058:	01000504 	movi	r4,20
 100305c:	10058ec0 	call	10058ec <vTaskDelay>
		if( xSemaphoreGiveRecursive( xMutex ) == pdPASS )
		{
			xErrorOccurred = pdTRUE;
		}

		for( ux = 0; ux < recmuMAX_COUNT; ux++ )
 1003060:	e0bffe17 	ldw	r2,-8(fp)
 1003064:	10800044 	addi	r2,r2,1
 1003068:	e0bffe15 	stw	r2,-8(fp)
 100306c:	e0bffe17 	ldw	r2,-8(fp)
 1003070:	108002b0 	cmpltui	r2,r2,10
 1003074:	103ff01e 	bne	r2,zero,1003038 <__alt_data_end+0xff803038>
			block time is specified) as the mutex is held by this task. */
			vTaskDelay( recmuSHORT_DELAY );
		}

		/* For each time we took the mutex, give it back. */
		for( ux = 0; ux < recmuMAX_COUNT; ux++ )
 1003078:	e03ffe15 	stw	zero,-8(fp)
 100307c:	00000c06 	br	10030b0 <prvRecursiveMutexControllingTask+0xb0>
		{
			/* Ensure the other task attempting to access the mutex (and the
			other demo tasks) are able to execute. */
			vTaskDelay( recmuSHORT_DELAY );
 1003080:	01000504 	movi	r4,20
 1003084:	10058ec0 	call	10058ec <vTaskDelay>
			/* We should now be able to give the mutex as many times as we
			took it.  When the mutex is available again the Blocking task
			should be unblocked but not run because it has a lower priority
			than this task.  The polling task should also not run at this point
			as it too has a lower priority than this task. */
			if( xSemaphoreGiveRecursive( xMutex ) != pdPASS )
 1003088:	d0a06d17 	ldw	r2,-32332(gp)
 100308c:	1009883a 	mov	r4,r2
 1003090:	100457c0 	call	100457c <xQueueGiveMutexRecursive>
 1003094:	10800060 	cmpeqi	r2,r2,1
 1003098:	1000021e 	bne	r2,zero,10030a4 <prvRecursiveMutexControllingTask+0xa4>
			{
				xErrorOccurred = pdTRUE;
 100309c:	00800044 	movi	r2,1
 10030a0:	d0a06e15 	stw	r2,-32328(gp)
			block time is specified) as the mutex is held by this task. */
			vTaskDelay( recmuSHORT_DELAY );
		}

		/* For each time we took the mutex, give it back. */
		for( ux = 0; ux < recmuMAX_COUNT; ux++ )
 10030a4:	e0bffe17 	ldw	r2,-8(fp)
 10030a8:	10800044 	addi	r2,r2,1
 10030ac:	e0bffe15 	stw	r2,-8(fp)
 10030b0:	e0bffe17 	ldw	r2,-8(fp)
 10030b4:	108002b0 	cmpltui	r2,r2,10
 10030b8:	103ff11e 	bne	r2,zero,1003080 <__alt_data_end+0xff803080>
			#endif
		}

		/* Having given it back the same number of times as it was taken, we
		should no longer be the mutex owner, so the next give should fail. */
		if( xSemaphoreGiveRecursive( xMutex ) == pdPASS )
 10030bc:	d0a06d17 	ldw	r2,-32332(gp)
 10030c0:	1009883a 	mov	r4,r2
 10030c4:	100457c0 	call	100457c <xQueueGiveMutexRecursive>
 10030c8:	10800058 	cmpnei	r2,r2,1
 10030cc:	1000021e 	bne	r2,zero,10030d8 <prvRecursiveMutexControllingTask+0xd8>
		{
			xErrorOccurred = pdTRUE;
 10030d0:	00800044 	movi	r2,1
 10030d4:	d0a06e15 	stw	r2,-32328(gp)
		}

		/* Keep count of the number of cycles this task has performed so a
		stall can be detected. */
		uxControllingCycles++;
 10030d8:	d0a07117 	ldw	r2,-32316(gp)
 10030dc:	10800044 	addi	r2,r2,1
 10030e0:	d0a07115 	stw	r2,-32316(gp)

		/* Suspend ourselves so the blocking task can execute. */
		xControllingIsSuspended = pdTRUE;
 10030e4:	00800044 	movi	r2,1
 10030e8:	d0a06f15 	stw	r2,-32324(gp)
		vTaskSuspend( NULL );
 10030ec:	0009883a 	mov	r4,zero
 10030f0:	1005ba40 	call	1005ba4 <vTaskSuspend>
		xControllingIsSuspended = pdFALSE;
 10030f4:	d0206f15 	stw	zero,-32324(gp)
	}
 10030f8:	003fc606 	br	1003014 <__alt_data_end+0xff803014>

010030fc <prvRecursiveMutexBlockingTask>:
}
/*-----------------------------------------------------------*/

static void prvRecursiveMutexBlockingTask( void *pvParameters )
{
 10030fc:	defffd04 	addi	sp,sp,-12
 1003100:	dfc00215 	stw	ra,8(sp)
 1003104:	df000115 	stw	fp,4(sp)
 1003108:	df000104 	addi	fp,sp,4
 100310c:	e13fff15 	stw	r4,-4(fp)
		this call should block until the controlling task has given up the
		mutex, and not actually execute	past this call until the controlling
		task is suspended.  portMAX_DELAY - 1 is used instead of portMAX_DELAY
		to ensure the task's state is reported as Blocked and not Suspended in
		a later call to configASSERT() (within the polling task). */
		if( xSemaphoreTakeRecursive( xMutex, ( portMAX_DELAY - 1 ) ) == pdPASS )
 1003110:	d0a06d17 	ldw	r2,-32332(gp)
 1003114:	017fff84 	movi	r5,-2
 1003118:	1009883a 	mov	r4,r2
 100311c:	100460c0 	call	100460c <xQueueTakeMutexRecursive>
 1003120:	10800058 	cmpnei	r2,r2,1
 1003124:	1000131e 	bne	r2,zero,1003174 <prvRecursiveMutexBlockingTask+0x78>
		{
			if( xControllingIsSuspended != pdTRUE )
 1003128:	d0a06f17 	ldw	r2,-32324(gp)
 100312c:	10800060 	cmpeqi	r2,r2,1
 1003130:	1000031e 	bne	r2,zero,1003140 <prvRecursiveMutexBlockingTask+0x44>
			{
				/* Did not expect to execute until the controlling task was
				suspended. */
				xErrorOccurred = pdTRUE;
 1003134:	00800044 	movi	r2,1
 1003138:	d0a06e15 	stw	r2,-32328(gp)
 100313c:	00000f06 	br	100317c <prvRecursiveMutexBlockingTask+0x80>
			}
			else
			{
				/* Give the mutex back before suspending ourselves to allow
				the polling task to obtain the mutex. */
				if( xSemaphoreGiveRecursive( xMutex ) != pdPASS )
 1003140:	d0a06d17 	ldw	r2,-32332(gp)
 1003144:	1009883a 	mov	r4,r2
 1003148:	100457c0 	call	100457c <xQueueGiveMutexRecursive>
 100314c:	10800060 	cmpeqi	r2,r2,1
 1003150:	1000021e 	bne	r2,zero,100315c <prvRecursiveMutexBlockingTask+0x60>
				{
					xErrorOccurred = pdTRUE;
 1003154:	00800044 	movi	r2,1
 1003158:	d0a06e15 	stw	r2,-32328(gp)
				}

				xBlockingIsSuspended = pdTRUE;
 100315c:	00800044 	movi	r2,1
 1003160:	d0a07015 	stw	r2,-32320(gp)
				vTaskSuspend( NULL );
 1003164:	0009883a 	mov	r4,zero
 1003168:	1005ba40 	call	1005ba4 <vTaskSuspend>
				xBlockingIsSuspended = pdFALSE;
 100316c:	d0207015 	stw	zero,-32320(gp)
 1003170:	00000206 	br	100317c <prvRecursiveMutexBlockingTask+0x80>
		}
		else
		{
			/* We should not leave the xSemaphoreTakeRecursive() function
			until the mutex was obtained. */
			xErrorOccurred = pdTRUE;
 1003174:	00800044 	movi	r2,1
 1003178:	d0a06e15 	stw	r2,-32328(gp)
		}

		/* The controlling and blocking tasks should be in lock step. */
		if( uxControllingCycles != ( uxBlockingCycles + 1 ) )
 100317c:	d0a07217 	ldw	r2,-32312(gp)
 1003180:	10c00044 	addi	r3,r2,1
 1003184:	d0a07117 	ldw	r2,-32316(gp)
 1003188:	18800226 	beq	r3,r2,1003194 <prvRecursiveMutexBlockingTask+0x98>
		{
			xErrorOccurred = pdTRUE;
 100318c:	00800044 	movi	r2,1
 1003190:	d0a06e15 	stw	r2,-32328(gp)
		}

		/* Keep count of the number of cycles this task has performed so a
		stall can be detected. */
		uxBlockingCycles++;
 1003194:	d0a07217 	ldw	r2,-32312(gp)
 1003198:	10800044 	addi	r2,r2,1
 100319c:	d0a07215 	stw	r2,-32312(gp)
	}
 10031a0:	003fdb06 	br	1003110 <__alt_data_end+0xff803110>

010031a4 <prvRecursiveMutexPollingTask>:
}
/*-----------------------------------------------------------*/

static void prvRecursiveMutexPollingTask( void *pvParameters )
{
 10031a4:	defffd04 	addi	sp,sp,-12
 10031a8:	dfc00215 	stw	ra,8(sp)
 10031ac:	df000115 	stw	fp,4(sp)
 10031b0:	df000104 	addi	fp,sp,4
 10031b4:	e13fff15 	stw	r4,-4(fp)
	for( ;; )
	{
		/* Keep attempting to obtain the mutex.  We should only obtain it when
		the blocking task has suspended itself, which in turn should only
		happen when the controlling task is also suspended. */
		if( xSemaphoreTakeRecursive( xMutex, recmuNO_DELAY ) == pdPASS )
 10031b8:	d0a06d17 	ldw	r2,-32332(gp)
 10031bc:	000b883a 	mov	r5,zero
 10031c0:	1009883a 	mov	r4,r2
 10031c4:	100460c0 	call	100460c <xQueueTakeMutexRecursive>
 10031c8:	10800058 	cmpnei	r2,r2,1
 10031cc:	103ffa1e 	bne	r2,zero,10031b8 <__alt_data_end+0xff8031b8>
				configASSERT( eTaskGetState( xBlockingTaskHandle ) == eSuspended );
			}
			#endif /* INCLUDE_eTaskGetState */

			/* Is the blocking task suspended? */
			if( ( xBlockingIsSuspended != pdTRUE ) || ( xControllingIsSuspended != pdTRUE ) )
 10031d0:	d0a07017 	ldw	r2,-32320(gp)
 10031d4:	10800058 	cmpnei	r2,r2,1
 10031d8:	1000031e 	bne	r2,zero,10031e8 <prvRecursiveMutexPollingTask+0x44>
 10031dc:	d0a06f17 	ldw	r2,-32324(gp)
 10031e0:	10800060 	cmpeqi	r2,r2,1
 10031e4:	1000031e 	bne	r2,zero,10031f4 <prvRecursiveMutexPollingTask+0x50>
			{
				xErrorOccurred = pdTRUE;
 10031e8:	00800044 	movi	r2,1
 10031ec:	d0a06e15 	stw	r2,-32328(gp)
 10031f0:	00001806 	br	1003254 <prvRecursiveMutexPollingTask+0xb0>
			}
			else
			{
				/* Keep count of the number of cycles this task has performed
				so a stall can be detected. */
				uxPollingCycles++;
 10031f4:	d0a07317 	ldw	r2,-32308(gp)
 10031f8:	10800044 	addi	r2,r2,1
 10031fc:	d0a07315 	stw	r2,-32308(gp)
				will then inherit the higher priority.  The Blocking task will
				block indefinitely when it attempts to obtain the mutex, the
				Controlling task will only block for a fixed period and an
				error will be latched if the polling task has not returned the
				mutex by the time this fixed period has expired. */
				vTaskResume( xBlockingTaskHandle );
 1003200:	d0a07517 	ldw	r2,-32300(gp)
 1003204:	1009883a 	mov	r4,r2
 1003208:	1005d180 	call	1005d18 <vTaskResume>
				#if( configUSE_PREEMPTION == 0 )
					taskYIELD();
				#endif

				vTaskResume( xControllingTaskHandle );
 100320c:	d0a07417 	ldw	r2,-32304(gp)
 1003210:	1009883a 	mov	r4,r2
 1003214:	1005d180 	call	1005d18 <vTaskResume>
					taskYIELD();
				#endif

				/* The other two tasks should now have executed and no longer
				be suspended. */
				if( ( xBlockingIsSuspended == pdTRUE ) || ( xControllingIsSuspended == pdTRUE ) )
 1003218:	d0a07017 	ldw	r2,-32320(gp)
 100321c:	10800060 	cmpeqi	r2,r2,1
 1003220:	1000031e 	bne	r2,zero,1003230 <prvRecursiveMutexPollingTask+0x8c>
 1003224:	d0a06f17 	ldw	r2,-32324(gp)
 1003228:	10800058 	cmpnei	r2,r2,1
 100322c:	1000021e 	bne	r2,zero,1003238 <prvRecursiveMutexPollingTask+0x94>
				{
					xErrorOccurred = pdTRUE;
 1003230:	00800044 	movi	r2,1
 1003234:	d0a06e15 	stw	r2,-32328(gp)
					configASSERT( eTaskGetState( xBlockingTaskHandle ) == eBlocked );
				}
				#endif /* INCLUDE_eTaskGetState */

				/* Release the mutex, disinheriting the higher priority again. */
				if( xSemaphoreGiveRecursive( xMutex ) != pdPASS )
 1003238:	d0a06d17 	ldw	r2,-32332(gp)
 100323c:	1009883a 	mov	r4,r2
 1003240:	100457c0 	call	100457c <xQueueGiveMutexRecursive>
 1003244:	10800060 	cmpeqi	r2,r2,1
 1003248:	103fdb1e 	bne	r2,zero,10031b8 <__alt_data_end+0xff8031b8>
				{
					xErrorOccurred = pdTRUE;
 100324c:	00800044 	movi	r2,1
 1003250:	d0a06e15 	stw	r2,-32328(gp)
		#if configUSE_PREEMPTION == 0
		{
			taskYIELD();
		}
		#endif
	}
 1003254:	003fd806 	br	10031b8 <__alt_data_end+0xff8031b8>

01003258 <xAreRecursiveMutexTasksStillRunning>:
}
/*-----------------------------------------------------------*/

/* This is called to check that all the created tasks are still running. */
BaseType_t xAreRecursiveMutexTasksStillRunning( void )
{
 1003258:	defffe04 	addi	sp,sp,-8
 100325c:	df000115 	stw	fp,4(sp)
 1003260:	df000104 	addi	fp,sp,4
BaseType_t xReturn;
static UBaseType_t uxLastControllingCycles = 0, uxLastBlockingCycles = 0, uxLastPollingCycles = 0;

	/* Is the controlling task still cycling? */
	if( uxLastControllingCycles == uxControllingCycles )
 1003264:	d0e07617 	ldw	r3,-32296(gp)
 1003268:	d0a07117 	ldw	r2,-32316(gp)
 100326c:	1880031e 	bne	r3,r2,100327c <xAreRecursiveMutexTasksStillRunning+0x24>
	{
		xErrorOccurred = pdTRUE;
 1003270:	00800044 	movi	r2,1
 1003274:	d0a06e15 	stw	r2,-32328(gp)
 1003278:	00000206 	br	1003284 <xAreRecursiveMutexTasksStillRunning+0x2c>
	}
	else
	{
		uxLastControllingCycles = uxControllingCycles;
 100327c:	d0a07117 	ldw	r2,-32316(gp)
 1003280:	d0a07615 	stw	r2,-32296(gp)
	}

	/* Is the blocking task still cycling? */
	if( uxLastBlockingCycles == uxBlockingCycles )
 1003284:	d0e07717 	ldw	r3,-32292(gp)
 1003288:	d0a07217 	ldw	r2,-32312(gp)
 100328c:	1880031e 	bne	r3,r2,100329c <xAreRecursiveMutexTasksStillRunning+0x44>
	{
		xErrorOccurred = pdTRUE;
 1003290:	00800044 	movi	r2,1
 1003294:	d0a06e15 	stw	r2,-32328(gp)
 1003298:	00000206 	br	10032a4 <xAreRecursiveMutexTasksStillRunning+0x4c>
	}
	else
	{
		uxLastBlockingCycles = uxBlockingCycles;
 100329c:	d0a07217 	ldw	r2,-32312(gp)
 10032a0:	d0a07715 	stw	r2,-32292(gp)
	}

	/* Is the polling task still cycling? */
	if( uxLastPollingCycles == uxPollingCycles )
 10032a4:	d0e07817 	ldw	r3,-32288(gp)
 10032a8:	d0a07317 	ldw	r2,-32308(gp)
 10032ac:	1880031e 	bne	r3,r2,10032bc <xAreRecursiveMutexTasksStillRunning+0x64>
	{
		xErrorOccurred = pdTRUE;
 10032b0:	00800044 	movi	r2,1
 10032b4:	d0a06e15 	stw	r2,-32328(gp)
 10032b8:	00000206 	br	10032c4 <xAreRecursiveMutexTasksStillRunning+0x6c>
	}
	else
	{
		uxLastPollingCycles = uxPollingCycles;
 10032bc:	d0a07317 	ldw	r2,-32308(gp)
 10032c0:	d0a07815 	stw	r2,-32288(gp)
	}

	if( xErrorOccurred == pdTRUE )
 10032c4:	d0a06e17 	ldw	r2,-32328(gp)
 10032c8:	10800058 	cmpnei	r2,r2,1
 10032cc:	1000021e 	bne	r2,zero,10032d8 <xAreRecursiveMutexTasksStillRunning+0x80>
	{
		xReturn = pdFAIL;
 10032d0:	e03fff15 	stw	zero,-4(fp)
 10032d4:	00000206 	br	10032e0 <xAreRecursiveMutexTasksStillRunning+0x88>
	}
	else
	{
		xReturn = pdPASS;
 10032d8:	00800044 	movi	r2,1
 10032dc:	e0bfff15 	stw	r2,-4(fp)
	}

	return xReturn;
 10032e0:	e0bfff17 	ldw	r2,-4(fp)
}
 10032e4:	e037883a 	mov	sp,fp
 10032e8:	df000017 	ldw	fp,0(sp)
 10032ec:	dec00104 	addi	sp,sp,4
 10032f0:	f800283a 	ret

010032f4 <vStartSemaphoreTasks>:
static volatile short sNextCheckVariable = 0;

/*-----------------------------------------------------------*/

void vStartSemaphoreTasks( UBaseType_t uxPriority )
{
 10032f4:	defff804 	addi	sp,sp,-32
 10032f8:	dfc00715 	stw	ra,28(sp)
 10032fc:	df000615 	stw	fp,24(sp)
 1003300:	df000604 	addi	fp,sp,24
 1003304:	e13fff15 	stw	r4,-4(fp)
xSemaphoreParameters *pxFirstSemaphoreParameters, *pxSecondSemaphoreParameters;
const TickType_t xBlockTime = ( TickType_t ) 100;
 1003308:	00801904 	movi	r2,100
 100330c:	e0bffc15 	stw	r2,-16(fp)

	/* Create the structure used to pass parameters to the first two tasks. */
	pxFirstSemaphoreParameters = ( xSemaphoreParameters * ) pvPortMalloc( sizeof( xSemaphoreParameters ) );
 1003310:	01000304 	movi	r4,12
 1003314:	1003f340 	call	1003f34 <pvPortMalloc>
 1003318:	e0bffd15 	stw	r2,-12(fp)

	if( pxFirstSemaphoreParameters != NULL )
 100331c:	e0bffd17 	ldw	r2,-12(fp)
 1003320:	10002e26 	beq	r2,zero,10033dc <vStartSemaphoreTasks+0xe8>
	{
		/* Create the semaphore used by the first two tasks. */
		pxFirstSemaphoreParameters->xSemaphore = xSemaphoreCreateBinary();		
 1003324:	018000c4 	movi	r6,3
 1003328:	000b883a 	mov	r5,zero
 100332c:	01000044 	movi	r4,1
 1003330:	100439c0 	call	100439c <xQueueGenericCreate>
 1003334:	1007883a 	mov	r3,r2
 1003338:	e0bffd17 	ldw	r2,-12(fp)
 100333c:	10c00015 	stw	r3,0(r2)

		if( pxFirstSemaphoreParameters->xSemaphore != NULL )
 1003340:	e0bffd17 	ldw	r2,-12(fp)
 1003344:	10800017 	ldw	r2,0(r2)
 1003348:	10002426 	beq	r2,zero,10033dc <vStartSemaphoreTasks+0xe8>
		{
			xSemaphoreGive( pxFirstSemaphoreParameters->xSemaphore );
 100334c:	e0bffd17 	ldw	r2,-12(fp)
 1003350:	10800017 	ldw	r2,0(r2)
 1003354:	000f883a 	mov	r7,zero
 1003358:	000d883a 	mov	r6,zero
 100335c:	000b883a 	mov	r5,zero
 1003360:	1009883a 	mov	r4,r2
 1003364:	10047080 	call	1004708 <xQueueGenericSend>
			
			/* Create the variable which is to be shared by the first two tasks. */
			pxFirstSemaphoreParameters->pulSharedVariable = ( uint32_t * ) pvPortMalloc( sizeof( uint32_t ) );
 1003368:	01000104 	movi	r4,4
 100336c:	1003f340 	call	1003f34 <pvPortMalloc>
 1003370:	1007883a 	mov	r3,r2
 1003374:	e0bffd17 	ldw	r2,-12(fp)
 1003378:	10c00115 	stw	r3,4(r2)

			/* Initialise the share variable to the value the tasks expect. */
			*( pxFirstSemaphoreParameters->pulSharedVariable ) = semtstNON_BLOCKING_EXPECTED_VALUE;
 100337c:	e0bffd17 	ldw	r2,-12(fp)
 1003380:	10800117 	ldw	r2,4(r2)
 1003384:	00c03fc4 	movi	r3,255
 1003388:	10c00015 	stw	r3,0(r2)

			/* The first two tasks do not block on semaphore calls. */
			pxFirstSemaphoreParameters->xBlockTime = ( TickType_t ) 0;
 100338c:	e0bffd17 	ldw	r2,-12(fp)
 1003390:	10000215 	stw	zero,8(r2)

			/* Spawn the first two tasks.  As they poll they operate at the idle priority. */
			xTaskCreate( prvSemaphoreTest, "PolSEM1", semtstSTACK_SIZE, ( void * ) pxFirstSemaphoreParameters, tskIDLE_PRIORITY, ( TaskHandle_t * ) NULL );
 1003394:	d8000115 	stw	zero,4(sp)
 1003398:	d8000015 	stw	zero,0(sp)
 100339c:	e1fffd17 	ldw	r7,-12(fp)
 10033a0:	01810004 	movi	r6,1024
 10033a4:	014040b4 	movhi	r5,258
 10033a8:	296a1604 	addi	r5,r5,-22440
 10033ac:	01004034 	movhi	r4,256
 10033b0:	210d3304 	addi	r4,r4,13516
 10033b4:	10053600 	call	1005360 <xTaskCreate>
			xTaskCreate( prvSemaphoreTest, "PolSEM2", semtstSTACK_SIZE, ( void * ) pxFirstSemaphoreParameters, tskIDLE_PRIORITY, ( TaskHandle_t * ) NULL );
 10033b8:	d8000115 	stw	zero,4(sp)
 10033bc:	d8000015 	stw	zero,0(sp)
 10033c0:	e1fffd17 	ldw	r7,-12(fp)
 10033c4:	01810004 	movi	r6,1024
 10033c8:	014040b4 	movhi	r5,258
 10033cc:	296a1804 	addi	r5,r5,-22432
 10033d0:	01004034 	movhi	r4,256
 10033d4:	210d3304 	addi	r4,r4,13516
 10033d8:	10053600 	call	1005360 <xTaskCreate>
		}
	}

	/* Do exactly the same to create the second set of tasks, only this time
	provide a block time for the semaphore calls. */
	pxSecondSemaphoreParameters = ( xSemaphoreParameters * ) pvPortMalloc( sizeof( xSemaphoreParameters ) );
 10033dc:	01000304 	movi	r4,12
 10033e0:	1003f340 	call	1003f34 <pvPortMalloc>
 10033e4:	e0bffe15 	stw	r2,-8(fp)
	if( pxSecondSemaphoreParameters != NULL )
 10033e8:	e0bffe17 	ldw	r2,-8(fp)
 10033ec:	10003126 	beq	r2,zero,10034b4 <vStartSemaphoreTasks+0x1c0>
	{
		pxSecondSemaphoreParameters->xSemaphore = xSemaphoreCreateBinary();		
 10033f0:	018000c4 	movi	r6,3
 10033f4:	000b883a 	mov	r5,zero
 10033f8:	01000044 	movi	r4,1
 10033fc:	100439c0 	call	100439c <xQueueGenericCreate>
 1003400:	1007883a 	mov	r3,r2
 1003404:	e0bffe17 	ldw	r2,-8(fp)
 1003408:	10c00015 	stw	r3,0(r2)

		if( pxSecondSemaphoreParameters->xSemaphore != NULL )
 100340c:	e0bffe17 	ldw	r2,-8(fp)
 1003410:	10800017 	ldw	r2,0(r2)
 1003414:	10002726 	beq	r2,zero,10034b4 <vStartSemaphoreTasks+0x1c0>
		{
			xSemaphoreGive( pxSecondSemaphoreParameters->xSemaphore );
 1003418:	e0bffe17 	ldw	r2,-8(fp)
 100341c:	10800017 	ldw	r2,0(r2)
 1003420:	000f883a 	mov	r7,zero
 1003424:	000d883a 	mov	r6,zero
 1003428:	000b883a 	mov	r5,zero
 100342c:	1009883a 	mov	r4,r2
 1003430:	10047080 	call	1004708 <xQueueGenericSend>
			
			pxSecondSemaphoreParameters->pulSharedVariable = ( uint32_t * ) pvPortMalloc( sizeof( uint32_t ) );
 1003434:	01000104 	movi	r4,4
 1003438:	1003f340 	call	1003f34 <pvPortMalloc>
 100343c:	1007883a 	mov	r3,r2
 1003440:	e0bffe17 	ldw	r2,-8(fp)
 1003444:	10c00115 	stw	r3,4(r2)
			*( pxSecondSemaphoreParameters->pulSharedVariable ) = semtstBLOCKING_EXPECTED_VALUE;
 1003448:	e0bffe17 	ldw	r2,-8(fp)
 100344c:	10800117 	ldw	r2,4(r2)
 1003450:	00c3ffc4 	movi	r3,4095
 1003454:	10c00015 	stw	r3,0(r2)
			pxSecondSemaphoreParameters->xBlockTime = xBlockTime / portTICK_PERIOD_MS;
 1003458:	e0bffe17 	ldw	r2,-8(fp)
 100345c:	e0fffc17 	ldw	r3,-16(fp)
 1003460:	10c00215 	stw	r3,8(r2)

			xTaskCreate( prvSemaphoreTest, "BlkSEM1", semtstSTACK_SIZE, ( void * ) pxSecondSemaphoreParameters, uxPriority, ( TaskHandle_t * ) NULL );
 1003464:	d8000115 	stw	zero,4(sp)
 1003468:	e0bfff17 	ldw	r2,-4(fp)
 100346c:	d8800015 	stw	r2,0(sp)
 1003470:	e1fffe17 	ldw	r7,-8(fp)
 1003474:	01810004 	movi	r6,1024
 1003478:	014040b4 	movhi	r5,258
 100347c:	296a1a04 	addi	r5,r5,-22424
 1003480:	01004034 	movhi	r4,256
 1003484:	210d3304 	addi	r4,r4,13516
 1003488:	10053600 	call	1005360 <xTaskCreate>
			xTaskCreate( prvSemaphoreTest, "BlkSEM2", semtstSTACK_SIZE, ( void * ) pxSecondSemaphoreParameters, uxPriority, ( TaskHandle_t * ) NULL );
 100348c:	d8000115 	stw	zero,4(sp)
 1003490:	e0bfff17 	ldw	r2,-4(fp)
 1003494:	d8800015 	stw	r2,0(sp)
 1003498:	e1fffe17 	ldw	r7,-8(fp)
 100349c:	01810004 	movi	r6,1024
 10034a0:	014040b4 	movhi	r5,258
 10034a4:	296a1c04 	addi	r5,r5,-22416
 10034a8:	01004034 	movhi	r4,256
 10034ac:	210d3304 	addi	r4,r4,13516
 10034b0:	10053600 	call	1005360 <xTaskCreate>
			be removed by the pre-processor if configQUEUE_REGISTRY_SIZE is not
			defined or is defined to be less than 1. */
			vQueueAddToRegistry( ( QueueHandle_t ) pxSecondSemaphoreParameters->xSemaphore, "Counting_Sem_2" );
		}
	}
}
 10034b4:	0001883a 	nop
 10034b8:	e037883a 	mov	sp,fp
 10034bc:	dfc00117 	ldw	ra,4(sp)
 10034c0:	df000017 	ldw	fp,0(sp)
 10034c4:	dec00204 	addi	sp,sp,8
 10034c8:	f800283a 	ret

010034cc <prvSemaphoreTest>:
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( prvSemaphoreTest, pvParameters )
{
 10034cc:	defff804 	addi	sp,sp,-32
 10034d0:	dfc00715 	stw	ra,28(sp)
 10034d4:	df000615 	stw	fp,24(sp)
 10034d8:	df000604 	addi	fp,sp,24
 10034dc:	e13fff15 	stw	r4,-4(fp)
xSemaphoreParameters *pxParameters;
volatile uint32_t *pulSharedVariable, ulExpectedValue;
uint32_t ulCounter;
short sError = pdFALSE, sCheckVariableToUse;
 10034e0:	e03ffb0d 	sth	zero,-20(fp)

	/* See which check variable to use.  sNextCheckVariable is not semaphore
	protected! */
	portENTER_CRITICAL();
 10034e4:	1006d680 	call	1006d68 <vTaskEnterCritical>
		sCheckVariableToUse = sNextCheckVariable;
 10034e8:	d0a07b0b 	ldhu	r2,-32276(gp)
 10034ec:	e0bffb8d 	sth	r2,-18(fp)
		sNextCheckVariable++;
 10034f0:	d0a07b0b 	ldhu	r2,-32276(gp)
 10034f4:	10800044 	addi	r2,r2,1
 10034f8:	d0a07b0d 	sth	r2,-32276(gp)
	portEXIT_CRITICAL();
 10034fc:	1006dbc0 	call	1006dbc <vTaskExitCritical>

	/* A structure is passed in as the parameter.  This contains the shared
	variable being guarded. */
	pxParameters = ( xSemaphoreParameters * ) pvParameters;
 1003500:	e0bfff17 	ldw	r2,-4(fp)
 1003504:	e0bffc15 	stw	r2,-16(fp)
	pulSharedVariable = pxParameters->pulSharedVariable;
 1003508:	e0bffc17 	ldw	r2,-16(fp)
 100350c:	10800117 	ldw	r2,4(r2)
 1003510:	e0bffd15 	stw	r2,-12(fp)

	/* If we are blocking we use a much higher count to ensure loads of context
	switches occur during the count. */
	if( pxParameters->xBlockTime > ( TickType_t ) 0 )
 1003514:	e0bffc17 	ldw	r2,-16(fp)
 1003518:	10800217 	ldw	r2,8(r2)
 100351c:	10000326 	beq	r2,zero,100352c <prvSemaphoreTest+0x60>
	{
		ulExpectedValue = semtstBLOCKING_EXPECTED_VALUE;
 1003520:	0083ffc4 	movi	r2,4095
 1003524:	e0bffe15 	stw	r2,-8(fp)
 1003528:	00000206 	br	1003534 <prvSemaphoreTest+0x68>
	}
	else
	{
		ulExpectedValue = semtstNON_BLOCKING_EXPECTED_VALUE;
 100352c:	00803fc4 	movi	r2,255
 1003530:	e0bffe15 	stw	r2,-8(fp)
	}

	for( ;; )
	{
		/* Try to obtain the semaphore. */
		if( xSemaphoreTake( pxParameters->xSemaphore, pxParameters->xBlockTime ) == pdPASS )
 1003534:	e0bffc17 	ldw	r2,-16(fp)
 1003538:	10c00017 	ldw	r3,0(r2)
 100353c:	e0bffc17 	ldw	r2,-16(fp)
 1003540:	10800217 	ldw	r2,8(r2)
 1003544:	000f883a 	mov	r7,zero
 1003548:	100d883a 	mov	r6,r2
 100354c:	000b883a 	mov	r5,zero
 1003550:	1809883a 	mov	r4,r3
 1003554:	1004a800 	call	1004a80 <xQueueGenericReceive>
 1003558:	10800058 	cmpnei	r2,r2,1
 100355c:	1000371e 	bne	r2,zero,100363c <prvSemaphoreTest+0x170>
		{
			/* We have the semaphore and so expect any other tasks using the
			shared variable to have left it in the state we expect to find
			it. */
			if( *pulSharedVariable != ulExpectedValue )
 1003560:	e0bffd17 	ldw	r2,-12(fp)
 1003564:	10c00017 	ldw	r3,0(r2)
 1003568:	e0bffe17 	ldw	r2,-8(fp)
 100356c:	18800226 	beq	r3,r2,1003578 <prvSemaphoreTest+0xac>
			{
				sError = pdTRUE;
 1003570:	00800044 	movi	r2,1
 1003574:	e0bffb0d 	sth	r2,-20(fp)
			}

			/* Clear the variable, then count it back up to the expected value
			before releasing the semaphore.  Would expect a context switch or
			two during this time. */
			for( ulCounter = ( uint32_t ) 0; ulCounter <= ulExpectedValue; ulCounter++ )
 1003578:	e03ffa15 	stw	zero,-24(fp)
 100357c:	00000c06 	br	10035b0 <prvSemaphoreTest+0xe4>
			{
				*pulSharedVariable = ulCounter;
 1003580:	e0bffd17 	ldw	r2,-12(fp)
 1003584:	e0fffa17 	ldw	r3,-24(fp)
 1003588:	10c00015 	stw	r3,0(r2)
				if( *pulSharedVariable != ulCounter )
 100358c:	e0bffd17 	ldw	r2,-12(fp)
 1003590:	10c00017 	ldw	r3,0(r2)
 1003594:	e0bffa17 	ldw	r2,-24(fp)
 1003598:	18800226 	beq	r3,r2,10035a4 <prvSemaphoreTest+0xd8>
				{
					sError = pdTRUE;
 100359c:	00800044 	movi	r2,1
 10035a0:	e0bffb0d 	sth	r2,-20(fp)
			}

			/* Clear the variable, then count it back up to the expected value
			before releasing the semaphore.  Would expect a context switch or
			two during this time. */
			for( ulCounter = ( uint32_t ) 0; ulCounter <= ulExpectedValue; ulCounter++ )
 10035a4:	e0bffa17 	ldw	r2,-24(fp)
 10035a8:	10800044 	addi	r2,r2,1
 10035ac:	e0bffa15 	stw	r2,-24(fp)
 10035b0:	e0fffe17 	ldw	r3,-8(fp)
 10035b4:	e0bffa17 	ldw	r2,-24(fp)
 10035b8:	18bff12e 	bgeu	r3,r2,1003580 <__alt_data_end+0xff803580>
				}
			}

			/* Release the semaphore, and if no errors have occurred increment the check
			variable. */
			if(	xSemaphoreGive( pxParameters->xSemaphore ) == pdFALSE )
 10035bc:	e0bffc17 	ldw	r2,-16(fp)
 10035c0:	10800017 	ldw	r2,0(r2)
 10035c4:	000f883a 	mov	r7,zero
 10035c8:	000d883a 	mov	r6,zero
 10035cc:	000b883a 	mov	r5,zero
 10035d0:	1009883a 	mov	r4,r2
 10035d4:	10047080 	call	1004708 <xQueueGenericSend>
 10035d8:	1000021e 	bne	r2,zero,10035e4 <prvSemaphoreTest+0x118>
			{
				sError = pdTRUE;
 10035dc:	00800044 	movi	r2,1
 10035e0:	e0bffb0d 	sth	r2,-20(fp)
			}

			if( sError == pdFALSE )
 10035e4:	e0bffb0f 	ldh	r2,-20(fp)
 10035e8:	10000e1e 	bne	r2,zero,1003624 <prvSemaphoreTest+0x158>
			{
				if( sCheckVariableToUse < semtstNUM_TASKS )
 10035ec:	e0bffb8f 	ldh	r2,-18(fp)
 10035f0:	10800108 	cmpgei	r2,r2,4
 10035f4:	10000b1e 	bne	r2,zero,1003624 <prvSemaphoreTest+0x158>
				{
					( sCheckVariables[ sCheckVariableToUse ] )++;
 10035f8:	e0bffb8f 	ldh	r2,-18(fp)
 10035fc:	1089883a 	add	r4,r2,r2
 1003600:	d0e07904 	addi	r3,gp,-32284
 1003604:	20c7883a 	add	r3,r4,r3
 1003608:	18c0000b 	ldhu	r3,0(r3)
 100360c:	18c00044 	addi	r3,r3,1
 1003610:	1809883a 	mov	r4,r3
 1003614:	1087883a 	add	r3,r2,r2
 1003618:	d0a07904 	addi	r2,gp,-32284
 100361c:	1885883a 	add	r2,r3,r2
 1003620:	1100000d 	sth	r4,0(r2)
			/* If we have a block time then we are running at a priority higher
			than the idle priority.  This task takes a long time to complete
			a cycle	(deliberately so to test the guarding) so will be starving
			out lower priority tasks.  Block for some time to allow give lower
			priority tasks some processor time. */
			vTaskDelay( pxParameters->xBlockTime * semtstDELAY_FACTOR );
 1003624:	e0bffc17 	ldw	r2,-16(fp)
 1003628:	10800217 	ldw	r2,8(r2)
 100362c:	108002a4 	muli	r2,r2,10
 1003630:	1009883a 	mov	r4,r2
 1003634:	10058ec0 	call	10058ec <vTaskDelay>
 1003638:	003fbe06 	br	1003534 <__alt_data_end+0xff803534>
		}
		else
		{
			if( pxParameters->xBlockTime == ( TickType_t ) 0 )
 100363c:	e0bffc17 	ldw	r2,-16(fp)
 1003640:	10800217 	ldw	r2,8(r2)
 1003644:	103fbb1e 	bne	r2,zero,1003534 <__alt_data_end+0xff803534>
			{
				/* We have not got the semaphore yet, so no point using the
				processor.  We are not blocking when attempting to obtain the
				semaphore. */
				taskYIELD();
 1003648:	003b683a 	trap	0
			}
		}
	}
 100364c:	003fb906 	br	1003534 <__alt_data_end+0xff803534>

01003650 <xAreSemaphoreTasksStillRunning>:
}
/*-----------------------------------------------------------*/

/* This is called to check that all the created tasks are still running. */
BaseType_t xAreSemaphoreTasksStillRunning( void )
{
 1003650:	defffd04 	addi	sp,sp,-12
 1003654:	df000215 	stw	fp,8(sp)
 1003658:	df000204 	addi	fp,sp,8
static short sLastCheckVariables[ semtstNUM_TASKS ] = { 0 };
BaseType_t xTask, xReturn = pdTRUE;
 100365c:	00800044 	movi	r2,1
 1003660:	e0bfff15 	stw	r2,-4(fp)

	for( xTask = 0; xTask < semtstNUM_TASKS; xTask++ )
 1003664:	e03ffe15 	stw	zero,-8(fp)
 1003668:	00001f06 	br	10036e8 <xAreSemaphoreTasksStillRunning+0x98>
	{
		if( sLastCheckVariables[ xTask ] == sCheckVariables[ xTask ] )
 100366c:	e0bffe17 	ldw	r2,-8(fp)
 1003670:	1087883a 	add	r3,r2,r2
 1003674:	d0a07b84 	addi	r2,gp,-32274
 1003678:	1885883a 	add	r2,r3,r2
 100367c:	1100000b 	ldhu	r4,0(r2)
 1003680:	e0bffe17 	ldw	r2,-8(fp)
 1003684:	1087883a 	add	r3,r2,r2
 1003688:	d0a07904 	addi	r2,gp,-32284
 100368c:	1885883a 	add	r2,r3,r2
 1003690:	1080000b 	ldhu	r2,0(r2)
 1003694:	20ffffcc 	andi	r3,r4,65535
 1003698:	18e0001c 	xori	r3,r3,32768
 100369c:	18e00004 	addi	r3,r3,-32768
 10036a0:	10bfffcc 	andi	r2,r2,65535
 10036a4:	10a0001c 	xori	r2,r2,32768
 10036a8:	10a00004 	addi	r2,r2,-32768
 10036ac:	1880011e 	bne	r3,r2,10036b4 <xAreSemaphoreTasksStillRunning+0x64>
		{
			xReturn = pdFALSE;
 10036b0:	e03fff15 	stw	zero,-4(fp)
		}

		sLastCheckVariables[ xTask ] = sCheckVariables[ xTask ];
 10036b4:	e0bffe17 	ldw	r2,-8(fp)
 10036b8:	1087883a 	add	r3,r2,r2
 10036bc:	d0a07904 	addi	r2,gp,-32284
 10036c0:	1885883a 	add	r2,r3,r2
 10036c4:	10c0000b 	ldhu	r3,0(r2)
 10036c8:	e0bffe17 	ldw	r2,-8(fp)
 10036cc:	1089883a 	add	r4,r2,r2
 10036d0:	d0a07b84 	addi	r2,gp,-32274
 10036d4:	2085883a 	add	r2,r4,r2
 10036d8:	10c0000d 	sth	r3,0(r2)
BaseType_t xAreSemaphoreTasksStillRunning( void )
{
static short sLastCheckVariables[ semtstNUM_TASKS ] = { 0 };
BaseType_t xTask, xReturn = pdTRUE;

	for( xTask = 0; xTask < semtstNUM_TASKS; xTask++ )
 10036dc:	e0bffe17 	ldw	r2,-8(fp)
 10036e0:	10800044 	addi	r2,r2,1
 10036e4:	e0bffe15 	stw	r2,-8(fp)
 10036e8:	e0bffe17 	ldw	r2,-8(fp)
 10036ec:	10800110 	cmplti	r2,r2,4
 10036f0:	103fde1e 	bne	r2,zero,100366c <__alt_data_end+0xff80366c>
		}

		sLastCheckVariables[ xTask ] = sCheckVariables[ xTask ];
	}

	return xReturn;
 10036f4:	e0bfff17 	ldw	r2,-4(fp)
}
 10036f8:	e037883a 	mov	sp,fp
 10036fc:	df000017 	ldw	fp,0(sp)
 1003700:	dec00104 	addi	sp,sp,4
 1003704:	f800283a 	ret

01003708 <vParTestInitialise>:
 **
 **     @param
 **
 */
/* ===================================================================*/
void vParTestInitialise(void) {
 1003708:	deffff04 	addi	sp,sp,-4
 100370c:	df000015 	stw	fp,0(sp)
 1003710:	d839883a 	mov	fp,sp
	//test IOWR_ALT_UP_PARALLEL_PORT_DIRECTION(LED_PIO_BASE, 0xFFFFFFFF);
	ulLedStates = 0;
 1003714:	d0207e15 	stw	zero,-32264(gp)
}
 1003718:	0001883a 	nop
 100371c:	e037883a 	mov	sp,fp
 1003720:	df000017 	ldw	fp,0(sp)
 1003724:	dec00104 	addi	sp,sp,4
 1003728:	f800283a 	ret

0100372c <vParTestSetLED>:
 **
 **     @param
 **
 */
/* ===================================================================*/
void vParTestSetLED(unsigned portBASE_TYPE uxLED, signed portBASE_TYPE xValue) {
 100372c:	defffc04 	addi	sp,sp,-16
 1003730:	dfc00315 	stw	ra,12(sp)
 1003734:	df000215 	stw	fp,8(sp)
 1003738:	df000204 	addi	fp,sp,8
 100373c:	e13ffe15 	stw	r4,-8(fp)
 1003740:	e17fff15 	stw	r5,-4(fp)
	if (uxLED < partstNUM_LEDS) {
 1003744:	e0bffe17 	ldw	r2,-8(fp)
 1003748:	10800228 	cmpgeui	r2,r2,8
 100374c:	1000141e 	bne	r2,zero,10037a0 <vParTestSetLED+0x74>
		taskENTER_CRITICAL();
 1003750:	1006d680 	call	1006d68 <vTaskEnterCritical>
		{
			if (xValue > 0) {
 1003754:	e0bfff17 	ldw	r2,-4(fp)
 1003758:	0080080e 	bge	zero,r2,100377c <vParTestSetLED+0x50>
				ulLedStates |= 1 << uxLED;
 100375c:	00c00044 	movi	r3,1
 1003760:	e0bffe17 	ldw	r2,-8(fp)
 1003764:	1884983a 	sll	r2,r3,r2
 1003768:	1007883a 	mov	r3,r2
 100376c:	d0a07e17 	ldw	r2,-32264(gp)
 1003770:	1884b03a 	or	r2,r3,r2
 1003774:	d0a07e15 	stw	r2,-32264(gp)
 1003778:	00000806 	br	100379c <vParTestSetLED+0x70>
			} else {
				ulLedStates &= ~(1 << uxLED);
 100377c:	00c00044 	movi	r3,1
 1003780:	e0bffe17 	ldw	r2,-8(fp)
 1003784:	1884983a 	sll	r2,r3,r2
 1003788:	0084303a 	nor	r2,zero,r2
 100378c:	1007883a 	mov	r3,r2
 1003790:	d0a07e17 	ldw	r2,-32264(gp)
 1003794:	1884703a 	and	r2,r3,r2
 1003798:	d0a07e15 	stw	r2,-32264(gp)
			}
			//test IOWR_ALT_UP_PARALLEL_PORT_DATA(LED_PIO_BASE, ulLedStates);
		}
		taskEXIT_CRITICAL();
 100379c:	1006dbc0 	call	1006dbc <vTaskExitCritical>
	}
}
 10037a0:	0001883a 	nop
 10037a4:	e037883a 	mov	sp,fp
 10037a8:	dfc00117 	ldw	ra,4(sp)
 10037ac:	df000017 	ldw	fp,0(sp)
 10037b0:	dec00204 	addi	sp,sp,8
 10037b4:	f800283a 	ret

010037b8 <vParTestToggleLED>:
 **
 **     @param
 **
 */
/* ===================================================================*/
void vParTestToggleLED(unsigned portBASE_TYPE uxLED) {
 10037b8:	defffd04 	addi	sp,sp,-12
 10037bc:	dfc00215 	stw	ra,8(sp)
 10037c0:	df000115 	stw	fp,4(sp)
 10037c4:	df000104 	addi	fp,sp,4
 10037c8:	e13fff15 	stw	r4,-4(fp)
	if (uxLED < partstNUM_LEDS) {
 10037cc:	e0bfff17 	ldw	r2,-4(fp)
 10037d0:	10800228 	cmpgeui	r2,r2,8
 10037d4:	10000d1e 	bne	r2,zero,100380c <vParTestToggleLED+0x54>
		taskENTER_CRITICAL();
 10037d8:	1006d680 	call	1006d68 <vTaskEnterCritical>
		{
			vParTestSetLED(uxLED, !(ulLedStates & (1 << uxLED)));
 10037dc:	00c00044 	movi	r3,1
 10037e0:	e0bfff17 	ldw	r2,-4(fp)
 10037e4:	1884983a 	sll	r2,r3,r2
 10037e8:	1007883a 	mov	r3,r2
 10037ec:	d0a07e17 	ldw	r2,-32264(gp)
 10037f0:	1884703a 	and	r2,r3,r2
 10037f4:	1005003a 	cmpeq	r2,r2,zero
 10037f8:	10803fcc 	andi	r2,r2,255
 10037fc:	100b883a 	mov	r5,r2
 1003800:	e13fff17 	ldw	r4,-4(fp)
 1003804:	100372c0 	call	100372c <vParTestSetLED>
		}
		taskEXIT_CRITICAL();
 1003808:	1006dbc0 	call	1006dbc <vTaskExitCritical>
	}
}
 100380c:	0001883a 	nop
 1003810:	e037883a 	mov	sp,fp
 1003814:	dfc00117 	ldw	ra,4(sp)
 1003818:	df000017 	ldw	fp,0(sp)
 100381c:	dec00204 	addi	sp,sp,8
 1003820:	f800283a 	ret

01003824 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
 1003824:	defffe04 	addi	sp,sp,-8
 1003828:	df000115 	stw	fp,4(sp)
 100382c:	df000104 	addi	fp,sp,4
 1003830:	e13fff15 	stw	r4,-4(fp)
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 1003834:	e0bfff17 	ldw	r2,-4(fp)
 1003838:	10c00204 	addi	r3,r2,8
 100383c:	e0bfff17 	ldw	r2,-4(fp)
 1003840:	10c00115 	stw	r3,4(r2)

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 1003844:	e0bfff17 	ldw	r2,-4(fp)
 1003848:	00ffffc4 	movi	r3,-1
 100384c:	10c00215 	stw	r3,8(r2)

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 1003850:	e0bfff17 	ldw	r2,-4(fp)
 1003854:	10c00204 	addi	r3,r2,8
 1003858:	e0bfff17 	ldw	r2,-4(fp)
 100385c:	10c00315 	stw	r3,12(r2)
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 1003860:	e0bfff17 	ldw	r2,-4(fp)
 1003864:	10c00204 	addi	r3,r2,8
 1003868:	e0bfff17 	ldw	r2,-4(fp)
 100386c:	10c00415 	stw	r3,16(r2)

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 1003870:	e0bfff17 	ldw	r2,-4(fp)
 1003874:	10000015 	stw	zero,0(r2)

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
 1003878:	0001883a 	nop
 100387c:	e037883a 	mov	sp,fp
 1003880:	df000017 	ldw	fp,0(sp)
 1003884:	dec00104 	addi	sp,sp,4
 1003888:	f800283a 	ret

0100388c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
 100388c:	defffe04 	addi	sp,sp,-8
 1003890:	df000115 	stw	fp,4(sp)
 1003894:	df000104 	addi	fp,sp,4
 1003898:	e13fff15 	stw	r4,-4(fp)
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 100389c:	e0bfff17 	ldw	r2,-4(fp)
 10038a0:	10000415 	stw	zero,16(r2)

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
 10038a4:	0001883a 	nop
 10038a8:	e037883a 	mov	sp,fp
 10038ac:	df000017 	ldw	fp,0(sp)
 10038b0:	dec00104 	addi	sp,sp,4
 10038b4:	f800283a 	ret

010038b8 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 10038b8:	defffc04 	addi	sp,sp,-16
 10038bc:	df000315 	stw	fp,12(sp)
 10038c0:	df000304 	addi	fp,sp,12
 10038c4:	e13ffe15 	stw	r4,-8(fp)
 10038c8:	e17fff15 	stw	r5,-4(fp)
ListItem_t * const pxIndex = pxList->pxIndex;
 10038cc:	e0bffe17 	ldw	r2,-8(fp)
 10038d0:	10800117 	ldw	r2,4(r2)
 10038d4:	e0bffd15 	stw	r2,-12(fp)
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 10038d8:	e0bfff17 	ldw	r2,-4(fp)
 10038dc:	e0fffd17 	ldw	r3,-12(fp)
 10038e0:	10c00115 	stw	r3,4(r2)
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 10038e4:	e0bffd17 	ldw	r2,-12(fp)
 10038e8:	10c00217 	ldw	r3,8(r2)
 10038ec:	e0bfff17 	ldw	r2,-4(fp)
 10038f0:	10c00215 	stw	r3,8(r2)

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 10038f4:	e0bffd17 	ldw	r2,-12(fp)
 10038f8:	10800217 	ldw	r2,8(r2)
 10038fc:	e0ffff17 	ldw	r3,-4(fp)
 1003900:	10c00115 	stw	r3,4(r2)
	pxIndex->pxPrevious = pxNewListItem;
 1003904:	e0bffd17 	ldw	r2,-12(fp)
 1003908:	e0ffff17 	ldw	r3,-4(fp)
 100390c:	10c00215 	stw	r3,8(r2)

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 1003910:	e0bfff17 	ldw	r2,-4(fp)
 1003914:	e0fffe17 	ldw	r3,-8(fp)
 1003918:	10c00415 	stw	r3,16(r2)

	( pxList->uxNumberOfItems )++;
 100391c:	e0bffe17 	ldw	r2,-8(fp)
 1003920:	10800017 	ldw	r2,0(r2)
 1003924:	10c00044 	addi	r3,r2,1
 1003928:	e0bffe17 	ldw	r2,-8(fp)
 100392c:	10c00015 	stw	r3,0(r2)
}
 1003930:	0001883a 	nop
 1003934:	e037883a 	mov	sp,fp
 1003938:	df000017 	ldw	fp,0(sp)
 100393c:	dec00104 	addi	sp,sp,4
 1003940:	f800283a 	ret

01003944 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 1003944:	defffb04 	addi	sp,sp,-20
 1003948:	df000415 	stw	fp,16(sp)
 100394c:	df000404 	addi	fp,sp,16
 1003950:	e13ffe15 	stw	r4,-8(fp)
 1003954:	e17fff15 	stw	r5,-4(fp)
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 1003958:	e0bfff17 	ldw	r2,-4(fp)
 100395c:	10800017 	ldw	r2,0(r2)
 1003960:	e0bffd15 	stw	r2,-12(fp)
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 1003964:	e0bffd17 	ldw	r2,-12(fp)
 1003968:	10bfffd8 	cmpnei	r2,r2,-1
 100396c:	1000041e 	bne	r2,zero,1003980 <vListInsert+0x3c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 1003970:	e0bffe17 	ldw	r2,-8(fp)
 1003974:	10800417 	ldw	r2,16(r2)
 1003978:	e0bffc15 	stw	r2,-16(fp)
 100397c:	00000c06 	br	10039b0 <vListInsert+0x6c>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 1003980:	e0bffe17 	ldw	r2,-8(fp)
 1003984:	10800204 	addi	r2,r2,8
 1003988:	e0bffc15 	stw	r2,-16(fp)
 100398c:	00000306 	br	100399c <vListInsert+0x58>
 1003990:	e0bffc17 	ldw	r2,-16(fp)
 1003994:	10800117 	ldw	r2,4(r2)
 1003998:	e0bffc15 	stw	r2,-16(fp)
 100399c:	e0bffc17 	ldw	r2,-16(fp)
 10039a0:	10800117 	ldw	r2,4(r2)
 10039a4:	10800017 	ldw	r2,0(r2)
 10039a8:	e0fffd17 	ldw	r3,-12(fp)
 10039ac:	18bff82e 	bgeu	r3,r2,1003990 <__alt_data_end+0xff803990>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 10039b0:	e0bffc17 	ldw	r2,-16(fp)
 10039b4:	10c00117 	ldw	r3,4(r2)
 10039b8:	e0bfff17 	ldw	r2,-4(fp)
 10039bc:	10c00115 	stw	r3,4(r2)
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 10039c0:	e0bfff17 	ldw	r2,-4(fp)
 10039c4:	10800117 	ldw	r2,4(r2)
 10039c8:	e0ffff17 	ldw	r3,-4(fp)
 10039cc:	10c00215 	stw	r3,8(r2)
	pxNewListItem->pxPrevious = pxIterator;
 10039d0:	e0bfff17 	ldw	r2,-4(fp)
 10039d4:	e0fffc17 	ldw	r3,-16(fp)
 10039d8:	10c00215 	stw	r3,8(r2)
	pxIterator->pxNext = pxNewListItem;
 10039dc:	e0bffc17 	ldw	r2,-16(fp)
 10039e0:	e0ffff17 	ldw	r3,-4(fp)
 10039e4:	10c00115 	stw	r3,4(r2)

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 10039e8:	e0bfff17 	ldw	r2,-4(fp)
 10039ec:	e0fffe17 	ldw	r3,-8(fp)
 10039f0:	10c00415 	stw	r3,16(r2)

	( pxList->uxNumberOfItems )++;
 10039f4:	e0bffe17 	ldw	r2,-8(fp)
 10039f8:	10800017 	ldw	r2,0(r2)
 10039fc:	10c00044 	addi	r3,r2,1
 1003a00:	e0bffe17 	ldw	r2,-8(fp)
 1003a04:	10c00015 	stw	r3,0(r2)
}
 1003a08:	0001883a 	nop
 1003a0c:	e037883a 	mov	sp,fp
 1003a10:	df000017 	ldw	fp,0(sp)
 1003a14:	dec00104 	addi	sp,sp,4
 1003a18:	f800283a 	ret

01003a1c <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
 1003a1c:	defffd04 	addi	sp,sp,-12
 1003a20:	df000215 	stw	fp,8(sp)
 1003a24:	df000204 	addi	fp,sp,8
 1003a28:	e13fff15 	stw	r4,-4(fp)
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 1003a2c:	e0bfff17 	ldw	r2,-4(fp)
 1003a30:	10800417 	ldw	r2,16(r2)
 1003a34:	e0bffe15 	stw	r2,-8(fp)

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 1003a38:	e0bfff17 	ldw	r2,-4(fp)
 1003a3c:	10800117 	ldw	r2,4(r2)
 1003a40:	e0ffff17 	ldw	r3,-4(fp)
 1003a44:	18c00217 	ldw	r3,8(r3)
 1003a48:	10c00215 	stw	r3,8(r2)
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 1003a4c:	e0bfff17 	ldw	r2,-4(fp)
 1003a50:	10800217 	ldw	r2,8(r2)
 1003a54:	e0ffff17 	ldw	r3,-4(fp)
 1003a58:	18c00117 	ldw	r3,4(r3)
 1003a5c:	10c00115 	stw	r3,4(r2)

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 1003a60:	e0bffe17 	ldw	r2,-8(fp)
 1003a64:	10c00117 	ldw	r3,4(r2)
 1003a68:	e0bfff17 	ldw	r2,-4(fp)
 1003a6c:	1880041e 	bne	r3,r2,1003a80 <uxListRemove+0x64>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 1003a70:	e0bfff17 	ldw	r2,-4(fp)
 1003a74:	10c00217 	ldw	r3,8(r2)
 1003a78:	e0bffe17 	ldw	r2,-8(fp)
 1003a7c:	10c00115 	stw	r3,4(r2)
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
 1003a80:	e0bfff17 	ldw	r2,-4(fp)
 1003a84:	10000415 	stw	zero,16(r2)
	( pxList->uxNumberOfItems )--;
 1003a88:	e0bffe17 	ldw	r2,-8(fp)
 1003a8c:	10800017 	ldw	r2,0(r2)
 1003a90:	10ffffc4 	addi	r3,r2,-1
 1003a94:	e0bffe17 	ldw	r2,-8(fp)
 1003a98:	10c00015 	stw	r3,0(r2)

	return pxList->uxNumberOfItems;
 1003a9c:	e0bffe17 	ldw	r2,-8(fp)
 1003aa0:	10800017 	ldw	r2,0(r2)
}
 1003aa4:	e037883a 	mov	sp,fp
 1003aa8:	df000017 	ldw	fp,0(sp)
 1003aac:	dec00104 	addi	sp,sp,4
 1003ab0:	f800283a 	ret

01003ab4 <prvReadGp>:
  void vPortSysTickHandler( void * context, alt_u32 id );
#endif
/*-----------------------------------------------------------*/

void prvReadGp( unsigned long *ulValue )
{
 1003ab4:	defffe04 	addi	sp,sp,-8
 1003ab8:	df000115 	stw	fp,4(sp)
 1003abc:	df000104 	addi	fp,sp,4
 1003ac0:	e13fff15 	stw	r4,-4(fp)
	asm( "stw gp, (r4) " );
 1003ac4:	26800015 	stw	gp,0(r4)
};
 1003ac8:	0001883a 	nop
 1003acc:	e037883a 	mov	sp,fp
 1003ad0:	df000017 	ldw	fp,0(sp)
 1003ad4:	dec00104 	addi	sp,sp,4
 1003ad8:	f800283a 	ret

01003adc <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
 1003adc:	defff904 	addi	sp,sp,-28
 1003ae0:	dfc00615 	stw	ra,24(sp)
 1003ae4:	df000515 	stw	fp,20(sp)
 1003ae8:	df000504 	addi	fp,sp,20
 1003aec:	e13ffd15 	stw	r4,-12(fp)
 1003af0:	e17ffe15 	stw	r5,-8(fp)
 1003af4:	e1bfff15 	stw	r6,-4(fp)
portSTACK_TYPE *pxFramePointer = pxTopOfStack - 1;
 1003af8:	e0bffd17 	ldw	r2,-12(fp)
 1003afc:	10bfff04 	addi	r2,r2,-4
 1003b00:	e0bffb15 	stw	r2,-20(fp)
portSTACK_TYPE xGlobalPointer;

    prvReadGp( &xGlobalPointer );
 1003b04:	e0bffc04 	addi	r2,fp,-16
 1003b08:	1009883a 	mov	r4,r2
 1003b0c:	1003ab40 	call	1003ab4 <prvReadGp>

    /* End of stack marker. */
    *pxTopOfStack = 0xdeadbeef;
 1003b10:	e0fffd17 	ldw	r3,-12(fp)
 1003b14:	00b7abb4 	movhi	r2,57006
 1003b18:	10afbbc4 	addi	r2,r2,-16657
 1003b1c:	18800015 	stw	r2,0(r3)
    pxTopOfStack--;
 1003b20:	e0bffd17 	ldw	r2,-12(fp)
 1003b24:	10bfff04 	addi	r2,r2,-4
 1003b28:	e0bffd15 	stw	r2,-12(fp)

    *pxTopOfStack = ( portSTACK_TYPE ) pxFramePointer;
 1003b2c:	e0fffb17 	ldw	r3,-20(fp)
 1003b30:	e0bffd17 	ldw	r2,-12(fp)
 1003b34:	10c00015 	stw	r3,0(r2)
    pxTopOfStack--;
 1003b38:	e0bffd17 	ldw	r2,-12(fp)
 1003b3c:	10bfff04 	addi	r2,r2,-4
 1003b40:	e0bffd15 	stw	r2,-12(fp)

    *pxTopOfStack = xGlobalPointer;
 1003b44:	e0fffc17 	ldw	r3,-16(fp)
 1003b48:	e0bffd17 	ldw	r2,-12(fp)
 1003b4c:	10c00015 	stw	r3,0(r2)

    /* Space for R23 to R16. */
    pxTopOfStack -= 9;
 1003b50:	e0bffd17 	ldw	r2,-12(fp)
 1003b54:	10bff704 	addi	r2,r2,-36
 1003b58:	e0bffd15 	stw	r2,-12(fp)

    *pxTopOfStack = ( portSTACK_TYPE ) pxCode;
 1003b5c:	e0fffe17 	ldw	r3,-8(fp)
 1003b60:	e0bffd17 	ldw	r2,-12(fp)
 1003b64:	10c00015 	stw	r3,0(r2)
    pxTopOfStack--;
 1003b68:	e0bffd17 	ldw	r2,-12(fp)
 1003b6c:	10bfff04 	addi	r2,r2,-4
 1003b70:	e0bffd15 	stw	r2,-12(fp)

    *pxTopOfStack = portINITIAL_ESTATUS;
 1003b74:	e0bffd17 	ldw	r2,-12(fp)
 1003b78:	00c00044 	movi	r3,1
 1003b7c:	10c00015 	stw	r3,0(r2)

    /* Space for R15 to R5. */
    pxTopOfStack -= 12;
 1003b80:	e0bffd17 	ldw	r2,-12(fp)
 1003b84:	10bff404 	addi	r2,r2,-48
 1003b88:	e0bffd15 	stw	r2,-12(fp)

    *pxTopOfStack = ( portSTACK_TYPE ) pvParameters;
 1003b8c:	e0ffff17 	ldw	r3,-4(fp)
 1003b90:	e0bffd17 	ldw	r2,-12(fp)
 1003b94:	10c00015 	stw	r3,0(r2)

    /* Space for R3 to R1, muldiv and RA. */
    pxTopOfStack -= 5;
 1003b98:	e0bffd17 	ldw	r2,-12(fp)
 1003b9c:	10bffb04 	addi	r2,r2,-20
 1003ba0:	e0bffd15 	stw	r2,-12(fp)

    return pxTopOfStack;
 1003ba4:	e0bffd17 	ldw	r2,-12(fp)
}
 1003ba8:	e037883a 	mov	sp,fp
 1003bac:	dfc00117 	ldw	ra,4(sp)
 1003bb0:	df000017 	ldw	fp,0(sp)
 1003bb4:	dec00204 	addi	sp,sp,8
 1003bb8:	f800283a 	ret

01003bbc <xPortStartScheduler>:

/*
 * See header file for description.
 */
portBASE_TYPE xPortStartScheduler( void )
{
 1003bbc:	defffe04 	addi	sp,sp,-8
 1003bc0:	dfc00115 	stw	ra,4(sp)
 1003bc4:	df000015 	stw	fp,0(sp)
 1003bc8:	d839883a 	mov	fp,sp
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();
 1003bcc:	1003c140 	call	1003c14 <prvSetupTimerInterrupt>
 1003bd0:	00804034 	movhi	r2,256

	/* Start the first task. */
    asm volatile (  " movia r2, restore_sp_from_pxCurrentTCB        \n"
 1003bd4:	10803104 	addi	r2,r2,196
 1003bd8:	1000683a 	jmp	r2
                    " jmp r2                                          " );

	/* Should not get here! */
	return 0;
 1003bdc:	0005883a 	mov	r2,zero
}
 1003be0:	e037883a 	mov	sp,fp
 1003be4:	dfc00117 	ldw	ra,4(sp)
 1003be8:	df000017 	ldw	fp,0(sp)
 1003bec:	dec00204 	addi	sp,sp,8
 1003bf0:	f800283a 	ret

01003bf4 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
 1003bf4:	deffff04 	addi	sp,sp,-4
 1003bf8:	df000015 	stw	fp,0(sp)
 1003bfc:	d839883a 	mov	fp,sp
	/* It is unlikely that the NIOS2 port will require this function as there
	is nothing to return to.  */
}
 1003c00:	0001883a 	nop
 1003c04:	e037883a 	mov	sp,fp
 1003c08:	df000017 	ldw	fp,0(sp)
 1003c0c:	dec00104 	addi	sp,sp,4
 1003c10:	f800283a 	ret

01003c14 <prvSetupTimerInterrupt>:
/*
 * Setup the systick timer to generate the tick interrupts at the required
 * frequency.
 */
void prvSetupTimerInterrupt( void )
{
 1003c14:	defffd04 	addi	sp,sp,-12
 1003c18:	dfc00215 	stw	ra,8(sp)
 1003c1c:	df000115 	stw	fp,4(sp)
 1003c20:	df000104 	addi	fp,sp,4
	/* Try to register the interrupt handler. */
	//cjr Jul-1-2010 new API
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
	if ( -EINVAL ==     alt_ic_isr_register(SYS_CLK_IRQ_INTERRUPT_CONTROLLER_ID, SYS_CLK_IRQ,
 1003c24:	d8000015 	stw	zero,0(sp)
 1003c28:	000f883a 	mov	r7,zero
 1003c2c:	01804034 	movhi	r6,256
 1003c30:	318f2904 	addi	r6,r6,15524
 1003c34:	014000c4 	movi	r5,3
 1003c38:	0009883a 	mov	r4,zero
 1003c3c:	10164880 	call	1016488 <alt_ic_isr_register>
 1003c40:	10bffa98 	cmpnei	r2,r2,-22
 1003c44:	1000021e 	bne	r2,zero,1003c50 <prvSetupTimerInterrupt+0x3c>
#else
	if ( -EINVAL == alt_irq_register( SYS_CLK_IRQ, 0x0, vPortSysTickHandler ) )
#endif
	{
		/* Failed to install the Interrupt Handler. */
		asm( "break" );
 1003c48:	003da03a 	break	0
 1003c4c:	00000c06 	br	1003c80 <prvSetupTimerInterrupt+0x6c>
	}
	else
	{
		/* Configure SysTick to interrupt at the requested rate. */
		IOWR_ALTERA_AVALON_TIMER_CONTROL( SYS_CLK_BASE, ALTERA_AVALON_TIMER_CONTROL_STOP_MSK );
 1003c50:	00c00204 	movi	r3,8
 1003c54:	00868104 	movi	r2,6660
 1003c58:	10c00035 	stwio	r3,0(r2)
		IOWR_ALTERA_AVALON_TIMER_PERIODL( SYS_CLK_BASE, ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) & 0xFFFF );
 1003c5c:	00e1a814 	movui	r3,34464
 1003c60:	00868204 	movi	r2,6664
 1003c64:	10c00035 	stwio	r3,0(r2)
		IOWR_ALTERA_AVALON_TIMER_PERIODH( SYS_CLK_BASE, ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) >> 16 );
 1003c68:	00c00044 	movi	r3,1
 1003c6c:	00868304 	movi	r2,6668
 1003c70:	10c00035 	stwio	r3,0(r2)
		IOWR_ALTERA_AVALON_TIMER_CONTROL( SYS_CLK_BASE, ALTERA_AVALON_TIMER_CONTROL_CONT_MSK | ALTERA_AVALON_TIMER_CONTROL_START_MSK | ALTERA_AVALON_TIMER_CONTROL_ITO_MSK );
 1003c74:	00c001c4 	movi	r3,7
 1003c78:	00868104 	movi	r2,6660
 1003c7c:	10c00035 	stwio	r3,0(r2)
	}

	/* Clear any already pending interrupts generated by the Timer. */
	IOWR_ALTERA_AVALON_TIMER_STATUS( SYS_CLK_BASE, ~ALTERA_AVALON_TIMER_STATUS_TO_MSK );
 1003c80:	00ffff84 	movi	r3,-2
 1003c84:	00868004 	movi	r2,6656
 1003c88:	10c00035 	stwio	r3,0(r2)
}
 1003c8c:	0001883a 	nop
 1003c90:	e037883a 	mov	sp,fp
 1003c94:	dfc00117 	ldw	ra,4(sp)
 1003c98:	df000017 	ldw	fp,0(sp)
 1003c9c:	dec00204 	addi	sp,sp,8
 1003ca0:	f800283a 	ret

01003ca4 <vPortSysTickHandler>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
void vPortSysTickHandler( void * context )
#else
void vPortSysTickHandler( void * context, alt_u32 id )
#endif
{
 1003ca4:	defffd04 	addi	sp,sp,-12
 1003ca8:	dfc00215 	stw	ra,8(sp)
 1003cac:	df000115 	stw	fp,4(sp)
 1003cb0:	df000104 	addi	fp,sp,4
 1003cb4:	e13fff15 	stw	r4,-4(fp)
	/* Increment the Kernel Tick. */
	//vTaskIncrementTick();
	(void)xTaskIncrementTick();
 1003cb8:	10061d40 	call	10061d4 <xTaskIncrementTick>

	/* If using preemption, also force a context switch. */
	#if configUSE_PREEMPTION == 1
        vTaskSwitchContext();
 1003cbc:	10063980 	call	1006398 <vTaskSwitchContext>
	#endif

	/* Clear the interrupt. */
	IOWR_ALTERA_AVALON_TIMER_STATUS( SYS_CLK_BASE, ~ALTERA_AVALON_TIMER_STATUS_TO_MSK );
 1003cc0:	00ffff84 	movi	r3,-2
 1003cc4:	00868004 	movi	r2,6656
 1003cc8:	10c00035 	stwio	r3,0(r2)
}
 1003ccc:	0001883a 	nop
 1003cd0:	e037883a 	mov	sp,fp
 1003cd4:	dfc00117 	ldw	ra,4(sp)
 1003cd8:	df000017 	ldw	fp,0(sp)
 1003cdc:	dec00204 	addi	sp,sp,8
 1003ce0:	f800283a 	ret

01003ce4 <alt_irq_register>:
#ifndef ALT_ENHANCED_INTERRUPT_API_PRESENT
int alt_irq_register( alt_u32 id, void* context, void (*handler)(void*, alt_u32) )
#else
int alt_irq_register( alt_u32 id, void* context, alt_isr_func handler )
#endif
{
 1003ce4:	defff104 	addi	sp,sp,-60
 1003ce8:	df000e15 	stw	fp,56(sp)
 1003cec:	df000e04 	addi	fp,sp,56
 1003cf0:	e13ffd15 	stw	r4,-12(fp)
 1003cf4:	e17ffe15 	stw	r5,-8(fp)
 1003cf8:	e1bfff15 	stw	r6,-4(fp)
	int rc = -EINVAL;
 1003cfc:	00bffa84 	movi	r2,-22
 1003d00:	e0bff215 	stw	r2,-56(fp)
	alt_irq_context status;

	if (id < ALT_NIRQ)
 1003d04:	e0bffd17 	ldw	r2,-12(fp)
 1003d08:	10800828 	cmpgeui	r2,r2,32
 1003d0c:	10004c1e 	bne	r2,zero,1003e40 <alt_irq_register+0x15c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1003d10:	0005303a 	rdctl	r2,status
 1003d14:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1003d18:	e0fff617 	ldw	r3,-40(fp)
 1003d1c:	00bfff84 	movi	r2,-2
 1003d20:	1884703a 	and	r2,r3,r2
 1003d24:	1001703a 	wrctl	status,r2
  
  return context;
 1003d28:	e0bff617 	ldw	r2,-40(fp)
		 * interrupts are disabled while the handler tables are updated to ensure
		 * that an interrupt doesn't occur while the tables are in an inconsistent
		 * state.
		 */

		status = alt_irq_disable_all ();
 1003d2c:	e0bff415 	stw	r2,-48(fp)

		alt_irq[id].handler = handler;
 1003d30:	00805cf4 	movhi	r2,371
 1003d34:	10ab6804 	addi	r2,r2,-21088
 1003d38:	e0fffd17 	ldw	r3,-12(fp)
 1003d3c:	180690fa 	slli	r3,r3,3
 1003d40:	10c5883a 	add	r2,r2,r3
 1003d44:	e0ffff17 	ldw	r3,-4(fp)
 1003d48:	10c00015 	stw	r3,0(r2)
		alt_irq[id].context = context;
 1003d4c:	00805cf4 	movhi	r2,371
 1003d50:	10ab6804 	addi	r2,r2,-21088
 1003d54:	e0fffd17 	ldw	r3,-12(fp)
 1003d58:	180690fa 	slli	r3,r3,3
 1003d5c:	10c5883a 	add	r2,r2,r3
 1003d60:	10800104 	addi	r2,r2,4
 1003d64:	e0fffe17 	ldw	r3,-8(fp)
 1003d68:	10c00015 	stw	r3,0(r2)

		rc = (handler) ? alt_irq_enable (id): alt_irq_disable (id);
 1003d6c:	e0bfff17 	ldw	r2,-4(fp)
 1003d70:	10001926 	beq	r2,zero,1003dd8 <alt_irq_register+0xf4>
 1003d74:	e0bffd17 	ldw	r2,-12(fp)
 1003d78:	e0bff315 	stw	r2,-52(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1003d7c:	0005303a 	rdctl	r2,status
 1003d80:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1003d84:	e0fff717 	ldw	r3,-36(fp)
 1003d88:	00bfff84 	movi	r2,-2
 1003d8c:	1884703a 	and	r2,r3,r2
 1003d90:	1001703a 	wrctl	status,r2
  
  return context;
 1003d94:	e0bff717 	ldw	r2,-36(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 1003d98:	e0bff815 	stw	r2,-32(fp)

  alt_irq_active |= (1 << id);
 1003d9c:	00c00044 	movi	r3,1
 1003da0:	e0bff317 	ldw	r2,-52(fp)
 1003da4:	1884983a 	sll	r2,r3,r2
 1003da8:	1007883a 	mov	r3,r2
 1003dac:	d0a0af17 	ldw	r2,-32068(gp)
 1003db0:	1884b03a 	or	r2,r3,r2
 1003db4:	d0a0af15 	stw	r2,-32068(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 1003db8:	d0a0af17 	ldw	r2,-32068(gp)
 1003dbc:	100170fa 	wrctl	ienable,r2
 1003dc0:	e0bff817 	ldw	r2,-32(fp)
 1003dc4:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 1003dc8:	e0bff917 	ldw	r2,-28(fp)
 1003dcc:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 1003dd0:	0005883a 	mov	r2,zero
 1003dd4:	00001906 	br	1003e3c <alt_irq_register+0x158>
 1003dd8:	e0bffd17 	ldw	r2,-12(fp)
 1003ddc:	e0bff515 	stw	r2,-44(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1003de0:	0005303a 	rdctl	r2,status
 1003de4:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1003de8:	e0fffa17 	ldw	r3,-24(fp)
 1003dec:	00bfff84 	movi	r2,-2
 1003df0:	1884703a 	and	r2,r3,r2
 1003df4:	1001703a 	wrctl	status,r2
  
  return context;
 1003df8:	e0bffa17 	ldw	r2,-24(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 1003dfc:	e0bffb15 	stw	r2,-20(fp)

  alt_irq_active &= ~(1 << id);
 1003e00:	00c00044 	movi	r3,1
 1003e04:	e0bff517 	ldw	r2,-44(fp)
 1003e08:	1884983a 	sll	r2,r3,r2
 1003e0c:	0084303a 	nor	r2,zero,r2
 1003e10:	1007883a 	mov	r3,r2
 1003e14:	d0a0af17 	ldw	r2,-32068(gp)
 1003e18:	1884703a 	and	r2,r3,r2
 1003e1c:	d0a0af15 	stw	r2,-32068(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 1003e20:	d0a0af17 	ldw	r2,-32068(gp)
 1003e24:	100170fa 	wrctl	ienable,r2
 1003e28:	e0bffb17 	ldw	r2,-20(fp)
 1003e2c:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 1003e30:	e0bffc17 	ldw	r2,-16(fp)
 1003e34:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 1003e38:	0005883a 	mov	r2,zero
 1003e3c:	e0bff215 	stw	r2,-56(fp)

		/* alt_irq_enable_all(status); This line is removed to prevent the interrupt from being immediately enabled. */
	}

	return rc;
 1003e40:	e0bff217 	ldw	r2,-56(fp)
}
 1003e44:	e037883a 	mov	sp,fp
 1003e48:	df000017 	ldw	fp,0(sp)
 1003e4c:	dec00104 	addi	sp,sp,4
 1003e50:	f800283a 	ret

01003e54 <alt_iic_isr_register>:
  * @param flags
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr,
  void *isr_context, void *flags)
{
 1003e54:	defff604 	addi	sp,sp,-40
 1003e58:	dfc00915 	stw	ra,36(sp)
 1003e5c:	df000815 	stw	fp,32(sp)
 1003e60:	df000804 	addi	fp,sp,32
 1003e64:	e13ffc15 	stw	r4,-16(fp)
 1003e68:	e17ffd15 	stw	r5,-12(fp)
 1003e6c:	e1bffe15 	stw	r6,-8(fp)
 1003e70:	e1ffff15 	stw	r7,-4(fp)
  int rc = -EINVAL;
 1003e74:	00bffa84 	movi	r2,-22
 1003e78:	e0bff815 	stw	r2,-32(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
 1003e7c:	e0bffd17 	ldw	r2,-12(fp)
 1003e80:	e0bff915 	stw	r2,-28(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
 1003e84:	e0bff917 	ldw	r2,-28(fp)
 1003e88:	10800808 	cmpgei	r2,r2,32
 1003e8c:	1000231e 	bne	r2,zero,1003f1c <alt_iic_isr_register+0xc8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1003e90:	0005303a 	rdctl	r2,status
 1003e94:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1003e98:	e0fffb17 	ldw	r3,-20(fp)
 1003e9c:	00bfff84 	movi	r2,-2
 1003ea0:	1884703a 	and	r2,r3,r2
 1003ea4:	1001703a 	wrctl	status,r2
  
  return context;
 1003ea8:	e0bffb17 	ldw	r2,-20(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
 1003eac:	e0bffa15 	stw	r2,-24(fp)

    alt_irq[id].handler = isr;
 1003eb0:	00805cf4 	movhi	r2,371
 1003eb4:	10ab6804 	addi	r2,r2,-21088
 1003eb8:	e0fff917 	ldw	r3,-28(fp)
 1003ebc:	180690fa 	slli	r3,r3,3
 1003ec0:	10c5883a 	add	r2,r2,r3
 1003ec4:	e0fffe17 	ldw	r3,-8(fp)
 1003ec8:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = isr_context;
 1003ecc:	00805cf4 	movhi	r2,371
 1003ed0:	10ab6804 	addi	r2,r2,-21088
 1003ed4:	e0fff917 	ldw	r3,-28(fp)
 1003ed8:	180690fa 	slli	r3,r3,3
 1003edc:	10c5883a 	add	r2,r2,r3
 1003ee0:	10800104 	addi	r2,r2,4
 1003ee4:	e0ffff17 	ldw	r3,-4(fp)
 1003ee8:	10c00015 	stw	r3,0(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
 1003eec:	e0bffe17 	ldw	r2,-8(fp)
 1003ef0:	10000526 	beq	r2,zero,1003f08 <alt_iic_isr_register+0xb4>
 1003ef4:	e0bff917 	ldw	r2,-28(fp)
 1003ef8:	100b883a 	mov	r5,r2
 1003efc:	e13ffc17 	ldw	r4,-16(fp)
 1003f00:	10164d80 	call	10164d8 <alt_ic_irq_enable>
 1003f04:	00000406 	br	1003f18 <alt_iic_isr_register+0xc4>
 1003f08:	e0bff917 	ldw	r2,-28(fp)
 1003f0c:	100b883a 	mov	r5,r2
 1003f10:	e13ffc17 	ldw	r4,-16(fp)
 1003f14:	10165600 	call	1016560 <alt_ic_irq_disable>
 1003f18:	e0bff815 	stw	r2,-32(fp)

  //  alt_irq_enable_all(status);
  }

  return rc;
 1003f1c:	e0bff817 	ldw	r2,-32(fp)
}
 1003f20:	e037883a 	mov	sp,fp
 1003f24:	dfc00117 	ldw	ra,4(sp)
 1003f28:	df000017 	ldw	fp,0(sp)
 1003f2c:	dec00204 	addi	sp,sp,8
 1003f30:	f800283a 	ret

01003f34 <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 1003f34:	defff704 	addi	sp,sp,-36
 1003f38:	dfc00815 	stw	ra,32(sp)
 1003f3c:	df000715 	stw	fp,28(sp)
 1003f40:	df000704 	addi	fp,sp,28
 1003f44:	e13fff15 	stw	r4,-4(fp)
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
 1003f48:	e03ffb15 	stw	zero,-20(fp)

	vTaskSuspendAll();
 1003f4c:	1005f9c0 	call	1005f9c <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
 1003f50:	d0a08317 	ldw	r2,-32244(gp)
 1003f54:	1000031e 	bne	r2,zero,1003f64 <pvPortMalloc+0x30>
		{
			prvHeapInit();
 1003f58:	10042140 	call	1004214 <prvHeapInit>
			xHeapHasBeenInitialised = pdTRUE;
 1003f5c:	00800044 	movi	r2,1
 1003f60:	d0a08315 	stw	r2,-32244(gp)
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
 1003f64:	e0bfff17 	ldw	r2,-4(fp)
 1003f68:	10000d26 	beq	r2,zero,1003fa0 <pvPortMalloc+0x6c>
		{
			xWantedSize += heapSTRUCT_SIZE;
 1003f6c:	00800204 	movi	r2,8
 1003f70:	10bfffcc 	andi	r2,r2,65535
 1003f74:	e0ffff17 	ldw	r3,-4(fp)
 1003f78:	1885883a 	add	r2,r3,r2
 1003f7c:	e0bfff15 	stw	r2,-4(fp)

			/* Ensure that blocks are always aligned to the required number of bytes. */
			if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0 )
 1003f80:	e0bfff17 	ldw	r2,-4(fp)
 1003f84:	108000cc 	andi	r2,r2,3
 1003f88:	10000526 	beq	r2,zero,1003fa0 <pvPortMalloc+0x6c>
			{
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 1003f8c:	e0ffff17 	ldw	r3,-4(fp)
 1003f90:	00bfff04 	movi	r2,-4
 1003f94:	1884703a 	and	r2,r3,r2
 1003f98:	10800104 	addi	r2,r2,4
 1003f9c:	e0bfff15 	stw	r2,-4(fp)
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
 1003fa0:	e0bfff17 	ldw	r2,-4(fp)
 1003fa4:	10005126 	beq	r2,zero,10040ec <pvPortMalloc+0x1b8>
 1003fa8:	e0ffff17 	ldw	r3,-4(fp)
 1003fac:	00801c74 	movhi	r2,113
 1003fb0:	10af6ec4 	addi	r2,r2,-16965
 1003fb4:	10c04d36 	bltu	r2,r3,10040ec <pvPortMalloc+0x1b8>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
 1003fb8:	d0a07f04 	addi	r2,gp,-32260
 1003fbc:	e0bffa15 	stw	r2,-24(fp)
			pxBlock = xStart.pxNextFreeBlock;
 1003fc0:	d0a07f17 	ldw	r2,-32260(gp)
 1003fc4:	e0bff915 	stw	r2,-28(fp)
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 1003fc8:	00000506 	br	1003fe0 <pvPortMalloc+0xac>
			{
				pxPreviousBlock = pxBlock;
 1003fcc:	e0bff917 	ldw	r2,-28(fp)
 1003fd0:	e0bffa15 	stw	r2,-24(fp)
				pxBlock = pxBlock->pxNextFreeBlock;
 1003fd4:	e0bff917 	ldw	r2,-28(fp)
 1003fd8:	10800017 	ldw	r2,0(r2)
 1003fdc:	e0bff915 	stw	r2,-28(fp)
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 1003fe0:	e0bff917 	ldw	r2,-28(fp)
 1003fe4:	10c00117 	ldw	r3,4(r2)
 1003fe8:	e0bfff17 	ldw	r2,-4(fp)
 1003fec:	1880032e 	bgeu	r3,r2,1003ffc <pvPortMalloc+0xc8>
 1003ff0:	e0bff917 	ldw	r2,-28(fp)
 1003ff4:	10800017 	ldw	r2,0(r2)
 1003ff8:	103ff41e 	bne	r2,zero,1003fcc <__alt_data_end+0xff803fcc>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
 1003ffc:	e0fff917 	ldw	r3,-28(fp)
 1004000:	d0a08104 	addi	r2,gp,-32252
 1004004:	18803926 	beq	r3,r2,10040ec <pvPortMalloc+0x1b8>
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
 1004008:	e0bffa17 	ldw	r2,-24(fp)
 100400c:	10c00017 	ldw	r3,0(r2)
 1004010:	00800204 	movi	r2,8
 1004014:	10bfffcc 	andi	r2,r2,65535
 1004018:	1885883a 	add	r2,r3,r2
 100401c:	e0bffb15 	stw	r2,-20(fp)

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 1004020:	e0bff917 	ldw	r2,-28(fp)
 1004024:	10c00017 	ldw	r3,0(r2)
 1004028:	e0bffa17 	ldw	r2,-24(fp)
 100402c:	10c00015 	stw	r3,0(r2)

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 1004030:	e0bff917 	ldw	r2,-28(fp)
 1004034:	10c00117 	ldw	r3,4(r2)
 1004038:	e0bfff17 	ldw	r2,-4(fp)
 100403c:	1887c83a 	sub	r3,r3,r2
 1004040:	00800204 	movi	r2,8
 1004044:	10bfffcc 	andi	r2,r2,65535
 1004048:	1085883a 	add	r2,r2,r2
 100404c:	10c0222e 	bgeu	r2,r3,10040d8 <pvPortMalloc+0x1a4>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 1004050:	e0fff917 	ldw	r3,-28(fp)
 1004054:	e0bfff17 	ldw	r2,-4(fp)
 1004058:	1885883a 	add	r2,r3,r2
 100405c:	e0bffd15 	stw	r2,-12(fp)

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 1004060:	e0bff917 	ldw	r2,-28(fp)
 1004064:	10c00117 	ldw	r3,4(r2)
 1004068:	e0bfff17 	ldw	r2,-4(fp)
 100406c:	1887c83a 	sub	r3,r3,r2
 1004070:	e0bffd17 	ldw	r2,-12(fp)
 1004074:	10c00115 	stw	r3,4(r2)
					pxBlock->xBlockSize = xWantedSize;
 1004078:	e0bff917 	ldw	r2,-28(fp)
 100407c:	e0ffff17 	ldw	r3,-4(fp)
 1004080:	10c00115 	stw	r3,4(r2)

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
 1004084:	e0bffd17 	ldw	r2,-12(fp)
 1004088:	10800117 	ldw	r2,4(r2)
 100408c:	e0bffe15 	stw	r2,-8(fp)
 1004090:	d0a07f04 	addi	r2,gp,-32260
 1004094:	e0bffc15 	stw	r2,-16(fp)
 1004098:	00000306 	br	10040a8 <pvPortMalloc+0x174>
 100409c:	e0bffc17 	ldw	r2,-16(fp)
 10040a0:	10800017 	ldw	r2,0(r2)
 10040a4:	e0bffc15 	stw	r2,-16(fp)
 10040a8:	e0bffc17 	ldw	r2,-16(fp)
 10040ac:	10800017 	ldw	r2,0(r2)
 10040b0:	10c00117 	ldw	r3,4(r2)
 10040b4:	e0bffe17 	ldw	r2,-8(fp)
 10040b8:	18bff836 	bltu	r3,r2,100409c <__alt_data_end+0xff80409c>
 10040bc:	e0bffc17 	ldw	r2,-16(fp)
 10040c0:	10c00017 	ldw	r3,0(r2)
 10040c4:	e0bffd17 	ldw	r2,-12(fp)
 10040c8:	10c00015 	stw	r3,0(r2)
 10040cc:	e0bffc17 	ldw	r2,-16(fp)
 10040d0:	e0fffd17 	ldw	r3,-12(fp)
 10040d4:	10c00015 	stw	r3,0(r2)
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
 10040d8:	d0e00317 	ldw	r3,-32756(gp)
 10040dc:	e0bff917 	ldw	r2,-28(fp)
 10040e0:	10800117 	ldw	r2,4(r2)
 10040e4:	1885c83a 	sub	r2,r3,r2
 10040e8:	d0a00315 	stw	r2,-32756(gp)
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
 10040ec:	1005fc80 	call	1005fc8 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
 10040f0:	e0bffb17 	ldw	r2,-20(fp)
}
 10040f4:	e037883a 	mov	sp,fp
 10040f8:	dfc00117 	ldw	ra,4(sp)
 10040fc:	df000017 	ldw	fp,0(sp)
 1004100:	dec00204 	addi	sp,sp,8
 1004104:	f800283a 	ret

01004108 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 1004108:	defff904 	addi	sp,sp,-28
 100410c:	dfc00615 	stw	ra,24(sp)
 1004110:	df000515 	stw	fp,20(sp)
 1004114:	df000504 	addi	fp,sp,20
 1004118:	e13fff15 	stw	r4,-4(fp)
uint8_t *puc = ( uint8_t * ) pv;
 100411c:	e0bfff17 	ldw	r2,-4(fp)
 1004120:	e0bffc15 	stw	r2,-16(fp)
BlockLink_t *pxLink;

	if( pv != NULL )
 1004124:	e0bfff17 	ldw	r2,-4(fp)
 1004128:	10002426 	beq	r2,zero,10041bc <vPortFree+0xb4>
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
 100412c:	00800204 	movi	r2,8
 1004130:	10bfffcc 	andi	r2,r2,65535
 1004134:	0085c83a 	sub	r2,zero,r2
 1004138:	e0fffc17 	ldw	r3,-16(fp)
 100413c:	1885883a 	add	r2,r3,r2
 1004140:	e0bffc15 	stw	r2,-16(fp)

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;
 1004144:	e0bffc17 	ldw	r2,-16(fp)
 1004148:	e0bffd15 	stw	r2,-12(fp)

		vTaskSuspendAll();
 100414c:	1005f9c0 	call	1005f9c <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 1004150:	e0bffd17 	ldw	r2,-12(fp)
 1004154:	10800117 	ldw	r2,4(r2)
 1004158:	e0bffe15 	stw	r2,-8(fp)
 100415c:	d0a07f04 	addi	r2,gp,-32260
 1004160:	e0bffb15 	stw	r2,-20(fp)
 1004164:	00000306 	br	1004174 <vPortFree+0x6c>
 1004168:	e0bffb17 	ldw	r2,-20(fp)
 100416c:	10800017 	ldw	r2,0(r2)
 1004170:	e0bffb15 	stw	r2,-20(fp)
 1004174:	e0bffb17 	ldw	r2,-20(fp)
 1004178:	10800017 	ldw	r2,0(r2)
 100417c:	10c00117 	ldw	r3,4(r2)
 1004180:	e0bffe17 	ldw	r2,-8(fp)
 1004184:	18bff836 	bltu	r3,r2,1004168 <__alt_data_end+0xff804168>
 1004188:	e0bffb17 	ldw	r2,-20(fp)
 100418c:	10c00017 	ldw	r3,0(r2)
 1004190:	e0bffd17 	ldw	r2,-12(fp)
 1004194:	10c00015 	stw	r3,0(r2)
 1004198:	e0bffb17 	ldw	r2,-20(fp)
 100419c:	e0fffd17 	ldw	r3,-12(fp)
 10041a0:	10c00015 	stw	r3,0(r2)
			xFreeBytesRemaining += pxLink->xBlockSize;
 10041a4:	e0bffd17 	ldw	r2,-12(fp)
 10041a8:	10c00117 	ldw	r3,4(r2)
 10041ac:	d0a00317 	ldw	r2,-32756(gp)
 10041b0:	1885883a 	add	r2,r3,r2
 10041b4:	d0a00315 	stw	r2,-32756(gp)
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
 10041b8:	1005fc80 	call	1005fc8 <xTaskResumeAll>
	}
}
 10041bc:	0001883a 	nop
 10041c0:	e037883a 	mov	sp,fp
 10041c4:	dfc00117 	ldw	ra,4(sp)
 10041c8:	df000017 	ldw	fp,0(sp)
 10041cc:	dec00204 	addi	sp,sp,8
 10041d0:	f800283a 	ret

010041d4 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
 10041d4:	deffff04 	addi	sp,sp,-4
 10041d8:	df000015 	stw	fp,0(sp)
 10041dc:	d839883a 	mov	fp,sp
	return xFreeBytesRemaining;
 10041e0:	d0a00317 	ldw	r2,-32756(gp)
}
 10041e4:	e037883a 	mov	sp,fp
 10041e8:	df000017 	ldw	fp,0(sp)
 10041ec:	dec00104 	addi	sp,sp,4
 10041f0:	f800283a 	ret

010041f4 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
 10041f4:	deffff04 	addi	sp,sp,-4
 10041f8:	df000015 	stw	fp,0(sp)
 10041fc:	d839883a 	mov	fp,sp
	/* This just exists to keep the linker quiet. */
}
 1004200:	0001883a 	nop
 1004204:	e037883a 	mov	sp,fp
 1004208:	df000017 	ldw	fp,0(sp)
 100420c:	dec00104 	addi	sp,sp,4
 1004210:	f800283a 	ret

01004214 <prvHeapInit>:
/*-----------------------------------------------------------*/

static void prvHeapInit( void )
{
 1004214:	defffd04 	addi	sp,sp,-12
 1004218:	df000215 	stw	fp,8(sp)
 100421c:	df000204 	addi	fp,sp,8
BlockLink_t *pxFirstFreeBlock;
uint8_t *pucAlignedHeap;

	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
 1004220:	008040b4 	movhi	r2,258
 1004224:	10b43504 	addi	r2,r2,-12076
 1004228:	00ffff04 	movi	r3,-4
 100422c:	10c4703a 	and	r2,r2,r3
 1004230:	e0bffe15 	stw	r2,-8(fp)

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 1004234:	e0bffe17 	ldw	r2,-8(fp)
 1004238:	d0a07f15 	stw	r2,-32260(gp)
	xStart.xBlockSize = ( size_t ) 0;
 100423c:	d0208015 	stw	zero,-32256(gp)

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
 1004240:	00801c74 	movhi	r2,113
 1004244:	10af6f04 	addi	r2,r2,-16964
 1004248:	d0a08215 	stw	r2,-32248(gp)
	xEnd.pxNextFreeBlock = NULL;
 100424c:	d0208115 	stw	zero,-32252(gp)

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
 1004250:	e0bffe17 	ldw	r2,-8(fp)
 1004254:	e0bfff15 	stw	r2,-4(fp)
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
 1004258:	e0ffff17 	ldw	r3,-4(fp)
 100425c:	00801c74 	movhi	r2,113
 1004260:	10af6f04 	addi	r2,r2,-16964
 1004264:	18800115 	stw	r2,4(r3)
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
 1004268:	e0bfff17 	ldw	r2,-4(fp)
 100426c:	d0e08104 	addi	r3,gp,-32252
 1004270:	10c00015 	stw	r3,0(r2)
}
 1004274:	0001883a 	nop
 1004278:	e037883a 	mov	sp,fp
 100427c:	df000017 	ldw	fp,0(sp)
 1004280:	dec00104 	addi	sp,sp,4
 1004284:	f800283a 	ret

01004288 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
 1004288:	defffb04 	addi	sp,sp,-20
 100428c:	dfc00415 	stw	ra,16(sp)
 1004290:	df000315 	stw	fp,12(sp)
 1004294:	df000304 	addi	fp,sp,12
 1004298:	e13ffe15 	stw	r4,-8(fp)
 100429c:	e17fff15 	stw	r5,-4(fp)
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 10042a0:	e0bffe17 	ldw	r2,-8(fp)
 10042a4:	e0bffd15 	stw	r2,-12(fp)

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
 10042a8:	1006d680 	call	1006d68 <vTaskEnterCritical>
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 10042ac:	e0bffd17 	ldw	r2,-12(fp)
 10042b0:	10c00017 	ldw	r3,0(r2)
 10042b4:	e0bffd17 	ldw	r2,-12(fp)
 10042b8:	11000f17 	ldw	r4,60(r2)
 10042bc:	e0bffd17 	ldw	r2,-12(fp)
 10042c0:	10801017 	ldw	r2,64(r2)
 10042c4:	2085383a 	mul	r2,r4,r2
 10042c8:	1887883a 	add	r3,r3,r2
 10042cc:	e0bffd17 	ldw	r2,-12(fp)
 10042d0:	10c00115 	stw	r3,4(r2)
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 10042d4:	e0bffd17 	ldw	r2,-12(fp)
 10042d8:	10000e15 	stw	zero,56(r2)
		pxQueue->pcWriteTo = pxQueue->pcHead;
 10042dc:	e0bffd17 	ldw	r2,-12(fp)
 10042e0:	10c00017 	ldw	r3,0(r2)
 10042e4:	e0bffd17 	ldw	r2,-12(fp)
 10042e8:	10c00215 	stw	r3,8(r2)
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
 10042ec:	e0bffd17 	ldw	r2,-12(fp)
 10042f0:	10c00017 	ldw	r3,0(r2)
 10042f4:	e0bffd17 	ldw	r2,-12(fp)
 10042f8:	10800f17 	ldw	r2,60(r2)
 10042fc:	113fffc4 	addi	r4,r2,-1
 1004300:	e0bffd17 	ldw	r2,-12(fp)
 1004304:	10801017 	ldw	r2,64(r2)
 1004308:	2085383a 	mul	r2,r4,r2
 100430c:	1887883a 	add	r3,r3,r2
 1004310:	e0bffd17 	ldw	r2,-12(fp)
 1004314:	10c00315 	stw	r3,12(r2)
		pxQueue->cRxLock = queueUNLOCKED;
 1004318:	e0bffd17 	ldw	r2,-12(fp)
 100431c:	00ffffc4 	movi	r3,-1
 1004320:	10c01105 	stb	r3,68(r2)
		pxQueue->cTxLock = queueUNLOCKED;
 1004324:	e0bffd17 	ldw	r2,-12(fp)
 1004328:	00ffffc4 	movi	r3,-1
 100432c:	10c01145 	stb	r3,69(r2)

		if( xNewQueue == pdFALSE )
 1004330:	e0bfff17 	ldw	r2,-4(fp)
 1004334:	10000a1e 	bne	r2,zero,1004360 <xQueueGenericReset+0xd8>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 1004338:	e0bffd17 	ldw	r2,-12(fp)
 100433c:	10800417 	ldw	r2,16(r2)
 1004340:	10000f26 	beq	r2,zero,1004380 <xQueueGenericReset+0xf8>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 1004344:	e0bffd17 	ldw	r2,-12(fp)
 1004348:	10800404 	addi	r2,r2,16
 100434c:	1009883a 	mov	r4,r2
 1004350:	10065240 	call	1006524 <xTaskRemoveFromEventList>
 1004354:	10000a26 	beq	r2,zero,1004380 <xQueueGenericReset+0xf8>
				{
					queueYIELD_IF_USING_PREEMPTION();
 1004358:	003b683a 	trap	0
 100435c:	00000806 	br	1004380 <xQueueGenericReset+0xf8>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 1004360:	e0bffd17 	ldw	r2,-12(fp)
 1004364:	10800404 	addi	r2,r2,16
 1004368:	1009883a 	mov	r4,r2
 100436c:	10038240 	call	1003824 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 1004370:	e0bffd17 	ldw	r2,-12(fp)
 1004374:	10800904 	addi	r2,r2,36
 1004378:	1009883a 	mov	r4,r2
 100437c:	10038240 	call	1003824 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
 1004380:	1006dbc0 	call	1006dbc <vTaskExitCritical>

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
 1004384:	00800044 	movi	r2,1
}
 1004388:	e037883a 	mov	sp,fp
 100438c:	dfc00117 	ldw	ra,4(sp)
 1004390:	df000017 	ldw	fp,0(sp)
 1004394:	dec00204 	addi	sp,sp,8
 1004398:	f800283a 	ret

0100439c <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
 100439c:	defff704 	addi	sp,sp,-36
 10043a0:	dfc00815 	stw	ra,32(sp)
 10043a4:	df000715 	stw	fp,28(sp)
 10043a8:	df000704 	addi	fp,sp,28
 10043ac:	e13ffd15 	stw	r4,-12(fp)
 10043b0:	e17ffe15 	stw	r5,-8(fp)
 10043b4:	3005883a 	mov	r2,r6
 10043b8:	e0bfff05 	stb	r2,-4(fp)
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
 10043bc:	e0bffe17 	ldw	r2,-8(fp)
 10043c0:	1000021e 	bne	r2,zero,10043cc <xQueueGenericCreate+0x30>
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
 10043c4:	e03ffa15 	stw	zero,-24(fp)
 10043c8:	00000406 	br	10043dc <xQueueGenericCreate+0x40>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 10043cc:	e0fffd17 	ldw	r3,-12(fp)
 10043d0:	e0bffe17 	ldw	r2,-8(fp)
 10043d4:	1885383a 	mul	r2,r3,r2
 10043d8:	e0bffa15 	stw	r2,-24(fp)
		}

		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
 10043dc:	e0bffa17 	ldw	r2,-24(fp)
 10043e0:	10801204 	addi	r2,r2,72
 10043e4:	1009883a 	mov	r4,r2
 10043e8:	1003f340 	call	1003f34 <pvPortMalloc>
 10043ec:	e0bffb15 	stw	r2,-20(fp)

		if( pxNewQueue != NULL )
 10043f0:	e0bffb17 	ldw	r2,-20(fp)
 10043f4:	10000b26 	beq	r2,zero,1004424 <xQueueGenericCreate+0x88>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
 10043f8:	e0bffb17 	ldw	r2,-20(fp)
 10043fc:	10801204 	addi	r2,r2,72
 1004400:	e0bffc15 	stw	r2,-16(fp)
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
 1004404:	e0ffff03 	ldbu	r3,-4(fp)
 1004408:	e0bffb17 	ldw	r2,-20(fp)
 100440c:	d8800015 	stw	r2,0(sp)
 1004410:	180f883a 	mov	r7,r3
 1004414:	e1bffc17 	ldw	r6,-16(fp)
 1004418:	e17ffe17 	ldw	r5,-8(fp)
 100441c:	e13ffd17 	ldw	r4,-12(fp)
 1004420:	100443c0 	call	100443c <prvInitialiseNewQueue>
		}

		return pxNewQueue;
 1004424:	e0bffb17 	ldw	r2,-20(fp)
	}
 1004428:	e037883a 	mov	sp,fp
 100442c:	dfc00117 	ldw	ra,4(sp)
 1004430:	df000017 	ldw	fp,0(sp)
 1004434:	dec00204 	addi	sp,sp,8
 1004438:	f800283a 	ret

0100443c <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
 100443c:	defffa04 	addi	sp,sp,-24
 1004440:	dfc00515 	stw	ra,20(sp)
 1004444:	df000415 	stw	fp,16(sp)
 1004448:	df000404 	addi	fp,sp,16
 100444c:	e13ffc15 	stw	r4,-16(fp)
 1004450:	e17ffd15 	stw	r5,-12(fp)
 1004454:	e1bffe15 	stw	r6,-8(fp)
 1004458:	3805883a 	mov	r2,r7
 100445c:	e0bfff05 	stb	r2,-4(fp)
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
 1004460:	e0bffd17 	ldw	r2,-12(fp)
 1004464:	1000041e 	bne	r2,zero,1004478 <prvInitialiseNewQueue+0x3c>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 1004468:	e0800217 	ldw	r2,8(fp)
 100446c:	e0c00217 	ldw	r3,8(fp)
 1004470:	10c00015 	stw	r3,0(r2)
 1004474:	00000306 	br	1004484 <prvInitialiseNewQueue+0x48>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 1004478:	e0800217 	ldw	r2,8(fp)
 100447c:	e0fffe17 	ldw	r3,-8(fp)
 1004480:	10c00015 	stw	r3,0(r2)
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
 1004484:	e0800217 	ldw	r2,8(fp)
 1004488:	e0fffc17 	ldw	r3,-16(fp)
 100448c:	10c00f15 	stw	r3,60(r2)
	pxNewQueue->uxItemSize = uxItemSize;
 1004490:	e0800217 	ldw	r2,8(fp)
 1004494:	e0fffd17 	ldw	r3,-12(fp)
 1004498:	10c01015 	stw	r3,64(r2)
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 100449c:	01400044 	movi	r5,1
 10044a0:	e1000217 	ldw	r4,8(fp)
 10044a4:	10042880 	call	1004288 <xQueueGenericReset>
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
 10044a8:	0001883a 	nop
 10044ac:	e037883a 	mov	sp,fp
 10044b0:	dfc00117 	ldw	ra,4(sp)
 10044b4:	df000017 	ldw	fp,0(sp)
 10044b8:	dec00204 	addi	sp,sp,8
 10044bc:	f800283a 	ret

010044c0 <prvInitialiseMutex>:
/*-----------------------------------------------------------*/

#if( configUSE_MUTEXES == 1 )

	static void prvInitialiseMutex( Queue_t *pxNewQueue )
	{
 10044c0:	defffd04 	addi	sp,sp,-12
 10044c4:	dfc00215 	stw	ra,8(sp)
 10044c8:	df000115 	stw	fp,4(sp)
 10044cc:	df000104 	addi	fp,sp,4
 10044d0:	e13fff15 	stw	r4,-4(fp)
		if( pxNewQueue != NULL )
 10044d4:	e0bfff17 	ldw	r2,-4(fp)
 10044d8:	10000b26 	beq	r2,zero,1004508 <prvInitialiseMutex+0x48>
		{
			/* The queue create function will set all the queue structure members
			correctly for a generic queue, but this function is creating a
			mutex.  Overwrite those members that need to be set differently -
			in particular the information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
 10044dc:	e0bfff17 	ldw	r2,-4(fp)
 10044e0:	10000115 	stw	zero,4(r2)
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 10044e4:	e0bfff17 	ldw	r2,-4(fp)
 10044e8:	10000015 	stw	zero,0(r2)

			/* In case this is a recursive mutex. */
			pxNewQueue->u.uxRecursiveCallCount = 0;
 10044ec:	e0bfff17 	ldw	r2,-4(fp)
 10044f0:	10000315 	stw	zero,12(r2)

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 10044f4:	000f883a 	mov	r7,zero
 10044f8:	000d883a 	mov	r6,zero
 10044fc:	000b883a 	mov	r5,zero
 1004500:	e13fff17 	ldw	r4,-4(fp)
 1004504:	10047080 	call	1004708 <xQueueGenericSend>
		}
		else
		{
			traceCREATE_MUTEX_FAILED();
		}
	}
 1004508:	0001883a 	nop
 100450c:	e037883a 	mov	sp,fp
 1004510:	dfc00117 	ldw	ra,4(sp)
 1004514:	df000017 	ldw	fp,0(sp)
 1004518:	dec00204 	addi	sp,sp,8
 100451c:	f800283a 	ret

01004520 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
 1004520:	defffa04 	addi	sp,sp,-24
 1004524:	dfc00515 	stw	ra,20(sp)
 1004528:	df000415 	stw	fp,16(sp)
 100452c:	df000404 	addi	fp,sp,16
 1004530:	2005883a 	mov	r2,r4
 1004534:	e0bfff05 	stb	r2,-4(fp)
	Queue_t *pxNewQueue;
	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
 1004538:	00800044 	movi	r2,1
 100453c:	e0bffc15 	stw	r2,-16(fp)
 1004540:	e03ffd15 	stw	zero,-12(fp)

		pxNewQueue = ( Queue_t * ) xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
 1004544:	e0bfff03 	ldbu	r2,-4(fp)
 1004548:	100d883a 	mov	r6,r2
 100454c:	e17ffd17 	ldw	r5,-12(fp)
 1004550:	e13ffc17 	ldw	r4,-16(fp)
 1004554:	100439c0 	call	100439c <xQueueGenericCreate>
 1004558:	e0bffe15 	stw	r2,-8(fp)
		prvInitialiseMutex( pxNewQueue );
 100455c:	e13ffe17 	ldw	r4,-8(fp)
 1004560:	10044c00 	call	10044c0 <prvInitialiseMutex>

		return pxNewQueue;
 1004564:	e0bffe17 	ldw	r2,-8(fp)
	}
 1004568:	e037883a 	mov	sp,fp
 100456c:	dfc00117 	ldw	ra,4(sp)
 1004570:	df000017 	ldw	fp,0(sp)
 1004574:	dec00204 	addi	sp,sp,8
 1004578:	f800283a 	ret

0100457c <xQueueGiveMutexRecursive>:
/*-----------------------------------------------------------*/

#if ( configUSE_RECURSIVE_MUTEXES == 1 )

	BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
	{
 100457c:	defffa04 	addi	sp,sp,-24
 1004580:	dfc00515 	stw	ra,20(sp)
 1004584:	df000415 	stw	fp,16(sp)
 1004588:	dc000315 	stw	r16,12(sp)
 100458c:	df000404 	addi	fp,sp,16
 1004590:	e13ffe15 	stw	r4,-8(fp)
	BaseType_t xReturn;
	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 1004594:	e0bffe17 	ldw	r2,-8(fp)
 1004598:	e0bffd15 	stw	r2,-12(fp)
		change outside of this task.  If this task does not hold the mutex then
		pxMutexHolder can never coincidentally equal the tasks handle, and as
		this is the only condition we are interested in it does not matter if
		pxMutexHolder is accessed simultaneously by another task.  Therefore no
		mutual exclusion is required to test the pxMutexHolder variable. */
		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Not a redundant cast as TaskHandle_t is a typedef. */
 100459c:	e0bffd17 	ldw	r2,-12(fp)
 10045a0:	14000117 	ldw	r16,4(r2)
 10045a4:	1006b1c0 	call	1006b1c <xTaskGetCurrentTaskHandle>
 10045a8:	8080101e 	bne	r16,r2,10045ec <xQueueGiveMutexRecursive+0x70>
			/* uxRecursiveCallCount cannot be zero if pxMutexHolder is equal to
			the task handle, therefore no underflow check is required.  Also,
			uxRecursiveCallCount is only modified by the mutex holder, and as
			there can only be one, no mutual exclusion is required to modify the
			uxRecursiveCallCount member. */
			( pxMutex->u.uxRecursiveCallCount )--;
 10045ac:	e0bffd17 	ldw	r2,-12(fp)
 10045b0:	10800317 	ldw	r2,12(r2)
 10045b4:	10ffffc4 	addi	r3,r2,-1
 10045b8:	e0bffd17 	ldw	r2,-12(fp)
 10045bc:	10c00315 	stw	r3,12(r2)

			/* Has the recursive call count unwound to 0? */
			if( pxMutex->u.uxRecursiveCallCount == ( UBaseType_t ) 0 )
 10045c0:	e0bffd17 	ldw	r2,-12(fp)
 10045c4:	10800317 	ldw	r2,12(r2)
 10045c8:	1000051e 	bne	r2,zero,10045e0 <xQueueGiveMutexRecursive+0x64>
			{
				/* Return the mutex.  This will automatically unblock any other
				task that might be waiting to access the mutex. */
				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
 10045cc:	000f883a 	mov	r7,zero
 10045d0:	000d883a 	mov	r6,zero
 10045d4:	000b883a 	mov	r5,zero
 10045d8:	e13ffd17 	ldw	r4,-12(fp)
 10045dc:	10047080 	call	1004708 <xQueueGenericSend>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			xReturn = pdPASS;
 10045e0:	00800044 	movi	r2,1
 10045e4:	e0bffc15 	stw	r2,-16(fp)
 10045e8:	00000106 	br	10045f0 <xQueueGiveMutexRecursive+0x74>
		}
		else
		{
			/* The mutex cannot be given because the calling task is not the
			holder. */
			xReturn = pdFAIL;
 10045ec:	e03ffc15 	stw	zero,-16(fp)

			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
		}

		return xReturn;
 10045f0:	e0bffc17 	ldw	r2,-16(fp)
	}
 10045f4:	e6ffff04 	addi	sp,fp,-4
 10045f8:	dfc00217 	ldw	ra,8(sp)
 10045fc:	df000117 	ldw	fp,4(sp)
 1004600:	dc000017 	ldw	r16,0(sp)
 1004604:	dec00304 	addi	sp,sp,12
 1004608:	f800283a 	ret

0100460c <xQueueTakeMutexRecursive>:
/*-----------------------------------------------------------*/

#if ( configUSE_RECURSIVE_MUTEXES == 1 )

	BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait )
	{
 100460c:	defff904 	addi	sp,sp,-28
 1004610:	dfc00615 	stw	ra,24(sp)
 1004614:	df000515 	stw	fp,20(sp)
 1004618:	dc000415 	stw	r16,16(sp)
 100461c:	df000504 	addi	fp,sp,20
 1004620:	e13ffd15 	stw	r4,-12(fp)
 1004624:	e17ffe15 	stw	r5,-8(fp)
	BaseType_t xReturn;
	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
 1004628:	e0bffd17 	ldw	r2,-12(fp)
 100462c:	e0bffc15 	stw	r2,-16(fp)
		/* Comments regarding mutual exclusion as per those within
		xQueueGiveMutexRecursive(). */

		traceTAKE_MUTEX_RECURSIVE( pxMutex );

		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
 1004630:	e0bffc17 	ldw	r2,-16(fp)
 1004634:	14000117 	ldw	r16,4(r2)
 1004638:	1006b1c0 	call	1006b1c <xTaskGetCurrentTaskHandle>
 100463c:	8080081e 	bne	r16,r2,1004660 <xQueueTakeMutexRecursive+0x54>
		{
			( pxMutex->u.uxRecursiveCallCount )++;
 1004640:	e0bffc17 	ldw	r2,-16(fp)
 1004644:	10800317 	ldw	r2,12(r2)
 1004648:	10c00044 	addi	r3,r2,1
 100464c:	e0bffc17 	ldw	r2,-16(fp)
 1004650:	10c00315 	stw	r3,12(r2)
			xReturn = pdPASS;
 1004654:	00800044 	movi	r2,1
 1004658:	e0bffb15 	stw	r2,-20(fp)
 100465c:	00000d06 	br	1004694 <xQueueTakeMutexRecursive+0x88>
		}
		else
		{
			xReturn = xQueueGenericReceive( pxMutex, NULL, xTicksToWait, pdFALSE );
 1004660:	000f883a 	mov	r7,zero
 1004664:	e1bffe17 	ldw	r6,-8(fp)
 1004668:	000b883a 	mov	r5,zero
 100466c:	e13ffc17 	ldw	r4,-16(fp)
 1004670:	1004a800 	call	1004a80 <xQueueGenericReceive>
 1004674:	e0bffb15 	stw	r2,-20(fp)

			/* pdPASS will only be returned if the mutex was successfully
			obtained.  The calling task may have entered the Blocked state
			before reaching here. */
			if( xReturn != pdFAIL )
 1004678:	e0bffb17 	ldw	r2,-20(fp)
 100467c:	10000526 	beq	r2,zero,1004694 <xQueueTakeMutexRecursive+0x88>
			{
				( pxMutex->u.uxRecursiveCallCount )++;
 1004680:	e0bffc17 	ldw	r2,-16(fp)
 1004684:	10800317 	ldw	r2,12(r2)
 1004688:	10c00044 	addi	r3,r2,1
 100468c:	e0bffc17 	ldw	r2,-16(fp)
 1004690:	10c00315 	stw	r3,12(r2)
			{
				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
			}
		}

		return xReturn;
 1004694:	e0bffb17 	ldw	r2,-20(fp)
	}
 1004698:	e6ffff04 	addi	sp,fp,-4
 100469c:	dfc00217 	ldw	ra,8(sp)
 10046a0:	df000117 	ldw	fp,4(sp)
 10046a4:	dc000017 	ldw	r16,0(sp)
 10046a8:	dec00304 	addi	sp,sp,12
 10046ac:	f800283a 	ret

010046b0 <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )
	{
 10046b0:	defffb04 	addi	sp,sp,-20
 10046b4:	dfc00415 	stw	ra,16(sp)
 10046b8:	df000315 	stw	fp,12(sp)
 10046bc:	df000304 	addi	fp,sp,12
 10046c0:	e13ffe15 	stw	r4,-8(fp)
 10046c4:	e17fff15 	stw	r5,-4(fp)
	QueueHandle_t xHandle;

		configASSERT( uxMaxCount != 0 );
		configASSERT( uxInitialCount <= uxMaxCount );

		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
 10046c8:	01800084 	movi	r6,2
 10046cc:	000b883a 	mov	r5,zero
 10046d0:	e13ffe17 	ldw	r4,-8(fp)
 10046d4:	100439c0 	call	100439c <xQueueGenericCreate>
 10046d8:	e0bffd15 	stw	r2,-12(fp)

		if( xHandle != NULL )
 10046dc:	e0bffd17 	ldw	r2,-12(fp)
 10046e0:	10000326 	beq	r2,zero,10046f0 <xQueueCreateCountingSemaphore+0x40>
		{
			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 10046e4:	e0bffd17 	ldw	r2,-12(fp)
 10046e8:	e0ffff17 	ldw	r3,-4(fp)
 10046ec:	10c00e15 	stw	r3,56(r2)
		else
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		return xHandle;
 10046f0:	e0bffd17 	ldw	r2,-12(fp)
	}
 10046f4:	e037883a 	mov	sp,fp
 10046f8:	dfc00117 	ldw	ra,4(sp)
 10046fc:	df000017 	ldw	fp,0(sp)
 1004700:	dec00204 	addi	sp,sp,8
 1004704:	f800283a 	ret

01004708 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
 1004708:	defff504 	addi	sp,sp,-44
 100470c:	dfc00a15 	stw	ra,40(sp)
 1004710:	df000915 	stw	fp,36(sp)
 1004714:	df000904 	addi	fp,sp,36
 1004718:	e13ffc15 	stw	r4,-16(fp)
 100471c:	e17ffd15 	stw	r5,-12(fp)
 1004720:	e1bffe15 	stw	r6,-8(fp)
 1004724:	e1ffff15 	stw	r7,-4(fp)
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 1004728:	e03ff715 	stw	zero,-36(fp)
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 100472c:	e0bffc17 	ldw	r2,-16(fp)
 1004730:	e0bff815 	stw	r2,-32(fp)
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
 1004734:	1006d680 	call	1006d68 <vTaskEnterCritical>
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 1004738:	e0bff817 	ldw	r2,-32(fp)
 100473c:	10c00e17 	ldw	r3,56(r2)
 1004740:	e0bff817 	ldw	r2,-32(fp)
 1004744:	10800f17 	ldw	r2,60(r2)
 1004748:	18800336 	bltu	r3,r2,1004758 <xQueueGenericSend+0x50>
 100474c:	e0bfff17 	ldw	r2,-4(fp)
 1004750:	10800098 	cmpnei	r2,r2,2
 1004754:	1000151e 	bne	r2,zero,10047ac <xQueueGenericSend+0xa4>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 1004758:	e1bfff17 	ldw	r6,-4(fp)
 100475c:	e17ffd17 	ldw	r5,-12(fp)
 1004760:	e13ff817 	ldw	r4,-32(fp)
 1004764:	1004f140 	call	1004f14 <prvCopyDataToQueue>
 1004768:	e0bff915 	stw	r2,-28(fp)
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 100476c:	e0bff817 	ldw	r2,-32(fp)
 1004770:	10800917 	ldw	r2,36(r2)
 1004774:	10000726 	beq	r2,zero,1004794 <xQueueGenericSend+0x8c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 1004778:	e0bff817 	ldw	r2,-32(fp)
 100477c:	10800904 	addi	r2,r2,36
 1004780:	1009883a 	mov	r4,r2
 1004784:	10065240 	call	1006524 <xTaskRemoveFromEventList>
 1004788:	10000526 	beq	r2,zero,10047a0 <xQueueGenericSend+0x98>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
 100478c:	003b683a 	trap	0
 1004790:	00000306 	br	10047a0 <xQueueGenericSend+0x98>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
 1004794:	e0bff917 	ldw	r2,-28(fp)
 1004798:	10000126 	beq	r2,zero,10047a0 <xQueueGenericSend+0x98>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
 100479c:	003b683a 	trap	0
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
 10047a0:	1006dbc0 	call	1006dbc <vTaskExitCritical>
				return pdPASS;
 10047a4:	00800044 	movi	r2,1
 10047a8:	00003f06 	br	10048a8 <xQueueGenericSend+0x1a0>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
 10047ac:	e0bffe17 	ldw	r2,-8(fp)
 10047b0:	1000031e 	bne	r2,zero,10047c0 <xQueueGenericSend+0xb8>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
 10047b4:	1006dbc0 	call	1006dbc <vTaskExitCritical>

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
 10047b8:	0005883a 	mov	r2,zero
 10047bc:	00003a06 	br	10048a8 <xQueueGenericSend+0x1a0>
				}
				else if( xEntryTimeSet == pdFALSE )
 10047c0:	e0bff717 	ldw	r2,-36(fp)
 10047c4:	1000051e 	bne	r2,zero,10047dc <xQueueGenericSend+0xd4>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
 10047c8:	e0bffa04 	addi	r2,fp,-24
 10047cc:	1009883a 	mov	r4,r2
 10047d0:	10066f00 	call	10066f0 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 10047d4:	00800044 	movi	r2,1
 10047d8:	e0bff715 	stw	r2,-36(fp)
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
 10047dc:	1006dbc0 	call	1006dbc <vTaskExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
 10047e0:	1005f9c0 	call	1005f9c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 10047e4:	1006d680 	call	1006d68 <vTaskEnterCritical>
 10047e8:	e0bff817 	ldw	r2,-32(fp)
 10047ec:	10801103 	ldbu	r2,68(r2)
 10047f0:	10803fcc 	andi	r2,r2,255
 10047f4:	1080201c 	xori	r2,r2,128
 10047f8:	10bfe004 	addi	r2,r2,-128
 10047fc:	10bfffd8 	cmpnei	r2,r2,-1
 1004800:	1000021e 	bne	r2,zero,100480c <xQueueGenericSend+0x104>
 1004804:	e0bff817 	ldw	r2,-32(fp)
 1004808:	10001105 	stb	zero,68(r2)
 100480c:	e0bff817 	ldw	r2,-32(fp)
 1004810:	10801143 	ldbu	r2,69(r2)
 1004814:	10803fcc 	andi	r2,r2,255
 1004818:	1080201c 	xori	r2,r2,128
 100481c:	10bfe004 	addi	r2,r2,-128
 1004820:	10bfffd8 	cmpnei	r2,r2,-1
 1004824:	1000021e 	bne	r2,zero,1004830 <xQueueGenericSend+0x128>
 1004828:	e0bff817 	ldw	r2,-32(fp)
 100482c:	10001145 	stb	zero,69(r2)
 1004830:	1006dbc0 	call	1006dbc <vTaskExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 1004834:	e0fffe04 	addi	r3,fp,-8
 1004838:	e0bffa04 	addi	r2,fp,-24
 100483c:	180b883a 	mov	r5,r3
 1004840:	1009883a 	mov	r4,r2
 1004844:	100672c0 	call	100672c <xTaskCheckForTimeOut>
 1004848:	1000131e 	bne	r2,zero,1004898 <xQueueGenericSend+0x190>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 100484c:	e13ff817 	ldw	r4,-32(fp)
 1004850:	10052c00 	call	10052c0 <prvIsQueueFull>
 1004854:	10000c26 	beq	r2,zero,1004888 <xQueueGenericSend+0x180>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 1004858:	e0bff817 	ldw	r2,-32(fp)
 100485c:	10800404 	addi	r2,r2,16
 1004860:	e0fffe17 	ldw	r3,-8(fp)
 1004864:	180b883a 	mov	r5,r3
 1004868:	1009883a 	mov	r4,r2
 100486c:	10064700 	call	1006470 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
 1004870:	e13ff817 	ldw	r4,-32(fp)
 1004874:	100513c0 	call	100513c <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
 1004878:	1005fc80 	call	1005fc8 <xTaskResumeAll>
 100487c:	103fad1e 	bne	r2,zero,1004734 <__alt_data_end+0xff804734>
				{
					portYIELD_WITHIN_API();
 1004880:	003b683a 	trap	0
 1004884:	003fab06 	br	1004734 <__alt_data_end+0xff804734>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
 1004888:	e13ff817 	ldw	r4,-32(fp)
 100488c:	100513c0 	call	100513c <prvUnlockQueue>
				( void ) xTaskResumeAll();
 1004890:	1005fc80 	call	1005fc8 <xTaskResumeAll>
 1004894:	003fa706 	br	1004734 <__alt_data_end+0xff804734>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
 1004898:	e13ff817 	ldw	r4,-32(fp)
 100489c:	100513c0 	call	100513c <prvUnlockQueue>
			( void ) xTaskResumeAll();
 10048a0:	1005fc80 	call	1005fc8 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
 10048a4:	0005883a 	mov	r2,zero
		}
	}
}
 10048a8:	e037883a 	mov	sp,fp
 10048ac:	dfc00117 	ldw	ra,4(sp)
 10048b0:	df000017 	ldw	fp,0(sp)
 10048b4:	dec00204 	addi	sp,sp,8
 10048b8:	f800283a 	ret

010048bc <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
 10048bc:	defff604 	addi	sp,sp,-40
 10048c0:	dfc00915 	stw	ra,36(sp)
 10048c4:	df000815 	stw	fp,32(sp)
 10048c8:	df000804 	addi	fp,sp,32
 10048cc:	e13ffc15 	stw	r4,-16(fp)
 10048d0:	e17ffd15 	stw	r5,-12(fp)
 10048d4:	e1bffe15 	stw	r6,-8(fp)
 10048d8:	e1ffff15 	stw	r7,-4(fp)
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 10048dc:	e0bffc17 	ldw	r2,-16(fp)
 10048e0:	e0bff915 	stw	r2,-28(fp)
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 10048e4:	e03ffa15 	stw	zero,-24(fp)
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 10048e8:	e0bff917 	ldw	r2,-28(fp)
 10048ec:	10c00e17 	ldw	r3,56(r2)
 10048f0:	e0bff917 	ldw	r2,-28(fp)
 10048f4:	10800f17 	ldw	r2,60(r2)
 10048f8:	18800336 	bltu	r3,r2,1004908 <xQueueGenericSendFromISR+0x4c>
 10048fc:	e0bfff17 	ldw	r2,-4(fp)
 1004900:	10800098 	cmpnei	r2,r2,2
 1004904:	1000201e 	bne	r2,zero,1004988 <xQueueGenericSendFromISR+0xcc>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
 1004908:	e0bff917 	ldw	r2,-28(fp)
 100490c:	10801143 	ldbu	r2,69(r2)
 1004910:	e0bffb05 	stb	r2,-20(fp)
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 1004914:	e1bfff17 	ldw	r6,-4(fp)
 1004918:	e17ffd17 	ldw	r5,-12(fp)
 100491c:	e13ff917 	ldw	r4,-28(fp)
 1004920:	1004f140 	call	1004f14 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
 1004924:	e0bffb07 	ldb	r2,-20(fp)
 1004928:	10bfffd8 	cmpnei	r2,r2,-1
 100492c:	10000e1e 	bne	r2,zero,1004968 <xQueueGenericSendFromISR+0xac>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 1004930:	e0bff917 	ldw	r2,-28(fp)
 1004934:	10800917 	ldw	r2,36(r2)
 1004938:	10001026 	beq	r2,zero,100497c <xQueueGenericSendFromISR+0xc0>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 100493c:	e0bff917 	ldw	r2,-28(fp)
 1004940:	10800904 	addi	r2,r2,36
 1004944:	1009883a 	mov	r4,r2
 1004948:	10065240 	call	1006524 <xTaskRemoveFromEventList>
 100494c:	10000b26 	beq	r2,zero,100497c <xQueueGenericSendFromISR+0xc0>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
 1004950:	e0bffe17 	ldw	r2,-8(fp)
 1004954:	10000926 	beq	r2,zero,100497c <xQueueGenericSendFromISR+0xc0>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
 1004958:	e0bffe17 	ldw	r2,-8(fp)
 100495c:	00c00044 	movi	r3,1
 1004960:	10c00015 	stw	r3,0(r2)
 1004964:	00000506 	br	100497c <xQueueGenericSendFromISR+0xc0>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 1004968:	e0bffb03 	ldbu	r2,-20(fp)
 100496c:	10800044 	addi	r2,r2,1
 1004970:	1007883a 	mov	r3,r2
 1004974:	e0bff917 	ldw	r2,-28(fp)
 1004978:	10c01145 	stb	r3,69(r2)
			}

			xReturn = pdPASS;
 100497c:	00800044 	movi	r2,1
 1004980:	e0bff815 	stw	r2,-32(fp)
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
		{
 1004984:	00000106 	br	100498c <xQueueGenericSendFromISR+0xd0>
			xReturn = pdPASS;
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
 1004988:	e03ff815 	stw	zero,-32(fp)
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
 100498c:	e0bff817 	ldw	r2,-32(fp)
}
 1004990:	e037883a 	mov	sp,fp
 1004994:	dfc00117 	ldw	ra,4(sp)
 1004998:	df000017 	ldw	fp,0(sp)
 100499c:	dec00204 	addi	sp,sp,8
 10049a0:	f800283a 	ret

010049a4 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
 10049a4:	defff704 	addi	sp,sp,-36
 10049a8:	dfc00815 	stw	ra,32(sp)
 10049ac:	df000715 	stw	fp,28(sp)
 10049b0:	df000704 	addi	fp,sp,28
 10049b4:	e13ffe15 	stw	r4,-8(fp)
 10049b8:	e17fff15 	stw	r5,-4(fp)
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 10049bc:	e0bffe17 	ldw	r2,-8(fp)
 10049c0:	e0bffa15 	stw	r2,-24(fp)
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 10049c4:	e03ffb15 	stw	zero,-20(fp)
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 10049c8:	e0bffa17 	ldw	r2,-24(fp)
 10049cc:	10800e17 	ldw	r2,56(r2)
 10049d0:	e0bffc15 	stw	r2,-16(fp)

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
 10049d4:	e0bffa17 	ldw	r2,-24(fp)
 10049d8:	10800f17 	ldw	r2,60(r2)
 10049dc:	e0fffc17 	ldw	r3,-16(fp)
 10049e0:	1880202e 	bgeu	r3,r2,1004a64 <xQueueGiveFromISR+0xc0>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
 10049e4:	e0bffa17 	ldw	r2,-24(fp)
 10049e8:	10801143 	ldbu	r2,69(r2)
 10049ec:	e0bffd05 	stb	r2,-12(fp)
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
 10049f0:	e0bffc17 	ldw	r2,-16(fp)
 10049f4:	10c00044 	addi	r3,r2,1
 10049f8:	e0bffa17 	ldw	r2,-24(fp)
 10049fc:	10c00e15 	stw	r3,56(r2)

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
 1004a00:	e0bffd07 	ldb	r2,-12(fp)
 1004a04:	10bfffd8 	cmpnei	r2,r2,-1
 1004a08:	10000e1e 	bne	r2,zero,1004a44 <xQueueGiveFromISR+0xa0>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 1004a0c:	e0bffa17 	ldw	r2,-24(fp)
 1004a10:	10800917 	ldw	r2,36(r2)
 1004a14:	10001026 	beq	r2,zero,1004a58 <xQueueGiveFromISR+0xb4>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 1004a18:	e0bffa17 	ldw	r2,-24(fp)
 1004a1c:	10800904 	addi	r2,r2,36
 1004a20:	1009883a 	mov	r4,r2
 1004a24:	10065240 	call	1006524 <xTaskRemoveFromEventList>
 1004a28:	10000b26 	beq	r2,zero,1004a58 <xQueueGiveFromISR+0xb4>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
 1004a2c:	e0bfff17 	ldw	r2,-4(fp)
 1004a30:	10000926 	beq	r2,zero,1004a58 <xQueueGiveFromISR+0xb4>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
 1004a34:	e0bfff17 	ldw	r2,-4(fp)
 1004a38:	00c00044 	movi	r3,1
 1004a3c:	10c00015 	stw	r3,0(r2)
 1004a40:	00000506 	br	1004a58 <xQueueGiveFromISR+0xb4>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 1004a44:	e0bffd03 	ldbu	r2,-12(fp)
 1004a48:	10800044 	addi	r2,r2,1
 1004a4c:	1007883a 	mov	r3,r2
 1004a50:	e0bffa17 	ldw	r2,-24(fp)
 1004a54:	10c01145 	stb	r3,69(r2)
			}

			xReturn = pdPASS;
 1004a58:	00800044 	movi	r2,1
 1004a5c:	e0bff915 	stw	r2,-28(fp)
 1004a60:	00000106 	br	1004a68 <xQueueGiveFromISR+0xc4>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
 1004a64:	e03ff915 	stw	zero,-28(fp)
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
 1004a68:	e0bff917 	ldw	r2,-28(fp)
}
 1004a6c:	e037883a 	mov	sp,fp
 1004a70:	dfc00117 	ldw	ra,4(sp)
 1004a74:	df000017 	ldw	fp,0(sp)
 1004a78:	dec00204 	addi	sp,sp,8
 1004a7c:	f800283a 	ret

01004a80 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
 1004a80:	defff404 	addi	sp,sp,-48
 1004a84:	dfc00b15 	stw	ra,44(sp)
 1004a88:	df000a15 	stw	fp,40(sp)
 1004a8c:	df000a04 	addi	fp,sp,40
 1004a90:	e13ffc15 	stw	r4,-16(fp)
 1004a94:	e17ffd15 	stw	r5,-12(fp)
 1004a98:	e1bffe15 	stw	r6,-8(fp)
 1004a9c:	e1ffff15 	stw	r7,-4(fp)
BaseType_t xEntryTimeSet = pdFALSE;
 1004aa0:	e03ff615 	stw	zero,-40(fp)
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 1004aa4:	e0bffc17 	ldw	r2,-16(fp)
 1004aa8:	e0bff715 	stw	r2,-36(fp)
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
 1004aac:	1006d680 	call	1006d68 <vTaskEnterCritical>
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 1004ab0:	e0bff717 	ldw	r2,-36(fp)
 1004ab4:	10800e17 	ldw	r2,56(r2)
 1004ab8:	e0bff815 	stw	r2,-32(fp)

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 1004abc:	e0bff817 	ldw	r2,-32(fp)
 1004ac0:	10002c26 	beq	r2,zero,1004b74 <xQueueGenericReceive+0xf4>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
 1004ac4:	e0bff717 	ldw	r2,-36(fp)
 1004ac8:	10800317 	ldw	r2,12(r2)
 1004acc:	e0bff915 	stw	r2,-28(fp)

				prvCopyDataFromQueue( pxQueue, pvBuffer );
 1004ad0:	e17ffd17 	ldw	r5,-12(fp)
 1004ad4:	e13ff717 	ldw	r4,-36(fp)
 1004ad8:	10050a00 	call	10050a0 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
 1004adc:	e0bfff17 	ldw	r2,-4(fp)
 1004ae0:	1000151e 	bne	r2,zero,1004b38 <xQueueGenericReceive+0xb8>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
 1004ae4:	e0bff817 	ldw	r2,-32(fp)
 1004ae8:	10ffffc4 	addi	r3,r2,-1
 1004aec:	e0bff717 	ldw	r2,-36(fp)
 1004af0:	10c00e15 	stw	r3,56(r2)

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 1004af4:	e0bff717 	ldw	r2,-36(fp)
 1004af8:	10800017 	ldw	r2,0(r2)
 1004afc:	1000041e 	bne	r2,zero,1004b10 <xQueueGenericReceive+0x90>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
 1004b00:	1006e600 	call	1006e60 <pvTaskIncrementMutexHeldCount>
 1004b04:	1007883a 	mov	r3,r2
 1004b08:	e0bff717 	ldw	r2,-36(fp)
 1004b0c:	10c00115 	stw	r3,4(r2)
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 1004b10:	e0bff717 	ldw	r2,-36(fp)
 1004b14:	10800417 	ldw	r2,16(r2)
 1004b18:	10001326 	beq	r2,zero,1004b68 <xQueueGenericReceive+0xe8>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 1004b1c:	e0bff717 	ldw	r2,-36(fp)
 1004b20:	10800404 	addi	r2,r2,16
 1004b24:	1009883a 	mov	r4,r2
 1004b28:	10065240 	call	1006524 <xTaskRemoveFromEventList>
 1004b2c:	10000e26 	beq	r2,zero,1004b68 <xQueueGenericReceive+0xe8>
						{
							queueYIELD_IF_USING_PREEMPTION();
 1004b30:	003b683a 	trap	0
 1004b34:	00000c06 	br	1004b68 <xQueueGenericReceive+0xe8>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 1004b38:	e0bff717 	ldw	r2,-36(fp)
 1004b3c:	e0fff917 	ldw	r3,-28(fp)
 1004b40:	10c00315 	stw	r3,12(r2)

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 1004b44:	e0bff717 	ldw	r2,-36(fp)
 1004b48:	10800917 	ldw	r2,36(r2)
 1004b4c:	10000626 	beq	r2,zero,1004b68 <xQueueGenericReceive+0xe8>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 1004b50:	e0bff717 	ldw	r2,-36(fp)
 1004b54:	10800904 	addi	r2,r2,36
 1004b58:	1009883a 	mov	r4,r2
 1004b5c:	10065240 	call	1006524 <xTaskRemoveFromEventList>
 1004b60:	10000126 	beq	r2,zero,1004b68 <xQueueGenericReceive+0xe8>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
 1004b64:	003b683a 	trap	0
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
 1004b68:	1006dbc0 	call	1006dbc <vTaskExitCritical>
				return pdPASS;
 1004b6c:	00800044 	movi	r2,1
 1004b70:	00004b06 	br	1004ca0 <xQueueGenericReceive+0x220>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
 1004b74:	e0bffe17 	ldw	r2,-8(fp)
 1004b78:	1000031e 	bne	r2,zero,1004b88 <xQueueGenericReceive+0x108>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
 1004b7c:	1006dbc0 	call	1006dbc <vTaskExitCritical>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
 1004b80:	0005883a 	mov	r2,zero
 1004b84:	00004606 	br	1004ca0 <xQueueGenericReceive+0x220>
				}
				else if( xEntryTimeSet == pdFALSE )
 1004b88:	e0bff617 	ldw	r2,-40(fp)
 1004b8c:	1000051e 	bne	r2,zero,1004ba4 <xQueueGenericReceive+0x124>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
 1004b90:	e0bffa04 	addi	r2,fp,-24
 1004b94:	1009883a 	mov	r4,r2
 1004b98:	10066f00 	call	10066f0 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 1004b9c:	00800044 	movi	r2,1
 1004ba0:	e0bff615 	stw	r2,-40(fp)
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
 1004ba4:	1006dbc0 	call	1006dbc <vTaskExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
 1004ba8:	1005f9c0 	call	1005f9c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 1004bac:	1006d680 	call	1006d68 <vTaskEnterCritical>
 1004bb0:	e0bff717 	ldw	r2,-36(fp)
 1004bb4:	10801103 	ldbu	r2,68(r2)
 1004bb8:	10803fcc 	andi	r2,r2,255
 1004bbc:	1080201c 	xori	r2,r2,128
 1004bc0:	10bfe004 	addi	r2,r2,-128
 1004bc4:	10bfffd8 	cmpnei	r2,r2,-1
 1004bc8:	1000021e 	bne	r2,zero,1004bd4 <xQueueGenericReceive+0x154>
 1004bcc:	e0bff717 	ldw	r2,-36(fp)
 1004bd0:	10001105 	stb	zero,68(r2)
 1004bd4:	e0bff717 	ldw	r2,-36(fp)
 1004bd8:	10801143 	ldbu	r2,69(r2)
 1004bdc:	10803fcc 	andi	r2,r2,255
 1004be0:	1080201c 	xori	r2,r2,128
 1004be4:	10bfe004 	addi	r2,r2,-128
 1004be8:	10bfffd8 	cmpnei	r2,r2,-1
 1004bec:	1000021e 	bne	r2,zero,1004bf8 <xQueueGenericReceive+0x178>
 1004bf0:	e0bff717 	ldw	r2,-36(fp)
 1004bf4:	10001145 	stb	zero,69(r2)
 1004bf8:	1006dbc0 	call	1006dbc <vTaskExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 1004bfc:	e0fffe04 	addi	r3,fp,-8
 1004c00:	e0bffa04 	addi	r2,fp,-24
 1004c04:	180b883a 	mov	r5,r3
 1004c08:	1009883a 	mov	r4,r2
 1004c0c:	100672c0 	call	100672c <xTaskCheckForTimeOut>
 1004c10:	10001c1e 	bne	r2,zero,1004c84 <xQueueGenericReceive+0x204>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 1004c14:	e13ff717 	ldw	r4,-36(fp)
 1004c18:	10052300 	call	1005230 <prvIsQueueEmpty>
 1004c1c:	10001526 	beq	r2,zero,1004c74 <xQueueGenericReceive+0x1f4>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 1004c20:	e0bff717 	ldw	r2,-36(fp)
 1004c24:	10800017 	ldw	r2,0(r2)
 1004c28:	1000061e 	bne	r2,zero,1004c44 <xQueueGenericReceive+0x1c4>
					{
						taskENTER_CRITICAL();
 1004c2c:	1006d680 	call	1006d68 <vTaskEnterCritical>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 1004c30:	e0bff717 	ldw	r2,-36(fp)
 1004c34:	10800117 	ldw	r2,4(r2)
 1004c38:	1009883a 	mov	r4,r2
 1004c3c:	1006b440 	call	1006b44 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
 1004c40:	1006dbc0 	call	1006dbc <vTaskExitCritical>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 1004c44:	e0bff717 	ldw	r2,-36(fp)
 1004c48:	10800904 	addi	r2,r2,36
 1004c4c:	e0fffe17 	ldw	r3,-8(fp)
 1004c50:	180b883a 	mov	r5,r3
 1004c54:	1009883a 	mov	r4,r2
 1004c58:	10064700 	call	1006470 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 1004c5c:	e13ff717 	ldw	r4,-36(fp)
 1004c60:	100513c0 	call	100513c <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 1004c64:	1005fc80 	call	1005fc8 <xTaskResumeAll>
 1004c68:	103f901e 	bne	r2,zero,1004aac <__alt_data_end+0xff804aac>
				{
					portYIELD_WITHIN_API();
 1004c6c:	003b683a 	trap	0
 1004c70:	003f8e06 	br	1004aac <__alt_data_end+0xff804aac>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
 1004c74:	e13ff717 	ldw	r4,-36(fp)
 1004c78:	100513c0 	call	100513c <prvUnlockQueue>
				( void ) xTaskResumeAll();
 1004c7c:	1005fc80 	call	1005fc8 <xTaskResumeAll>
 1004c80:	003f8a06 	br	1004aac <__alt_data_end+0xff804aac>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
 1004c84:	e13ff717 	ldw	r4,-36(fp)
 1004c88:	100513c0 	call	100513c <prvUnlockQueue>
			( void ) xTaskResumeAll();
 1004c8c:	1005fc80 	call	1005fc8 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 1004c90:	e13ff717 	ldw	r4,-36(fp)
 1004c94:	10052300 	call	1005230 <prvIsQueueEmpty>
 1004c98:	103f8426 	beq	r2,zero,1004aac <__alt_data_end+0xff804aac>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
 1004c9c:	0005883a 	mov	r2,zero
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
 1004ca0:	e037883a 	mov	sp,fp
 1004ca4:	dfc00117 	ldw	ra,4(sp)
 1004ca8:	df000017 	ldw	fp,0(sp)
 1004cac:	dec00204 	addi	sp,sp,8
 1004cb0:	f800283a 	ret

01004cb4 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
 1004cb4:	defff604 	addi	sp,sp,-40
 1004cb8:	dfc00915 	stw	ra,36(sp)
 1004cbc:	df000815 	stw	fp,32(sp)
 1004cc0:	df000804 	addi	fp,sp,32
 1004cc4:	e13ffd15 	stw	r4,-12(fp)
 1004cc8:	e17ffe15 	stw	r5,-8(fp)
 1004ccc:	e1bfff15 	stw	r6,-4(fp)
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 1004cd0:	e0bffd17 	ldw	r2,-12(fp)
 1004cd4:	e0bff915 	stw	r2,-28(fp)
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1004cd8:	e03ffa15 	stw	zero,-24(fp)
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 1004cdc:	e0bff917 	ldw	r2,-28(fp)
 1004ce0:	10800e17 	ldw	r2,56(r2)
 1004ce4:	e0bffb15 	stw	r2,-20(fp)

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 1004ce8:	e0bffb17 	ldw	r2,-20(fp)
 1004cec:	10002326 	beq	r2,zero,1004d7c <xQueueReceiveFromISR+0xc8>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
 1004cf0:	e0bff917 	ldw	r2,-28(fp)
 1004cf4:	10801103 	ldbu	r2,68(r2)
 1004cf8:	e0bffc05 	stb	r2,-16(fp)

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
 1004cfc:	e17ffe17 	ldw	r5,-8(fp)
 1004d00:	e13ff917 	ldw	r4,-28(fp)
 1004d04:	10050a00 	call	10050a0 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
 1004d08:	e0bffb17 	ldw	r2,-20(fp)
 1004d0c:	10ffffc4 	addi	r3,r2,-1
 1004d10:	e0bff917 	ldw	r2,-28(fp)
 1004d14:	10c00e15 	stw	r3,56(r2)

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
 1004d18:	e0bffc07 	ldb	r2,-16(fp)
 1004d1c:	10bfffd8 	cmpnei	r2,r2,-1
 1004d20:	10000e1e 	bne	r2,zero,1004d5c <xQueueReceiveFromISR+0xa8>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 1004d24:	e0bff917 	ldw	r2,-28(fp)
 1004d28:	10800417 	ldw	r2,16(r2)
 1004d2c:	10001026 	beq	r2,zero,1004d70 <xQueueReceiveFromISR+0xbc>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 1004d30:	e0bff917 	ldw	r2,-28(fp)
 1004d34:	10800404 	addi	r2,r2,16
 1004d38:	1009883a 	mov	r4,r2
 1004d3c:	10065240 	call	1006524 <xTaskRemoveFromEventList>
 1004d40:	10000b26 	beq	r2,zero,1004d70 <xQueueReceiveFromISR+0xbc>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
 1004d44:	e0bfff17 	ldw	r2,-4(fp)
 1004d48:	10000926 	beq	r2,zero,1004d70 <xQueueReceiveFromISR+0xbc>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
 1004d4c:	e0bfff17 	ldw	r2,-4(fp)
 1004d50:	00c00044 	movi	r3,1
 1004d54:	10c00015 	stw	r3,0(r2)
 1004d58:	00000506 	br	1004d70 <xQueueReceiveFromISR+0xbc>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
 1004d5c:	e0bffc03 	ldbu	r2,-16(fp)
 1004d60:	10800044 	addi	r2,r2,1
 1004d64:	1007883a 	mov	r3,r2
 1004d68:	e0bff917 	ldw	r2,-28(fp)
 1004d6c:	10c01105 	stb	r3,68(r2)
			}

			xReturn = pdPASS;
 1004d70:	00800044 	movi	r2,1
 1004d74:	e0bff815 	stw	r2,-32(fp)
 1004d78:	00000106 	br	1004d80 <xQueueReceiveFromISR+0xcc>
		}
		else
		{
			xReturn = pdFAIL;
 1004d7c:	e03ff815 	stw	zero,-32(fp)
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
 1004d80:	e0bff817 	ldw	r2,-32(fp)
}
 1004d84:	e037883a 	mov	sp,fp
 1004d88:	dfc00117 	ldw	ra,4(sp)
 1004d8c:	df000017 	ldw	fp,0(sp)
 1004d90:	dec00204 	addi	sp,sp,8
 1004d94:	f800283a 	ret

01004d98 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
 1004d98:	defff804 	addi	sp,sp,-32
 1004d9c:	dfc00715 	stw	ra,28(sp)
 1004da0:	df000615 	stw	fp,24(sp)
 1004da4:	df000604 	addi	fp,sp,24
 1004da8:	e13ffe15 	stw	r4,-8(fp)
 1004dac:	e17fff15 	stw	r5,-4(fp)
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 1004db0:	e0bffe17 	ldw	r2,-8(fp)
 1004db4:	e0bffb15 	stw	r2,-20(fp)
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1004db8:	e03ffc15 	stw	zero,-16(fp)
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 1004dbc:	e0bffb17 	ldw	r2,-20(fp)
 1004dc0:	10800e17 	ldw	r2,56(r2)
 1004dc4:	10000c26 	beq	r2,zero,1004df8 <xQueuePeekFromISR+0x60>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
 1004dc8:	e0bffb17 	ldw	r2,-20(fp)
 1004dcc:	10800317 	ldw	r2,12(r2)
 1004dd0:	e0bffd15 	stw	r2,-12(fp)
			prvCopyDataFromQueue( pxQueue, pvBuffer );
 1004dd4:	e17fff17 	ldw	r5,-4(fp)
 1004dd8:	e13ffb17 	ldw	r4,-20(fp)
 1004ddc:	10050a00 	call	10050a0 <prvCopyDataFromQueue>
			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 1004de0:	e0bffb17 	ldw	r2,-20(fp)
 1004de4:	e0fffd17 	ldw	r3,-12(fp)
 1004de8:	10c00315 	stw	r3,12(r2)

			xReturn = pdPASS;
 1004dec:	00800044 	movi	r2,1
 1004df0:	e0bffa15 	stw	r2,-24(fp)
 1004df4:	00000106 	br	1004dfc <xQueuePeekFromISR+0x64>
		}
		else
		{
			xReturn = pdFAIL;
 1004df8:	e03ffa15 	stw	zero,-24(fp)
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
 1004dfc:	e0bffa17 	ldw	r2,-24(fp)
}
 1004e00:	e037883a 	mov	sp,fp
 1004e04:	dfc00117 	ldw	ra,4(sp)
 1004e08:	df000017 	ldw	fp,0(sp)
 1004e0c:	dec00204 	addi	sp,sp,8
 1004e10:	f800283a 	ret

01004e14 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
 1004e14:	defffc04 	addi	sp,sp,-16
 1004e18:	dfc00315 	stw	ra,12(sp)
 1004e1c:	df000215 	stw	fp,8(sp)
 1004e20:	df000204 	addi	fp,sp,8
 1004e24:	e13fff15 	stw	r4,-4(fp)
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
 1004e28:	1006d680 	call	1006d68 <vTaskEnterCritical>
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
 1004e2c:	e0bfff17 	ldw	r2,-4(fp)
 1004e30:	10800e17 	ldw	r2,56(r2)
 1004e34:	e0bffe15 	stw	r2,-8(fp)
	}
	taskEXIT_CRITICAL();
 1004e38:	1006dbc0 	call	1006dbc <vTaskExitCritical>

	return uxReturn;
 1004e3c:	e0bffe17 	ldw	r2,-8(fp)
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 1004e40:	e037883a 	mov	sp,fp
 1004e44:	dfc00117 	ldw	ra,4(sp)
 1004e48:	df000017 	ldw	fp,0(sp)
 1004e4c:	dec00204 	addi	sp,sp,8
 1004e50:	f800283a 	ret

01004e54 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
 1004e54:	defffb04 	addi	sp,sp,-20
 1004e58:	dfc00415 	stw	ra,16(sp)
 1004e5c:	df000315 	stw	fp,12(sp)
 1004e60:	df000304 	addi	fp,sp,12
 1004e64:	e13fff15 	stw	r4,-4(fp)
UBaseType_t uxReturn;
Queue_t *pxQueue;

	pxQueue = ( Queue_t * ) xQueue;
 1004e68:	e0bfff17 	ldw	r2,-4(fp)
 1004e6c:	e0bffd15 	stw	r2,-12(fp)
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
 1004e70:	1006d680 	call	1006d68 <vTaskEnterCritical>
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
 1004e74:	e0bffd17 	ldw	r2,-12(fp)
 1004e78:	10c00f17 	ldw	r3,60(r2)
 1004e7c:	e0bffd17 	ldw	r2,-12(fp)
 1004e80:	10800e17 	ldw	r2,56(r2)
 1004e84:	1885c83a 	sub	r2,r3,r2
 1004e88:	e0bffe15 	stw	r2,-8(fp)
	}
	taskEXIT_CRITICAL();
 1004e8c:	1006dbc0 	call	1006dbc <vTaskExitCritical>

	return uxReturn;
 1004e90:	e0bffe17 	ldw	r2,-8(fp)
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 1004e94:	e037883a 	mov	sp,fp
 1004e98:	dfc00117 	ldw	ra,4(sp)
 1004e9c:	df000017 	ldw	fp,0(sp)
 1004ea0:	dec00204 	addi	sp,sp,8
 1004ea4:	f800283a 	ret

01004ea8 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
 1004ea8:	defffd04 	addi	sp,sp,-12
 1004eac:	df000215 	stw	fp,8(sp)
 1004eb0:	df000204 	addi	fp,sp,8
 1004eb4:	e13fff15 	stw	r4,-4(fp)
UBaseType_t uxReturn;

	configASSERT( xQueue );

	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
 1004eb8:	e0bfff17 	ldw	r2,-4(fp)
 1004ebc:	10800e17 	ldw	r2,56(r2)
 1004ec0:	e0bffe15 	stw	r2,-8(fp)

	return uxReturn;
 1004ec4:	e0bffe17 	ldw	r2,-8(fp)
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 1004ec8:	e037883a 	mov	sp,fp
 1004ecc:	df000017 	ldw	fp,0(sp)
 1004ed0:	dec00104 	addi	sp,sp,4
 1004ed4:	f800283a 	ret

01004ed8 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
 1004ed8:	defffc04 	addi	sp,sp,-16
 1004edc:	dfc00315 	stw	ra,12(sp)
 1004ee0:	df000215 	stw	fp,8(sp)
 1004ee4:	df000204 	addi	fp,sp,8
 1004ee8:	e13fff15 	stw	r4,-4(fp)
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 1004eec:	e0bfff17 	ldw	r2,-4(fp)
 1004ef0:	e0bffe15 	stw	r2,-8(fp)

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
 1004ef4:	e13ffe17 	ldw	r4,-8(fp)
 1004ef8:	10041080 	call	1004108 <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
 1004efc:	0001883a 	nop
 1004f00:	e037883a 	mov	sp,fp
 1004f04:	dfc00117 	ldw	ra,4(sp)
 1004f08:	df000017 	ldw	fp,0(sp)
 1004f0c:	dec00204 	addi	sp,sp,8
 1004f10:	f800283a 	ret

01004f14 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
 1004f14:	defff904 	addi	sp,sp,-28
 1004f18:	dfc00615 	stw	ra,24(sp)
 1004f1c:	df000515 	stw	fp,20(sp)
 1004f20:	df000504 	addi	fp,sp,20
 1004f24:	e13ffd15 	stw	r4,-12(fp)
 1004f28:	e17ffe15 	stw	r5,-8(fp)
 1004f2c:	e1bfff15 	stw	r6,-4(fp)
BaseType_t xReturn = pdFALSE;
 1004f30:	e03ffb15 	stw	zero,-20(fp)
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 1004f34:	e0bffd17 	ldw	r2,-12(fp)
 1004f38:	10800e17 	ldw	r2,56(r2)
 1004f3c:	e0bffc15 	stw	r2,-16(fp)

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 1004f40:	e0bffd17 	ldw	r2,-12(fp)
 1004f44:	10801017 	ldw	r2,64(r2)
 1004f48:	10000b1e 	bne	r2,zero,1004f78 <prvCopyDataToQueue+0x64>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 1004f4c:	e0bffd17 	ldw	r2,-12(fp)
 1004f50:	10800017 	ldw	r2,0(r2)
 1004f54:	1000481e 	bne	r2,zero,1005078 <prvCopyDataToQueue+0x164>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
 1004f58:	e0bffd17 	ldw	r2,-12(fp)
 1004f5c:	10800117 	ldw	r2,4(r2)
 1004f60:	1009883a 	mov	r4,r2
 1004f64:	1006c6c0 	call	1006c6c <xTaskPriorityDisinherit>
 1004f68:	e0bffb15 	stw	r2,-20(fp)
				pxQueue->pxMutexHolder = NULL;
 1004f6c:	e0bffd17 	ldw	r2,-12(fp)
 1004f70:	10000115 	stw	zero,4(r2)
 1004f74:	00004006 	br	1005078 <prvCopyDataToQueue+0x164>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
 1004f78:	e0bfff17 	ldw	r2,-4(fp)
 1004f7c:	1000191e 	bne	r2,zero,1004fe4 <prvCopyDataToQueue+0xd0>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
 1004f80:	e0bffd17 	ldw	r2,-12(fp)
 1004f84:	10c00217 	ldw	r3,8(r2)
 1004f88:	e0bffd17 	ldw	r2,-12(fp)
 1004f8c:	10801017 	ldw	r2,64(r2)
 1004f90:	100d883a 	mov	r6,r2
 1004f94:	e17ffe17 	ldw	r5,-8(fp)
 1004f98:	1809883a 	mov	r4,r3
 1004f9c:	10099d40 	call	10099d4 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 1004fa0:	e0bffd17 	ldw	r2,-12(fp)
 1004fa4:	10c00217 	ldw	r3,8(r2)
 1004fa8:	e0bffd17 	ldw	r2,-12(fp)
 1004fac:	10801017 	ldw	r2,64(r2)
 1004fb0:	1887883a 	add	r3,r3,r2
 1004fb4:	e0bffd17 	ldw	r2,-12(fp)
 1004fb8:	10c00215 	stw	r3,8(r2)
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 1004fbc:	e0bffd17 	ldw	r2,-12(fp)
 1004fc0:	10c00217 	ldw	r3,8(r2)
 1004fc4:	e0bffd17 	ldw	r2,-12(fp)
 1004fc8:	10800117 	ldw	r2,4(r2)
 1004fcc:	18802a36 	bltu	r3,r2,1005078 <prvCopyDataToQueue+0x164>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
 1004fd0:	e0bffd17 	ldw	r2,-12(fp)
 1004fd4:	10c00017 	ldw	r3,0(r2)
 1004fd8:	e0bffd17 	ldw	r2,-12(fp)
 1004fdc:	10c00215 	stw	r3,8(r2)
 1004fe0:	00002506 	br	1005078 <prvCopyDataToQueue+0x164>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 1004fe4:	e0bffd17 	ldw	r2,-12(fp)
 1004fe8:	10c00317 	ldw	r3,12(r2)
 1004fec:	e0bffd17 	ldw	r2,-12(fp)
 1004ff0:	10801017 	ldw	r2,64(r2)
 1004ff4:	100d883a 	mov	r6,r2
 1004ff8:	e17ffe17 	ldw	r5,-8(fp)
 1004ffc:	1809883a 	mov	r4,r3
 1005000:	10099d40 	call	10099d4 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 1005004:	e0bffd17 	ldw	r2,-12(fp)
 1005008:	10c00317 	ldw	r3,12(r2)
 100500c:	e0bffd17 	ldw	r2,-12(fp)
 1005010:	10801017 	ldw	r2,64(r2)
 1005014:	0085c83a 	sub	r2,zero,r2
 1005018:	1887883a 	add	r3,r3,r2
 100501c:	e0bffd17 	ldw	r2,-12(fp)
 1005020:	10c00315 	stw	r3,12(r2)
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 1005024:	e0bffd17 	ldw	r2,-12(fp)
 1005028:	10c00317 	ldw	r3,12(r2)
 100502c:	e0bffd17 	ldw	r2,-12(fp)
 1005030:	10800017 	ldw	r2,0(r2)
 1005034:	1880082e 	bgeu	r3,r2,1005058 <prvCopyDataToQueue+0x144>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
 1005038:	e0bffd17 	ldw	r2,-12(fp)
 100503c:	10c00117 	ldw	r3,4(r2)
 1005040:	e0bffd17 	ldw	r2,-12(fp)
 1005044:	10801017 	ldw	r2,64(r2)
 1005048:	0085c83a 	sub	r2,zero,r2
 100504c:	1887883a 	add	r3,r3,r2
 1005050:	e0bffd17 	ldw	r2,-12(fp)
 1005054:	10c00315 	stw	r3,12(r2)
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
 1005058:	e0bfff17 	ldw	r2,-4(fp)
 100505c:	10800098 	cmpnei	r2,r2,2
 1005060:	1000051e 	bne	r2,zero,1005078 <prvCopyDataToQueue+0x164>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 1005064:	e0bffc17 	ldw	r2,-16(fp)
 1005068:	10000326 	beq	r2,zero,1005078 <prvCopyDataToQueue+0x164>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
 100506c:	e0bffc17 	ldw	r2,-16(fp)
 1005070:	10bfffc4 	addi	r2,r2,-1
 1005074:	e0bffc15 	stw	r2,-16(fp)
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
 1005078:	e0bffc17 	ldw	r2,-16(fp)
 100507c:	10c00044 	addi	r3,r2,1
 1005080:	e0bffd17 	ldw	r2,-12(fp)
 1005084:	10c00e15 	stw	r3,56(r2)

	return xReturn;
 1005088:	e0bffb17 	ldw	r2,-20(fp)
}
 100508c:	e037883a 	mov	sp,fp
 1005090:	dfc00117 	ldw	ra,4(sp)
 1005094:	df000017 	ldw	fp,0(sp)
 1005098:	dec00204 	addi	sp,sp,8
 100509c:	f800283a 	ret

010050a0 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
 10050a0:	defffc04 	addi	sp,sp,-16
 10050a4:	dfc00315 	stw	ra,12(sp)
 10050a8:	df000215 	stw	fp,8(sp)
 10050ac:	df000204 	addi	fp,sp,8
 10050b0:	e13ffe15 	stw	r4,-8(fp)
 10050b4:	e17fff15 	stw	r5,-4(fp)
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 10050b8:	e0bffe17 	ldw	r2,-8(fp)
 10050bc:	10801017 	ldw	r2,64(r2)
 10050c0:	10001826 	beq	r2,zero,1005124 <prvCopyDataFromQueue+0x84>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 10050c4:	e0bffe17 	ldw	r2,-8(fp)
 10050c8:	10c00317 	ldw	r3,12(r2)
 10050cc:	e0bffe17 	ldw	r2,-8(fp)
 10050d0:	10801017 	ldw	r2,64(r2)
 10050d4:	1887883a 	add	r3,r3,r2
 10050d8:	e0bffe17 	ldw	r2,-8(fp)
 10050dc:	10c00315 	stw	r3,12(r2)
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 10050e0:	e0bffe17 	ldw	r2,-8(fp)
 10050e4:	10c00317 	ldw	r3,12(r2)
 10050e8:	e0bffe17 	ldw	r2,-8(fp)
 10050ec:	10800117 	ldw	r2,4(r2)
 10050f0:	18800436 	bltu	r3,r2,1005104 <prvCopyDataFromQueue+0x64>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
 10050f4:	e0bffe17 	ldw	r2,-8(fp)
 10050f8:	10c00017 	ldw	r3,0(r2)
 10050fc:	e0bffe17 	ldw	r2,-8(fp)
 1005100:	10c00315 	stw	r3,12(r2)
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
 1005104:	e0bffe17 	ldw	r2,-8(fp)
 1005108:	10c00317 	ldw	r3,12(r2)
 100510c:	e0bffe17 	ldw	r2,-8(fp)
 1005110:	10801017 	ldw	r2,64(r2)
 1005114:	100d883a 	mov	r6,r2
 1005118:	180b883a 	mov	r5,r3
 100511c:	e13fff17 	ldw	r4,-4(fp)
 1005120:	10099d40 	call	10099d4 <memcpy>
	}
}
 1005124:	0001883a 	nop
 1005128:	e037883a 	mov	sp,fp
 100512c:	dfc00117 	ldw	ra,4(sp)
 1005130:	df000017 	ldw	fp,0(sp)
 1005134:	dec00204 	addi	sp,sp,8
 1005138:	f800283a 	ret

0100513c <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
 100513c:	defffc04 	addi	sp,sp,-16
 1005140:	dfc00315 	stw	ra,12(sp)
 1005144:	df000215 	stw	fp,8(sp)
 1005148:	df000204 	addi	fp,sp,8
 100514c:	e13fff15 	stw	r4,-4(fp)

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
 1005150:	1006d680 	call	1006d68 <vTaskEnterCritical>
	{
		int8_t cTxLock = pxQueue->cTxLock;
 1005154:	e0bfff17 	ldw	r2,-4(fp)
 1005158:	10801143 	ldbu	r2,69(r2)
 100515c:	e0bffe05 	stb	r2,-8(fp)

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
 1005160:	00000c06 	br	1005194 <prvUnlockQueue+0x58>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 1005164:	e0bfff17 	ldw	r2,-4(fp)
 1005168:	10800917 	ldw	r2,36(r2)
 100516c:	10000c26 	beq	r2,zero,10051a0 <prvUnlockQueue+0x64>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 1005170:	e0bfff17 	ldw	r2,-4(fp)
 1005174:	10800904 	addi	r2,r2,36
 1005178:	1009883a 	mov	r4,r2
 100517c:	10065240 	call	1006524 <xTaskRemoveFromEventList>
 1005180:	10000126 	beq	r2,zero,1005188 <prvUnlockQueue+0x4c>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
 1005184:	10068080 	call	1006808 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
 1005188:	e0bffe03 	ldbu	r2,-8(fp)
 100518c:	10bfffc4 	addi	r2,r2,-1
 1005190:	e0bffe05 	stb	r2,-8(fp)
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
 1005194:	e0bffe07 	ldb	r2,-8(fp)
 1005198:	00bff216 	blt	zero,r2,1005164 <__alt_data_end+0xff805164>
 100519c:	00000106 	br	10051a4 <prvUnlockQueue+0x68>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				else
				{
					break;
 10051a0:	0001883a 	nop
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
 10051a4:	e0bfff17 	ldw	r2,-4(fp)
 10051a8:	00ffffc4 	movi	r3,-1
 10051ac:	10c01145 	stb	r3,69(r2)
	}
	taskEXIT_CRITICAL();
 10051b0:	1006dbc0 	call	1006dbc <vTaskExitCritical>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
 10051b4:	1006d680 	call	1006d68 <vTaskEnterCritical>
	{
		int8_t cRxLock = pxQueue->cRxLock;
 10051b8:	e0bfff17 	ldw	r2,-4(fp)
 10051bc:	10801103 	ldbu	r2,68(r2)
 10051c0:	e0bffe45 	stb	r2,-7(fp)

		while( cRxLock > queueLOCKED_UNMODIFIED )
 10051c4:	00000c06 	br	10051f8 <prvUnlockQueue+0xbc>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 10051c8:	e0bfff17 	ldw	r2,-4(fp)
 10051cc:	10800417 	ldw	r2,16(r2)
 10051d0:	10000c26 	beq	r2,zero,1005204 <prvUnlockQueue+0xc8>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 10051d4:	e0bfff17 	ldw	r2,-4(fp)
 10051d8:	10800404 	addi	r2,r2,16
 10051dc:	1009883a 	mov	r4,r2
 10051e0:	10065240 	call	1006524 <xTaskRemoveFromEventList>
 10051e4:	10000126 	beq	r2,zero,10051ec <prvUnlockQueue+0xb0>
				{
					vTaskMissedYield();
 10051e8:	10068080 	call	1006808 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
 10051ec:	e0bffe43 	ldbu	r2,-7(fp)
 10051f0:	10bfffc4 	addi	r2,r2,-1
 10051f4:	e0bffe45 	stb	r2,-7(fp)
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
 10051f8:	e0bffe47 	ldb	r2,-7(fp)
 10051fc:	00bff216 	blt	zero,r2,10051c8 <__alt_data_end+0xff8051c8>
 1005200:	00000106 	br	1005208 <prvUnlockQueue+0xcc>

				--cRxLock;
			}
			else
			{
				break;
 1005204:	0001883a 	nop
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
 1005208:	e0bfff17 	ldw	r2,-4(fp)
 100520c:	00ffffc4 	movi	r3,-1
 1005210:	10c01105 	stb	r3,68(r2)
	}
	taskEXIT_CRITICAL();
 1005214:	1006dbc0 	call	1006dbc <vTaskExitCritical>
}
 1005218:	0001883a 	nop
 100521c:	e037883a 	mov	sp,fp
 1005220:	dfc00117 	ldw	ra,4(sp)
 1005224:	df000017 	ldw	fp,0(sp)
 1005228:	dec00204 	addi	sp,sp,8
 100522c:	f800283a 	ret

01005230 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
 1005230:	defffc04 	addi	sp,sp,-16
 1005234:	dfc00315 	stw	ra,12(sp)
 1005238:	df000215 	stw	fp,8(sp)
 100523c:	df000204 	addi	fp,sp,8
 1005240:	e13fff15 	stw	r4,-4(fp)
BaseType_t xReturn;

	taskENTER_CRITICAL();
 1005244:	1006d680 	call	1006d68 <vTaskEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 1005248:	e0bfff17 	ldw	r2,-4(fp)
 100524c:	10800e17 	ldw	r2,56(r2)
 1005250:	1000031e 	bne	r2,zero,1005260 <prvIsQueueEmpty+0x30>
		{
			xReturn = pdTRUE;
 1005254:	00800044 	movi	r2,1
 1005258:	e0bffe15 	stw	r2,-8(fp)
 100525c:	00000106 	br	1005264 <prvIsQueueEmpty+0x34>
		}
		else
		{
			xReturn = pdFALSE;
 1005260:	e03ffe15 	stw	zero,-8(fp)
		}
	}
	taskEXIT_CRITICAL();
 1005264:	1006dbc0 	call	1006dbc <vTaskExitCritical>

	return xReturn;
 1005268:	e0bffe17 	ldw	r2,-8(fp)
}
 100526c:	e037883a 	mov	sp,fp
 1005270:	dfc00117 	ldw	ra,4(sp)
 1005274:	df000017 	ldw	fp,0(sp)
 1005278:	dec00204 	addi	sp,sp,8
 100527c:	f800283a 	ret

01005280 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
 1005280:	defffd04 	addi	sp,sp,-12
 1005284:	df000215 	stw	fp,8(sp)
 1005288:	df000204 	addi	fp,sp,8
 100528c:	e13fff15 	stw	r4,-4(fp)
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
 1005290:	e0bfff17 	ldw	r2,-4(fp)
 1005294:	10800e17 	ldw	r2,56(r2)
 1005298:	1000031e 	bne	r2,zero,10052a8 <xQueueIsQueueEmptyFromISR+0x28>
	{
		xReturn = pdTRUE;
 100529c:	00800044 	movi	r2,1
 10052a0:	e0bffe15 	stw	r2,-8(fp)
 10052a4:	00000106 	br	10052ac <xQueueIsQueueEmptyFromISR+0x2c>
	}
	else
	{
		xReturn = pdFALSE;
 10052a8:	e03ffe15 	stw	zero,-8(fp)
	}

	return xReturn;
 10052ac:	e0bffe17 	ldw	r2,-8(fp)
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 10052b0:	e037883a 	mov	sp,fp
 10052b4:	df000017 	ldw	fp,0(sp)
 10052b8:	dec00104 	addi	sp,sp,4
 10052bc:	f800283a 	ret

010052c0 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
 10052c0:	defffc04 	addi	sp,sp,-16
 10052c4:	dfc00315 	stw	ra,12(sp)
 10052c8:	df000215 	stw	fp,8(sp)
 10052cc:	df000204 	addi	fp,sp,8
 10052d0:	e13fff15 	stw	r4,-4(fp)
BaseType_t xReturn;

	taskENTER_CRITICAL();
 10052d4:	1006d680 	call	1006d68 <vTaskEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 10052d8:	e0bfff17 	ldw	r2,-4(fp)
 10052dc:	10c00e17 	ldw	r3,56(r2)
 10052e0:	e0bfff17 	ldw	r2,-4(fp)
 10052e4:	10800f17 	ldw	r2,60(r2)
 10052e8:	1880031e 	bne	r3,r2,10052f8 <prvIsQueueFull+0x38>
		{
			xReturn = pdTRUE;
 10052ec:	00800044 	movi	r2,1
 10052f0:	e0bffe15 	stw	r2,-8(fp)
 10052f4:	00000106 	br	10052fc <prvIsQueueFull+0x3c>
		}
		else
		{
			xReturn = pdFALSE;
 10052f8:	e03ffe15 	stw	zero,-8(fp)
		}
	}
	taskEXIT_CRITICAL();
 10052fc:	1006dbc0 	call	1006dbc <vTaskExitCritical>

	return xReturn;
 1005300:	e0bffe17 	ldw	r2,-8(fp)
}
 1005304:	e037883a 	mov	sp,fp
 1005308:	dfc00117 	ldw	ra,4(sp)
 100530c:	df000017 	ldw	fp,0(sp)
 1005310:	dec00204 	addi	sp,sp,8
 1005314:	f800283a 	ret

01005318 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
 1005318:	defffd04 	addi	sp,sp,-12
 100531c:	df000215 	stw	fp,8(sp)
 1005320:	df000204 	addi	fp,sp,8
 1005324:	e13fff15 	stw	r4,-4(fp)
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
 1005328:	e0bfff17 	ldw	r2,-4(fp)
 100532c:	10c00e17 	ldw	r3,56(r2)
 1005330:	e0bfff17 	ldw	r2,-4(fp)
 1005334:	10800f17 	ldw	r2,60(r2)
 1005338:	1880031e 	bne	r3,r2,1005348 <xQueueIsQueueFullFromISR+0x30>
	{
		xReturn = pdTRUE;
 100533c:	00800044 	movi	r2,1
 1005340:	e0bffe15 	stw	r2,-8(fp)
 1005344:	00000106 	br	100534c <xQueueIsQueueFullFromISR+0x34>
	}
	else
	{
		xReturn = pdFALSE;
 1005348:	e03ffe15 	stw	zero,-8(fp)
	}

	return xReturn;
 100534c:	e0bffe17 	ldw	r2,-8(fp)
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 1005350:	e037883a 	mov	sp,fp
 1005354:	df000017 	ldw	fp,0(sp)
 1005358:	dec00104 	addi	sp,sp,4
 100535c:	f800283a 	ret

01005360 <xTaskCreate>:
							const char * const pcName,
							const uint16_t usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
 1005360:	defff304 	addi	sp,sp,-52
 1005364:	dfc00c15 	stw	ra,48(sp)
 1005368:	df000b15 	stw	fp,44(sp)
 100536c:	df000b04 	addi	fp,sp,44
 1005370:	e13ffc15 	stw	r4,-16(fp)
 1005374:	e17ffd15 	stw	r5,-12(fp)
 1005378:	3005883a 	mov	r2,r6
 100537c:	e1ffff15 	stw	r7,-4(fp)
 1005380:	e0bffe0d 	sth	r2,-8(fp)
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 1005384:	e0bffe0b 	ldhu	r2,-8(fp)
 1005388:	1085883a 	add	r2,r2,r2
 100538c:	1085883a 	add	r2,r2,r2
 1005390:	1009883a 	mov	r4,r2
 1005394:	1003f340 	call	1003f34 <pvPortMalloc>
 1005398:	e0bffb15 	stw	r2,-20(fp)

			if( pxStack != NULL )
 100539c:	e0bffb17 	ldw	r2,-20(fp)
 10053a0:	10000c26 	beq	r2,zero,10053d4 <xTaskCreate+0x74>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
 10053a4:	01001404 	movi	r4,80
 10053a8:	1003f340 	call	1003f34 <pvPortMalloc>
 10053ac:	e0bff915 	stw	r2,-28(fp)

				if( pxNewTCB != NULL )
 10053b0:	e0bff917 	ldw	r2,-28(fp)
 10053b4:	10000426 	beq	r2,zero,10053c8 <xTaskCreate+0x68>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
 10053b8:	e0bff917 	ldw	r2,-28(fp)
 10053bc:	e0fffb17 	ldw	r3,-20(fp)
 10053c0:	10c00c15 	stw	r3,48(r2)
 10053c4:	00000406 	br	10053d8 <xTaskCreate+0x78>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
 10053c8:	e13ffb17 	ldw	r4,-20(fp)
 10053cc:	10041080 	call	1004108 <vPortFree>
 10053d0:	00000106 	br	10053d8 <xTaskCreate+0x78>
				}
			}
			else
			{
				pxNewTCB = NULL;
 10053d4:	e03ff915 	stw	zero,-28(fp)
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
 10053d8:	e0bff917 	ldw	r2,-28(fp)
 10053dc:	10001226 	beq	r2,zero,1005428 <xTaskCreate+0xc8>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
 10053e0:	e0fffe0b 	ldhu	r3,-8(fp)
 10053e4:	d8000315 	stw	zero,12(sp)
 10053e8:	e0bff917 	ldw	r2,-28(fp)
 10053ec:	d8800215 	stw	r2,8(sp)
 10053f0:	e0800317 	ldw	r2,12(fp)
 10053f4:	d8800115 	stw	r2,4(sp)
 10053f8:	e0800217 	ldw	r2,8(fp)
 10053fc:	d8800015 	stw	r2,0(sp)
 1005400:	e1ffff17 	ldw	r7,-4(fp)
 1005404:	180d883a 	mov	r6,r3
 1005408:	e17ffd17 	ldw	r5,-12(fp)
 100540c:	e13ffc17 	ldw	r4,-16(fp)
 1005410:	10054480 	call	1005448 <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
 1005414:	e13ff917 	ldw	r4,-28(fp)
 1005418:	10056180 	call	1005618 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
 100541c:	00800044 	movi	r2,1
 1005420:	e0bffa15 	stw	r2,-24(fp)
 1005424:	00000206 	br	1005430 <xTaskCreate+0xd0>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 1005428:	00bfffc4 	movi	r2,-1
 100542c:	e0bffa15 	stw	r2,-24(fp)
		}

		return xReturn;
 1005430:	e0bffa17 	ldw	r2,-24(fp)
	}
 1005434:	e037883a 	mov	sp,fp
 1005438:	dfc00117 	ldw	ra,4(sp)
 100543c:	df000017 	ldw	fp,0(sp)
 1005440:	dec00204 	addi	sp,sp,8
 1005444:	f800283a 	ret

01005448 <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
 1005448:	defff804 	addi	sp,sp,-32
 100544c:	dfc00715 	stw	ra,28(sp)
 1005450:	df000615 	stw	fp,24(sp)
 1005454:	df000604 	addi	fp,sp,24
 1005458:	e13ffc15 	stw	r4,-16(fp)
 100545c:	e17ffd15 	stw	r5,-12(fp)
 1005460:	e1bffe15 	stw	r6,-8(fp)
 1005464:	e1ffff15 	stw	r7,-4(fp)

	/* Avoid dependency on memset() if it is not required. */
	#if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
	{
		/* Fill the stack with a known value to assist debugging. */
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 1005468:	e0800417 	ldw	r2,16(fp)
 100546c:	10c00c17 	ldw	r3,48(r2)
 1005470:	e0bffe17 	ldw	r2,-8(fp)
 1005474:	1085883a 	add	r2,r2,r2
 1005478:	1085883a 	add	r2,r2,r2
 100547c:	100d883a 	mov	r6,r2
 1005480:	01402944 	movi	r5,165
 1005484:	1809883a 	mov	r4,r3
 1005488:	1009b1c0 	call	1009b1c <memset>
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 100548c:	e0800417 	ldw	r2,16(fp)
 1005490:	10c00c17 	ldw	r3,48(r2)
 1005494:	e13ffe17 	ldw	r4,-8(fp)
 1005498:	00900034 	movhi	r2,16384
 100549c:	10bfffc4 	addi	r2,r2,-1
 10054a0:	2085883a 	add	r2,r4,r2
 10054a4:	1085883a 	add	r2,r2,r2
 10054a8:	1085883a 	add	r2,r2,r2
 10054ac:	1885883a 	add	r2,r3,r2
 10054b0:	e0bffb15 	stw	r2,-20(fp)
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
 10054b4:	e0fffb17 	ldw	r3,-20(fp)
 10054b8:	00bfff04 	movi	r2,-4
 10054bc:	1884703a 	and	r2,r3,r2
 10054c0:	e0bffb15 	stw	r2,-20(fp)
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 10054c4:	e03ffa15 	stw	zero,-24(fp)
 10054c8:	00001406 	br	100551c <prvInitialiseNewTask+0xd4>
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 10054cc:	e0fffd17 	ldw	r3,-12(fp)
 10054d0:	e0bffa17 	ldw	r2,-24(fp)
 10054d4:	1885883a 	add	r2,r3,r2
 10054d8:	10c00003 	ldbu	r3,0(r2)
 10054dc:	e1000417 	ldw	r4,16(fp)
 10054e0:	e0bffa17 	ldw	r2,-24(fp)
 10054e4:	2085883a 	add	r2,r4,r2
 10054e8:	10800d04 	addi	r2,r2,52
 10054ec:	10c00005 	stb	r3,0(r2)

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
 10054f0:	e0fffd17 	ldw	r3,-12(fp)
 10054f4:	e0bffa17 	ldw	r2,-24(fp)
 10054f8:	1885883a 	add	r2,r3,r2
 10054fc:	10800003 	ldbu	r2,0(r2)
 1005500:	10803fcc 	andi	r2,r2,255
 1005504:	1080201c 	xori	r2,r2,128
 1005508:	10bfe004 	addi	r2,r2,-128
 100550c:	10000726 	beq	r2,zero,100552c <prvInitialiseNewTask+0xe4>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 1005510:	e0bffa17 	ldw	r2,-24(fp)
 1005514:	10800044 	addi	r2,r2,1
 1005518:	e0bffa15 	stw	r2,-24(fp)
 100551c:	e0bffa17 	ldw	r2,-24(fp)
 1005520:	10800230 	cmpltui	r2,r2,8
 1005524:	103fe91e 	bne	r2,zero,10054cc <__alt_data_end+0xff8054cc>
 1005528:	00000106 	br	1005530 <prvInitialiseNewTask+0xe8>
		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
		{
			break;
 100552c:	0001883a 	nop
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 1005530:	e0800417 	ldw	r2,16(fp)
 1005534:	10000ec5 	stb	zero,59(r2)

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 1005538:	e0800217 	ldw	r2,8(fp)
 100553c:	10800170 	cmpltui	r2,r2,5
 1005540:	1000021e 	bne	r2,zero,100554c <prvInitialiseNewTask+0x104>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 1005544:	00800104 	movi	r2,4
 1005548:	e0800215 	stw	r2,8(fp)
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
 100554c:	e0800417 	ldw	r2,16(fp)
 1005550:	e0c00217 	ldw	r3,8(fp)
 1005554:	10c00b15 	stw	r3,44(r2)
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
 1005558:	e0800417 	ldw	r2,16(fp)
 100555c:	e0c00217 	ldw	r3,8(fp)
 1005560:	10c01015 	stw	r3,64(r2)
		pxNewTCB->uxMutexesHeld = 0;
 1005564:	e0800417 	ldw	r2,16(fp)
 1005568:	10001115 	stw	zero,68(r2)
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 100556c:	e0800417 	ldw	r2,16(fp)
 1005570:	10800104 	addi	r2,r2,4
 1005574:	1009883a 	mov	r4,r2
 1005578:	100388c0 	call	100388c <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 100557c:	e0800417 	ldw	r2,16(fp)
 1005580:	10800604 	addi	r2,r2,24
 1005584:	1009883a 	mov	r4,r2
 1005588:	100388c0 	call	100388c <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 100558c:	e0800417 	ldw	r2,16(fp)
 1005590:	e0c00417 	ldw	r3,16(fp)
 1005594:	10c00415 	stw	r3,16(r2)

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 1005598:	00c00144 	movi	r3,5
 100559c:	e0800217 	ldw	r2,8(fp)
 10055a0:	1887c83a 	sub	r3,r3,r2
 10055a4:	e0800417 	ldw	r2,16(fp)
 10055a8:	10c00615 	stw	r3,24(r2)
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 10055ac:	e0800417 	ldw	r2,16(fp)
 10055b0:	e0c00417 	ldw	r3,16(fp)
 10055b4:	10c00915 	stw	r3,36(r2)

	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
	{
		pxNewTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
 10055b8:	e0800417 	ldw	r2,16(fp)
 10055bc:	10000f15 	stw	zero,60(r2)
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
 10055c0:	e0800417 	ldw	r2,16(fp)
 10055c4:	10001215 	stw	zero,72(r2)
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 10055c8:	e0800417 	ldw	r2,16(fp)
 10055cc:	10001305 	stb	zero,76(r2)
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 10055d0:	e1bfff17 	ldw	r6,-4(fp)
 10055d4:	e17ffc17 	ldw	r5,-16(fp)
 10055d8:	e13ffb17 	ldw	r4,-20(fp)
 10055dc:	1003adc0 	call	1003adc <pxPortInitialiseStack>
 10055e0:	1007883a 	mov	r3,r2
 10055e4:	e0800417 	ldw	r2,16(fp)
 10055e8:	10c00015 	stw	r3,0(r2)
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( ( void * ) pxCreatedTask != NULL )
 10055ec:	e0800317 	ldw	r2,12(fp)
 10055f0:	10000326 	beq	r2,zero,1005600 <prvInitialiseNewTask+0x1b8>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 10055f4:	e0800317 	ldw	r2,12(fp)
 10055f8:	e0c00417 	ldw	r3,16(fp)
 10055fc:	10c00015 	stw	r3,0(r2)
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 1005600:	0001883a 	nop
 1005604:	e037883a 	mov	sp,fp
 1005608:	dfc00117 	ldw	ra,4(sp)
 100560c:	df000017 	ldw	fp,0(sp)
 1005610:	dec00204 	addi	sp,sp,8
 1005614:	f800283a 	ret

01005618 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
 1005618:	defffd04 	addi	sp,sp,-12
 100561c:	dfc00215 	stw	ra,8(sp)
 1005620:	df000115 	stw	fp,4(sp)
 1005624:	df000104 	addi	fp,sp,4
 1005628:	e13fff15 	stw	r4,-4(fp)
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
 100562c:	1006d680 	call	1006d68 <vTaskEnterCritical>
	{
		uxCurrentNumberOfTasks++;
 1005630:	d0a08817 	ldw	r2,-32224(gp)
 1005634:	10800044 	addi	r2,r2,1
 1005638:	d0a08815 	stw	r2,-32224(gp)
		if( pxCurrentTCB == NULL )
 100563c:	d0a08417 	ldw	r2,-32240(gp)
 1005640:	1000071e 	bne	r2,zero,1005660 <prvAddNewTaskToReadyList+0x48>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
 1005644:	e0bfff17 	ldw	r2,-4(fp)
 1005648:	d0a08415 	stw	r2,-32240(gp)

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 100564c:	d0a08817 	ldw	r2,-32224(gp)
 1005650:	10800058 	cmpnei	r2,r2,1
 1005654:	10000b1e 	bne	r2,zero,1005684 <prvAddNewTaskToReadyList+0x6c>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
 1005658:	100684c0 	call	100684c <prvInitialiseTaskLists>
 100565c:	00000906 	br	1005684 <prvAddNewTaskToReadyList+0x6c>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
 1005660:	d0a08b17 	ldw	r2,-32212(gp)
 1005664:	1000071e 	bne	r2,zero,1005684 <prvAddNewTaskToReadyList+0x6c>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 1005668:	d0a08417 	ldw	r2,-32240(gp)
 100566c:	10800b17 	ldw	r2,44(r2)
 1005670:	e0ffff17 	ldw	r3,-4(fp)
 1005674:	18c00b17 	ldw	r3,44(r3)
 1005678:	18800236 	bltu	r3,r2,1005684 <prvAddNewTaskToReadyList+0x6c>
				{
					pxCurrentTCB = pxNewTCB;
 100567c:	e0bfff17 	ldw	r2,-4(fp)
 1005680:	d0a08415 	stw	r2,-32240(gp)
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
 1005684:	d0a08f17 	ldw	r2,-32196(gp)
 1005688:	10800044 	addi	r2,r2,1
 100568c:	d0a08f15 	stw	r2,-32196(gp)
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
 1005690:	e0bfff17 	ldw	r2,-4(fp)
 1005694:	10800b17 	ldw	r2,44(r2)
 1005698:	d0e08a17 	ldw	r3,-32216(gp)
 100569c:	1880032e 	bgeu	r3,r2,10056ac <prvAddNewTaskToReadyList+0x94>
 10056a0:	e0bfff17 	ldw	r2,-4(fp)
 10056a4:	10800b17 	ldw	r2,44(r2)
 10056a8:	d0a08a15 	stw	r2,-32216(gp)
 10056ac:	e0bfff17 	ldw	r2,-4(fp)
 10056b0:	10800b17 	ldw	r2,44(r2)
 10056b4:	10c00524 	muli	r3,r2,20
 10056b8:	00805cf4 	movhi	r2,371
 10056bc:	10a3a404 	addi	r2,r2,-29040
 10056c0:	1887883a 	add	r3,r3,r2
 10056c4:	e0bfff17 	ldw	r2,-4(fp)
 10056c8:	10800104 	addi	r2,r2,4
 10056cc:	100b883a 	mov	r5,r2
 10056d0:	1809883a 	mov	r4,r3
 10056d4:	10038b80 	call	10038b8 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
 10056d8:	1006dbc0 	call	1006dbc <vTaskExitCritical>

	if( xSchedulerRunning != pdFALSE )
 10056dc:	d0a08b17 	ldw	r2,-32212(gp)
 10056e0:	10000626 	beq	r2,zero,10056fc <prvAddNewTaskToReadyList+0xe4>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 10056e4:	d0a08417 	ldw	r2,-32240(gp)
 10056e8:	10c00b17 	ldw	r3,44(r2)
 10056ec:	e0bfff17 	ldw	r2,-4(fp)
 10056f0:	10800b17 	ldw	r2,44(r2)
 10056f4:	1880012e 	bgeu	r3,r2,10056fc <prvAddNewTaskToReadyList+0xe4>
		{
			taskYIELD_IF_USING_PREEMPTION();
 10056f8:	003b683a 	trap	0
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 10056fc:	0001883a 	nop
 1005700:	e037883a 	mov	sp,fp
 1005704:	dfc00117 	ldw	ra,4(sp)
 1005708:	df000017 	ldw	fp,0(sp)
 100570c:	dec00204 	addi	sp,sp,8
 1005710:	f800283a 	ret

01005714 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
 1005714:	defffc04 	addi	sp,sp,-16
 1005718:	dfc00315 	stw	ra,12(sp)
 100571c:	df000215 	stw	fp,8(sp)
 1005720:	df000204 	addi	fp,sp,8
 1005724:	e13fff15 	stw	r4,-4(fp)
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
 1005728:	1006d680 	call	1006d68 <vTaskEnterCritical>
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 100572c:	e0bfff17 	ldw	r2,-4(fp)
 1005730:	1000021e 	bne	r2,zero,100573c <vTaskDelete+0x28>
 1005734:	d0a08417 	ldw	r2,-32240(gp)
 1005738:	00000106 	br	1005740 <vTaskDelete+0x2c>
 100573c:	e0bfff17 	ldw	r2,-4(fp)
 1005740:	e0bffe15 	stw	r2,-8(fp)

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 1005744:	e0bffe17 	ldw	r2,-8(fp)
 1005748:	10800104 	addi	r2,r2,4
 100574c:	1009883a 	mov	r4,r2
 1005750:	1003a1c0 	call	1003a1c <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 1005754:	e0bffe17 	ldw	r2,-8(fp)
 1005758:	10800a17 	ldw	r2,40(r2)
 100575c:	10000426 	beq	r2,zero,1005770 <vTaskDelete+0x5c>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 1005760:	e0bffe17 	ldw	r2,-8(fp)
 1005764:	10800604 	addi	r2,r2,24
 1005768:	1009883a 	mov	r4,r2
 100576c:	1003a1c0 	call	1003a1c <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
 1005770:	d0a08f17 	ldw	r2,-32196(gp)
 1005774:	10800044 	addi	r2,r2,1
 1005778:	d0a08f15 	stw	r2,-32196(gp)

			if( pxTCB == pxCurrentTCB )
 100577c:	d0a08417 	ldw	r2,-32240(gp)
 1005780:	e0fffe17 	ldw	r3,-8(fp)
 1005784:	18800a1e 	bne	r3,r2,10057b0 <vTaskDelete+0x9c>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
 1005788:	e0bffe17 	ldw	r2,-8(fp)
 100578c:	10800104 	addi	r2,r2,4
 1005790:	100b883a 	mov	r5,r2
 1005794:	01005cf4 	movhi	r4,371
 1005798:	2123cc04 	addi	r4,r4,-28880
 100579c:	10038b80 	call	10038b8 <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
 10057a0:	d0a08717 	ldw	r2,-32228(gp)
 10057a4:	10800044 	addi	r2,r2,1
 10057a8:	d0a08715 	stw	r2,-32228(gp)
 10057ac:	00000606 	br	10057c8 <vTaskDelete+0xb4>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
 10057b0:	d0a08817 	ldw	r2,-32224(gp)
 10057b4:	10bfffc4 	addi	r2,r2,-1
 10057b8:	d0a08815 	stw	r2,-32224(gp)
				prvDeleteTCB( pxTCB );
 10057bc:	e13ffe17 	ldw	r4,-8(fp)
 10057c0:	1006a700 	call	1006a70 <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
 10057c4:	1006ab40 	call	1006ab4 <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
 10057c8:	1006dbc0 	call	1006dbc <vTaskExitCritical>

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
 10057cc:	d0a08b17 	ldw	r2,-32212(gp)
 10057d0:	10000426 	beq	r2,zero,10057e4 <vTaskDelete+0xd0>
		{
			if( pxTCB == pxCurrentTCB )
 10057d4:	d0a08417 	ldw	r2,-32240(gp)
 10057d8:	e0fffe17 	ldw	r3,-8(fp)
 10057dc:	1880011e 	bne	r3,r2,10057e4 <vTaskDelete+0xd0>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
 10057e0:	003b683a 	trap	0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
 10057e4:	0001883a 	nop
 10057e8:	e037883a 	mov	sp,fp
 10057ec:	dfc00117 	ldw	ra,4(sp)
 10057f0:	df000017 	ldw	fp,0(sp)
 10057f4:	dec00204 	addi	sp,sp,8
 10057f8:	f800283a 	ret

010057fc <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
 10057fc:	defff804 	addi	sp,sp,-32
 1005800:	dfc00715 	stw	ra,28(sp)
 1005804:	df000615 	stw	fp,24(sp)
 1005808:	df000604 	addi	fp,sp,24
 100580c:	e13ffe15 	stw	r4,-8(fp)
 1005810:	e17fff15 	stw	r5,-4(fp)
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
 1005814:	e03ffa15 	stw	zero,-24(fp)

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
 1005818:	1005f9c0 	call	1005f9c <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
 100581c:	d0a08917 	ldw	r2,-32220(gp)
 1005820:	e0bffb15 	stw	r2,-20(fp)

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 1005824:	e0bffe17 	ldw	r2,-8(fp)
 1005828:	10c00017 	ldw	r3,0(r2)
 100582c:	e0bfff17 	ldw	r2,-4(fp)
 1005830:	1885883a 	add	r2,r3,r2
 1005834:	e0bffc15 	stw	r2,-16(fp)

			if( xConstTickCount < *pxPreviousWakeTime )
 1005838:	e0bffe17 	ldw	r2,-8(fp)
 100583c:	10800017 	ldw	r2,0(r2)
 1005840:	e0fffb17 	ldw	r3,-20(fp)
 1005844:	18800a2e 	bgeu	r3,r2,1005870 <vTaskDelayUntil+0x74>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
 1005848:	e0bffe17 	ldw	r2,-8(fp)
 100584c:	10800017 	ldw	r2,0(r2)
 1005850:	e0fffc17 	ldw	r3,-16(fp)
 1005854:	18800f2e 	bgeu	r3,r2,1005894 <vTaskDelayUntil+0x98>
 1005858:	e0bffc17 	ldw	r2,-16(fp)
 100585c:	e0fffb17 	ldw	r3,-20(fp)
 1005860:	18800c2e 	bgeu	r3,r2,1005894 <vTaskDelayUntil+0x98>
				{
					xShouldDelay = pdTRUE;
 1005864:	00800044 	movi	r2,1
 1005868:	e0bffa15 	stw	r2,-24(fp)
 100586c:	00000906 	br	1005894 <vTaskDelayUntil+0x98>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
 1005870:	e0bffe17 	ldw	r2,-8(fp)
 1005874:	10800017 	ldw	r2,0(r2)
 1005878:	e0fffc17 	ldw	r3,-16(fp)
 100587c:	18800336 	bltu	r3,r2,100588c <vTaskDelayUntil+0x90>
 1005880:	e0bffc17 	ldw	r2,-16(fp)
 1005884:	e0fffb17 	ldw	r3,-20(fp)
 1005888:	1880022e 	bgeu	r3,r2,1005894 <vTaskDelayUntil+0x98>
				{
					xShouldDelay = pdTRUE;
 100588c:	00800044 	movi	r2,1
 1005890:	e0bffa15 	stw	r2,-24(fp)
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
 1005894:	e0bffe17 	ldw	r2,-8(fp)
 1005898:	e0fffc17 	ldw	r3,-16(fp)
 100589c:	10c00015 	stw	r3,0(r2)

			if( xShouldDelay != pdFALSE )
 10058a0:	e0bffa17 	ldw	r2,-24(fp)
 10058a4:	10000626 	beq	r2,zero,10058c0 <vTaskDelayUntil+0xc4>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
 10058a8:	e0fffc17 	ldw	r3,-16(fp)
 10058ac:	e0bffb17 	ldw	r2,-20(fp)
 10058b0:	1885c83a 	sub	r2,r3,r2
 10058b4:	000b883a 	mov	r5,zero
 10058b8:	1009883a 	mov	r4,r2
 10058bc:	100755c0 	call	100755c <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
 10058c0:	1005fc80 	call	1005fc8 <xTaskResumeAll>
 10058c4:	e0bffd15 	stw	r2,-12(fp)

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 10058c8:	e0bffd17 	ldw	r2,-12(fp)
 10058cc:	1000011e 	bne	r2,zero,10058d4 <vTaskDelayUntil+0xd8>
		{
			portYIELD_WITHIN_API();
 10058d0:	003b683a 	trap	0
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 10058d4:	0001883a 	nop
 10058d8:	e037883a 	mov	sp,fp
 10058dc:	dfc00117 	ldw	ra,4(sp)
 10058e0:	df000017 	ldw	fp,0(sp)
 10058e4:	dec00204 	addi	sp,sp,8
 10058e8:	f800283a 	ret

010058ec <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
 10058ec:	defffc04 	addi	sp,sp,-16
 10058f0:	dfc00315 	stw	ra,12(sp)
 10058f4:	df000215 	stw	fp,8(sp)
 10058f8:	df000204 	addi	fp,sp,8
 10058fc:	e13fff15 	stw	r4,-4(fp)
	BaseType_t xAlreadyYielded = pdFALSE;
 1005900:	e03ffe15 	stw	zero,-8(fp)

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
 1005904:	e0bfff17 	ldw	r2,-4(fp)
 1005908:	10000626 	beq	r2,zero,1005924 <vTaskDelay+0x38>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
 100590c:	1005f9c0 	call	1005f9c <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 1005910:	000b883a 	mov	r5,zero
 1005914:	e13fff17 	ldw	r4,-4(fp)
 1005918:	100755c0 	call	100755c <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
 100591c:	1005fc80 	call	1005fc8 <xTaskResumeAll>
 1005920:	e0bffe15 	stw	r2,-8(fp)
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 1005924:	e0bffe17 	ldw	r2,-8(fp)
 1005928:	1000011e 	bne	r2,zero,1005930 <vTaskDelay+0x44>
		{
			portYIELD_WITHIN_API();
 100592c:	003b683a 	trap	0
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 1005930:	0001883a 	nop
 1005934:	e037883a 	mov	sp,fp
 1005938:	dfc00117 	ldw	ra,4(sp)
 100593c:	df000017 	ldw	fp,0(sp)
 1005940:	dec00204 	addi	sp,sp,8
 1005944:	f800283a 	ret

01005948 <uxTaskPriorityGet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
	{
 1005948:	defffb04 	addi	sp,sp,-20
 100594c:	dfc00415 	stw	ra,16(sp)
 1005950:	df000315 	stw	fp,12(sp)
 1005954:	df000304 	addi	fp,sp,12
 1005958:	e13fff15 	stw	r4,-4(fp)
	TCB_t *pxTCB;
	UBaseType_t uxReturn;

		taskENTER_CRITICAL();
 100595c:	1006d680 	call	1006d68 <vTaskEnterCritical>
		{
			/* If null is passed in here then it is the priority of the that
			called uxTaskPriorityGet() that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
 1005960:	e0bfff17 	ldw	r2,-4(fp)
 1005964:	1000021e 	bne	r2,zero,1005970 <uxTaskPriorityGet+0x28>
 1005968:	d0a08417 	ldw	r2,-32240(gp)
 100596c:	00000106 	br	1005974 <uxTaskPriorityGet+0x2c>
 1005970:	e0bfff17 	ldw	r2,-4(fp)
 1005974:	e0bffd15 	stw	r2,-12(fp)
			uxReturn = pxTCB->uxPriority;
 1005978:	e0bffd17 	ldw	r2,-12(fp)
 100597c:	10800b17 	ldw	r2,44(r2)
 1005980:	e0bffe15 	stw	r2,-8(fp)
		}
		taskEXIT_CRITICAL();
 1005984:	1006dbc0 	call	1006dbc <vTaskExitCritical>

		return uxReturn;
 1005988:	e0bffe17 	ldw	r2,-8(fp)
	}
 100598c:	e037883a 	mov	sp,fp
 1005990:	dfc00117 	ldw	ra,4(sp)
 1005994:	df000017 	ldw	fp,0(sp)
 1005998:	dec00204 	addi	sp,sp,8
 100599c:	f800283a 	ret

010059a0 <uxTaskPriorityGetFromISR>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	UBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask )
	{
 10059a0:	defffb04 	addi	sp,sp,-20
 10059a4:	df000415 	stw	fp,16(sp)
 10059a8:	df000404 	addi	fp,sp,16
 10059ac:	e13fff15 	stw	r4,-4(fp)
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
 10059b0:	e03ffc15 	stw	zero,-16(fp)
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
 10059b4:	e0bfff17 	ldw	r2,-4(fp)
 10059b8:	1000021e 	bne	r2,zero,10059c4 <uxTaskPriorityGetFromISR+0x24>
 10059bc:	d0a08417 	ldw	r2,-32240(gp)
 10059c0:	00000106 	br	10059c8 <uxTaskPriorityGetFromISR+0x28>
 10059c4:	e0bfff17 	ldw	r2,-4(fp)
 10059c8:	e0bffd15 	stw	r2,-12(fp)
			uxReturn = pxTCB->uxPriority;
 10059cc:	e0bffd17 	ldw	r2,-12(fp)
 10059d0:	10800b17 	ldw	r2,44(r2)
 10059d4:	e0bffe15 	stw	r2,-8(fp)
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );

		return uxReturn;
 10059d8:	e0bffe17 	ldw	r2,-8(fp)
	}
 10059dc:	e037883a 	mov	sp,fp
 10059e0:	df000017 	ldw	fp,0(sp)
 10059e4:	dec00104 	addi	sp,sp,4
 10059e8:	f800283a 	ret

010059ec <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
	{
 10059ec:	defff804 	addi	sp,sp,-32
 10059f0:	dfc00715 	stw	ra,28(sp)
 10059f4:	df000615 	stw	fp,24(sp)
 10059f8:	df000604 	addi	fp,sp,24
 10059fc:	e13ffe15 	stw	r4,-8(fp)
 1005a00:	e17fff15 	stw	r5,-4(fp)
	TCB_t *pxTCB;
	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
	BaseType_t xYieldRequired = pdFALSE;
 1005a04:	e03ffa15 	stw	zero,-24(fp)

		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );

		/* Ensure the new priority is valid. */
		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 1005a08:	e0bfff17 	ldw	r2,-4(fp)
 1005a0c:	10800170 	cmpltui	r2,r2,5
 1005a10:	1000021e 	bne	r2,zero,1005a1c <vTaskPrioritySet+0x30>
		{
			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 1005a14:	00800104 	movi	r2,4
 1005a18:	e0bfff15 	stw	r2,-4(fp)
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		taskENTER_CRITICAL();
 1005a1c:	1006d680 	call	1006d68 <vTaskEnterCritical>
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being changed. */
			pxTCB = prvGetTCBFromHandle( xTask );
 1005a20:	e0bffe17 	ldw	r2,-8(fp)
 1005a24:	1000021e 	bne	r2,zero,1005a30 <vTaskPrioritySet+0x44>
 1005a28:	d0a08417 	ldw	r2,-32240(gp)
 1005a2c:	00000106 	br	1005a34 <vTaskPrioritySet+0x48>
 1005a30:	e0bffe17 	ldw	r2,-8(fp)
 1005a34:	e0bffb15 	stw	r2,-20(fp)

			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );

			#if ( configUSE_MUTEXES == 1 )
			{
				uxCurrentBasePriority = pxTCB->uxBasePriority;
 1005a38:	e0bffb17 	ldw	r2,-20(fp)
 1005a3c:	10801017 	ldw	r2,64(r2)
 1005a40:	e0bffc15 	stw	r2,-16(fp)
			{
				uxCurrentBasePriority = pxTCB->uxPriority;
			}
			#endif

			if( uxCurrentBasePriority != uxNewPriority )
 1005a44:	e0fffc17 	ldw	r3,-16(fp)
 1005a48:	e0bfff17 	ldw	r2,-4(fp)
 1005a4c:	18804e26 	beq	r3,r2,1005b88 <vTaskPrioritySet+0x19c>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentBasePriority )
 1005a50:	e0bfff17 	ldw	r2,-4(fp)
 1005a54:	e0fffc17 	ldw	r3,-16(fp)
 1005a58:	18800a2e 	bgeu	r3,r2,1005a84 <vTaskPrioritySet+0x98>
				{
					if( pxTCB != pxCurrentTCB )
 1005a5c:	d0a08417 	ldw	r2,-32240(gp)
 1005a60:	e0fffb17 	ldw	r3,-20(fp)
 1005a64:	18800c26 	beq	r3,r2,1005a98 <vTaskPrioritySet+0xac>
					{
						/* The priority of a task other than the currently
						running task is being raised.  Is the priority being
						raised above that of the running task? */
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
 1005a68:	d0a08417 	ldw	r2,-32240(gp)
 1005a6c:	10800b17 	ldw	r2,44(r2)
 1005a70:	e0ffff17 	ldw	r3,-4(fp)
 1005a74:	18800836 	bltu	r3,r2,1005a98 <vTaskPrioritySet+0xac>
						{
							xYieldRequired = pdTRUE;
 1005a78:	00800044 	movi	r2,1
 1005a7c:	e0bffa15 	stw	r2,-24(fp)
 1005a80:	00000506 	br	1005a98 <vTaskPrioritySet+0xac>
						/* The priority of the running task is being raised,
						but the running task must already be the highest
						priority task able to run so no yield is required. */
					}
				}
				else if( pxTCB == pxCurrentTCB )
 1005a84:	d0a08417 	ldw	r2,-32240(gp)
 1005a88:	e0fffb17 	ldw	r3,-20(fp)
 1005a8c:	1880021e 	bne	r3,r2,1005a98 <vTaskPrioritySet+0xac>
				{
					/* Setting the priority of the running task down means
					there may now be another task of higher priority that
					is ready to execute. */
					xYieldRequired = pdTRUE;
 1005a90:	00800044 	movi	r2,1
 1005a94:	e0bffa15 	stw	r2,-24(fp)
				}

				/* Remember the ready list the task might be referenced from
				before its uxPriority member is changed so the
				taskRESET_READY_PRIORITY() macro can function correctly. */
				uxPriorityUsedOnEntry = pxTCB->uxPriority;
 1005a98:	e0bffb17 	ldw	r2,-20(fp)
 1005a9c:	10800b17 	ldw	r2,44(r2)
 1005aa0:	e0bffd15 	stw	r2,-12(fp)

				#if ( configUSE_MUTEXES == 1 )
				{
					/* Only change the priority being used if the task is not
					currently using an inherited priority. */
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
 1005aa4:	e0bffb17 	ldw	r2,-20(fp)
 1005aa8:	10c01017 	ldw	r3,64(r2)
 1005aac:	e0bffb17 	ldw	r2,-20(fp)
 1005ab0:	10800b17 	ldw	r2,44(r2)
 1005ab4:	1880031e 	bne	r3,r2,1005ac4 <vTaskPrioritySet+0xd8>
					{
						pxTCB->uxPriority = uxNewPriority;
 1005ab8:	e0bffb17 	ldw	r2,-20(fp)
 1005abc:	e0ffff17 	ldw	r3,-4(fp)
 1005ac0:	10c00b15 	stw	r3,44(r2)
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
 1005ac4:	e0bffb17 	ldw	r2,-20(fp)
 1005ac8:	e0ffff17 	ldw	r3,-4(fp)
 1005acc:	10c01015 	stw	r3,64(r2)
				}
				#endif

				/* Only reset the event list item value if the value is not
				being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 1005ad0:	e0bffb17 	ldw	r2,-20(fp)
 1005ad4:	10800617 	ldw	r2,24(r2)
 1005ad8:	10000516 	blt	r2,zero,1005af0 <vTaskPrioritySet+0x104>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 1005adc:	00c00144 	movi	r3,5
 1005ae0:	e0bfff17 	ldw	r2,-4(fp)
 1005ae4:	1887c83a 	sub	r3,r3,r2
 1005ae8:	e0bffb17 	ldw	r2,-20(fp)
 1005aec:	10c00615 	stw	r3,24(r2)

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the list appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 1005af0:	e0bffb17 	ldw	r2,-20(fp)
 1005af4:	10c00517 	ldw	r3,20(r2)
 1005af8:	e0bffd17 	ldw	r2,-12(fp)
 1005afc:	11000524 	muli	r4,r2,20
 1005b00:	00805cf4 	movhi	r2,371
 1005b04:	10a3a404 	addi	r2,r2,-29040
 1005b08:	2085883a 	add	r2,r4,r2
 1005b0c:	1880021e 	bne	r3,r2,1005b18 <vTaskPrioritySet+0x12c>
 1005b10:	00800044 	movi	r2,1
 1005b14:	00000106 	br	1005b1c <vTaskPrioritySet+0x130>
 1005b18:	0005883a 	mov	r2,zero
 1005b1c:	10803fcc 	andi	r2,r2,255
 1005b20:	10001626 	beq	r2,zero,1005b7c <vTaskPrioritySet+0x190>
				{
					/* The task is currently in its ready list - remove before adding
					it to it's new ready list.  As we are in a critical section we
					can do this even if the scheduler is suspended. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 1005b24:	e0bffb17 	ldw	r2,-20(fp)
 1005b28:	10800104 	addi	r2,r2,4
 1005b2c:	1009883a 	mov	r4,r2
 1005b30:	1003a1c0 	call	1003a1c <uxListRemove>
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
					prvAddTaskToReadyList( pxTCB );
 1005b34:	e0bffb17 	ldw	r2,-20(fp)
 1005b38:	10800b17 	ldw	r2,44(r2)
 1005b3c:	d0e08a17 	ldw	r3,-32216(gp)
 1005b40:	1880032e 	bgeu	r3,r2,1005b50 <vTaskPrioritySet+0x164>
 1005b44:	e0bffb17 	ldw	r2,-20(fp)
 1005b48:	10800b17 	ldw	r2,44(r2)
 1005b4c:	d0a08a15 	stw	r2,-32216(gp)
 1005b50:	e0bffb17 	ldw	r2,-20(fp)
 1005b54:	10800b17 	ldw	r2,44(r2)
 1005b58:	10c00524 	muli	r3,r2,20
 1005b5c:	00805cf4 	movhi	r2,371
 1005b60:	10a3a404 	addi	r2,r2,-29040
 1005b64:	1887883a 	add	r3,r3,r2
 1005b68:	e0bffb17 	ldw	r2,-20(fp)
 1005b6c:	10800104 	addi	r2,r2,4
 1005b70:	100b883a 	mov	r5,r2
 1005b74:	1809883a 	mov	r4,r3
 1005b78:	10038b80 	call	10038b8 <vListInsertEnd>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldRequired != pdFALSE )
 1005b7c:	e0bffa17 	ldw	r2,-24(fp)
 1005b80:	10000126 	beq	r2,zero,1005b88 <vTaskPrioritySet+0x19c>
				{
					taskYIELD_IF_USING_PREEMPTION();
 1005b84:	003b683a 	trap	0
				/* Remove compiler warning about unused variables when the port
				optimised task selection is not being used. */
				( void ) uxPriorityUsedOnEntry;
			}
		}
		taskEXIT_CRITICAL();
 1005b88:	1006dbc0 	call	1006dbc <vTaskExitCritical>
	}
 1005b8c:	0001883a 	nop
 1005b90:	e037883a 	mov	sp,fp
 1005b94:	dfc00117 	ldw	ra,4(sp)
 1005b98:	df000017 	ldw	fp,0(sp)
 1005b9c:	dec00204 	addi	sp,sp,8
 1005ba0:	f800283a 	ret

01005ba4 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
 1005ba4:	defffc04 	addi	sp,sp,-16
 1005ba8:	dfc00315 	stw	ra,12(sp)
 1005bac:	df000215 	stw	fp,8(sp)
 1005bb0:	df000204 	addi	fp,sp,8
 1005bb4:	e13fff15 	stw	r4,-4(fp)
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
 1005bb8:	1006d680 	call	1006d68 <vTaskEnterCritical>
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
 1005bbc:	e0bfff17 	ldw	r2,-4(fp)
 1005bc0:	1000021e 	bne	r2,zero,1005bcc <vTaskSuspend+0x28>
 1005bc4:	d0a08417 	ldw	r2,-32240(gp)
 1005bc8:	00000106 	br	1005bd0 <vTaskSuspend+0x2c>
 1005bcc:	e0bfff17 	ldw	r2,-4(fp)
 1005bd0:	e0bffe15 	stw	r2,-8(fp)

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 1005bd4:	e0bffe17 	ldw	r2,-8(fp)
 1005bd8:	10800104 	addi	r2,r2,4
 1005bdc:	1009883a 	mov	r4,r2
 1005be0:	1003a1c0 	call	1003a1c <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 1005be4:	e0bffe17 	ldw	r2,-8(fp)
 1005be8:	10800a17 	ldw	r2,40(r2)
 1005bec:	10000426 	beq	r2,zero,1005c00 <vTaskSuspend+0x5c>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 1005bf0:	e0bffe17 	ldw	r2,-8(fp)
 1005bf4:	10800604 	addi	r2,r2,24
 1005bf8:	1009883a 	mov	r4,r2
 1005bfc:	1003a1c0 	call	1003a1c <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
 1005c00:	e0bffe17 	ldw	r2,-8(fp)
 1005c04:	10800104 	addi	r2,r2,4
 1005c08:	100b883a 	mov	r5,r2
 1005c0c:	01005cf4 	movhi	r4,371
 1005c10:	2123d104 	addi	r4,r4,-28860
 1005c14:	10038b80 	call	10038b8 <vListInsertEnd>
		}
		taskEXIT_CRITICAL();
 1005c18:	1006dbc0 	call	1006dbc <vTaskExitCritical>

		if( xSchedulerRunning != pdFALSE )
 1005c1c:	d0a08b17 	ldw	r2,-32212(gp)
 1005c20:	10000326 	beq	r2,zero,1005c30 <vTaskSuspend+0x8c>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
 1005c24:	1006d680 	call	1006d68 <vTaskEnterCritical>
			{
				prvResetNextTaskUnblockTime();
 1005c28:	1006ab40 	call	1006ab4 <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
 1005c2c:	1006dbc0 	call	1006dbc <vTaskExitCritical>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
 1005c30:	d0a08417 	ldw	r2,-32240(gp)
 1005c34:	e0fffe17 	ldw	r3,-8(fp)
 1005c38:	18800c1e 	bne	r3,r2,1005c6c <vTaskSuspend+0xc8>
		{
			if( xSchedulerRunning != pdFALSE )
 1005c3c:	d0a08b17 	ldw	r2,-32212(gp)
 1005c40:	10000226 	beq	r2,zero,1005c4c <vTaskSuspend+0xa8>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
 1005c44:	003b683a 	trap	0
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 1005c48:	00000806 	br	1005c6c <vTaskSuspend+0xc8>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
 1005c4c:	00805cf4 	movhi	r2,371
 1005c50:	10a3d104 	addi	r2,r2,-28860
 1005c54:	10c00017 	ldw	r3,0(r2)
 1005c58:	d0a08817 	ldw	r2,-32224(gp)
 1005c5c:	1880021e 	bne	r3,r2,1005c68 <vTaskSuspend+0xc4>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
 1005c60:	d0208415 	stw	zero,-32240(gp)
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 1005c64:	00000106 	br	1005c6c <vTaskSuspend+0xc8>
					is. */
					pxCurrentTCB = NULL;
				}
				else
				{
					vTaskSwitchContext();
 1005c68:	10063980 	call	1006398 <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 1005c6c:	0001883a 	nop
 1005c70:	e037883a 	mov	sp,fp
 1005c74:	dfc00117 	ldw	ra,4(sp)
 1005c78:	df000017 	ldw	fp,0(sp)
 1005c7c:	dec00204 	addi	sp,sp,8
 1005c80:	f800283a 	ret

01005c84 <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
 1005c84:	defffc04 	addi	sp,sp,-16
 1005c88:	df000315 	stw	fp,12(sp)
 1005c8c:	df000304 	addi	fp,sp,12
 1005c90:	e13fff15 	stw	r4,-4(fp)
	BaseType_t xReturn = pdFALSE;
 1005c94:	e03ffd15 	stw	zero,-12(fp)
	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
 1005c98:	e0bfff17 	ldw	r2,-4(fp)
 1005c9c:	e0bffe15 	stw	r2,-8(fp)

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
 1005ca0:	e0bffe17 	ldw	r2,-8(fp)
 1005ca4:	10c00517 	ldw	r3,20(r2)
 1005ca8:	00805cf4 	movhi	r2,371
 1005cac:	10a3d104 	addi	r2,r2,-28860
 1005cb0:	1880021e 	bne	r3,r2,1005cbc <prvTaskIsTaskSuspended+0x38>
 1005cb4:	00800044 	movi	r2,1
 1005cb8:	00000106 	br	1005cc0 <prvTaskIsTaskSuspended+0x3c>
 1005cbc:	0005883a 	mov	r2,zero
 1005cc0:	10803fcc 	andi	r2,r2,255
 1005cc4:	10000f26 	beq	r2,zero,1005d04 <prvTaskIsTaskSuspended+0x80>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
 1005cc8:	e0bffe17 	ldw	r2,-8(fp)
 1005ccc:	10c00a17 	ldw	r3,40(r2)
 1005cd0:	00805cf4 	movhi	r2,371
 1005cd4:	10a3c704 	addi	r2,r2,-28900
 1005cd8:	18800a26 	beq	r3,r2,1005d04 <prvTaskIsTaskSuspended+0x80>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
 1005cdc:	e0bffe17 	ldw	r2,-8(fp)
 1005ce0:	10800a17 	ldw	r2,40(r2)
 1005ce4:	1000021e 	bne	r2,zero,1005cf0 <prvTaskIsTaskSuspended+0x6c>
 1005ce8:	00800044 	movi	r2,1
 1005cec:	00000106 	br	1005cf4 <prvTaskIsTaskSuspended+0x70>
 1005cf0:	0005883a 	mov	r2,zero
 1005cf4:	10803fcc 	andi	r2,r2,255
 1005cf8:	10000226 	beq	r2,zero,1005d04 <prvTaskIsTaskSuspended+0x80>
				{
					xReturn = pdTRUE;
 1005cfc:	00800044 	movi	r2,1
 1005d00:	e0bffd15 	stw	r2,-12(fp)
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
 1005d04:	e0bffd17 	ldw	r2,-12(fp)
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
 1005d08:	e037883a 	mov	sp,fp
 1005d0c:	df000017 	ldw	fp,0(sp)
 1005d10:	dec00104 	addi	sp,sp,4
 1005d14:	f800283a 	ret

01005d18 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
 1005d18:	defffc04 	addi	sp,sp,-16
 1005d1c:	dfc00315 	stw	ra,12(sp)
 1005d20:	df000215 	stw	fp,8(sp)
 1005d24:	df000204 	addi	fp,sp,8
 1005d28:	e13fff15 	stw	r4,-4(fp)
	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
 1005d2c:	e0bfff17 	ldw	r2,-4(fp)
 1005d30:	e0bffe15 	stw	r2,-8(fp)
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
 1005d34:	e0bffe17 	ldw	r2,-8(fp)
 1005d38:	10002426 	beq	r2,zero,1005dcc <vTaskResume+0xb4>
 1005d3c:	d0a08417 	ldw	r2,-32240(gp)
 1005d40:	e0fffe17 	ldw	r3,-8(fp)
 1005d44:	18802126 	beq	r3,r2,1005dcc <vTaskResume+0xb4>
		{
			taskENTER_CRITICAL();
 1005d48:	1006d680 	call	1006d68 <vTaskEnterCritical>
			{
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
 1005d4c:	e13ffe17 	ldw	r4,-8(fp)
 1005d50:	1005c840 	call	1005c84 <prvTaskIsTaskSuspended>
 1005d54:	10001c26 	beq	r2,zero,1005dc8 <vTaskResume+0xb0>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
 1005d58:	e0bffe17 	ldw	r2,-8(fp)
 1005d5c:	10800104 	addi	r2,r2,4
 1005d60:	1009883a 	mov	r4,r2
 1005d64:	1003a1c0 	call	1003a1c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 1005d68:	e0bffe17 	ldw	r2,-8(fp)
 1005d6c:	10800b17 	ldw	r2,44(r2)
 1005d70:	d0e08a17 	ldw	r3,-32216(gp)
 1005d74:	1880032e 	bgeu	r3,r2,1005d84 <vTaskResume+0x6c>
 1005d78:	e0bffe17 	ldw	r2,-8(fp)
 1005d7c:	10800b17 	ldw	r2,44(r2)
 1005d80:	d0a08a15 	stw	r2,-32216(gp)
 1005d84:	e0bffe17 	ldw	r2,-8(fp)
 1005d88:	10800b17 	ldw	r2,44(r2)
 1005d8c:	10c00524 	muli	r3,r2,20
 1005d90:	00805cf4 	movhi	r2,371
 1005d94:	10a3a404 	addi	r2,r2,-29040
 1005d98:	1887883a 	add	r3,r3,r2
 1005d9c:	e0bffe17 	ldw	r2,-8(fp)
 1005da0:	10800104 	addi	r2,r2,4
 1005da4:	100b883a 	mov	r5,r2
 1005da8:	1809883a 	mov	r4,r3
 1005dac:	10038b80 	call	10038b8 <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1005db0:	e0bffe17 	ldw	r2,-8(fp)
 1005db4:	10c00b17 	ldw	r3,44(r2)
 1005db8:	d0a08417 	ldw	r2,-32240(gp)
 1005dbc:	10800b17 	ldw	r2,44(r2)
 1005dc0:	18800136 	bltu	r3,r2,1005dc8 <vTaskResume+0xb0>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
 1005dc4:	003b683a 	trap	0
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
 1005dc8:	1006dbc0 	call	1006dbc <vTaskExitCritical>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 1005dcc:	0001883a 	nop
 1005dd0:	e037883a 	mov	sp,fp
 1005dd4:	dfc00117 	ldw	ra,4(sp)
 1005dd8:	df000017 	ldw	fp,0(sp)
 1005ddc:	dec00204 	addi	sp,sp,8
 1005de0:	f800283a 	ret

01005de4 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
 1005de4:	defffa04 	addi	sp,sp,-24
 1005de8:	dfc00515 	stw	ra,20(sp)
 1005dec:	df000415 	stw	fp,16(sp)
 1005df0:	df000404 	addi	fp,sp,16
 1005df4:	e13fff15 	stw	r4,-4(fp)
	BaseType_t xYieldRequired = pdFALSE;
 1005df8:	e03ffc15 	stw	zero,-16(fp)
	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
 1005dfc:	e0bfff17 	ldw	r2,-4(fp)
 1005e00:	e0bffd15 	stw	r2,-12(fp)
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1005e04:	e03ffe15 	stw	zero,-8(fp)
		{
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
 1005e08:	e13ffd17 	ldw	r4,-12(fp)
 1005e0c:	1005c840 	call	1005c84 <prvTaskIsTaskSuspended>
 1005e10:	10002626 	beq	r2,zero,1005eac <xTaskResumeFromISR+0xc8>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 1005e14:	d0a09217 	ldw	r2,-32184(gp)
 1005e18:	10001e1e 	bne	r2,zero,1005e94 <xTaskResumeFromISR+0xb0>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1005e1c:	e0bffd17 	ldw	r2,-12(fp)
 1005e20:	10c00b17 	ldw	r3,44(r2)
 1005e24:	d0a08417 	ldw	r2,-32240(gp)
 1005e28:	10800b17 	ldw	r2,44(r2)
 1005e2c:	18800236 	bltu	r3,r2,1005e38 <xTaskResumeFromISR+0x54>
					{
						xYieldRequired = pdTRUE;
 1005e30:	00800044 	movi	r2,1
 1005e34:	e0bffc15 	stw	r2,-16(fp)
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 1005e38:	e0bffd17 	ldw	r2,-12(fp)
 1005e3c:	10800104 	addi	r2,r2,4
 1005e40:	1009883a 	mov	r4,r2
 1005e44:	1003a1c0 	call	1003a1c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 1005e48:	e0bffd17 	ldw	r2,-12(fp)
 1005e4c:	10800b17 	ldw	r2,44(r2)
 1005e50:	d0e08a17 	ldw	r3,-32216(gp)
 1005e54:	1880032e 	bgeu	r3,r2,1005e64 <xTaskResumeFromISR+0x80>
 1005e58:	e0bffd17 	ldw	r2,-12(fp)
 1005e5c:	10800b17 	ldw	r2,44(r2)
 1005e60:	d0a08a15 	stw	r2,-32216(gp)
 1005e64:	e0bffd17 	ldw	r2,-12(fp)
 1005e68:	10800b17 	ldw	r2,44(r2)
 1005e6c:	10c00524 	muli	r3,r2,20
 1005e70:	00805cf4 	movhi	r2,371
 1005e74:	10a3a404 	addi	r2,r2,-29040
 1005e78:	1887883a 	add	r3,r3,r2
 1005e7c:	e0bffd17 	ldw	r2,-12(fp)
 1005e80:	10800104 	addi	r2,r2,4
 1005e84:	100b883a 	mov	r5,r2
 1005e88:	1809883a 	mov	r4,r3
 1005e8c:	10038b80 	call	10038b8 <vListInsertEnd>
 1005e90:	00000606 	br	1005eac <xTaskResumeFromISR+0xc8>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 1005e94:	e0bffd17 	ldw	r2,-12(fp)
 1005e98:	10800604 	addi	r2,r2,24
 1005e9c:	100b883a 	mov	r5,r2
 1005ea0:	01005cf4 	movhi	r4,371
 1005ea4:	2123c704 	addi	r4,r4,-28900
 1005ea8:	10038b80 	call	10038b8 <vListInsertEnd>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
 1005eac:	e0bffc17 	ldw	r2,-16(fp)
	}
 1005eb0:	e037883a 	mov	sp,fp
 1005eb4:	dfc00117 	ldw	ra,4(sp)
 1005eb8:	df000017 	ldw	fp,0(sp)
 1005ebc:	dec00204 	addi	sp,sp,8
 1005ec0:	f800283a 	ret

01005ec4 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
 1005ec4:	defffa04 	addi	sp,sp,-24
 1005ec8:	dfc00515 	stw	ra,20(sp)
 1005ecc:	df000415 	stw	fp,16(sp)
 1005ed0:	df000404 	addi	fp,sp,16
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
 1005ed4:	d0a09104 	addi	r2,gp,-32188
 1005ed8:	d8800115 	stw	r2,4(sp)
 1005edc:	d8000015 	stw	zero,0(sp)
 1005ee0:	000f883a 	mov	r7,zero
 1005ee4:	01810004 	movi	r6,1024
 1005ee8:	014040b4 	movhi	r5,258
 1005eec:	296a1e04 	addi	r5,r5,-22408
 1005ef0:	01004034 	movhi	r4,256
 1005ef4:	211a0c04 	addi	r4,r4,26672
 1005ef8:	10053600 	call	1005360 <xTaskCreate>
 1005efc:	e0bffe15 	stw	r2,-8(fp)
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
 1005f00:	e0bffe17 	ldw	r2,-8(fp)
 1005f04:	10800058 	cmpnei	r2,r2,1
 1005f08:	10000c1e 	bne	r2,zero,1005f3c <vTaskStartScheduler+0x78>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1005f0c:	0005303a 	rdctl	r2,status
 1005f10:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1005f14:	e0ffff17 	ldw	r3,-4(fp)
 1005f18:	00bfff84 	movi	r2,-2
 1005f1c:	1884703a 	and	r2,r3,r2
 1005f20:	1001703a 	wrctl	status,r2
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
 1005f24:	00bfffc4 	movi	r2,-1
 1005f28:	d0a09015 	stw	r2,-32192(gp)
		xSchedulerRunning = pdTRUE;
 1005f2c:	00800044 	movi	r2,1
 1005f30:	d0a08b15 	stw	r2,-32212(gp)
		xTickCount = ( TickType_t ) 0U;
 1005f34:	d0208915 	stw	zero,-32220(gp)
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
 1005f38:	1003bbc0 	call	1003bbc <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
 1005f3c:	0001883a 	nop
 1005f40:	e037883a 	mov	sp,fp
 1005f44:	dfc00117 	ldw	ra,4(sp)
 1005f48:	df000017 	ldw	fp,0(sp)
 1005f4c:	dec00204 	addi	sp,sp,8
 1005f50:	f800283a 	ret

01005f54 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
 1005f54:	defffd04 	addi	sp,sp,-12
 1005f58:	dfc00215 	stw	ra,8(sp)
 1005f5c:	df000115 	stw	fp,4(sp)
 1005f60:	df000104 	addi	fp,sp,4
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1005f64:	0005303a 	rdctl	r2,status
 1005f68:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1005f6c:	e0ffff17 	ldw	r3,-4(fp)
 1005f70:	00bfff84 	movi	r2,-2
 1005f74:	1884703a 	and	r2,r3,r2
 1005f78:	1001703a 	wrctl	status,r2
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
	xSchedulerRunning = pdFALSE;
 1005f7c:	d0208b15 	stw	zero,-32212(gp)
	vPortEndScheduler();
 1005f80:	1003bf40 	call	1003bf4 <vPortEndScheduler>
}
 1005f84:	0001883a 	nop
 1005f88:	e037883a 	mov	sp,fp
 1005f8c:	dfc00117 	ldw	ra,4(sp)
 1005f90:	df000017 	ldw	fp,0(sp)
 1005f94:	dec00204 	addi	sp,sp,8
 1005f98:	f800283a 	ret

01005f9c <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
 1005f9c:	deffff04 	addi	sp,sp,-4
 1005fa0:	df000015 	stw	fp,0(sp)
 1005fa4:	d839883a 	mov	fp,sp
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
 1005fa8:	d0a09217 	ldw	r2,-32184(gp)
 1005fac:	10800044 	addi	r2,r2,1
 1005fb0:	d0a09215 	stw	r2,-32184(gp)
}
 1005fb4:	0001883a 	nop
 1005fb8:	e037883a 	mov	sp,fp
 1005fbc:	df000017 	ldw	fp,0(sp)
 1005fc0:	dec00104 	addi	sp,sp,4
 1005fc4:	f800283a 	ret

01005fc8 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
 1005fc8:	defffb04 	addi	sp,sp,-20
 1005fcc:	dfc00415 	stw	ra,16(sp)
 1005fd0:	df000315 	stw	fp,12(sp)
 1005fd4:	df000304 	addi	fp,sp,12
TCB_t *pxTCB = NULL;
 1005fd8:	e03ffd15 	stw	zero,-12(fp)
BaseType_t xAlreadyYielded = pdFALSE;
 1005fdc:	e03ffe15 	stw	zero,-8(fp)
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
 1005fe0:	1006d680 	call	1006d68 <vTaskEnterCritical>
	{
		--uxSchedulerSuspended;
 1005fe4:	d0a09217 	ldw	r2,-32184(gp)
 1005fe8:	10bfffc4 	addi	r2,r2,-1
 1005fec:	d0a09215 	stw	r2,-32184(gp)

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 1005ff0:	d0a09217 	ldw	r2,-32184(gp)
 1005ff4:	1000431e 	bne	r2,zero,1006104 <xTaskResumeAll+0x13c>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 1005ff8:	d0a08817 	ldw	r2,-32224(gp)
 1005ffc:	10004126 	beq	r2,zero,1006104 <xTaskResumeAll+0x13c>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 1006000:	00002606 	br	100609c <xTaskResumeAll+0xd4>
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 1006004:	00805cf4 	movhi	r2,371
 1006008:	10a3c704 	addi	r2,r2,-28900
 100600c:	10800317 	ldw	r2,12(r2)
 1006010:	10800317 	ldw	r2,12(r2)
 1006014:	e0bffd15 	stw	r2,-12(fp)
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 1006018:	e0bffd17 	ldw	r2,-12(fp)
 100601c:	10800604 	addi	r2,r2,24
 1006020:	1009883a 	mov	r4,r2
 1006024:	1003a1c0 	call	1003a1c <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 1006028:	e0bffd17 	ldw	r2,-12(fp)
 100602c:	10800104 	addi	r2,r2,4
 1006030:	1009883a 	mov	r4,r2
 1006034:	1003a1c0 	call	1003a1c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 1006038:	e0bffd17 	ldw	r2,-12(fp)
 100603c:	10800b17 	ldw	r2,44(r2)
 1006040:	d0e08a17 	ldw	r3,-32216(gp)
 1006044:	1880032e 	bgeu	r3,r2,1006054 <xTaskResumeAll+0x8c>
 1006048:	e0bffd17 	ldw	r2,-12(fp)
 100604c:	10800b17 	ldw	r2,44(r2)
 1006050:	d0a08a15 	stw	r2,-32216(gp)
 1006054:	e0bffd17 	ldw	r2,-12(fp)
 1006058:	10800b17 	ldw	r2,44(r2)
 100605c:	10c00524 	muli	r3,r2,20
 1006060:	00805cf4 	movhi	r2,371
 1006064:	10a3a404 	addi	r2,r2,-29040
 1006068:	1887883a 	add	r3,r3,r2
 100606c:	e0bffd17 	ldw	r2,-12(fp)
 1006070:	10800104 	addi	r2,r2,4
 1006074:	100b883a 	mov	r5,r2
 1006078:	1809883a 	mov	r4,r3
 100607c:	10038b80 	call	10038b8 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1006080:	e0bffd17 	ldw	r2,-12(fp)
 1006084:	10c00b17 	ldw	r3,44(r2)
 1006088:	d0a08417 	ldw	r2,-32240(gp)
 100608c:	10800b17 	ldw	r2,44(r2)
 1006090:	18800236 	bltu	r3,r2,100609c <xTaskResumeAll+0xd4>
					{
						xYieldPending = pdTRUE;
 1006094:	00800044 	movi	r2,1
 1006098:	d0a08d15 	stw	r2,-32204(gp)
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 100609c:	00805cf4 	movhi	r2,371
 10060a0:	10a3c704 	addi	r2,r2,-28900
 10060a4:	10800017 	ldw	r2,0(r2)
 10060a8:	103fd61e 	bne	r2,zero,1006004 <__alt_data_end+0xff806004>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
 10060ac:	e0bffd17 	ldw	r2,-12(fp)
 10060b0:	10000126 	beq	r2,zero,10060b8 <xTaskResumeAll+0xf0>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
 10060b4:	1006ab40 	call	1006ab4 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
 10060b8:	d0a08c17 	ldw	r2,-32208(gp)
 10060bc:	e0bfff15 	stw	r2,-4(fp)

					if( uxPendedCounts > ( UBaseType_t ) 0U )
 10060c0:	e0bfff17 	ldw	r2,-4(fp)
 10060c4:	10000a26 	beq	r2,zero,10060f0 <xTaskResumeAll+0x128>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
 10060c8:	10061d40 	call	10061d4 <xTaskIncrementTick>
 10060cc:	10000226 	beq	r2,zero,10060d8 <xTaskResumeAll+0x110>
							{
								xYieldPending = pdTRUE;
 10060d0:	00800044 	movi	r2,1
 10060d4:	d0a08d15 	stw	r2,-32204(gp)
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
 10060d8:	e0bfff17 	ldw	r2,-4(fp)
 10060dc:	10bfffc4 	addi	r2,r2,-1
 10060e0:	e0bfff15 	stw	r2,-4(fp)
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
 10060e4:	e0bfff17 	ldw	r2,-4(fp)
 10060e8:	103ff71e 	bne	r2,zero,10060c8 <__alt_data_end+0xff8060c8>

						uxPendedTicks = 0;
 10060ec:	d0208c15 	stw	zero,-32208(gp)
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
 10060f0:	d0a08d17 	ldw	r2,-32204(gp)
 10060f4:	10000326 	beq	r2,zero,1006104 <xTaskResumeAll+0x13c>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
 10060f8:	00800044 	movi	r2,1
 10060fc:	e0bffe15 	stw	r2,-8(fp)
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
 1006100:	003b683a 	trap	0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
 1006104:	1006dbc0 	call	1006dbc <vTaskExitCritical>

	return xAlreadyYielded;
 1006108:	e0bffe17 	ldw	r2,-8(fp)
}
 100610c:	e037883a 	mov	sp,fp
 1006110:	dfc00117 	ldw	ra,4(sp)
 1006114:	df000017 	ldw	fp,0(sp)
 1006118:	dec00204 	addi	sp,sp,8
 100611c:	f800283a 	ret

01006120 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
 1006120:	defffe04 	addi	sp,sp,-8
 1006124:	df000115 	stw	fp,4(sp)
 1006128:	df000104 	addi	fp,sp,4
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
	{
		xTicks = xTickCount;
 100612c:	d0a08917 	ldw	r2,-32220(gp)
 1006130:	e0bfff15 	stw	r2,-4(fp)
	}
	portTICK_TYPE_EXIT_CRITICAL();

	return xTicks;
 1006134:	e0bfff17 	ldw	r2,-4(fp)
}
 1006138:	e037883a 	mov	sp,fp
 100613c:	df000017 	ldw	fp,0(sp)
 1006140:	dec00104 	addi	sp,sp,4
 1006144:	f800283a 	ret

01006148 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
 1006148:	defffd04 	addi	sp,sp,-12
 100614c:	df000215 	stw	fp,8(sp)
 1006150:	df000204 	addi	fp,sp,8
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
 1006154:	e03ffe15 	stw	zero,-8(fp)
	{
		xReturn = xTickCount;
 1006158:	d0a08917 	ldw	r2,-32220(gp)
 100615c:	e0bfff15 	stw	r2,-4(fp)
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
 1006160:	e0bfff17 	ldw	r2,-4(fp)
}
 1006164:	e037883a 	mov	sp,fp
 1006168:	df000017 	ldw	fp,0(sp)
 100616c:	dec00104 	addi	sp,sp,4
 1006170:	f800283a 	ret

01006174 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
 1006174:	deffff04 	addi	sp,sp,-4
 1006178:	df000015 	stw	fp,0(sp)
 100617c:	d839883a 	mov	fp,sp
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
 1006180:	d0a08817 	ldw	r2,-32224(gp)
}
 1006184:	e037883a 	mov	sp,fp
 1006188:	df000017 	ldw	fp,0(sp)
 100618c:	dec00104 	addi	sp,sp,4
 1006190:	f800283a 	ret

01006194 <pcTaskGetName>:
/*-----------------------------------------------------------*/

char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
 1006194:	defffd04 	addi	sp,sp,-12
 1006198:	df000215 	stw	fp,8(sp)
 100619c:	df000204 	addi	fp,sp,8
 10061a0:	e13fff15 	stw	r4,-4(fp)
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
 10061a4:	e0bfff17 	ldw	r2,-4(fp)
 10061a8:	1000021e 	bne	r2,zero,10061b4 <pcTaskGetName+0x20>
 10061ac:	d0a08417 	ldw	r2,-32240(gp)
 10061b0:	00000106 	br	10061b8 <pcTaskGetName+0x24>
 10061b4:	e0bfff17 	ldw	r2,-4(fp)
 10061b8:	e0bffe15 	stw	r2,-8(fp)
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
 10061bc:	e0bffe17 	ldw	r2,-8(fp)
 10061c0:	10800d04 	addi	r2,r2,52
}
 10061c4:	e037883a 	mov	sp,fp
 10061c8:	df000017 	ldw	fp,0(sp)
 10061cc:	dec00104 	addi	sp,sp,4
 10061d0:	f800283a 	ret

010061d4 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
 10061d4:	defff904 	addi	sp,sp,-28
 10061d8:	dfc00615 	stw	ra,24(sp)
 10061dc:	df000515 	stw	fp,20(sp)
 10061e0:	df000504 	addi	fp,sp,20
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
 10061e4:	e03ffb15 	stw	zero,-20(fp)

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 10061e8:	d0a09217 	ldw	r2,-32184(gp)
 10061ec:	10005d1e 	bne	r2,zero,1006364 <xTaskIncrementTick+0x190>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + 1;
 10061f0:	d0a08917 	ldw	r2,-32220(gp)
 10061f4:	10800044 	addi	r2,r2,1
 10061f8:	e0bffc15 	stw	r2,-16(fp)

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
 10061fc:	e0bffc17 	ldw	r2,-16(fp)
 1006200:	d0a08915 	stw	r2,-32220(gp)

		if( xConstTickCount == ( TickType_t ) 0U )
 1006204:	e0bffc17 	ldw	r2,-16(fp)
 1006208:	10000a1e 	bne	r2,zero,1006234 <xTaskIncrementTick+0x60>
		{
			taskSWITCH_DELAYED_LISTS();
 100620c:	d0a08517 	ldw	r2,-32236(gp)
 1006210:	e0bffd15 	stw	r2,-12(fp)
 1006214:	d0a08617 	ldw	r2,-32232(gp)
 1006218:	d0a08515 	stw	r2,-32236(gp)
 100621c:	e0bffd17 	ldw	r2,-12(fp)
 1006220:	d0a08615 	stw	r2,-32232(gp)
 1006224:	d0a08e17 	ldw	r2,-32200(gp)
 1006228:	10800044 	addi	r2,r2,1
 100622c:	d0a08e15 	stw	r2,-32200(gp)
 1006230:	1006ab40 	call	1006ab4 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
 1006234:	d0a09017 	ldw	r2,-32192(gp)
 1006238:	e0fffc17 	ldw	r3,-16(fp)
 100623c:	18803d36 	bltu	r3,r2,1006334 <xTaskIncrementTick+0x160>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 1006240:	d0a08517 	ldw	r2,-32236(gp)
 1006244:	10800017 	ldw	r2,0(r2)
 1006248:	1000021e 	bne	r2,zero,1006254 <xTaskIncrementTick+0x80>
 100624c:	00800044 	movi	r2,1
 1006250:	00000106 	br	1006258 <xTaskIncrementTick+0x84>
 1006254:	0005883a 	mov	r2,zero
 1006258:	10803fcc 	andi	r2,r2,255
 100625c:	10000326 	beq	r2,zero,100626c <xTaskIncrementTick+0x98>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 1006260:	00bfffc4 	movi	r2,-1
 1006264:	d0a09015 	stw	r2,-32192(gp)
					break;
 1006268:	00003206 	br	1006334 <xTaskIncrementTick+0x160>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 100626c:	d0a08517 	ldw	r2,-32236(gp)
 1006270:	10800317 	ldw	r2,12(r2)
 1006274:	10800317 	ldw	r2,12(r2)
 1006278:	e0bffe15 	stw	r2,-8(fp)
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 100627c:	e0bffe17 	ldw	r2,-8(fp)
 1006280:	10800117 	ldw	r2,4(r2)
 1006284:	e0bfff15 	stw	r2,-4(fp)

					if( xConstTickCount < xItemValue )
 1006288:	e0fffc17 	ldw	r3,-16(fp)
 100628c:	e0bfff17 	ldw	r2,-4(fp)
 1006290:	1880032e 	bgeu	r3,r2,10062a0 <xTaskIncrementTick+0xcc>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
 1006294:	e0bfff17 	ldw	r2,-4(fp)
 1006298:	d0a09015 	stw	r2,-32192(gp)
						break;
 100629c:	00002506 	br	1006334 <xTaskIncrementTick+0x160>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 10062a0:	e0bffe17 	ldw	r2,-8(fp)
 10062a4:	10800104 	addi	r2,r2,4
 10062a8:	1009883a 	mov	r4,r2
 10062ac:	1003a1c0 	call	1003a1c <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 10062b0:	e0bffe17 	ldw	r2,-8(fp)
 10062b4:	10800a17 	ldw	r2,40(r2)
 10062b8:	10000426 	beq	r2,zero,10062cc <xTaskIncrementTick+0xf8>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 10062bc:	e0bffe17 	ldw	r2,-8(fp)
 10062c0:	10800604 	addi	r2,r2,24
 10062c4:	1009883a 	mov	r4,r2
 10062c8:	1003a1c0 	call	1003a1c <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
 10062cc:	e0bffe17 	ldw	r2,-8(fp)
 10062d0:	10800b17 	ldw	r2,44(r2)
 10062d4:	d0e08a17 	ldw	r3,-32216(gp)
 10062d8:	1880032e 	bgeu	r3,r2,10062e8 <xTaskIncrementTick+0x114>
 10062dc:	e0bffe17 	ldw	r2,-8(fp)
 10062e0:	10800b17 	ldw	r2,44(r2)
 10062e4:	d0a08a15 	stw	r2,-32216(gp)
 10062e8:	e0bffe17 	ldw	r2,-8(fp)
 10062ec:	10800b17 	ldw	r2,44(r2)
 10062f0:	10c00524 	muli	r3,r2,20
 10062f4:	00805cf4 	movhi	r2,371
 10062f8:	10a3a404 	addi	r2,r2,-29040
 10062fc:	1887883a 	add	r3,r3,r2
 1006300:	e0bffe17 	ldw	r2,-8(fp)
 1006304:	10800104 	addi	r2,r2,4
 1006308:	100b883a 	mov	r5,r2
 100630c:	1809883a 	mov	r4,r3
 1006310:	10038b80 	call	10038b8 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1006314:	e0bffe17 	ldw	r2,-8(fp)
 1006318:	10c00b17 	ldw	r3,44(r2)
 100631c:	d0a08417 	ldw	r2,-32240(gp)
 1006320:	10800b17 	ldw	r2,44(r2)
 1006324:	18bfc636 	bltu	r3,r2,1006240 <__alt_data_end+0xff806240>
						{
							xSwitchRequired = pdTRUE;
 1006328:	00800044 	movi	r2,1
 100632c:	e0bffb15 	stw	r2,-20(fp)
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_PREEMPTION */
				}
			}
 1006330:	003fc306 	br	1006240 <__alt_data_end+0xff806240>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 1006334:	d0a08417 	ldw	r2,-32240(gp)
 1006338:	10c00b17 	ldw	r3,44(r2)
 100633c:	00805cf4 	movhi	r2,371
 1006340:	10a3a404 	addi	r2,r2,-29040
 1006344:	18c00524 	muli	r3,r3,20
 1006348:	10c5883a 	add	r2,r2,r3
 100634c:	10800017 	ldw	r2,0(r2)
 1006350:	108000b0 	cmpltui	r2,r2,2
 1006354:	1000061e 	bne	r2,zero,1006370 <xTaskIncrementTick+0x19c>
			{
				xSwitchRequired = pdTRUE;
 1006358:	00800044 	movi	r2,1
 100635c:	e0bffb15 	stw	r2,-20(fp)
 1006360:	00000306 	br	1006370 <xTaskIncrementTick+0x19c>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
 1006364:	d0a08c17 	ldw	r2,-32208(gp)
 1006368:	10800044 	addi	r2,r2,1
 100636c:	d0a08c15 	stw	r2,-32208(gp)
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
 1006370:	d0a08d17 	ldw	r2,-32204(gp)
 1006374:	10000226 	beq	r2,zero,1006380 <xTaskIncrementTick+0x1ac>
		{
			xSwitchRequired = pdTRUE;
 1006378:	00800044 	movi	r2,1
 100637c:	e0bffb15 	stw	r2,-20(fp)
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
 1006380:	e0bffb17 	ldw	r2,-20(fp)
}
 1006384:	e037883a 	mov	sp,fp
 1006388:	dfc00117 	ldw	ra,4(sp)
 100638c:	df000017 	ldw	fp,0(sp)
 1006390:	dec00204 	addi	sp,sp,8
 1006394:	f800283a 	ret

01006398 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
 1006398:	defffd04 	addi	sp,sp,-12
 100639c:	df000215 	stw	fp,8(sp)
 10063a0:	df000204 	addi	fp,sp,8
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 10063a4:	d0a09217 	ldw	r2,-32184(gp)
 10063a8:	10000326 	beq	r2,zero,10063b8 <vTaskSwitchContext+0x20>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
 10063ac:	00800044 	movi	r2,1
 10063b0:	d0a08d15 	stw	r2,-32204(gp)
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
 10063b4:	00002906 	br	100645c <vTaskSwitchContext+0xc4>
		switch. */
		xYieldPending = pdTRUE;
	}
	else
	{
		xYieldPending = pdFALSE;
 10063b8:	d0208d15 	stw	zero,-32204(gp)
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
 10063bc:	d0a08a17 	ldw	r2,-32216(gp)
 10063c0:	e0bffe15 	stw	r2,-8(fp)
 10063c4:	00000306 	br	10063d4 <vTaskSwitchContext+0x3c>
 10063c8:	e0bffe17 	ldw	r2,-8(fp)
 10063cc:	10bfffc4 	addi	r2,r2,-1
 10063d0:	e0bffe15 	stw	r2,-8(fp)
 10063d4:	00805cf4 	movhi	r2,371
 10063d8:	10a3a404 	addi	r2,r2,-29040
 10063dc:	e0fffe17 	ldw	r3,-8(fp)
 10063e0:	18c00524 	muli	r3,r3,20
 10063e4:	10c5883a 	add	r2,r2,r3
 10063e8:	10800017 	ldw	r2,0(r2)
 10063ec:	103ff626 	beq	r2,zero,10063c8 <__alt_data_end+0xff8063c8>
 10063f0:	e0bffe17 	ldw	r2,-8(fp)
 10063f4:	10c00524 	muli	r3,r2,20
 10063f8:	00805cf4 	movhi	r2,371
 10063fc:	10a3a404 	addi	r2,r2,-29040
 1006400:	1885883a 	add	r2,r3,r2
 1006404:	e0bfff15 	stw	r2,-4(fp)
 1006408:	e0bfff17 	ldw	r2,-4(fp)
 100640c:	10800117 	ldw	r2,4(r2)
 1006410:	10c00117 	ldw	r3,4(r2)
 1006414:	e0bfff17 	ldw	r2,-4(fp)
 1006418:	10c00115 	stw	r3,4(r2)
 100641c:	e0bfff17 	ldw	r2,-4(fp)
 1006420:	10c00117 	ldw	r3,4(r2)
 1006424:	e0bfff17 	ldw	r2,-4(fp)
 1006428:	10800204 	addi	r2,r2,8
 100642c:	1880051e 	bne	r3,r2,1006444 <vTaskSwitchContext+0xac>
 1006430:	e0bfff17 	ldw	r2,-4(fp)
 1006434:	10800117 	ldw	r2,4(r2)
 1006438:	10c00117 	ldw	r3,4(r2)
 100643c:	e0bfff17 	ldw	r2,-4(fp)
 1006440:	10c00115 	stw	r3,4(r2)
 1006444:	e0bfff17 	ldw	r2,-4(fp)
 1006448:	10800117 	ldw	r2,4(r2)
 100644c:	10800317 	ldw	r2,12(r2)
 1006450:	d0a08415 	stw	r2,-32240(gp)
 1006454:	e0bffe17 	ldw	r2,-8(fp)
 1006458:	d0a08a15 	stw	r2,-32216(gp)
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
 100645c:	0001883a 	nop
 1006460:	e037883a 	mov	sp,fp
 1006464:	df000017 	ldw	fp,0(sp)
 1006468:	dec00104 	addi	sp,sp,4
 100646c:	f800283a 	ret

01006470 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
 1006470:	defffc04 	addi	sp,sp,-16
 1006474:	dfc00315 	stw	ra,12(sp)
 1006478:	df000215 	stw	fp,8(sp)
 100647c:	df000204 	addi	fp,sp,8
 1006480:	e13ffe15 	stw	r4,-8(fp)
 1006484:	e17fff15 	stw	r5,-4(fp)

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 1006488:	d0a08417 	ldw	r2,-32240(gp)
 100648c:	10800604 	addi	r2,r2,24
 1006490:	100b883a 	mov	r5,r2
 1006494:	e13ffe17 	ldw	r4,-8(fp)
 1006498:	10039440 	call	1003944 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 100649c:	01400044 	movi	r5,1
 10064a0:	e13fff17 	ldw	r4,-4(fp)
 10064a4:	100755c0 	call	100755c <prvAddCurrentTaskToDelayedList>
}
 10064a8:	0001883a 	nop
 10064ac:	e037883a 	mov	sp,fp
 10064b0:	dfc00117 	ldw	ra,4(sp)
 10064b4:	df000017 	ldw	fp,0(sp)
 10064b8:	dec00204 	addi	sp,sp,8
 10064bc:	f800283a 	ret

010064c0 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
 10064c0:	defffb04 	addi	sp,sp,-20
 10064c4:	dfc00415 	stw	ra,16(sp)
 10064c8:	df000315 	stw	fp,12(sp)
 10064cc:	df000304 	addi	fp,sp,12
 10064d0:	e13ffd15 	stw	r4,-12(fp)
 10064d4:	e17ffe15 	stw	r5,-8(fp)
 10064d8:	e1bfff15 	stw	r6,-4(fp)
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 10064dc:	d0a08417 	ldw	r2,-32240(gp)
 10064e0:	e0fffe17 	ldw	r3,-8(fp)
 10064e4:	18e00034 	orhi	r3,r3,32768
 10064e8:	10c00615 	stw	r3,24(r2)
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 10064ec:	d0a08417 	ldw	r2,-32240(gp)
 10064f0:	10800604 	addi	r2,r2,24
 10064f4:	100b883a 	mov	r5,r2
 10064f8:	e13ffd17 	ldw	r4,-12(fp)
 10064fc:	10038b80 	call	10038b8 <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 1006500:	01400044 	movi	r5,1
 1006504:	e13fff17 	ldw	r4,-4(fp)
 1006508:	100755c0 	call	100755c <prvAddCurrentTaskToDelayedList>
}
 100650c:	0001883a 	nop
 1006510:	e037883a 	mov	sp,fp
 1006514:	dfc00117 	ldw	ra,4(sp)
 1006518:	df000017 	ldw	fp,0(sp)
 100651c:	dec00204 	addi	sp,sp,8
 1006520:	f800283a 	ret

01006524 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
 1006524:	defffb04 	addi	sp,sp,-20
 1006528:	dfc00415 	stw	ra,16(sp)
 100652c:	df000315 	stw	fp,12(sp)
 1006530:	df000304 	addi	fp,sp,12
 1006534:	e13fff15 	stw	r4,-4(fp)
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 1006538:	e0bfff17 	ldw	r2,-4(fp)
 100653c:	10800317 	ldw	r2,12(r2)
 1006540:	10800317 	ldw	r2,12(r2)
 1006544:	e0bffe15 	stw	r2,-8(fp)
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 1006548:	e0bffe17 	ldw	r2,-8(fp)
 100654c:	10800604 	addi	r2,r2,24
 1006550:	1009883a 	mov	r4,r2
 1006554:	1003a1c0 	call	1003a1c <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 1006558:	d0a09217 	ldw	r2,-32184(gp)
 100655c:	1000171e 	bne	r2,zero,10065bc <xTaskRemoveFromEventList+0x98>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 1006560:	e0bffe17 	ldw	r2,-8(fp)
 1006564:	10800104 	addi	r2,r2,4
 1006568:	1009883a 	mov	r4,r2
 100656c:	1003a1c0 	call	1003a1c <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
 1006570:	e0bffe17 	ldw	r2,-8(fp)
 1006574:	10800b17 	ldw	r2,44(r2)
 1006578:	d0e08a17 	ldw	r3,-32216(gp)
 100657c:	1880032e 	bgeu	r3,r2,100658c <xTaskRemoveFromEventList+0x68>
 1006580:	e0bffe17 	ldw	r2,-8(fp)
 1006584:	10800b17 	ldw	r2,44(r2)
 1006588:	d0a08a15 	stw	r2,-32216(gp)
 100658c:	e0bffe17 	ldw	r2,-8(fp)
 1006590:	10800b17 	ldw	r2,44(r2)
 1006594:	10c00524 	muli	r3,r2,20
 1006598:	00805cf4 	movhi	r2,371
 100659c:	10a3a404 	addi	r2,r2,-29040
 10065a0:	1887883a 	add	r3,r3,r2
 10065a4:	e0bffe17 	ldw	r2,-8(fp)
 10065a8:	10800104 	addi	r2,r2,4
 10065ac:	100b883a 	mov	r5,r2
 10065b0:	1809883a 	mov	r4,r3
 10065b4:	10038b80 	call	10038b8 <vListInsertEnd>
 10065b8:	00000606 	br	10065d4 <xTaskRemoveFromEventList+0xb0>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 10065bc:	e0bffe17 	ldw	r2,-8(fp)
 10065c0:	10800604 	addi	r2,r2,24
 10065c4:	100b883a 	mov	r5,r2
 10065c8:	01005cf4 	movhi	r4,371
 10065cc:	2123c704 	addi	r4,r4,-28900
 10065d0:	10038b80 	call	10038b8 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 10065d4:	e0bffe17 	ldw	r2,-8(fp)
 10065d8:	10800b17 	ldw	r2,44(r2)
 10065dc:	d0e08417 	ldw	r3,-32240(gp)
 10065e0:	18c00b17 	ldw	r3,44(r3)
 10065e4:	1880052e 	bgeu	r3,r2,10065fc <xTaskRemoveFromEventList+0xd8>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
 10065e8:	00800044 	movi	r2,1
 10065ec:	e0bffd15 	stw	r2,-12(fp)

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
 10065f0:	00800044 	movi	r2,1
 10065f4:	d0a08d15 	stw	r2,-32204(gp)
 10065f8:	00000106 	br	1006600 <xTaskRemoveFromEventList+0xdc>
	}
	else
	{
		xReturn = pdFALSE;
 10065fc:	e03ffd15 	stw	zero,-12(fp)
		ensure it is updated at the earliest possible time. */
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
 1006600:	e0bffd17 	ldw	r2,-12(fp)
}
 1006604:	e037883a 	mov	sp,fp
 1006608:	dfc00117 	ldw	ra,4(sp)
 100660c:	df000017 	ldw	fp,0(sp)
 1006610:	dec00204 	addi	sp,sp,8
 1006614:	f800283a 	ret

01006618 <xTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
 1006618:	defffa04 	addi	sp,sp,-24
 100661c:	dfc00515 	stw	ra,20(sp)
 1006620:	df000415 	stw	fp,16(sp)
 1006624:	df000404 	addi	fp,sp,16
 1006628:	e13ffe15 	stw	r4,-8(fp)
 100662c:	e17fff15 	stw	r5,-4(fp)
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 1006630:	e0bfff17 	ldw	r2,-4(fp)
 1006634:	10e00034 	orhi	r3,r2,32768
 1006638:	e0bffe17 	ldw	r2,-8(fp)
 100663c:	10c00015 	stw	r3,0(r2)

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
 1006640:	e0bffe17 	ldw	r2,-8(fp)
 1006644:	10800317 	ldw	r2,12(r2)
 1006648:	e0bffd15 	stw	r2,-12(fp)
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
 100664c:	e13ffe17 	ldw	r4,-8(fp)
 1006650:	1003a1c0 	call	1003a1c <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 1006654:	e0bffd17 	ldw	r2,-12(fp)
 1006658:	10800104 	addi	r2,r2,4
 100665c:	1009883a 	mov	r4,r2
 1006660:	1003a1c0 	call	1003a1c <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
 1006664:	e0bffd17 	ldw	r2,-12(fp)
 1006668:	10800b17 	ldw	r2,44(r2)
 100666c:	d0e08a17 	ldw	r3,-32216(gp)
 1006670:	1880032e 	bgeu	r3,r2,1006680 <xTaskRemoveFromUnorderedEventList+0x68>
 1006674:	e0bffd17 	ldw	r2,-12(fp)
 1006678:	10800b17 	ldw	r2,44(r2)
 100667c:	d0a08a15 	stw	r2,-32216(gp)
 1006680:	e0bffd17 	ldw	r2,-12(fp)
 1006684:	10800b17 	ldw	r2,44(r2)
 1006688:	10c00524 	muli	r3,r2,20
 100668c:	00805cf4 	movhi	r2,371
 1006690:	10a3a404 	addi	r2,r2,-29040
 1006694:	1887883a 	add	r3,r3,r2
 1006698:	e0bffd17 	ldw	r2,-12(fp)
 100669c:	10800104 	addi	r2,r2,4
 10066a0:	100b883a 	mov	r5,r2
 10066a4:	1809883a 	mov	r4,r3
 10066a8:	10038b80 	call	10038b8 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 10066ac:	e0bffd17 	ldw	r2,-12(fp)
 10066b0:	10800b17 	ldw	r2,44(r2)
 10066b4:	d0e08417 	ldw	r3,-32240(gp)
 10066b8:	18c00b17 	ldw	r3,44(r3)
 10066bc:	1880052e 	bgeu	r3,r2,10066d4 <xTaskRemoveFromUnorderedEventList+0xbc>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
 10066c0:	00800044 	movi	r2,1
 10066c4:	e0bffc15 	stw	r2,-16(fp)

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
 10066c8:	00800044 	movi	r2,1
 10066cc:	d0a08d15 	stw	r2,-32204(gp)
 10066d0:	00000106 	br	10066d8 <xTaskRemoveFromUnorderedEventList+0xc0>
	}
	else
	{
		xReturn = pdFALSE;
 10066d4:	e03ffc15 	stw	zero,-16(fp)
	}

	return xReturn;
 10066d8:	e0bffc17 	ldw	r2,-16(fp)
}
 10066dc:	e037883a 	mov	sp,fp
 10066e0:	dfc00117 	ldw	ra,4(sp)
 10066e4:	df000017 	ldw	fp,0(sp)
 10066e8:	dec00204 	addi	sp,sp,8
 10066ec:	f800283a 	ret

010066f0 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
 10066f0:	defffe04 	addi	sp,sp,-8
 10066f4:	df000115 	stw	fp,4(sp)
 10066f8:	df000104 	addi	fp,sp,4
 10066fc:	e13fff15 	stw	r4,-4(fp)
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 1006700:	d0e08e17 	ldw	r3,-32200(gp)
 1006704:	e0bfff17 	ldw	r2,-4(fp)
 1006708:	10c00015 	stw	r3,0(r2)
	pxTimeOut->xTimeOnEntering = xTickCount;
 100670c:	d0e08917 	ldw	r3,-32220(gp)
 1006710:	e0bfff17 	ldw	r2,-4(fp)
 1006714:	10c00115 	stw	r3,4(r2)
}
 1006718:	0001883a 	nop
 100671c:	e037883a 	mov	sp,fp
 1006720:	df000017 	ldw	fp,0(sp)
 1006724:	dec00104 	addi	sp,sp,4
 1006728:	f800283a 	ret

0100672c <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
 100672c:	defffa04 	addi	sp,sp,-24
 1006730:	dfc00515 	stw	ra,20(sp)
 1006734:	df000415 	stw	fp,16(sp)
 1006738:	df000404 	addi	fp,sp,16
 100673c:	e13ffe15 	stw	r4,-8(fp)
 1006740:	e17fff15 	stw	r5,-4(fp)
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
 1006744:	1006d680 	call	1006d68 <vTaskEnterCritical>
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
 1006748:	d0a08917 	ldw	r2,-32220(gp)
 100674c:	e0bffd15 	stw	r2,-12(fp)
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
 1006750:	e0bfff17 	ldw	r2,-4(fp)
 1006754:	10800017 	ldw	r2,0(r2)
 1006758:	10bfffd8 	cmpnei	r2,r2,-1
 100675c:	1000021e 	bne	r2,zero,1006768 <xTaskCheckForTimeOut+0x3c>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
 1006760:	e03ffc15 	stw	zero,-16(fp)
 1006764:	00002106 	br	10067ec <xTaskCheckForTimeOut+0xc0>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 1006768:	e0bffe17 	ldw	r2,-8(fp)
 100676c:	10c00017 	ldw	r3,0(r2)
 1006770:	d0a08e17 	ldw	r2,-32200(gp)
 1006774:	18800726 	beq	r3,r2,1006794 <xTaskCheckForTimeOut+0x68>
 1006778:	e0bffe17 	ldw	r2,-8(fp)
 100677c:	10800117 	ldw	r2,4(r2)
 1006780:	e0fffd17 	ldw	r3,-12(fp)
 1006784:	18800336 	bltu	r3,r2,1006794 <xTaskCheckForTimeOut+0x68>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
 1006788:	00800044 	movi	r2,1
 100678c:	e0bffc15 	stw	r2,-16(fp)
 1006790:	00001606 	br	10067ec <xTaskCheckForTimeOut+0xc0>
		}
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
 1006794:	e0bffe17 	ldw	r2,-8(fp)
 1006798:	10800117 	ldw	r2,4(r2)
 100679c:	e0fffd17 	ldw	r3,-12(fp)
 10067a0:	1887c83a 	sub	r3,r3,r2
 10067a4:	e0bfff17 	ldw	r2,-4(fp)
 10067a8:	10800017 	ldw	r2,0(r2)
 10067ac:	18800d2e 	bgeu	r3,r2,10067e4 <xTaskCheckForTimeOut+0xb8>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
 10067b0:	e0bfff17 	ldw	r2,-4(fp)
 10067b4:	10c00017 	ldw	r3,0(r2)
 10067b8:	e0bffe17 	ldw	r2,-8(fp)
 10067bc:	11000117 	ldw	r4,4(r2)
 10067c0:	e0bffd17 	ldw	r2,-12(fp)
 10067c4:	2085c83a 	sub	r2,r4,r2
 10067c8:	1887883a 	add	r3,r3,r2
 10067cc:	e0bfff17 	ldw	r2,-4(fp)
 10067d0:	10c00015 	stw	r3,0(r2)
			vTaskSetTimeOutState( pxTimeOut );
 10067d4:	e13ffe17 	ldw	r4,-8(fp)
 10067d8:	10066f00 	call	10066f0 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
 10067dc:	e03ffc15 	stw	zero,-16(fp)
 10067e0:	00000206 	br	10067ec <xTaskCheckForTimeOut+0xc0>
		}
		else
		{
			xReturn = pdTRUE;
 10067e4:	00800044 	movi	r2,1
 10067e8:	e0bffc15 	stw	r2,-16(fp)
		}
	}
	taskEXIT_CRITICAL();
 10067ec:	1006dbc0 	call	1006dbc <vTaskExitCritical>

	return xReturn;
 10067f0:	e0bffc17 	ldw	r2,-16(fp)
}
 10067f4:	e037883a 	mov	sp,fp
 10067f8:	dfc00117 	ldw	ra,4(sp)
 10067fc:	df000017 	ldw	fp,0(sp)
 1006800:	dec00204 	addi	sp,sp,8
 1006804:	f800283a 	ret

01006808 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
 1006808:	deffff04 	addi	sp,sp,-4
 100680c:	df000015 	stw	fp,0(sp)
 1006810:	d839883a 	mov	fp,sp
	xYieldPending = pdTRUE;
 1006814:	00800044 	movi	r2,1
 1006818:	d0a08d15 	stw	r2,-32204(gp)
}
 100681c:	0001883a 	nop
 1006820:	e037883a 	mov	sp,fp
 1006824:	df000017 	ldw	fp,0(sp)
 1006828:	dec00104 	addi	sp,sp,4
 100682c:	f800283a 	ret

01006830 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
 1006830:	defffd04 	addi	sp,sp,-12
 1006834:	dfc00215 	stw	ra,8(sp)
 1006838:	df000115 	stw	fp,4(sp)
 100683c:	df000104 	addi	fp,sp,4
 1006840:	e13fff15 	stw	r4,-4(fp)

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
 1006844:	10069040 	call	1006904 <prvCheckTasksWaitingTermination>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
 1006848:	003ffe06 	br	1006844 <__alt_data_end+0xff806844>

0100684c <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
 100684c:	defffd04 	addi	sp,sp,-12
 1006850:	dfc00215 	stw	ra,8(sp)
 1006854:	df000115 	stw	fp,4(sp)
 1006858:	df000104 	addi	fp,sp,4
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 100685c:	e03fff15 	stw	zero,-4(fp)
 1006860:	00000a06 	br	100688c <prvInitialiseTaskLists+0x40>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 1006864:	e0bfff17 	ldw	r2,-4(fp)
 1006868:	10c00524 	muli	r3,r2,20
 100686c:	00805cf4 	movhi	r2,371
 1006870:	10a3a404 	addi	r2,r2,-29040
 1006874:	1885883a 	add	r2,r3,r2
 1006878:	1009883a 	mov	r4,r2
 100687c:	10038240 	call	1003824 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 1006880:	e0bfff17 	ldw	r2,-4(fp)
 1006884:	10800044 	addi	r2,r2,1
 1006888:	e0bfff15 	stw	r2,-4(fp)
 100688c:	e0bfff17 	ldw	r2,-4(fp)
 1006890:	10800170 	cmpltui	r2,r2,5
 1006894:	103ff31e 	bne	r2,zero,1006864 <__alt_data_end+0xff806864>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
 1006898:	01005cf4 	movhi	r4,371
 100689c:	2123bd04 	addi	r4,r4,-28940
 10068a0:	10038240 	call	1003824 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 10068a4:	01005cf4 	movhi	r4,371
 10068a8:	2123c204 	addi	r4,r4,-28920
 10068ac:	10038240 	call	1003824 <vListInitialise>
	vListInitialise( &xPendingReadyList );
 10068b0:	01005cf4 	movhi	r4,371
 10068b4:	2123c704 	addi	r4,r4,-28900
 10068b8:	10038240 	call	1003824 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
 10068bc:	01005cf4 	movhi	r4,371
 10068c0:	2123cc04 	addi	r4,r4,-28880
 10068c4:	10038240 	call	1003824 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
 10068c8:	01005cf4 	movhi	r4,371
 10068cc:	2123d104 	addi	r4,r4,-28860
 10068d0:	10038240 	call	1003824 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
 10068d4:	00805cf4 	movhi	r2,371
 10068d8:	10a3bd04 	addi	r2,r2,-28940
 10068dc:	d0a08515 	stw	r2,-32236(gp)
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 10068e0:	00805cf4 	movhi	r2,371
 10068e4:	10a3c204 	addi	r2,r2,-28920
 10068e8:	d0a08615 	stw	r2,-32232(gp)
}
 10068ec:	0001883a 	nop
 10068f0:	e037883a 	mov	sp,fp
 10068f4:	dfc00117 	ldw	ra,4(sp)
 10068f8:	df000017 	ldw	fp,0(sp)
 10068fc:	dec00204 	addi	sp,sp,8
 1006900:	f800283a 	ret

01006904 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
 1006904:	defffc04 	addi	sp,sp,-16
 1006908:	dfc00315 	stw	ra,12(sp)
 100690c:	df000215 	stw	fp,8(sp)
 1006910:	df000204 	addi	fp,sp,8
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 1006914:	00001d06 	br	100698c <prvCheckTasksWaitingTermination+0x88>
		{
			vTaskSuspendAll();
 1006918:	1005f9c0 	call	1005f9c <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 100691c:	00805cf4 	movhi	r2,371
 1006920:	10a3cc04 	addi	r2,r2,-28880
 1006924:	10800017 	ldw	r2,0(r2)
 1006928:	1005003a 	cmpeq	r2,r2,zero
 100692c:	10803fcc 	andi	r2,r2,255
 1006930:	e0bffe15 	stw	r2,-8(fp)
			}
			( void ) xTaskResumeAll();
 1006934:	1005fc80 	call	1005fc8 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
 1006938:	e0bffe17 	ldw	r2,-8(fp)
 100693c:	1000131e 	bne	r2,zero,100698c <prvCheckTasksWaitingTermination+0x88>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
 1006940:	1006d680 	call	1006d68 <vTaskEnterCritical>
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 1006944:	00805cf4 	movhi	r2,371
 1006948:	10a3cc04 	addi	r2,r2,-28880
 100694c:	10800317 	ldw	r2,12(r2)
 1006950:	10800317 	ldw	r2,12(r2)
 1006954:	e0bfff15 	stw	r2,-4(fp)
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 1006958:	e0bfff17 	ldw	r2,-4(fp)
 100695c:	10800104 	addi	r2,r2,4
 1006960:	1009883a 	mov	r4,r2
 1006964:	1003a1c0 	call	1003a1c <uxListRemove>
					--uxCurrentNumberOfTasks;
 1006968:	d0a08817 	ldw	r2,-32224(gp)
 100696c:	10bfffc4 	addi	r2,r2,-1
 1006970:	d0a08815 	stw	r2,-32224(gp)
					--uxDeletedTasksWaitingCleanUp;
 1006974:	d0a08717 	ldw	r2,-32228(gp)
 1006978:	10bfffc4 	addi	r2,r2,-1
 100697c:	d0a08715 	stw	r2,-32228(gp)
				}
				taskEXIT_CRITICAL();
 1006980:	1006dbc0 	call	1006dbc <vTaskExitCritical>

				prvDeleteTCB( pxTCB );
 1006984:	e13fff17 	ldw	r4,-4(fp)
 1006988:	1006a700 	call	1006a70 <prvDeleteTCB>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 100698c:	d0a08717 	ldw	r2,-32228(gp)
 1006990:	103fe11e 	bne	r2,zero,1006918 <__alt_data_end+0xff806918>
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
 1006994:	0001883a 	nop
 1006998:	e037883a 	mov	sp,fp
 100699c:	dfc00117 	ldw	ra,4(sp)
 10069a0:	df000017 	ldw	fp,0(sp)
 10069a4:	dec00204 	addi	sp,sp,8
 10069a8:	f800283a 	ret

010069ac <prvTaskCheckFreeStackSpace>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
	{
 10069ac:	defffd04 	addi	sp,sp,-12
 10069b0:	df000215 	stw	fp,8(sp)
 10069b4:	df000204 	addi	fp,sp,8
 10069b8:	e13fff15 	stw	r4,-4(fp)
	uint32_t ulCount = 0U;
 10069bc:	e03ffe15 	stw	zero,-8(fp)

		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
 10069c0:	00000606 	br	10069dc <prvTaskCheckFreeStackSpace+0x30>
		{
			pucStackByte -= portSTACK_GROWTH;
 10069c4:	e0bfff17 	ldw	r2,-4(fp)
 10069c8:	10800044 	addi	r2,r2,1
 10069cc:	e0bfff15 	stw	r2,-4(fp)
			ulCount++;
 10069d0:	e0bffe17 	ldw	r2,-8(fp)
 10069d4:	10800044 	addi	r2,r2,1
 10069d8:	e0bffe15 	stw	r2,-8(fp)

	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
	{
	uint32_t ulCount = 0U;

		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
 10069dc:	e0bfff17 	ldw	r2,-4(fp)
 10069e0:	10800003 	ldbu	r2,0(r2)
 10069e4:	10803fcc 	andi	r2,r2,255
 10069e8:	10802960 	cmpeqi	r2,r2,165
 10069ec:	103ff51e 	bne	r2,zero,10069c4 <__alt_data_end+0xff8069c4>
		{
			pucStackByte -= portSTACK_GROWTH;
			ulCount++;
		}

		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller architectures. */
 10069f0:	e0bffe17 	ldw	r2,-8(fp)
 10069f4:	1004d0ba 	srli	r2,r2,2
 10069f8:	e0bffe15 	stw	r2,-8(fp)

		return ( uint16_t ) ulCount;
 10069fc:	e0bffe17 	ldw	r2,-8(fp)
	}
 1006a00:	e037883a 	mov	sp,fp
 1006a04:	df000017 	ldw	fp,0(sp)
 1006a08:	dec00104 	addi	sp,sp,4
 1006a0c:	f800283a 	ret

01006a10 <uxTaskGetStackHighWaterMark>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )

	UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
	{
 1006a10:	defffa04 	addi	sp,sp,-24
 1006a14:	dfc00515 	stw	ra,20(sp)
 1006a18:	df000415 	stw	fp,16(sp)
 1006a1c:	df000404 	addi	fp,sp,16
 1006a20:	e13fff15 	stw	r4,-4(fp)
	TCB_t *pxTCB;
	uint8_t *pucEndOfStack;
	UBaseType_t uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
 1006a24:	e0bfff17 	ldw	r2,-4(fp)
 1006a28:	1000021e 	bne	r2,zero,1006a34 <uxTaskGetStackHighWaterMark+0x24>
 1006a2c:	d0a08417 	ldw	r2,-32240(gp)
 1006a30:	00000106 	br	1006a38 <uxTaskGetStackHighWaterMark+0x28>
 1006a34:	e0bfff17 	ldw	r2,-4(fp)
 1006a38:	e0bffc15 	stw	r2,-16(fp)

		#if portSTACK_GROWTH < 0
		{
			pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
 1006a3c:	e0bffc17 	ldw	r2,-16(fp)
 1006a40:	10800c17 	ldw	r2,48(r2)
 1006a44:	e0bffd15 	stw	r2,-12(fp)
		{
			pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
		}
		#endif

		uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
 1006a48:	e13ffd17 	ldw	r4,-12(fp)
 1006a4c:	10069ac0 	call	10069ac <prvTaskCheckFreeStackSpace>
 1006a50:	10bfffcc 	andi	r2,r2,65535
 1006a54:	e0bffe15 	stw	r2,-8(fp)

		return uxReturn;
 1006a58:	e0bffe17 	ldw	r2,-8(fp)
	}
 1006a5c:	e037883a 	mov	sp,fp
 1006a60:	dfc00117 	ldw	ra,4(sp)
 1006a64:	df000017 	ldw	fp,0(sp)
 1006a68:	dec00204 	addi	sp,sp,8
 1006a6c:	f800283a 	ret

01006a70 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
 1006a70:	defffd04 	addi	sp,sp,-12
 1006a74:	dfc00215 	stw	ra,8(sp)
 1006a78:	df000115 	stw	fp,4(sp)
 1006a7c:	df000104 	addi	fp,sp,4
 1006a80:	e13fff15 	stw	r4,-4(fp)

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
 1006a84:	e0bfff17 	ldw	r2,-4(fp)
 1006a88:	10800c17 	ldw	r2,48(r2)
 1006a8c:	1009883a 	mov	r4,r2
 1006a90:	10041080 	call	1004108 <vPortFree>
			vPortFree( pxTCB );
 1006a94:	e13fff17 	ldw	r4,-4(fp)
 1006a98:	10041080 	call	1004108 <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	)
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
 1006a9c:	0001883a 	nop
 1006aa0:	e037883a 	mov	sp,fp
 1006aa4:	dfc00117 	ldw	ra,4(sp)
 1006aa8:	df000017 	ldw	fp,0(sp)
 1006aac:	dec00204 	addi	sp,sp,8
 1006ab0:	f800283a 	ret

01006ab4 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
 1006ab4:	defffe04 	addi	sp,sp,-8
 1006ab8:	df000115 	stw	fp,4(sp)
 1006abc:	df000104 	addi	fp,sp,4
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 1006ac0:	d0a08517 	ldw	r2,-32236(gp)
 1006ac4:	10800017 	ldw	r2,0(r2)
 1006ac8:	1000021e 	bne	r2,zero,1006ad4 <prvResetNextTaskUnblockTime+0x20>
 1006acc:	00800044 	movi	r2,1
 1006ad0:	00000106 	br	1006ad8 <prvResetNextTaskUnblockTime+0x24>
 1006ad4:	0005883a 	mov	r2,zero
 1006ad8:	10803fcc 	andi	r2,r2,255
 1006adc:	10000326 	beq	r2,zero,1006aec <prvResetNextTaskUnblockTime+0x38>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
 1006ae0:	00bfffc4 	movi	r2,-1
 1006ae4:	d0a09015 	stw	r2,-32192(gp)
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
	}
}
 1006ae8:	00000706 	br	1006b08 <prvResetNextTaskUnblockTime+0x54>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 1006aec:	d0a08517 	ldw	r2,-32236(gp)
 1006af0:	10800317 	ldw	r2,12(r2)
 1006af4:	10800317 	ldw	r2,12(r2)
 1006af8:	e0bfff15 	stw	r2,-4(fp)
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 1006afc:	e0bfff17 	ldw	r2,-4(fp)
 1006b00:	10800117 	ldw	r2,4(r2)
 1006b04:	d0a09015 	stw	r2,-32192(gp)
	}
}
 1006b08:	0001883a 	nop
 1006b0c:	e037883a 	mov	sp,fp
 1006b10:	df000017 	ldw	fp,0(sp)
 1006b14:	dec00104 	addi	sp,sp,4
 1006b18:	f800283a 	ret

01006b1c <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	TaskHandle_t xTaskGetCurrentTaskHandle( void )
	{
 1006b1c:	defffe04 	addi	sp,sp,-8
 1006b20:	df000115 	stw	fp,4(sp)
 1006b24:	df000104 	addi	fp,sp,4
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
 1006b28:	d0a08417 	ldw	r2,-32240(gp)
 1006b2c:	e0bfff15 	stw	r2,-4(fp)

		return xReturn;
 1006b30:	e0bfff17 	ldw	r2,-4(fp)
	}
 1006b34:	e037883a 	mov	sp,fp
 1006b38:	df000017 	ldw	fp,0(sp)
 1006b3c:	dec00104 	addi	sp,sp,4
 1006b40:	f800283a 	ret

01006b44 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
 1006b44:	defffc04 	addi	sp,sp,-16
 1006b48:	dfc00315 	stw	ra,12(sp)
 1006b4c:	df000215 	stw	fp,8(sp)
 1006b50:	df000204 	addi	fp,sp,8
 1006b54:	e13fff15 	stw	r4,-4(fp)
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
 1006b58:	e0bfff17 	ldw	r2,-4(fp)
 1006b5c:	e0bffe15 	stw	r2,-8(fp)

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
 1006b60:	e0bfff17 	ldw	r2,-4(fp)
 1006b64:	10003b26 	beq	r2,zero,1006c54 <vTaskPriorityInherit+0x110>
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
 1006b68:	e0bffe17 	ldw	r2,-8(fp)
 1006b6c:	10c00b17 	ldw	r3,44(r2)
 1006b70:	d0a08417 	ldw	r2,-32240(gp)
 1006b74:	10800b17 	ldw	r2,44(r2)
 1006b78:	1880362e 	bgeu	r3,r2,1006c54 <vTaskPriorityInherit+0x110>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not	being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 1006b7c:	e0bffe17 	ldw	r2,-8(fp)
 1006b80:	10800617 	ldw	r2,24(r2)
 1006b84:	10000616 	blt	r2,zero,1006ba0 <vTaskPriorityInherit+0x5c>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 1006b88:	d0a08417 	ldw	r2,-32240(gp)
 1006b8c:	10800b17 	ldw	r2,44(r2)
 1006b90:	00c00144 	movi	r3,5
 1006b94:	1887c83a 	sub	r3,r3,r2
 1006b98:	e0bffe17 	ldw	r2,-8(fp)
 1006b9c:	10c00615 	stw	r3,24(r2)
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 1006ba0:	e0bffe17 	ldw	r2,-8(fp)
 1006ba4:	10c00517 	ldw	r3,20(r2)
 1006ba8:	e0bffe17 	ldw	r2,-8(fp)
 1006bac:	10800b17 	ldw	r2,44(r2)
 1006bb0:	11000524 	muli	r4,r2,20
 1006bb4:	00805cf4 	movhi	r2,371
 1006bb8:	10a3a404 	addi	r2,r2,-29040
 1006bbc:	2085883a 	add	r2,r4,r2
 1006bc0:	1880021e 	bne	r3,r2,1006bcc <vTaskPriorityInherit+0x88>
 1006bc4:	00800044 	movi	r2,1
 1006bc8:	00000106 	br	1006bd0 <vTaskPriorityInherit+0x8c>
 1006bcc:	0005883a 	mov	r2,zero
 1006bd0:	10803fcc 	andi	r2,r2,255
 1006bd4:	10001b26 	beq	r2,zero,1006c44 <vTaskPriorityInherit+0x100>
				{
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 1006bd8:	e0bffe17 	ldw	r2,-8(fp)
 1006bdc:	10800104 	addi	r2,r2,4
 1006be0:	1009883a 	mov	r4,r2
 1006be4:	1003a1c0 	call	1003a1c <uxListRemove>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 1006be8:	d0a08417 	ldw	r2,-32240(gp)
 1006bec:	10c00b17 	ldw	r3,44(r2)
 1006bf0:	e0bffe17 	ldw	r2,-8(fp)
 1006bf4:	10c00b15 	stw	r3,44(r2)
					prvAddTaskToReadyList( pxTCB );
 1006bf8:	e0bffe17 	ldw	r2,-8(fp)
 1006bfc:	10800b17 	ldw	r2,44(r2)
 1006c00:	d0e08a17 	ldw	r3,-32216(gp)
 1006c04:	1880032e 	bgeu	r3,r2,1006c14 <vTaskPriorityInherit+0xd0>
 1006c08:	e0bffe17 	ldw	r2,-8(fp)
 1006c0c:	10800b17 	ldw	r2,44(r2)
 1006c10:	d0a08a15 	stw	r2,-32216(gp)
 1006c14:	e0bffe17 	ldw	r2,-8(fp)
 1006c18:	10800b17 	ldw	r2,44(r2)
 1006c1c:	10c00524 	muli	r3,r2,20
 1006c20:	00805cf4 	movhi	r2,371
 1006c24:	10a3a404 	addi	r2,r2,-29040
 1006c28:	1887883a 	add	r3,r3,r2
 1006c2c:	e0bffe17 	ldw	r2,-8(fp)
 1006c30:	10800104 	addi	r2,r2,4
 1006c34:	100b883a 	mov	r5,r2
 1006c38:	1809883a 	mov	r4,r3
 1006c3c:	10038b80 	call	10038b8 <vListInsertEnd>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 1006c40:	00000406 	br	1006c54 <vTaskPriorityInherit+0x110>
					prvAddTaskToReadyList( pxTCB );
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 1006c44:	d0a08417 	ldw	r2,-32240(gp)
 1006c48:	10c00b17 	ldw	r3,44(r2)
 1006c4c:	e0bffe17 	ldw	r2,-8(fp)
 1006c50:	10c00b15 	stw	r3,44(r2)
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 1006c54:	0001883a 	nop
 1006c58:	e037883a 	mov	sp,fp
 1006c5c:	dfc00117 	ldw	ra,4(sp)
 1006c60:	df000017 	ldw	fp,0(sp)
 1006c64:	dec00204 	addi	sp,sp,8
 1006c68:	f800283a 	ret

01006c6c <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
 1006c6c:	defffb04 	addi	sp,sp,-20
 1006c70:	dfc00415 	stw	ra,16(sp)
 1006c74:	df000315 	stw	fp,12(sp)
 1006c78:	df000304 	addi	fp,sp,12
 1006c7c:	e13fff15 	stw	r4,-4(fp)
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
 1006c80:	e0bfff17 	ldw	r2,-4(fp)
 1006c84:	e0bffe15 	stw	r2,-8(fp)
	BaseType_t xReturn = pdFALSE;
 1006c88:	e03ffd15 	stw	zero,-12(fp)

		if( pxMutexHolder != NULL )
 1006c8c:	e0bfff17 	ldw	r2,-4(fp)
 1006c90:	10002f26 	beq	r2,zero,1006d50 <xTaskPriorityDisinherit+0xe4>
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );

			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
 1006c94:	e0bffe17 	ldw	r2,-8(fp)
 1006c98:	10801117 	ldw	r2,68(r2)
 1006c9c:	10ffffc4 	addi	r3,r2,-1
 1006ca0:	e0bffe17 	ldw	r2,-8(fp)
 1006ca4:	10c01115 	stw	r3,68(r2)

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 1006ca8:	e0bffe17 	ldw	r2,-8(fp)
 1006cac:	10c00b17 	ldw	r3,44(r2)
 1006cb0:	e0bffe17 	ldw	r2,-8(fp)
 1006cb4:	10801017 	ldw	r2,64(r2)
 1006cb8:	18802526 	beq	r3,r2,1006d50 <xTaskPriorityDisinherit+0xe4>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
 1006cbc:	e0bffe17 	ldw	r2,-8(fp)
 1006cc0:	10801117 	ldw	r2,68(r2)
 1006cc4:	1000221e 	bne	r2,zero,1006d50 <xTaskPriorityDisinherit+0xe4>
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding	task then it must be the running state task.  Remove
					the	holding task from the ready	list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 1006cc8:	e0bffe17 	ldw	r2,-8(fp)
 1006ccc:	10800104 	addi	r2,r2,4
 1006cd0:	1009883a 	mov	r4,r2
 1006cd4:	1003a1c0 	call	1003a1c <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
 1006cd8:	e0bffe17 	ldw	r2,-8(fp)
 1006cdc:	10c01017 	ldw	r3,64(r2)
 1006ce0:	e0bffe17 	ldw	r2,-8(fp)
 1006ce4:	10c00b15 	stw	r3,44(r2)

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 1006ce8:	e0bffe17 	ldw	r2,-8(fp)
 1006cec:	10800b17 	ldw	r2,44(r2)
 1006cf0:	00c00144 	movi	r3,5
 1006cf4:	1887c83a 	sub	r3,r3,r2
 1006cf8:	e0bffe17 	ldw	r2,-8(fp)
 1006cfc:	10c00615 	stw	r3,24(r2)
					prvAddTaskToReadyList( pxTCB );
 1006d00:	e0bffe17 	ldw	r2,-8(fp)
 1006d04:	10800b17 	ldw	r2,44(r2)
 1006d08:	d0e08a17 	ldw	r3,-32216(gp)
 1006d0c:	1880032e 	bgeu	r3,r2,1006d1c <xTaskPriorityDisinherit+0xb0>
 1006d10:	e0bffe17 	ldw	r2,-8(fp)
 1006d14:	10800b17 	ldw	r2,44(r2)
 1006d18:	d0a08a15 	stw	r2,-32216(gp)
 1006d1c:	e0bffe17 	ldw	r2,-8(fp)
 1006d20:	10800b17 	ldw	r2,44(r2)
 1006d24:	10c00524 	muli	r3,r2,20
 1006d28:	00805cf4 	movhi	r2,371
 1006d2c:	10a3a404 	addi	r2,r2,-29040
 1006d30:	1887883a 	add	r3,r3,r2
 1006d34:	e0bffe17 	ldw	r2,-8(fp)
 1006d38:	10800104 	addi	r2,r2,4
 1006d3c:	100b883a 	mov	r5,r2
 1006d40:	1809883a 	mov	r4,r3
 1006d44:	10038b80 	call	10038b8 <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
 1006d48:	00800044 	movi	r2,1
 1006d4c:	e0bffd15 	stw	r2,-12(fp)
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
 1006d50:	e0bffd17 	ldw	r2,-12(fp)
	}
 1006d54:	e037883a 	mov	sp,fp
 1006d58:	dfc00117 	ldw	ra,4(sp)
 1006d5c:	df000017 	ldw	fp,0(sp)
 1006d60:	dec00204 	addi	sp,sp,8
 1006d64:	f800283a 	ret

01006d68 <vTaskEnterCritical>:
/*-----------------------------------------------------------*/

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskEnterCritical( void )
	{
 1006d68:	defffe04 	addi	sp,sp,-8
 1006d6c:	df000115 	stw	fp,4(sp)
 1006d70:	df000104 	addi	fp,sp,4
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1006d74:	0005303a 	rdctl	r2,status
 1006d78:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1006d7c:	e0ffff17 	ldw	r3,-4(fp)
 1006d80:	00bfff84 	movi	r2,-2
 1006d84:	1884703a 	and	r2,r3,r2
 1006d88:	1001703a 	wrctl	status,r2
		portDISABLE_INTERRUPTS();

		if( xSchedulerRunning != pdFALSE )
 1006d8c:	d0a08b17 	ldw	r2,-32212(gp)
 1006d90:	10000526 	beq	r2,zero,1006da8 <vTaskEnterCritical+0x40>
		{
			( pxCurrentTCB->uxCriticalNesting )++;
 1006d94:	d0a08417 	ldw	r2,-32240(gp)
 1006d98:	10c00f17 	ldw	r3,60(r2)
 1006d9c:	18c00044 	addi	r3,r3,1
 1006da0:	10c00f15 	stw	r3,60(r2)
			function so	assert() if it is being called from an interrupt
			context.  Only API functions that end in "FromISR" can be used in an
			interrupt.  Only assert if the critical nesting count is 1 to
			protect against recursive calls if the assert function also uses a
			critical section. */
			if( pxCurrentTCB->uxCriticalNesting == 1 )
 1006da4:	d0a08417 	ldw	r2,-32240(gp)
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 1006da8:	0001883a 	nop
 1006dac:	e037883a 	mov	sp,fp
 1006db0:	df000017 	ldw	fp,0(sp)
 1006db4:	dec00104 	addi	sp,sp,4
 1006db8:	f800283a 	ret

01006dbc <vTaskExitCritical>:
/*-----------------------------------------------------------*/

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskExitCritical( void )
	{
 1006dbc:	defffe04 	addi	sp,sp,-8
 1006dc0:	df000115 	stw	fp,4(sp)
 1006dc4:	df000104 	addi	fp,sp,4
		if( xSchedulerRunning != pdFALSE )
 1006dc8:	d0a08b17 	ldw	r2,-32212(gp)
 1006dcc:	10000e26 	beq	r2,zero,1006e08 <vTaskExitCritical+0x4c>
		{
			if( pxCurrentTCB->uxCriticalNesting > 0U )
 1006dd0:	d0a08417 	ldw	r2,-32240(gp)
 1006dd4:	10800f17 	ldw	r2,60(r2)
 1006dd8:	10000b26 	beq	r2,zero,1006e08 <vTaskExitCritical+0x4c>
			{
				( pxCurrentTCB->uxCriticalNesting )--;
 1006ddc:	d0a08417 	ldw	r2,-32240(gp)
 1006de0:	10c00f17 	ldw	r3,60(r2)
 1006de4:	18ffffc4 	addi	r3,r3,-1
 1006de8:	10c00f15 	stw	r3,60(r2)

				if( pxCurrentTCB->uxCriticalNesting == 0U )
 1006dec:	d0a08417 	ldw	r2,-32240(gp)
 1006df0:	10800f17 	ldw	r2,60(r2)
 1006df4:	1000041e 	bne	r2,zero,1006e08 <vTaskExitCritical+0x4c>
 1006df8:	00800044 	movi	r2,1
 1006dfc:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 1006e00:	e0bfff17 	ldw	r2,-4(fp)
 1006e04:	1001703a 	wrctl	status,r2
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 1006e08:	0001883a 	nop
 1006e0c:	e037883a 	mov	sp,fp
 1006e10:	df000017 	ldw	fp,0(sp)
 1006e14:	dec00104 	addi	sp,sp,4
 1006e18:	f800283a 	ret

01006e1c <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
 1006e1c:	defffe04 	addi	sp,sp,-8
 1006e20:	df000115 	stw	fp,4(sp)
 1006e24:	df000104 	addi	fp,sp,4
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
 1006e28:	d0a08417 	ldw	r2,-32240(gp)
 1006e2c:	10800617 	ldw	r2,24(r2)
 1006e30:	e0bfff15 	stw	r2,-4(fp)

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 1006e34:	d0a08417 	ldw	r2,-32240(gp)
 1006e38:	d0e08417 	ldw	r3,-32240(gp)
 1006e3c:	18c00b17 	ldw	r3,44(r3)
 1006e40:	01000144 	movi	r4,5
 1006e44:	20c7c83a 	sub	r3,r4,r3
 1006e48:	10c00615 	stw	r3,24(r2)

	return uxReturn;
 1006e4c:	e0bfff17 	ldw	r2,-4(fp)
}
 1006e50:	e037883a 	mov	sp,fp
 1006e54:	df000017 	ldw	fp,0(sp)
 1006e58:	dec00104 	addi	sp,sp,4
 1006e5c:	f800283a 	ret

01006e60 <pvTaskIncrementMutexHeldCount>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void *pvTaskIncrementMutexHeldCount( void )
	{
 1006e60:	deffff04 	addi	sp,sp,-4
 1006e64:	df000015 	stw	fp,0(sp)
 1006e68:	d839883a 	mov	fp,sp
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
 1006e6c:	d0a08417 	ldw	r2,-32240(gp)
 1006e70:	10000426 	beq	r2,zero,1006e84 <pvTaskIncrementMutexHeldCount+0x24>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
 1006e74:	d0a08417 	ldw	r2,-32240(gp)
 1006e78:	10c01117 	ldw	r3,68(r2)
 1006e7c:	18c00044 	addi	r3,r3,1
 1006e80:	10c01115 	stw	r3,68(r2)
		}

		return pxCurrentTCB;
 1006e84:	d0a08417 	ldw	r2,-32240(gp)
	}
 1006e88:	e037883a 	mov	sp,fp
 1006e8c:	df000017 	ldw	fp,0(sp)
 1006e90:	dec00104 	addi	sp,sp,4
 1006e94:	f800283a 	ret

01006e98 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
 1006e98:	defffb04 	addi	sp,sp,-20
 1006e9c:	dfc00415 	stw	ra,16(sp)
 1006ea0:	df000315 	stw	fp,12(sp)
 1006ea4:	df000304 	addi	fp,sp,12
 1006ea8:	e13ffe15 	stw	r4,-8(fp)
 1006eac:	e17fff15 	stw	r5,-4(fp)
	uint32_t ulReturn;

		taskENTER_CRITICAL();
 1006eb0:	1006d680 	call	1006d68 <vTaskEnterCritical>
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
 1006eb4:	d0a08417 	ldw	r2,-32240(gp)
 1006eb8:	10801217 	ldw	r2,72(r2)
 1006ebc:	1000091e 	bne	r2,zero,1006ee4 <ulTaskNotifyTake+0x4c>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
 1006ec0:	d0a08417 	ldw	r2,-32240(gp)
 1006ec4:	00c00044 	movi	r3,1
 1006ec8:	10c01305 	stb	r3,76(r2)

				if( xTicksToWait > ( TickType_t ) 0 )
 1006ecc:	e0bfff17 	ldw	r2,-4(fp)
 1006ed0:	10000426 	beq	r2,zero,1006ee4 <ulTaskNotifyTake+0x4c>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 1006ed4:	01400044 	movi	r5,1
 1006ed8:	e13fff17 	ldw	r4,-4(fp)
 1006edc:	100755c0 	call	100755c <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
 1006ee0:	003b683a 	trap	0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
 1006ee4:	1006dbc0 	call	1006dbc <vTaskExitCritical>

		taskENTER_CRITICAL();
 1006ee8:	1006d680 	call	1006d68 <vTaskEnterCritical>
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
 1006eec:	d0a08417 	ldw	r2,-32240(gp)
 1006ef0:	10801217 	ldw	r2,72(r2)
 1006ef4:	e0bffd15 	stw	r2,-12(fp)

			if( ulReturn != 0UL )
 1006ef8:	e0bffd17 	ldw	r2,-12(fp)
 1006efc:	10000926 	beq	r2,zero,1006f24 <ulTaskNotifyTake+0x8c>
			{
				if( xClearCountOnExit != pdFALSE )
 1006f00:	e0bffe17 	ldw	r2,-8(fp)
 1006f04:	10000326 	beq	r2,zero,1006f14 <ulTaskNotifyTake+0x7c>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
 1006f08:	d0a08417 	ldw	r2,-32240(gp)
 1006f0c:	10001215 	stw	zero,72(r2)
 1006f10:	00000406 	br	1006f24 <ulTaskNotifyTake+0x8c>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - 1;
 1006f14:	d0a08417 	ldw	r2,-32240(gp)
 1006f18:	e0fffd17 	ldw	r3,-12(fp)
 1006f1c:	18ffffc4 	addi	r3,r3,-1
 1006f20:	10c01215 	stw	r3,72(r2)
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 1006f24:	d0a08417 	ldw	r2,-32240(gp)
 1006f28:	10001305 	stb	zero,76(r2)
		}
		taskEXIT_CRITICAL();
 1006f2c:	1006dbc0 	call	1006dbc <vTaskExitCritical>

		return ulReturn;
 1006f30:	e0bffd17 	ldw	r2,-12(fp)
	}
 1006f34:	e037883a 	mov	sp,fp
 1006f38:	dfc00117 	ldw	ra,4(sp)
 1006f3c:	df000017 	ldw	fp,0(sp)
 1006f40:	dec00204 	addi	sp,sp,8
 1006f44:	f800283a 	ret

01006f48 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
 1006f48:	defff904 	addi	sp,sp,-28
 1006f4c:	dfc00615 	stw	ra,24(sp)
 1006f50:	df000515 	stw	fp,20(sp)
 1006f54:	df000504 	addi	fp,sp,20
 1006f58:	e13ffc15 	stw	r4,-16(fp)
 1006f5c:	e17ffd15 	stw	r5,-12(fp)
 1006f60:	e1bffe15 	stw	r6,-8(fp)
 1006f64:	e1ffff15 	stw	r7,-4(fp)
	BaseType_t xReturn;

		taskENTER_CRITICAL();
 1006f68:	1006d680 	call	1006d68 <vTaskEnterCritical>
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
 1006f6c:	d0a08417 	ldw	r2,-32240(gp)
 1006f70:	10801303 	ldbu	r2,76(r2)
 1006f74:	10803fcc 	andi	r2,r2,255
 1006f78:	108000a0 	cmpeqi	r2,r2,2
 1006f7c:	10000f1e 	bne	r2,zero,1006fbc <xTaskNotifyWait+0x74>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
 1006f80:	d0a08417 	ldw	r2,-32240(gp)
 1006f84:	11001217 	ldw	r4,72(r2)
 1006f88:	e0fffc17 	ldw	r3,-16(fp)
 1006f8c:	00c6303a 	nor	r3,zero,r3
 1006f90:	20c6703a 	and	r3,r4,r3
 1006f94:	10c01215 	stw	r3,72(r2)

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
 1006f98:	d0a08417 	ldw	r2,-32240(gp)
 1006f9c:	00c00044 	movi	r3,1
 1006fa0:	10c01305 	stb	r3,76(r2)

				if( xTicksToWait > ( TickType_t ) 0 )
 1006fa4:	e0bfff17 	ldw	r2,-4(fp)
 1006fa8:	10000426 	beq	r2,zero,1006fbc <xTaskNotifyWait+0x74>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 1006fac:	01400044 	movi	r5,1
 1006fb0:	e13fff17 	ldw	r4,-4(fp)
 1006fb4:	100755c0 	call	100755c <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
 1006fb8:	003b683a 	trap	0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
 1006fbc:	1006dbc0 	call	1006dbc <vTaskExitCritical>

		taskENTER_CRITICAL();
 1006fc0:	1006d680 	call	1006d68 <vTaskEnterCritical>
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
 1006fc4:	e0bffe17 	ldw	r2,-8(fp)
 1006fc8:	10000426 	beq	r2,zero,1006fdc <xTaskNotifyWait+0x94>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
 1006fcc:	d0a08417 	ldw	r2,-32240(gp)
 1006fd0:	10c01217 	ldw	r3,72(r2)
 1006fd4:	e0bffe17 	ldw	r2,-8(fp)
 1006fd8:	10c00015 	stw	r3,0(r2)

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState == taskWAITING_NOTIFICATION )
 1006fdc:	d0a08417 	ldw	r2,-32240(gp)
 1006fe0:	10801303 	ldbu	r2,76(r2)
 1006fe4:	10803fcc 	andi	r2,r2,255
 1006fe8:	10800058 	cmpnei	r2,r2,1
 1006fec:	1000021e 	bne	r2,zero,1006ff8 <xTaskNotifyWait+0xb0>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
 1006ff0:	e03ffb15 	stw	zero,-20(fp)
 1006ff4:	00000806 	br	1007018 <xTaskNotifyWait+0xd0>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
 1006ff8:	d0a08417 	ldw	r2,-32240(gp)
 1006ffc:	11001217 	ldw	r4,72(r2)
 1007000:	e0fffd17 	ldw	r3,-12(fp)
 1007004:	00c6303a 	nor	r3,zero,r3
 1007008:	20c6703a 	and	r3,r4,r3
 100700c:	10c01215 	stw	r3,72(r2)
				xReturn = pdTRUE;
 1007010:	00800044 	movi	r2,1
 1007014:	e0bffb15 	stw	r2,-20(fp)
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 1007018:	d0a08417 	ldw	r2,-32240(gp)
 100701c:	10001305 	stb	zero,76(r2)
		}
		taskEXIT_CRITICAL();
 1007020:	1006dbc0 	call	1006dbc <vTaskExitCritical>

		return xReturn;
 1007024:	e0bffb17 	ldw	r2,-20(fp)
	}
 1007028:	e037883a 	mov	sp,fp
 100702c:	dfc00117 	ldw	ra,4(sp)
 1007030:	df000017 	ldw	fp,0(sp)
 1007034:	dec00204 	addi	sp,sp,8
 1007038:	f800283a 	ret

0100703c <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
 100703c:	defff704 	addi	sp,sp,-36
 1007040:	dfc00815 	stw	ra,32(sp)
 1007044:	df000715 	stw	fp,28(sp)
 1007048:	df000704 	addi	fp,sp,28
 100704c:	e13ffc15 	stw	r4,-16(fp)
 1007050:	e17ffd15 	stw	r5,-12(fp)
 1007054:	e1bffe15 	stw	r6,-8(fp)
 1007058:	e1ffff15 	stw	r7,-4(fp)
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
 100705c:	00800044 	movi	r2,1
 1007060:	e0bff915 	stw	r2,-28(fp)
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = ( TCB_t * ) xTaskToNotify;
 1007064:	e0bffc17 	ldw	r2,-16(fp)
 1007068:	e0bffa15 	stw	r2,-24(fp)

		taskENTER_CRITICAL();
 100706c:	1006d680 	call	1006d68 <vTaskEnterCritical>
		{
			if( pulPreviousNotificationValue != NULL )
 1007070:	e0bfff17 	ldw	r2,-4(fp)
 1007074:	10000426 	beq	r2,zero,1007088 <xTaskGenericNotify+0x4c>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
 1007078:	e0bffa17 	ldw	r2,-24(fp)
 100707c:	10c01217 	ldw	r3,72(r2)
 1007080:	e0bfff17 	ldw	r2,-4(fp)
 1007084:	10c00015 	stw	r3,0(r2)
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
 1007088:	e0bffa17 	ldw	r2,-24(fp)
 100708c:	10801303 	ldbu	r2,76(r2)
 1007090:	e0bffb05 	stb	r2,-20(fp)

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 1007094:	e0bffa17 	ldw	r2,-24(fp)
 1007098:	00c00084 	movi	r3,2
 100709c:	10c01305 	stb	r3,76(r2)

			switch( eAction )
 10070a0:	e0bffe17 	ldw	r2,-8(fp)
 10070a4:	10800168 	cmpgeui	r2,r2,5
 10070a8:	1000271e 	bne	r2,zero,1007148 <xTaskGenericNotify+0x10c>
 10070ac:	e0bffe17 	ldw	r2,-8(fp)
 10070b0:	100690ba 	slli	r3,r2,2
 10070b4:	00804034 	movhi	r2,256
 10070b8:	109c3204 	addi	r2,r2,28872
 10070bc:	1885883a 	add	r2,r3,r2
 10070c0:	10800017 	ldw	r2,0(r2)
 10070c4:	1000683a 	jmp	r2
 10070c8:	01007144 	movi	r4,453
 10070cc:	010070dc 	xori	r4,zero,451
 10070d0:	010070f8 	rdprs	r4,zero,451
 10070d4:	01007110 	cmplti	r4,zero,452
 10070d8:	01007120 	cmpeqi	r4,zero,452
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
 10070dc:	e0bffa17 	ldw	r2,-24(fp)
 10070e0:	10c01217 	ldw	r3,72(r2)
 10070e4:	e0bffd17 	ldw	r2,-12(fp)
 10070e8:	1886b03a 	or	r3,r3,r2
 10070ec:	e0bffa17 	ldw	r2,-24(fp)
 10070f0:	10c01215 	stw	r3,72(r2)
					break;
 10070f4:	00001406 	br	1007148 <xTaskGenericNotify+0x10c>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
 10070f8:	e0bffa17 	ldw	r2,-24(fp)
 10070fc:	10801217 	ldw	r2,72(r2)
 1007100:	10c00044 	addi	r3,r2,1
 1007104:	e0bffa17 	ldw	r2,-24(fp)
 1007108:	10c01215 	stw	r3,72(r2)
					break;
 100710c:	00000e06 	br	1007148 <xTaskGenericNotify+0x10c>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
 1007110:	e0bffa17 	ldw	r2,-24(fp)
 1007114:	e0fffd17 	ldw	r3,-12(fp)
 1007118:	10c01215 	stw	r3,72(r2)
					break;
 100711c:	00000a06 	br	1007148 <xTaskGenericNotify+0x10c>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
 1007120:	e0bffb03 	ldbu	r2,-20(fp)
 1007124:	108000a0 	cmpeqi	r2,r2,2
 1007128:	1000041e 	bne	r2,zero,100713c <xTaskGenericNotify+0x100>
					{
						pxTCB->ulNotifiedValue = ulValue;
 100712c:	e0bffa17 	ldw	r2,-24(fp)
 1007130:	e0fffd17 	ldw	r3,-12(fp)
 1007134:	10c01215 	stw	r3,72(r2)
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
					}
					break;
 1007138:	00000306 	br	1007148 <xTaskGenericNotify+0x10c>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
 100713c:	e03ff915 	stw	zero,-28(fp)
					}
					break;
 1007140:	00000106 	br	1007148 <xTaskGenericNotify+0x10c>

				case eNoAction:
					/* The task is being notified without its notify value being
					updated. */
					break;
 1007144:	0001883a 	nop

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 1007148:	e0bffb03 	ldbu	r2,-20(fp)
 100714c:	10800058 	cmpnei	r2,r2,1
 1007150:	10001c1e 	bne	r2,zero,10071c4 <xTaskGenericNotify+0x188>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 1007154:	e0bffa17 	ldw	r2,-24(fp)
 1007158:	10800104 	addi	r2,r2,4
 100715c:	1009883a 	mov	r4,r2
 1007160:	1003a1c0 	call	1003a1c <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
 1007164:	e0bffa17 	ldw	r2,-24(fp)
 1007168:	10800b17 	ldw	r2,44(r2)
 100716c:	d0e08a17 	ldw	r3,-32216(gp)
 1007170:	1880032e 	bgeu	r3,r2,1007180 <xTaskGenericNotify+0x144>
 1007174:	e0bffa17 	ldw	r2,-24(fp)
 1007178:	10800b17 	ldw	r2,44(r2)
 100717c:	d0a08a15 	stw	r2,-32216(gp)
 1007180:	e0bffa17 	ldw	r2,-24(fp)
 1007184:	10800b17 	ldw	r2,44(r2)
 1007188:	10c00524 	muli	r3,r2,20
 100718c:	00805cf4 	movhi	r2,371
 1007190:	10a3a404 	addi	r2,r2,-29040
 1007194:	1887883a 	add	r3,r3,r2
 1007198:	e0bffa17 	ldw	r2,-24(fp)
 100719c:	10800104 	addi	r2,r2,4
 10071a0:	100b883a 	mov	r5,r2
 10071a4:	1809883a 	mov	r4,r3
 10071a8:	10038b80 	call	10038b8 <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 10071ac:	e0bffa17 	ldw	r2,-24(fp)
 10071b0:	10800b17 	ldw	r2,44(r2)
 10071b4:	d0e08417 	ldw	r3,-32240(gp)
 10071b8:	18c00b17 	ldw	r3,44(r3)
 10071bc:	1880012e 	bgeu	r3,r2,10071c4 <xTaskGenericNotify+0x188>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
 10071c0:	003b683a 	trap	0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
 10071c4:	1006dbc0 	call	1006dbc <vTaskExitCritical>

		return xReturn;
 10071c8:	e0bff917 	ldw	r2,-28(fp)
	}
 10071cc:	e037883a 	mov	sp,fp
 10071d0:	dfc00117 	ldw	ra,4(sp)
 10071d4:	df000017 	ldw	fp,0(sp)
 10071d8:	dec00204 	addi	sp,sp,8
 10071dc:	f800283a 	ret

010071e0 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
 10071e0:	defff604 	addi	sp,sp,-40
 10071e4:	dfc00915 	stw	ra,36(sp)
 10071e8:	df000815 	stw	fp,32(sp)
 10071ec:	df000804 	addi	fp,sp,32
 10071f0:	e13ffc15 	stw	r4,-16(fp)
 10071f4:	e17ffd15 	stw	r5,-12(fp)
 10071f8:	e1bffe15 	stw	r6,-8(fp)
 10071fc:	e1ffff15 	stw	r7,-4(fp)
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
 1007200:	00800044 	movi	r2,1
 1007204:	e0bff815 	stw	r2,-32(fp)
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = ( TCB_t * ) xTaskToNotify;
 1007208:	e0bffc17 	ldw	r2,-16(fp)
 100720c:	e0bff915 	stw	r2,-28(fp)

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 1007210:	e03ffa15 	stw	zero,-24(fp)
		{
			if( pulPreviousNotificationValue != NULL )
 1007214:	e0bfff17 	ldw	r2,-4(fp)
 1007218:	10000426 	beq	r2,zero,100722c <xTaskGenericNotifyFromISR+0x4c>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
 100721c:	e0bff917 	ldw	r2,-28(fp)
 1007220:	10c01217 	ldw	r3,72(r2)
 1007224:	e0bfff17 	ldw	r2,-4(fp)
 1007228:	10c00015 	stw	r3,0(r2)
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
 100722c:	e0bff917 	ldw	r2,-28(fp)
 1007230:	10801303 	ldbu	r2,76(r2)
 1007234:	e0bffb05 	stb	r2,-20(fp)
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 1007238:	e0bff917 	ldw	r2,-28(fp)
 100723c:	00c00084 	movi	r3,2
 1007240:	10c01305 	stb	r3,76(r2)

			switch( eAction )
 1007244:	e0bffe17 	ldw	r2,-8(fp)
 1007248:	10800168 	cmpgeui	r2,r2,5
 100724c:	1000271e 	bne	r2,zero,10072ec <xTaskGenericNotifyFromISR+0x10c>
 1007250:	e0bffe17 	ldw	r2,-8(fp)
 1007254:	100690ba 	slli	r3,r2,2
 1007258:	00804034 	movhi	r2,256
 100725c:	109c9b04 	addi	r2,r2,29292
 1007260:	1885883a 	add	r2,r3,r2
 1007264:	10800017 	ldw	r2,0(r2)
 1007268:	1000683a 	jmp	r2
 100726c:	010072e8 	cmpgeui	r4,zero,459
 1007270:	01007280 	call	100728 <__reset+0x80728>
 1007274:	0100729c 	xori	r4,zero,458
 1007278:	010072b4 	movhi	r4,458
 100727c:	010072c4 	movi	r4,459
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
 1007280:	e0bff917 	ldw	r2,-28(fp)
 1007284:	10c01217 	ldw	r3,72(r2)
 1007288:	e0bffd17 	ldw	r2,-12(fp)
 100728c:	1886b03a 	or	r3,r3,r2
 1007290:	e0bff917 	ldw	r2,-28(fp)
 1007294:	10c01215 	stw	r3,72(r2)
					break;
 1007298:	00001406 	br	10072ec <xTaskGenericNotifyFromISR+0x10c>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
 100729c:	e0bff917 	ldw	r2,-28(fp)
 10072a0:	10801217 	ldw	r2,72(r2)
 10072a4:	10c00044 	addi	r3,r2,1
 10072a8:	e0bff917 	ldw	r2,-28(fp)
 10072ac:	10c01215 	stw	r3,72(r2)
					break;
 10072b0:	00000e06 	br	10072ec <xTaskGenericNotifyFromISR+0x10c>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
 10072b4:	e0bff917 	ldw	r2,-28(fp)
 10072b8:	e0fffd17 	ldw	r3,-12(fp)
 10072bc:	10c01215 	stw	r3,72(r2)
					break;
 10072c0:	00000a06 	br	10072ec <xTaskGenericNotifyFromISR+0x10c>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
 10072c4:	e0bffb03 	ldbu	r2,-20(fp)
 10072c8:	108000a0 	cmpeqi	r2,r2,2
 10072cc:	1000041e 	bne	r2,zero,10072e0 <xTaskGenericNotifyFromISR+0x100>
					{
						pxTCB->ulNotifiedValue = ulValue;
 10072d0:	e0bff917 	ldw	r2,-28(fp)
 10072d4:	e0fffd17 	ldw	r3,-12(fp)
 10072d8:	10c01215 	stw	r3,72(r2)
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
					}
					break;
 10072dc:	00000306 	br	10072ec <xTaskGenericNotifyFromISR+0x10c>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
 10072e0:	e03ff815 	stw	zero,-32(fp)
					}
					break;
 10072e4:	00000106 	br	10072ec <xTaskGenericNotifyFromISR+0x10c>

				case eNoAction :
					/* The task is being notified without its notify value being
					updated. */
					break;
 10072e8:	0001883a 	nop

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 10072ec:	e0bffb03 	ldbu	r2,-20(fp)
 10072f0:	10800058 	cmpnei	r2,r2,1
 10072f4:	10002c1e 	bne	r2,zero,10073a8 <xTaskGenericNotifyFromISR+0x1c8>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 10072f8:	d0a09217 	ldw	r2,-32184(gp)
 10072fc:	1000171e 	bne	r2,zero,100735c <xTaskGenericNotifyFromISR+0x17c>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 1007300:	e0bff917 	ldw	r2,-28(fp)
 1007304:	10800104 	addi	r2,r2,4
 1007308:	1009883a 	mov	r4,r2
 100730c:	1003a1c0 	call	1003a1c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 1007310:	e0bff917 	ldw	r2,-28(fp)
 1007314:	10800b17 	ldw	r2,44(r2)
 1007318:	d0e08a17 	ldw	r3,-32216(gp)
 100731c:	1880032e 	bgeu	r3,r2,100732c <xTaskGenericNotifyFromISR+0x14c>
 1007320:	e0bff917 	ldw	r2,-28(fp)
 1007324:	10800b17 	ldw	r2,44(r2)
 1007328:	d0a08a15 	stw	r2,-32216(gp)
 100732c:	e0bff917 	ldw	r2,-28(fp)
 1007330:	10800b17 	ldw	r2,44(r2)
 1007334:	10c00524 	muli	r3,r2,20
 1007338:	00805cf4 	movhi	r2,371
 100733c:	10a3a404 	addi	r2,r2,-29040
 1007340:	1887883a 	add	r3,r3,r2
 1007344:	e0bff917 	ldw	r2,-28(fp)
 1007348:	10800104 	addi	r2,r2,4
 100734c:	100b883a 	mov	r5,r2
 1007350:	1809883a 	mov	r4,r3
 1007354:	10038b80 	call	10038b8 <vListInsertEnd>
 1007358:	00000606 	br	1007374 <xTaskGenericNotifyFromISR+0x194>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 100735c:	e0bff917 	ldw	r2,-28(fp)
 1007360:	10800604 	addi	r2,r2,24
 1007364:	100b883a 	mov	r5,r2
 1007368:	01005cf4 	movhi	r4,371
 100736c:	2123c704 	addi	r4,r4,-28900
 1007370:	10038b80 	call	10038b8 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 1007374:	e0bff917 	ldw	r2,-28(fp)
 1007378:	10800b17 	ldw	r2,44(r2)
 100737c:	d0e08417 	ldw	r3,-32240(gp)
 1007380:	18c00b17 	ldw	r3,44(r3)
 1007384:	1880082e 	bgeu	r3,r2,10073a8 <xTaskGenericNotifyFromISR+0x1c8>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
 1007388:	e0800217 	ldw	r2,8(fp)
 100738c:	10000426 	beq	r2,zero,10073a0 <xTaskGenericNotifyFromISR+0x1c0>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
 1007390:	e0800217 	ldw	r2,8(fp)
 1007394:	00c00044 	movi	r3,1
 1007398:	10c00015 	stw	r3,0(r2)
 100739c:	00000206 	br	10073a8 <xTaskGenericNotifyFromISR+0x1c8>
					else
					{
						/* Mark that a yield is pending in case the user is not
						using the "xHigherPriorityTaskWoken" parameter to an ISR
						safe FreeRTOS function. */
						xYieldPending = pdTRUE;
 10073a0:	00800044 	movi	r2,1
 10073a4:	d0a08d15 	stw	r2,-32204(gp)
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
 10073a8:	e0bff817 	ldw	r2,-32(fp)
	}
 10073ac:	e037883a 	mov	sp,fp
 10073b0:	dfc00117 	ldw	ra,4(sp)
 10073b4:	df000017 	ldw	fp,0(sp)
 10073b8:	dec00204 	addi	sp,sp,8
 10073bc:	f800283a 	ret

010073c0 <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
 10073c0:	defff904 	addi	sp,sp,-28
 10073c4:	dfc00615 	stw	ra,24(sp)
 10073c8:	df000515 	stw	fp,20(sp)
 10073cc:	df000504 	addi	fp,sp,20
 10073d0:	e13ffe15 	stw	r4,-8(fp)
 10073d4:	e17fff15 	stw	r5,-4(fp)
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = ( TCB_t * ) xTaskToNotify;
 10073d8:	e0bffe17 	ldw	r2,-8(fp)
 10073dc:	e0bffb15 	stw	r2,-20(fp)

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 10073e0:	e03ffc15 	stw	zero,-16(fp)
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
 10073e4:	e0bffb17 	ldw	r2,-20(fp)
 10073e8:	10801303 	ldbu	r2,76(r2)
 10073ec:	e0bffd05 	stb	r2,-12(fp)
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 10073f0:	e0bffb17 	ldw	r2,-20(fp)
 10073f4:	00c00084 	movi	r3,2
 10073f8:	10c01305 	stb	r3,76(r2)

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
 10073fc:	e0bffb17 	ldw	r2,-20(fp)
 1007400:	10801217 	ldw	r2,72(r2)
 1007404:	10c00044 	addi	r3,r2,1
 1007408:	e0bffb17 	ldw	r2,-20(fp)
 100740c:	10c01215 	stw	r3,72(r2)

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 1007410:	e0bffd03 	ldbu	r2,-12(fp)
 1007414:	10800058 	cmpnei	r2,r2,1
 1007418:	10002c1e 	bne	r2,zero,10074cc <vTaskNotifyGiveFromISR+0x10c>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 100741c:	d0a09217 	ldw	r2,-32184(gp)
 1007420:	1000171e 	bne	r2,zero,1007480 <vTaskNotifyGiveFromISR+0xc0>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 1007424:	e0bffb17 	ldw	r2,-20(fp)
 1007428:	10800104 	addi	r2,r2,4
 100742c:	1009883a 	mov	r4,r2
 1007430:	1003a1c0 	call	1003a1c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 1007434:	e0bffb17 	ldw	r2,-20(fp)
 1007438:	10800b17 	ldw	r2,44(r2)
 100743c:	d0e08a17 	ldw	r3,-32216(gp)
 1007440:	1880032e 	bgeu	r3,r2,1007450 <vTaskNotifyGiveFromISR+0x90>
 1007444:	e0bffb17 	ldw	r2,-20(fp)
 1007448:	10800b17 	ldw	r2,44(r2)
 100744c:	d0a08a15 	stw	r2,-32216(gp)
 1007450:	e0bffb17 	ldw	r2,-20(fp)
 1007454:	10800b17 	ldw	r2,44(r2)
 1007458:	10c00524 	muli	r3,r2,20
 100745c:	00805cf4 	movhi	r2,371
 1007460:	10a3a404 	addi	r2,r2,-29040
 1007464:	1887883a 	add	r3,r3,r2
 1007468:	e0bffb17 	ldw	r2,-20(fp)
 100746c:	10800104 	addi	r2,r2,4
 1007470:	100b883a 	mov	r5,r2
 1007474:	1809883a 	mov	r4,r3
 1007478:	10038b80 	call	10038b8 <vListInsertEnd>
 100747c:	00000606 	br	1007498 <vTaskNotifyGiveFromISR+0xd8>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 1007480:	e0bffb17 	ldw	r2,-20(fp)
 1007484:	10800604 	addi	r2,r2,24
 1007488:	100b883a 	mov	r5,r2
 100748c:	01005cf4 	movhi	r4,371
 1007490:	2123c704 	addi	r4,r4,-28900
 1007494:	10038b80 	call	10038b8 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 1007498:	e0bffb17 	ldw	r2,-20(fp)
 100749c:	10800b17 	ldw	r2,44(r2)
 10074a0:	d0e08417 	ldw	r3,-32240(gp)
 10074a4:	18c00b17 	ldw	r3,44(r3)
 10074a8:	1880082e 	bgeu	r3,r2,10074cc <vTaskNotifyGiveFromISR+0x10c>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
 10074ac:	e0bfff17 	ldw	r2,-4(fp)
 10074b0:	10000426 	beq	r2,zero,10074c4 <vTaskNotifyGiveFromISR+0x104>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
 10074b4:	e0bfff17 	ldw	r2,-4(fp)
 10074b8:	00c00044 	movi	r3,1
 10074bc:	10c00015 	stw	r3,0(r2)
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
 10074c0:	00000206 	br	10074cc <vTaskNotifyGiveFromISR+0x10c>
					else
					{
						/* Mark that a yield is pending in case the user is not
						using the "xHigherPriorityTaskWoken" parameter in an ISR
						safe FreeRTOS function. */
						xYieldPending = pdTRUE;
 10074c4:	00800044 	movi	r2,1
 10074c8:	d0a08d15 	stw	r2,-32204(gp)
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
 10074cc:	0001883a 	nop
 10074d0:	e037883a 	mov	sp,fp
 10074d4:	dfc00117 	ldw	ra,4(sp)
 10074d8:	df000017 	ldw	fp,0(sp)
 10074dc:	dec00204 	addi	sp,sp,8
 10074e0:	f800283a 	ret

010074e4 <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
 10074e4:	defffb04 	addi	sp,sp,-20
 10074e8:	dfc00415 	stw	ra,16(sp)
 10074ec:	df000315 	stw	fp,12(sp)
 10074f0:	df000304 	addi	fp,sp,12
 10074f4:	e13fff15 	stw	r4,-4(fp)
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
 10074f8:	e0bfff17 	ldw	r2,-4(fp)
 10074fc:	1000021e 	bne	r2,zero,1007508 <xTaskNotifyStateClear+0x24>
 1007500:	d0a08417 	ldw	r2,-32240(gp)
 1007504:	00000106 	br	100750c <xTaskNotifyStateClear+0x28>
 1007508:	e0bfff17 	ldw	r2,-4(fp)
 100750c:	e0bffe15 	stw	r2,-8(fp)

		taskENTER_CRITICAL();
 1007510:	1006d680 	call	1006d68 <vTaskEnterCritical>
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
 1007514:	e0bffe17 	ldw	r2,-8(fp)
 1007518:	10801303 	ldbu	r2,76(r2)
 100751c:	10803fcc 	andi	r2,r2,255
 1007520:	10800098 	cmpnei	r2,r2,2
 1007524:	1000051e 	bne	r2,zero,100753c <xTaskNotifyStateClear+0x58>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 1007528:	e0bffe17 	ldw	r2,-8(fp)
 100752c:	10001305 	stb	zero,76(r2)
				xReturn = pdPASS;
 1007530:	00800044 	movi	r2,1
 1007534:	e0bffd15 	stw	r2,-12(fp)
 1007538:	00000106 	br	1007540 <xTaskNotifyStateClear+0x5c>
			}
			else
			{
				xReturn = pdFAIL;
 100753c:	e03ffd15 	stw	zero,-12(fp)
			}
		}
		taskEXIT_CRITICAL();
 1007540:	1006dbc0 	call	1006dbc <vTaskExitCritical>

		return xReturn;
 1007544:	e0bffd17 	ldw	r2,-12(fp)
	}
 1007548:	e037883a 	mov	sp,fp
 100754c:	dfc00117 	ldw	ra,4(sp)
 1007550:	df000017 	ldw	fp,0(sp)
 1007554:	dec00204 	addi	sp,sp,8
 1007558:	f800283a 	ret

0100755c <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
 100755c:	defffa04 	addi	sp,sp,-24
 1007560:	dfc00515 	stw	ra,20(sp)
 1007564:	df000415 	stw	fp,16(sp)
 1007568:	df000404 	addi	fp,sp,16
 100756c:	e13ffe15 	stw	r4,-8(fp)
 1007570:	e17fff15 	stw	r5,-4(fp)
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
 1007574:	d0a08917 	ldw	r2,-32220(gp)
 1007578:	e0bffc15 	stw	r2,-16(fp)
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 100757c:	d0a08417 	ldw	r2,-32240(gp)
 1007580:	10800104 	addi	r2,r2,4
 1007584:	1009883a 	mov	r4,r2
 1007588:	1003a1c0 	call	1003a1c <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 100758c:	e0bffe17 	ldw	r2,-8(fp)
 1007590:	10bfffd8 	cmpnei	r2,r2,-1
 1007594:	1000091e 	bne	r2,zero,10075bc <prvAddCurrentTaskToDelayedList+0x60>
 1007598:	e0bfff17 	ldw	r2,-4(fp)
 100759c:	10000726 	beq	r2,zero,10075bc <prvAddCurrentTaskToDelayedList+0x60>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 10075a0:	d0a08417 	ldw	r2,-32240(gp)
 10075a4:	10800104 	addi	r2,r2,4
 10075a8:	100b883a 	mov	r5,r2
 10075ac:	01005cf4 	movhi	r4,371
 10075b0:	2123d104 	addi	r4,r4,-28860
 10075b4:	10038b80 	call	10038b8 <vListInsertEnd>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 10075b8:	00001c06 	br	100762c <prvAddCurrentTaskToDelayedList+0xd0>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
 10075bc:	e0fffc17 	ldw	r3,-16(fp)
 10075c0:	e0bffe17 	ldw	r2,-8(fp)
 10075c4:	1885883a 	add	r2,r3,r2
 10075c8:	e0bffd15 	stw	r2,-12(fp)

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 10075cc:	d0a08417 	ldw	r2,-32240(gp)
 10075d0:	e0fffd17 	ldw	r3,-12(fp)
 10075d4:	10c00115 	stw	r3,4(r2)

			if( xTimeToWake < xConstTickCount )
 10075d8:	e0fffd17 	ldw	r3,-12(fp)
 10075dc:	e0bffc17 	ldw	r2,-16(fp)
 10075e0:	1880072e 	bgeu	r3,r2,1007600 <prvAddCurrentTaskToDelayedList+0xa4>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 10075e4:	d0e08617 	ldw	r3,-32232(gp)
 10075e8:	d0a08417 	ldw	r2,-32240(gp)
 10075ec:	10800104 	addi	r2,r2,4
 10075f0:	100b883a 	mov	r5,r2
 10075f4:	1809883a 	mov	r4,r3
 10075f8:	10039440 	call	1003944 <vListInsert>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 10075fc:	00000b06 	br	100762c <prvAddCurrentTaskToDelayedList+0xd0>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 1007600:	d0e08517 	ldw	r3,-32236(gp)
 1007604:	d0a08417 	ldw	r2,-32240(gp)
 1007608:	10800104 	addi	r2,r2,4
 100760c:	100b883a 	mov	r5,r2
 1007610:	1809883a 	mov	r4,r3
 1007614:	10039440 	call	1003944 <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
 1007618:	d0a09017 	ldw	r2,-32192(gp)
 100761c:	e0fffd17 	ldw	r3,-12(fp)
 1007620:	1880022e 	bgeu	r3,r2,100762c <prvAddCurrentTaskToDelayedList+0xd0>
				{
					xNextTaskUnblockTime = xTimeToWake;
 1007624:	e0bffd17 	ldw	r2,-12(fp)
 1007628:	d0a09015 	stw	r2,-32192(gp)

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 100762c:	0001883a 	nop
 1007630:	e037883a 	mov	sp,fp
 1007634:	dfc00117 	ldw	ra,4(sp)
 1007638:	df000017 	ldw	fp,0(sp)
 100763c:	dec00204 	addi	sp,sp,8
 1007640:	f800283a 	ret

01007644 <xSerialPortInitMinimal>:
static void vUARTReceiveHandler( alt_u32 status );
static void vUARTTransmitHandler( alt_u32 status );
/*---------------------------------------------------------------------------*/

xComPortHandle xSerialPortInitMinimal( unsigned long ulWantedBaud, unsigned portBASE_TYPE uxQueueLength )
{
 1007644:	defffb04 	addi	sp,sp,-20
 1007648:	dfc00415 	stw	ra,16(sp)
 100764c:	df000315 	stw	fp,12(sp)
 1007650:	df000304 	addi	fp,sp,12
 1007654:	e13ffe15 	stw	r4,-8(fp)
 1007658:	e17fff15 	stw	r5,-4(fp)
	/* Create the queues used to hold Rx and Tx characters. */
	xRxedChars = xQueueCreate( uxQueueLength, ( unsigned portBASE_TYPE ) sizeof( signed char ) );
 100765c:	000d883a 	mov	r6,zero
 1007660:	01400044 	movi	r5,1
 1007664:	e13fff17 	ldw	r4,-4(fp)
 1007668:	100439c0 	call	100439c <xQueueGenericCreate>
 100766c:	d0a09315 	stw	r2,-32180(gp)
	xCharsForTx = xQueueCreate( uxQueueLength + 1, ( unsigned portBASE_TYPE ) sizeof( signed char ) );
 1007670:	e0bfff17 	ldw	r2,-4(fp)
 1007674:	10800044 	addi	r2,r2,1
 1007678:	000d883a 	mov	r6,zero
 100767c:	01400044 	movi	r5,1
 1007680:	1009883a 	mov	r4,r2
 1007684:	100439c0 	call	100439c <xQueueGenericCreate>
 1007688:	d0a09415 	stw	r2,-32176(gp)

	/* If the queues were created correctly then setup the serial port hardware. */
	if( ( xRxedChars != serINVALID_QUEUE ) && ( xCharsForTx != serINVALID_QUEUE ) )
 100768c:	d0a09317 	ldw	r2,-32180(gp)
 1007690:	10001326 	beq	r2,zero,10076e0 <xSerialPortInitMinimal+0x9c>
 1007694:	d0a09417 	ldw	r2,-32176(gp)
 1007698:	10001126 	beq	r2,zero,10076e0 <xSerialPortInitMinimal+0x9c>
	{
		portENTER_CRITICAL();
 100769c:	1006d680 	call	1006d68 <vTaskEnterCritical>
		{
			uartControl = ALTERA_AVALON_UART_CONTROL_RTS_MSK | ALTERA_AVALON_UART_CONTROL_RRDY_MSK | ALTERA_AVALON_UART_CONTROL_DCTS_MSK;
 10076a0:	00832004 	movi	r2,3200
 10076a4:	d0a09515 	stw	r2,-32172(gp)
			IOWR_ALTERA_AVALON_UART_CONTROL( UART_BASE, uartControl );
 10076a8:	d0a09517 	ldw	r2,-32172(gp)
 10076ac:	1007883a 	mov	r3,r2
 10076b0:	00869b04 	movi	r2,6764
 10076b4:	10c00035 	stwio	r3,0(r2)

		    /* register the interrupt handler */
			//cjr Jul-1-2010 new API
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
    alt_ic_isr_register(UART_IRQ_INTERRUPT_CONTROLLER_ID, UART_IRQ,
 10076b8:	d8000015 	stw	zero,0(sp)
 10076bc:	000f883a 	mov	r7,zero
 10076c0:	01804034 	movhi	r6,256
 10076c4:	319e2b04 	addi	r6,r6,30892
 10076c8:	01400084 	movi	r5,2
 10076cc:	0009883a 	mov	r4,zero
 10076d0:	10164880 	call	1016488 <alt_ic_isr_register>
#else
	alt_irq_register ( UART_IRQ, NULL, vUARTInterruptHandler );

#endif
		}
		portEXIT_CRITICAL();
 10076d4:	1006dbc0 	call	1006dbc <vTaskExitCritical>
	}
	else
	{
		return ( xComPortHandle ) 0;
	}
    return ( xComPortHandle ) 1;
 10076d8:	00800044 	movi	r2,1
 10076dc:	00000106 	br	10076e4 <xSerialPortInitMinimal+0xa0>
		}
		portEXIT_CRITICAL();
	}
	else
	{
		return ( xComPortHandle ) 0;
 10076e0:	0005883a 	mov	r2,zero
	}
    return ( xComPortHandle ) 1;
}
 10076e4:	e037883a 	mov	sp,fp
 10076e8:	dfc00117 	ldw	ra,4(sp)
 10076ec:	df000017 	ldw	fp,0(sp)
 10076f0:	dec00204 	addi	sp,sp,8
 10076f4:	f800283a 	ret

010076f8 <vSerialClose>:
/*---------------------------------------------------------------------------*/

void vSerialClose( xComPortHandle xPort )
{
 10076f8:	defffe04 	addi	sp,sp,-8
 10076fc:	df000115 	stw	fp,4(sp)
 1007700:	df000104 	addi	fp,sp,4
 1007704:	e13fff15 	stw	r4,-4(fp)
    /* Never used. */
}
 1007708:	0001883a 	nop
 100770c:	e037883a 	mov	sp,fp
 1007710:	df000017 	ldw	fp,0(sp)
 1007714:	dec00104 	addi	sp,sp,4
 1007718:	f800283a 	ret

0100771c <xSerialGetChar>:
/*---------------------------------------------------------------------------*/

signed portBASE_TYPE xSerialGetChar( xComPortHandle pxPort, signed char *pcRxedChar, portTickType xBlockTime )
{
 100771c:	defffb04 	addi	sp,sp,-20
 1007720:	dfc00415 	stw	ra,16(sp)
 1007724:	df000315 	stw	fp,12(sp)
 1007728:	df000304 	addi	fp,sp,12
 100772c:	e13ffd15 	stw	r4,-12(fp)
 1007730:	e17ffe15 	stw	r5,-8(fp)
 1007734:	e1bfff15 	stw	r6,-4(fp)
	( void ) pxPort;


	/* Get the next character from the buffer.  Return false if no characters
	are available, or arrive before xBlockTime expires. */
	if( xQueueReceive( xRxedChars, pcRxedChar, xBlockTime ) )
 1007738:	d0a09317 	ldw	r2,-32180(gp)
 100773c:	000f883a 	mov	r7,zero
 1007740:	e1bfff17 	ldw	r6,-4(fp)
 1007744:	e17ffe17 	ldw	r5,-8(fp)
 1007748:	1009883a 	mov	r4,r2
 100774c:	1004a800 	call	1004a80 <xQueueGenericReceive>
 1007750:	10000226 	beq	r2,zero,100775c <xSerialGetChar+0x40>
	{
		return pdTRUE;
 1007754:	00800044 	movi	r2,1
 1007758:	00000806 	br	100777c <xSerialGetChar+0x60>
	}
	else
	{
		uartControl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
 100775c:	d0a09517 	ldw	r2,-32172(gp)
 1007760:	10802014 	ori	r2,r2,128
 1007764:	d0a09515 	stw	r2,-32172(gp)
		IOWR_ALTERA_AVALON_UART_CONTROL( UART_BASE, uartControl );
 1007768:	d0a09517 	ldw	r2,-32172(gp)
 100776c:	1007883a 	mov	r3,r2
 1007770:	00869b04 	movi	r2,6764
 1007774:	10c00035 	stwio	r3,0(r2)
		return pdFALSE;
 1007778:	0005883a 	mov	r2,zero
	}
}
 100777c:	e037883a 	mov	sp,fp
 1007780:	dfc00117 	ldw	ra,4(sp)
 1007784:	df000017 	ldw	fp,0(sp)
 1007788:	dec00204 	addi	sp,sp,8
 100778c:	f800283a 	ret

01007790 <xSerialPutChar>:
/*---------------------------------------------------------------------------*/

signed portBASE_TYPE xSerialPutChar( xComPortHandle pxPort, signed char cOutChar, portTickType xBlockTime )
{
 1007790:	defffa04 	addi	sp,sp,-24
 1007794:	dfc00515 	stw	ra,20(sp)
 1007798:	df000415 	stw	fp,16(sp)
 100779c:	df000404 	addi	fp,sp,16
 10077a0:	e13ffd15 	stw	r4,-12(fp)
 10077a4:	2805883a 	mov	r2,r5
 10077a8:	e1bfff15 	stw	r6,-4(fp)
 10077ac:	e0bffe05 	stb	r2,-8(fp)
signed portBASE_TYPE lReturn = pdPASS;
 10077b0:	00800044 	movi	r2,1
 10077b4:	e0bffc15 	stw	r2,-16(fp)

	/* Place the character in the queue of characters to be transmitted. */
	if( xQueueSend( xCharsForTx, &cOutChar, xBlockTime ) == pdPASS )
 10077b8:	d0a09417 	ldw	r2,-32176(gp)
 10077bc:	e0fffe04 	addi	r3,fp,-8
 10077c0:	000f883a 	mov	r7,zero
 10077c4:	e1bfff17 	ldw	r6,-4(fp)
 10077c8:	180b883a 	mov	r5,r3
 10077cc:	1009883a 	mov	r4,r2
 10077d0:	10047080 	call	1004708 <xQueueGenericSend>
 10077d4:	10800058 	cmpnei	r2,r2,1
 10077d8:	10000a1e 	bne	r2,zero,1007804 <xSerialPutChar+0x74>
	{
        /*Triggers an interrupt on every character or (down) when queue is full. */
        uartControl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
 10077dc:	d0a09517 	ldw	r2,-32172(gp)
 10077e0:	10801014 	ori	r2,r2,64
 10077e4:	d0a09515 	stw	r2,-32172(gp)
        IOWR_ALTERA_AVALON_UART_CONTROL( UART_BASE, uartControl );
 10077e8:	d0a09517 	ldw	r2,-32172(gp)
 10077ec:	1007883a 	mov	r3,r2
 10077f0:	00869b04 	movi	r2,6764
 10077f4:	10c00035 	stwio	r3,0(r2)
        lReturn = pdPASS;
 10077f8:	00800044 	movi	r2,1
 10077fc:	e0bffc15 	stw	r2,-16(fp)
 1007800:	00000106 	br	1007808 <xSerialPutChar+0x78>
    }
    else
    {
		lReturn = pdFAIL;
 1007804:	e03ffc15 	stw	zero,-16(fp)
	}
	return lReturn;
 1007808:	e0bffc17 	ldw	r2,-16(fp)
}
 100780c:	e037883a 	mov	sp,fp
 1007810:	dfc00117 	ldw	ra,4(sp)
 1007814:	df000017 	ldw	fp,0(sp)
 1007818:	dec00204 	addi	sp,sp,8
 100781c:	f800283a 	ret

01007820 <vSerialPutString>:
/*---------------------------------------------------------------------------*/

void vSerialPutString( xComPortHandle pxPort, const signed char * const pcString, unsigned short usStringLength )
{
 1007820:	defffa04 	addi	sp,sp,-24
 1007824:	dfc00515 	stw	ra,20(sp)
 1007828:	df000415 	stw	fp,16(sp)
 100782c:	df000404 	addi	fp,sp,16
 1007830:	e13ffd15 	stw	r4,-12(fp)
 1007834:	e17ffe15 	stw	r5,-8(fp)
 1007838:	3005883a 	mov	r2,r6
 100783c:	e0bfff0d 	sth	r2,-4(fp)

	/* The port handle is not required as this driver only supports UART0. */
	( void ) pxPort;

	/* Send each character in the string, one at a time. */
	pxNext = ( signed char * ) pcString;
 1007840:	e0bffe17 	ldw	r2,-8(fp)
 1007844:	e0bffc15 	stw	r2,-16(fp)
	while( *pxNext )
 1007848:	00000c06 	br	100787c <vSerialPutString+0x5c>
	{
		xSerialPutChar( pxPort, *pxNext, serNO_BLOCK );
 100784c:	e0bffc17 	ldw	r2,-16(fp)
 1007850:	10800003 	ldbu	r2,0(r2)
 1007854:	10803fcc 	andi	r2,r2,255
 1007858:	1080201c 	xori	r2,r2,128
 100785c:	10bfe004 	addi	r2,r2,-128
 1007860:	000d883a 	mov	r6,zero
 1007864:	100b883a 	mov	r5,r2
 1007868:	e13ffd17 	ldw	r4,-12(fp)
 100786c:	10077900 	call	1007790 <xSerialPutChar>
		pxNext++;
 1007870:	e0bffc17 	ldw	r2,-16(fp)
 1007874:	10800044 	addi	r2,r2,1
 1007878:	e0bffc15 	stw	r2,-16(fp)
	/* The port handle is not required as this driver only supports UART0. */
	( void ) pxPort;

	/* Send each character in the string, one at a time. */
	pxNext = ( signed char * ) pcString;
	while( *pxNext )
 100787c:	e0bffc17 	ldw	r2,-16(fp)
 1007880:	10800003 	ldbu	r2,0(r2)
 1007884:	10803fcc 	andi	r2,r2,255
 1007888:	1080201c 	xori	r2,r2,128
 100788c:	10bfe004 	addi	r2,r2,-128
 1007890:	103fee1e 	bne	r2,zero,100784c <__alt_data_end+0xff80784c>
	{
		xSerialPutChar( pxPort, *pxNext, serNO_BLOCK );
		pxNext++;
	}
}
 1007894:	0001883a 	nop
 1007898:	e037883a 	mov	sp,fp
 100789c:	dfc00117 	ldw	ra,4(sp)
 10078a0:	df000017 	ldw	fp,0(sp)
 10078a4:	dec00204 	addi	sp,sp,8
 10078a8:	f800283a 	ret

010078ac <vUARTInterruptHandler>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void vUARTInterruptHandler(void* context)
#else
static void vUARTInterruptHandler(void* context, alt_u32 id)
#endif
{
 10078ac:	defffc04 	addi	sp,sp,-16
 10078b0:	dfc00315 	stw	ra,12(sp)
 10078b4:	df000215 	stw	fp,8(sp)
 10078b8:	df000204 	addi	fp,sp,8
 10078bc:	e13fff15 	stw	r4,-4(fp)
	alt_u32 status;

	/* Read the status register in order to determine the cause of the
    interrupt. */
	status = IORD_ALTERA_AVALON_UART_STATUS( UART_BASE );
 10078c0:	00869a04 	movi	r2,6760
 10078c4:	10800037 	ldwio	r2,0(r2)
 10078c8:	e0bffe15 	stw	r2,-8(fp)

	/* Clear any error flags set at the device */
	IOWR_ALTERA_AVALON_UART_STATUS( UART_BASE, 0 );
 10078cc:	0007883a 	mov	r3,zero
 10078d0:	00869a04 	movi	r2,6760
 10078d4:	10c00035 	stwio	r3,0(r2)

	/* process a read irq */
	if ( status & ALTERA_AVALON_UART_STATUS_RRDY_MSK )
 10078d8:	e0bffe17 	ldw	r2,-8(fp)
 10078dc:	1080200c 	andi	r2,r2,128
 10078e0:	10000226 	beq	r2,zero,10078ec <vUARTInterruptHandler+0x40>
	{
		vUARTReceiveHandler( status );
 10078e4:	e13ffe17 	ldw	r4,-8(fp)
 10078e8:	10079180 	call	1007918 <vUARTReceiveHandler>
	}

	/* process a write irq */
	if ( status & ( ALTERA_AVALON_UART_STATUS_TRDY_MSK  ) )
 10078ec:	e0bffe17 	ldw	r2,-8(fp)
 10078f0:	1080100c 	andi	r2,r2,64
 10078f4:	10000226 	beq	r2,zero,1007900 <vUARTInterruptHandler+0x54>
	{
		vUARTTransmitHandler( status );
 10078f8:	e13ffe17 	ldw	r4,-8(fp)
 10078fc:	10079b40 	call	10079b4 <vUARTTransmitHandler>
	}
}
 1007900:	0001883a 	nop
 1007904:	e037883a 	mov	sp,fp
 1007908:	dfc00117 	ldw	ra,4(sp)
 100790c:	df000017 	ldw	fp,0(sp)
 1007910:	dec00204 	addi	sp,sp,8
 1007914:	f800283a 	ret

01007918 <vUARTReceiveHandler>:
/*---------------------------------------------------------------------------*/

static void vUARTReceiveHandler( alt_u32 status )
{
 1007918:	defffb04 	addi	sp,sp,-20
 100791c:	dfc00415 	stw	ra,16(sp)
 1007920:	df000315 	stw	fp,12(sp)
 1007924:	df000304 	addi	fp,sp,12
 1007928:	e13fff15 	stw	r4,-4(fp)
signed char cChar;
portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
 100792c:	e03ffe15 	stw	zero,-8(fp)

	/* If there was an error, discard the data */
	if ( status & ( ALTERA_AVALON_UART_STATUS_PE_MSK | ALTERA_AVALON_UART_STATUS_FE_MSK ) )
 1007930:	e0bfff17 	ldw	r2,-4(fp)
 1007934:	108000cc 	andi	r2,r2,3
 1007938:	10000226 	beq	r2,zero,1007944 <vUARTReceiveHandler+0x2c>
	{
        asm("break");
 100793c:	003da03a 	break	0
 1007940:	00001706 	br	10079a0 <vUARTReceiveHandler+0x88>
		return;
	}

	/* Transfer data from the device to the circular buffer */
	cChar = IORD_ALTERA_AVALON_UART_RXDATA( UART_BASE );
 1007944:	00869804 	movi	r2,6752
 1007948:	10800037 	ldwio	r2,0(r2)
 100794c:	e0bffd05 	stb	r2,-12(fp)
	if ( pdTRUE != xQueueSendFromISR( xRxedChars, &cChar, &xHigherPriorityTaskWoken ) )
 1007950:	d0a09317 	ldw	r2,-32180(gp)
 1007954:	e0fffe04 	addi	r3,fp,-8
 1007958:	000f883a 	mov	r7,zero
 100795c:	180d883a 	mov	r6,r3
 1007960:	e17ffd04 	addi	r5,fp,-12
 1007964:	1009883a 	mov	r4,r2
 1007968:	10048bc0 	call	10048bc <xQueueGenericSendFromISR>
 100796c:	10800060 	cmpeqi	r2,r2,1
 1007970:	1000081e 	bne	r2,zero,1007994 <vUARTReceiveHandler+0x7c>
	{
		/* If the circular buffer was full, disable interrupts. Interrupts will
        be re-enabled when data is removed from the buffer. */
		uartControl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
 1007974:	d0e09517 	ldw	r3,-32172(gp)
 1007978:	00bfdfc4 	movi	r2,-129
 100797c:	1884703a 	and	r2,r3,r2
 1007980:	d0a09515 	stw	r2,-32172(gp)
		IOWR_ALTERA_AVALON_UART_CONTROL( UART_BASE, uartControl );
 1007984:	d0a09517 	ldw	r2,-32172(gp)
 1007988:	1007883a 	mov	r3,r2
 100798c:	00869b04 	movi	r2,6764
 1007990:	10c00035 	stwio	r3,0(r2)
	}

	portEND_SWITCHING_ISR( xHigherPriorityTaskWoken );
 1007994:	e0bffe17 	ldw	r2,-8(fp)
 1007998:	10000126 	beq	r2,zero,10079a0 <vUARTReceiveHandler+0x88>
 100799c:	10063980 	call	1006398 <vTaskSwitchContext>
}
 10079a0:	e037883a 	mov	sp,fp
 10079a4:	dfc00117 	ldw	ra,4(sp)
 10079a8:	df000017 	ldw	fp,0(sp)
 10079ac:	dec00204 	addi	sp,sp,8
 10079b0:	f800283a 	ret

010079b4 <vUARTTransmitHandler>:
/*---------------------------------------------------------------------------*/

static void vUARTTransmitHandler( alt_u32 status )
{
 10079b4:	defffb04 	addi	sp,sp,-20
 10079b8:	dfc00415 	stw	ra,16(sp)
 10079bc:	df000315 	stw	fp,12(sp)
 10079c0:	df000304 	addi	fp,sp,12
 10079c4:	e13fff15 	stw	r4,-4(fp)
signed char cChar;
portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
 10079c8:	e03ffe15 	stw	zero,-8(fp)
	/* Transfer data if there is some ready to be transferred */
	if( xQueueReceiveFromISR( xCharsForTx, &cChar, &xHigherPriorityTaskWoken ) == pdTRUE )
 10079cc:	d0a09417 	ldw	r2,-32176(gp)
 10079d0:	e0fffe04 	addi	r3,fp,-8
 10079d4:	180d883a 	mov	r6,r3
 10079d8:	e17ffd04 	addi	r5,fp,-12
 10079dc:	1009883a 	mov	r4,r2
 10079e0:	1004cb40 	call	1004cb4 <xQueueReceiveFromISR>
 10079e4:	10800058 	cmpnei	r2,r2,1
 10079e8:	1000071e 	bne	r2,zero,1007a08 <vUARTTransmitHandler+0x54>
	{
		IOWR_ALTERA_AVALON_UART_TXDATA( UART_BASE, cChar );
 10079ec:	e0bffd03 	ldbu	r2,-12(fp)
 10079f0:	10c03fcc 	andi	r3,r2,255
 10079f4:	18c0201c 	xori	r3,r3,128
 10079f8:	18ffe004 	addi	r3,r3,-128
 10079fc:	00869904 	movi	r2,6756
 1007a00:	10c00035 	stwio	r3,0(r2)
 1007a04:	00000406 	br	1007a18 <vUARTTransmitHandler+0x64>
    }
    else
    {
		uartControl &= ~ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
 1007a08:	d0e09517 	ldw	r3,-32172(gp)
 1007a0c:	00bfefc4 	movi	r2,-65
 1007a10:	1884703a 	and	r2,r3,r2
 1007a14:	d0a09515 	stw	r2,-32172(gp)
    }

	IOWR_ALTERA_AVALON_UART_CONTROL( UART_BASE, uartControl );
 1007a18:	d0a09517 	ldw	r2,-32172(gp)
 1007a1c:	1007883a 	mov	r3,r2
 1007a20:	00869b04 	movi	r2,6764
 1007a24:	10c00035 	stwio	r3,0(r2)
    portEND_SWITCHING_ISR( xHigherPriorityTaskWoken );
 1007a28:	e0bffe17 	ldw	r2,-8(fp)
 1007a2c:	10000126 	beq	r2,zero,1007a34 <vUARTTransmitHandler+0x80>
 1007a30:	10063980 	call	1006398 <vTaskSwitchContext>
}
 1007a34:	0001883a 	nop
 1007a38:	e037883a 	mov	sp,fp
 1007a3c:	dfc00117 	ldw	ra,4(sp)
 1007a40:	df000017 	ldw	fp,0(sp)
 1007a44:	dec00204 	addi	sp,sp,8
 1007a48:	f800283a 	ret

01007a4c <i2c_setup>:
#include "SigmaStudioFW.h"

uint8_t i2c_write_data[5120 + 2] = {0x00};

void i2c_setup(uint8_t per_h_reg, uint8_t per_l_reg)
{
 1007a4c:	defffd04 	addi	sp,sp,-12
 1007a50:	df000215 	stw	fp,8(sp)
 1007a54:	df000204 	addi	fp,sp,8
 1007a58:	2007883a 	mov	r3,r4
 1007a5c:	2805883a 	mov	r2,r5
 1007a60:	e0fffe05 	stb	r3,-8(fp)
 1007a64:	e0bfff05 	stb	r2,-4(fp)
	//IOWR_ALTERA_AVALON_PIO_DATA(I2C_CTR, 0x00);
	IOWR(I2C_BASEADDR, I2C_CTR, 0x00);
 1007a68:	0007883a 	mov	r3,zero
 1007a6c:	00900034 	movhi	r2,16384
 1007a70:	10801204 	addi	r2,r2,72
 1007a74:	10c00035 	stwio	r3,0(r2)
	IOWR(I2C_BASEADDR, I2C_CR, 0x01);
 1007a78:	00c00044 	movi	r3,1
 1007a7c:	00900034 	movhi	r2,16384
 1007a80:	10801404 	addi	r2,r2,80
 1007a84:	10c00035 	stwio	r3,0(r2)

	//IOWR_ALTERA_AVALON_PIO_DATA(I2C_PRERL, per_l_reg);
	//IOWR_ALTERA_AVALON_PIO_DATA(I2C_PRERH, per_h_reg);
	//IOWR_ALTERA_AVALON_PIO_DATA(I2C_CTR,   0x80);

	IOWR(I2C_BASEADDR, I2C_PRERL, per_l_reg);
 1007a88:	e0ffff03 	ldbu	r3,-4(fp)
 1007a8c:	00900034 	movhi	r2,16384
 1007a90:	10801004 	addi	r2,r2,64
 1007a94:	10c00035 	stwio	r3,0(r2)
	IOWR(I2C_BASEADDR, I2C_PRERH, per_h_reg);
 1007a98:	e0fffe03 	ldbu	r3,-8(fp)
 1007a9c:	00900034 	movhi	r2,16384
 1007aa0:	10801104 	addi	r2,r2,68
 1007aa4:	10c00035 	stwio	r3,0(r2)
	IOWR(I2C_BASEADDR, I2C_CTR,   0x80);
 1007aa8:	00c02004 	movi	r3,128
 1007aac:	00900034 	movhi	r2,16384
 1007ab0:	10801204 	addi	r2,r2,72
 1007ab4:	10c00035 	stwio	r3,0(r2)
}
 1007ab8:	0001883a 	nop
 1007abc:	e037883a 	mov	sp,fp
 1007ac0:	df000017 	ldw	fp,0(sp)
 1007ac4:	dec00104 	addi	sp,sp,4
 1007ac8:	f800283a 	ret

01007acc <i2c_start>:

bool i2c_start(uint8_t devAddress, uint8_t rw)
{
 1007acc:	defffc04 	addi	sp,sp,-16
 1007ad0:	dfc00315 	stw	ra,12(sp)
 1007ad4:	df000215 	stw	fp,8(sp)
 1007ad8:	df000204 	addi	fp,sp,8
 1007adc:	2007883a 	mov	r3,r4
 1007ae0:	2805883a 	mov	r2,r5
 1007ae4:	e0fffe05 	stb	r3,-8(fp)
 1007ae8:	e0bfff05 	stb	r2,-4(fp)
	IOWR(I2C_BASEADDR, I2C_TXR, (devAddress << 0) + (rw & 0x01));
 1007aec:	e0fffe03 	ldbu	r3,-8(fp)
 1007af0:	e0bfff03 	ldbu	r2,-4(fp)
 1007af4:	1080004c 	andi	r2,r2,1
 1007af8:	1887883a 	add	r3,r3,r2
 1007afc:	00900034 	movhi	r2,16384
 1007b00:	10801304 	addi	r2,r2,76
 1007b04:	10c00035 	stwio	r3,0(r2)
	IOWR(I2C_BASEADDR, I2C_CR, 0x90);
 1007b08:	00c02404 	movi	r3,144
 1007b0c:	00900034 	movhi	r2,16384
 1007b10:	10801404 	addi	r2,r2,80
 1007b14:	10c00035 	stwio	r3,0(r2)

	while (IORD(I2C_BASEADDR, I2C_SR) & 0x02)
 1007b18:	00000206 	br	1007b24 <i2c_start+0x58>
	{
		usleep(10);
 1007b1c:	01000284 	movi	r4,10
 1007b20:	1016b6c0 	call	1016b6c <usleep>
bool i2c_start(uint8_t devAddress, uint8_t rw)
{
	IOWR(I2C_BASEADDR, I2C_TXR, (devAddress << 0) + (rw & 0x01));
	IOWR(I2C_BASEADDR, I2C_CR, 0x90);

	while (IORD(I2C_BASEADDR, I2C_SR) & 0x02)
 1007b24:	00900034 	movhi	r2,16384
 1007b28:	10801404 	addi	r2,r2,80
 1007b2c:	10800037 	ldwio	r2,0(r2)
 1007b30:	1080008c 	andi	r2,r2,2
 1007b34:	103ff91e 	bne	r2,zero,1007b1c <__alt_data_end+0xff807b1c>
	{
		usleep(10);
	}

	usleep(10);
 1007b38:	01000284 	movi	r4,10
 1007b3c:	1016b6c0 	call	1016b6c <usleep>

	if (IORD(I2C_BASEADDR, I2C_SR) & 0x80)
 1007b40:	00900034 	movhi	r2,16384
 1007b44:	10801404 	addi	r2,r2,80
 1007b48:	10800037 	ldwio	r2,0(r2)
 1007b4c:	1080200c 	andi	r2,r2,128
 1007b50:	10000226 	beq	r2,zero,1007b5c <i2c_start+0x90>
	{
		return false;
 1007b54:	0005883a 	mov	r2,zero
 1007b58:	00000106 	br	1007b60 <i2c_start+0x94>
	}
	else
	{
		return true;
 1007b5c:	00800044 	movi	r2,1
	}
}
 1007b60:	e037883a 	mov	sp,fp
 1007b64:	dfc00117 	ldw	ra,4(sp)
 1007b68:	df000017 	ldw	fp,0(sp)
 1007b6c:	dec00204 	addi	sp,sp,8
 1007b70:	f800283a 	ret

01007b74 <i2c_write_byte>:

bool i2c_write_byte(uint8_t data)
{
 1007b74:	defffd04 	addi	sp,sp,-12
 1007b78:	dfc00215 	stw	ra,8(sp)
 1007b7c:	df000115 	stw	fp,4(sp)
 1007b80:	df000104 	addi	fp,sp,4
 1007b84:	2005883a 	mov	r2,r4
 1007b88:	e0bfff05 	stb	r2,-4(fp)
	IOWR(I2C_BASEADDR, I2C_TXR, data);
 1007b8c:	e0ffff03 	ldbu	r3,-4(fp)
 1007b90:	00900034 	movhi	r2,16384
 1007b94:	10801304 	addi	r2,r2,76
 1007b98:	10c00035 	stwio	r3,0(r2)
	IOWR(I2C_BASEADDR, I2C_CR,  0x10); //wr
 1007b9c:	00c00404 	movi	r3,16
 1007ba0:	00900034 	movhi	r2,16384
 1007ba4:	10801404 	addi	r2,r2,80
 1007ba8:	10c00035 	stwio	r3,0(r2)

	while (IORD(I2C_BASEADDR, I2C_SR) & 0x02)
 1007bac:	00000206 	br	1007bb8 <i2c_write_byte+0x44>
	{
		usleep(10);
 1007bb0:	01000284 	movi	r4,10
 1007bb4:	1016b6c0 	call	1016b6c <usleep>
bool i2c_write_byte(uint8_t data)
{
	IOWR(I2C_BASEADDR, I2C_TXR, data);
	IOWR(I2C_BASEADDR, I2C_CR,  0x10); //wr

	while (IORD(I2C_BASEADDR, I2C_SR) & 0x02)
 1007bb8:	00900034 	movhi	r2,16384
 1007bbc:	10801404 	addi	r2,r2,80
 1007bc0:	10800037 	ldwio	r2,0(r2)
 1007bc4:	1080008c 	andi	r2,r2,2
 1007bc8:	103ff91e 	bne	r2,zero,1007bb0 <__alt_data_end+0xff807bb0>
	{
		usleep(10);
	}

	usleep(10);
 1007bcc:	01000284 	movi	r4,10
 1007bd0:	1016b6c0 	call	1016b6c <usleep>

	if (IORD(I2C_BASEADDR, I2C_SR) & 0x80)
 1007bd4:	00900034 	movhi	r2,16384
 1007bd8:	10801404 	addi	r2,r2,80
 1007bdc:	10800037 	ldwio	r2,0(r2)
 1007be0:	1080200c 	andi	r2,r2,128
 1007be4:	10000926 	beq	r2,zero,1007c0c <i2c_write_byte+0x98>
	{
		printf("I2C_SR %d\n", IORD(I2C_BASEADDR, I2C_SR));
 1007be8:	00900034 	movhi	r2,16384
 1007bec:	10801404 	addi	r2,r2,80
 1007bf0:	10800037 	ldwio	r2,0(r2)
 1007bf4:	100b883a 	mov	r5,r2
 1007bf8:	010040b4 	movhi	r4,258
 1007bfc:	212a2004 	addi	r4,r4,-22400
 1007c00:	1009c740 	call	1009c74 <printf>
		return false;
 1007c04:	0005883a 	mov	r2,zero
 1007c08:	00000106 	br	1007c10 <i2c_write_byte+0x9c>
	}
	else
	{
		return true;
 1007c0c:	00800044 	movi	r2,1
	}
}
 1007c10:	e037883a 	mov	sp,fp
 1007c14:	dfc00117 	ldw	ra,4(sp)
 1007c18:	df000017 	ldw	fp,0(sp)
 1007c1c:	dec00204 	addi	sp,sp,8
 1007c20:	f800283a 	ret

01007c24 <i2c_write_byte_stop>:

bool i2c_write_byte_stop(uint8_t data)
{
 1007c24:	defffd04 	addi	sp,sp,-12
 1007c28:	dfc00215 	stw	ra,8(sp)
 1007c2c:	df000115 	stw	fp,4(sp)
 1007c30:	df000104 	addi	fp,sp,4
 1007c34:	2005883a 	mov	r2,r4
 1007c38:	e0bfff05 	stb	r2,-4(fp)
	IOWR(I2C_BASEADDR, I2C_TXR, data);
 1007c3c:	e0ffff03 	ldbu	r3,-4(fp)
 1007c40:	00900034 	movhi	r2,16384
 1007c44:	10801304 	addi	r2,r2,76
 1007c48:	10c00035 	stwio	r3,0(r2)
	IOWR(I2C_BASEADDR, I2C_CR, 0x50); //stop
 1007c4c:	00c01404 	movi	r3,80
 1007c50:	00900034 	movhi	r2,16384
 1007c54:	10801404 	addi	r2,r2,80
 1007c58:	10c00035 	stwio	r3,0(r2)

	while (IORD(I2C_BASEADDR, I2C_SR) & 0x02)
 1007c5c:	00000206 	br	1007c68 <i2c_write_byte_stop+0x44>
	{
		usleep(10);
 1007c60:	01000284 	movi	r4,10
 1007c64:	1016b6c0 	call	1016b6c <usleep>
bool i2c_write_byte_stop(uint8_t data)
{
	IOWR(I2C_BASEADDR, I2C_TXR, data);
	IOWR(I2C_BASEADDR, I2C_CR, 0x50); //stop

	while (IORD(I2C_BASEADDR, I2C_SR) & 0x02)
 1007c68:	00900034 	movhi	r2,16384
 1007c6c:	10801404 	addi	r2,r2,80
 1007c70:	10800037 	ldwio	r2,0(r2)
 1007c74:	1080008c 	andi	r2,r2,2
 1007c78:	103ff91e 	bne	r2,zero,1007c60 <__alt_data_end+0xff807c60>
	{
		usleep(10);
	}

	usleep(10);
 1007c7c:	01000284 	movi	r4,10
 1007c80:	1016b6c0 	call	1016b6c <usleep>

	if (IORD(I2C_BASEADDR, I2C_SR) & 0x80)
 1007c84:	00900034 	movhi	r2,16384
 1007c88:	10801404 	addi	r2,r2,80
 1007c8c:	10800037 	ldwio	r2,0(r2)
 1007c90:	1080200c 	andi	r2,r2,128
 1007c94:	10000226 	beq	r2,zero,1007ca0 <i2c_write_byte_stop+0x7c>
	{
		return false;
 1007c98:	0005883a 	mov	r2,zero
 1007c9c:	00000106 	br	1007ca4 <i2c_write_byte_stop+0x80>
	}
	else
	{
		return true;
 1007ca0:	00800044 	movi	r2,1
	}
}
 1007ca4:	e037883a 	mov	sp,fp
 1007ca8:	dfc00117 	ldw	ra,4(sp)
 1007cac:	df000017 	ldw	fp,0(sp)
 1007cb0:	dec00204 	addi	sp,sp,8
 1007cb4:	f800283a 	ret

01007cb8 <i2c_multiple_write>:

bool i2c_multiple_write(uint8_t devAddress, uint16_t controlAddress, uint8_t data[], uint16_t len)
{
 1007cb8:	defff904 	addi	sp,sp,-28
 1007cbc:	dfc00615 	stw	ra,24(sp)
 1007cc0:	df000515 	stw	fp,20(sp)
 1007cc4:	df000504 	addi	fp,sp,20
 1007cc8:	2807883a 	mov	r3,r5
 1007ccc:	e1bffe15 	stw	r6,-8(fp)
 1007cd0:	3805883a 	mov	r2,r7
 1007cd4:	e13ffc05 	stb	r4,-16(fp)
 1007cd8:	e0fffd0d 	sth	r3,-12(fp)
 1007cdc:	e0bfff0d 	sth	r2,-4(fp)
	if (!i2c_start(devAddress, 0x00))
 1007ce0:	e0bffc03 	ldbu	r2,-16(fp)
 1007ce4:	000b883a 	mov	r5,zero
 1007ce8:	1009883a 	mov	r4,r2
 1007cec:	1007acc0 	call	1007acc <i2c_start>
 1007cf0:	1080005c 	xori	r2,r2,1
 1007cf4:	10803fcc 	andi	r2,r2,255
 1007cf8:	10000526 	beq	r2,zero,1007d10 <i2c_multiple_write+0x58>
	{
		printf("I2C start failed.\n");
 1007cfc:	010040b4 	movhi	r4,258
 1007d00:	212a2304 	addi	r4,r4,-22388
 1007d04:	1009d900 	call	1009d90 <puts>
		return false;
 1007d08:	0005883a 	mov	r2,zero
 1007d0c:	00004b06 	br	1007e3c <i2c_multiple_write+0x184>
	}

	usleep(100);
 1007d10:	01001904 	movi	r4,100
 1007d14:	1016b6c0 	call	1016b6c <usleep>

	if (!i2c_write_byte((controlAddress >> 8) & 0xFF))
 1007d18:	e0bffd0b 	ldhu	r2,-12(fp)
 1007d1c:	1004d23a 	srli	r2,r2,8
 1007d20:	10803fcc 	andi	r2,r2,255
 1007d24:	1009883a 	mov	r4,r2
 1007d28:	1007b740 	call	1007b74 <i2c_write_byte>
 1007d2c:	1080005c 	xori	r2,r2,1
 1007d30:	10803fcc 	andi	r2,r2,255
 1007d34:	10000326 	beq	r2,zero,1007d44 <i2c_multiple_write+0x8c>
	{
		printf("I2C caddrH write failed.\n");
 1007d38:	010040b4 	movhi	r4,258
 1007d3c:	212a2804 	addi	r4,r4,-22368
 1007d40:	1009d900 	call	1009d90 <puts>
		//return false;
	}

	usleep(100);
 1007d44:	01001904 	movi	r4,100
 1007d48:	1016b6c0 	call	1016b6c <usleep>

	if (!i2c_write_byte(controlAddress & 0xFF))
 1007d4c:	e0bffd0b 	ldhu	r2,-12(fp)
 1007d50:	10803fcc 	andi	r2,r2,255
 1007d54:	1009883a 	mov	r4,r2
 1007d58:	1007b740 	call	1007b74 <i2c_write_byte>
 1007d5c:	1080005c 	xori	r2,r2,1
 1007d60:	10803fcc 	andi	r2,r2,255
 1007d64:	10000526 	beq	r2,zero,1007d7c <i2c_multiple_write+0xc4>
	{
		printf("I2C caddrL write failed.\n");
 1007d68:	010040b4 	movhi	r4,258
 1007d6c:	212a2f04 	addi	r4,r4,-22340
 1007d70:	1009d900 	call	1009d90 <puts>
		return false;
 1007d74:	0005883a 	mov	r2,zero
 1007d78:	00003006 	br	1007e3c <i2c_multiple_write+0x184>
	}

	usleep(100);
 1007d7c:	01001904 	movi	r4,100
 1007d80:	1016b6c0 	call	1016b6c <usleep>

	for (int i = 0; i < len; i++)
 1007d84:	e03ffb15 	stw	zero,-20(fp)
 1007d88:	00002806 	br	1007e2c <i2c_multiple_write+0x174>
	{
		if (i == len - 1)
 1007d8c:	e0bfff0b 	ldhu	r2,-4(fp)
 1007d90:	10ffffc4 	addi	r3,r2,-1
 1007d94:	e0bffb17 	ldw	r2,-20(fp)
 1007d98:	18800f1e 	bne	r3,r2,1007dd8 <i2c_multiple_write+0x120>
		{
			if (!i2c_write_byte_stop(data[i]))
 1007d9c:	e0bffb17 	ldw	r2,-20(fp)
 1007da0:	e0fffe17 	ldw	r3,-8(fp)
 1007da4:	1885883a 	add	r2,r3,r2
 1007da8:	10800003 	ldbu	r2,0(r2)
 1007dac:	10803fcc 	andi	r2,r2,255
 1007db0:	1009883a 	mov	r4,r2
 1007db4:	1007c240 	call	1007c24 <i2c_write_byte_stop>
 1007db8:	1080005c 	xori	r2,r2,1
 1007dbc:	10803fcc 	andi	r2,r2,255
 1007dc0:	10001526 	beq	r2,zero,1007e18 <i2c_multiple_write+0x160>
			{
				printf("I2C stop failed.\n");
 1007dc4:	010040b4 	movhi	r4,258
 1007dc8:	212a3604 	addi	r4,r4,-22312
 1007dcc:	1009d900 	call	1009d90 <puts>
				return false;
 1007dd0:	0005883a 	mov	r2,zero
 1007dd4:	00001906 	br	1007e3c <i2c_multiple_write+0x184>
			}
		}
		else
		{
			if (!i2c_write_byte(data[i]))
 1007dd8:	e0bffb17 	ldw	r2,-20(fp)
 1007ddc:	e0fffe17 	ldw	r3,-8(fp)
 1007de0:	1885883a 	add	r2,r3,r2
 1007de4:	10800003 	ldbu	r2,0(r2)
 1007de8:	10803fcc 	andi	r2,r2,255
 1007dec:	1009883a 	mov	r4,r2
 1007df0:	1007b740 	call	1007b74 <i2c_write_byte>
 1007df4:	1080005c 	xori	r2,r2,1
 1007df8:	10803fcc 	andi	r2,r2,255
 1007dfc:	10000626 	beq	r2,zero,1007e18 <i2c_multiple_write+0x160>
			{
				printf("I2C data[%d] write failed.\n", i);
 1007e00:	e17ffb17 	ldw	r5,-20(fp)
 1007e04:	010040b4 	movhi	r4,258
 1007e08:	212a3b04 	addi	r4,r4,-22292
 1007e0c:	1009c740 	call	1009c74 <printf>
				return false;
 1007e10:	0005883a 	mov	r2,zero
 1007e14:	00000906 	br	1007e3c <i2c_multiple_write+0x184>
			}
		}

		usleep(100);
 1007e18:	01001904 	movi	r4,100
 1007e1c:	1016b6c0 	call	1016b6c <usleep>
		return false;
	}

	usleep(100);

	for (int i = 0; i < len; i++)
 1007e20:	e0bffb17 	ldw	r2,-20(fp)
 1007e24:	10800044 	addi	r2,r2,1
 1007e28:	e0bffb15 	stw	r2,-20(fp)
 1007e2c:	e0bfff0b 	ldhu	r2,-4(fp)
 1007e30:	e0fffb17 	ldw	r3,-20(fp)
 1007e34:	18bfd516 	blt	r3,r2,1007d8c <__alt_data_end+0xff807d8c>
		}

		usleep(100);
	}

	return true;
 1007e38:	00800044 	movi	r2,1
}
 1007e3c:	e037883a 	mov	sp,fp
 1007e40:	dfc00117 	ldw	ra,4(sp)
 1007e44:	df000017 	ldw	fp,0(sp)
 1007e48:	dec00204 	addi	sp,sp,8
 1007e4c:	f800283a 	ret

01007e50 <SIGMA_WRITE_REGISTER_BLOCK>:

bool SIGMA_WRITE_REGISTER_BLOCK(uint8_t devAddress, uint16_t address, uint16_t length, ADI_REG_TYPE *pData)
{
 1007e50:	defff904 	addi	sp,sp,-28
 1007e54:	dfc00615 	stw	ra,24(sp)
 1007e58:	df000515 	stw	fp,20(sp)
 1007e5c:	df000504 	addi	fp,sp,20
 1007e60:	2807883a 	mov	r3,r5
 1007e64:	3005883a 	mov	r2,r6
 1007e68:	e1ffff15 	stw	r7,-4(fp)
 1007e6c:	e13ffc05 	stb	r4,-16(fp)
 1007e70:	e0fffd0d 	sth	r3,-12(fp)
 1007e74:	e0bffe0d 	sth	r2,-8(fp)

  ret = I2CSPM_Transfer(I2C0, &seq);
#endif

  //ret = i2c_multiple_write(PIO_2_BASE, PIO_3_BASE, devAddress, address, pData, length);
  ret = i2c_multiple_write(devAddress, address, pData, length);
 1007e78:	e0bffc03 	ldbu	r2,-16(fp)
 1007e7c:	e0fffd0b 	ldhu	r3,-12(fp)
 1007e80:	e13ffe0b 	ldhu	r4,-8(fp)
 1007e84:	200f883a 	mov	r7,r4
 1007e88:	e1bfff17 	ldw	r6,-4(fp)
 1007e8c:	180b883a 	mov	r5,r3
 1007e90:	1009883a 	mov	r4,r2
 1007e94:	1007cb80 	call	1007cb8 <i2c_multiple_write>
 1007e98:	e0bffb05 	stb	r2,-20(fp)

  usleep(1000);
 1007e9c:	0100fa04 	movi	r4,1000
 1007ea0:	1016b6c0 	call	1016b6c <usleep>

  //if (ret != i2cTransferDone)
  if (!ret)
 1007ea4:	e0bffb03 	ldbu	r2,-20(fp)
 1007ea8:	1080005c 	xori	r2,r2,1
 1007eac:	10803fcc 	andi	r2,r2,255
 1007eb0:	10000226 	beq	r2,zero,1007ebc <SIGMA_WRITE_REGISTER_BLOCK+0x6c>
  {
    //return((uint32_t) ret);
	  return false;
 1007eb4:	0005883a 	mov	r2,zero
 1007eb8:	00000106 	br	1007ec0 <SIGMA_WRITE_REGISTER_BLOCK+0x70>
  }

  //return((uint32_t) 0);
  return true;
 1007ebc:	00800044 	movi	r2,1
}
 1007ec0:	e037883a 	mov	sp,fp
 1007ec4:	dfc00117 	ldw	ra,4(sp)
 1007ec8:	df000017 	ldw	fp,0(sp)
 1007ecc:	dec00204 	addi	sp,sp,8
 1007ed0:	f800283a 	ret

01007ed4 <SIGMA_WRITE_REGISTER_CONTROL>:

bool SIGMA_WRITE_REGISTER_CONTROL(uint8_t devAddress, uint16_t address, uint16_t length, ADI_REG_U8 *pData)
{
 1007ed4:	defff904 	addi	sp,sp,-28
 1007ed8:	dfc00615 	stw	ra,24(sp)
 1007edc:	df000515 	stw	fp,20(sp)
 1007ee0:	df000504 	addi	fp,sp,20
 1007ee4:	2807883a 	mov	r3,r5
 1007ee8:	3005883a 	mov	r2,r6
 1007eec:	e1ffff15 	stw	r7,-4(fp)
 1007ef0:	e13ffc05 	stb	r4,-16(fp)
 1007ef4:	e0fffd0d 	sth	r3,-12(fp)
 1007ef8:	e0bffe0d 	sth	r2,-8(fp)

  ret = I2CSPM_Transfer(I2C0, &seq);
#endif

  //ret = i2c_multiple_write(PIO_2_BASE, PIO_3_BASE, devAddress, address, pData, length);
  ret = i2c_multiple_write(devAddress, address, pData, length);
 1007efc:	e0bffc03 	ldbu	r2,-16(fp)
 1007f00:	e0fffd0b 	ldhu	r3,-12(fp)
 1007f04:	e13ffe0b 	ldhu	r4,-8(fp)
 1007f08:	200f883a 	mov	r7,r4
 1007f0c:	e1bfff17 	ldw	r6,-4(fp)
 1007f10:	180b883a 	mov	r5,r3
 1007f14:	1009883a 	mov	r4,r2
 1007f18:	1007cb80 	call	1007cb8 <i2c_multiple_write>
 1007f1c:	e0bffb05 	stb	r2,-20(fp)

  //if (ret != i2cTransferDone)
  if (!ret)
 1007f20:	e0bffb03 	ldbu	r2,-20(fp)
 1007f24:	1080005c 	xori	r2,r2,1
 1007f28:	10803fcc 	andi	r2,r2,255
 1007f2c:	10000226 	beq	r2,zero,1007f38 <SIGMA_WRITE_REGISTER_CONTROL+0x64>
  {
    //return((uint32_t) ret);
	  return false;
 1007f30:	0005883a 	mov	r2,zero
 1007f34:	00000106 	br	1007f3c <SIGMA_WRITE_REGISTER_CONTROL+0x68>
  }

  //free(i2c_write_data);

  //return((uint32_t) 0);
  return true;
 1007f38:	00800044 	movi	r2,1
}
 1007f3c:	e037883a 	mov	sp,fp
 1007f40:	dfc00117 	ldw	ra,4(sp)
 1007f44:	df000017 	ldw	fp,0(sp)
 1007f48:	dec00204 	addi	sp,sp,8
 1007f4c:	f800283a 	ret

01007f50 <SIGMA_SAFELOAD_WRITE_ADDR>:

bool SIGMA_SAFELOAD_WRITE_ADDR(uint8_t devAddress, uint16_t addrAddress, uint16_t address)
{
 1007f50:	defffa04 	addi	sp,sp,-24
 1007f54:	dfc00515 	stw	ra,20(sp)
 1007f58:	df000415 	stw	fp,16(sp)
 1007f5c:	df000404 	addi	fp,sp,16
 1007f60:	2807883a 	mov	r3,r5
 1007f64:	3005883a 	mov	r2,r6
 1007f68:	e13ffd05 	stb	r4,-12(fp)
 1007f6c:	e0fffe0d 	sth	r3,-8(fp)
 1007f70:	e0bfff0d 	sth	r2,-4(fp)
  seq.buf[1].len  = 0;

  ret = I2CSPM_Transfer(I2C0, &seq);
#endif

  wdata[0] = (address >> 8) & 0x00FF;
 1007f74:	e0bfff0b 	ldhu	r2,-4(fp)
 1007f78:	1004d23a 	srli	r2,r2,8
 1007f7c:	e0bffc45 	stb	r2,-15(fp)
  wdata[1] = address & 0x00FF;
 1007f80:	e0bfff0b 	ldhu	r2,-4(fp)
 1007f84:	e0bffc85 	stb	r2,-14(fp)
  //ret = i2c_multiple_write(PIO_2_BASE, PIO_3_BASE, devAddress, address, wdata, 2);
  ret = i2c_multiple_write(devAddress, address, wdata, 2);
 1007f88:	e0bffd03 	ldbu	r2,-12(fp)
 1007f8c:	e0ffff0b 	ldhu	r3,-4(fp)
 1007f90:	e13ffc44 	addi	r4,fp,-15
 1007f94:	01c00084 	movi	r7,2
 1007f98:	200d883a 	mov	r6,r4
 1007f9c:	180b883a 	mov	r5,r3
 1007fa0:	1009883a 	mov	r4,r2
 1007fa4:	1007cb80 	call	1007cb8 <i2c_multiple_write>
 1007fa8:	e0bffc05 	stb	r2,-16(fp)

  //if (ret != i2cTransferDone)
  if (!ret)
 1007fac:	e0bffc03 	ldbu	r2,-16(fp)
 1007fb0:	1080005c 	xori	r2,r2,1
 1007fb4:	10803fcc 	andi	r2,r2,255
 1007fb8:	10000226 	beq	r2,zero,1007fc4 <SIGMA_SAFELOAD_WRITE_ADDR+0x74>
  {
    //return((uint32_t) ret);
	  return false;
 1007fbc:	0005883a 	mov	r2,zero
 1007fc0:	00000106 	br	1007fc8 <SIGMA_SAFELOAD_WRITE_ADDR+0x78>
  }

  //return((uint32_t) 0);
  return true;
 1007fc4:	00800044 	movi	r2,1
}
 1007fc8:	e037883a 	mov	sp,fp
 1007fcc:	dfc00117 	ldw	ra,4(sp)
 1007fd0:	df000017 	ldw	fp,0(sp)
 1007fd4:	dec00204 	addi	sp,sp,8
 1007fd8:	f800283a 	ret

01007fdc <SIGMA_SAFELOAD_WRITE_DATA>:

bool SIGMA_SAFELOAD_WRITE_DATA(uint8_t devAddress, uint16_t dataAddress, uint16_t length, ADI_REG_U8 *pData)
{
 1007fdc:	defff404 	addi	sp,sp,-48
 1007fe0:	dfc00b15 	stw	ra,44(sp)
 1007fe4:	df000a15 	stw	fp,40(sp)
 1007fe8:	df000a04 	addi	fp,sp,40
 1007fec:	2807883a 	mov	r3,r5
 1007ff0:	3005883a 	mov	r2,r6
 1007ff4:	e1ffff15 	stw	r7,-4(fp)
 1007ff8:	e13ffc05 	stb	r4,-16(fp)
 1007ffc:	e0fffd0d 	sth	r3,-12(fp)
 1008000:	e0bffe0d 	sth	r2,-8(fp)

  ret = I2CSPM_Transfer(I2C0, &seq);
#endif

  bool ret;
  uint8_t wdata[16] = {0};
 1008004:	e0bff744 	addi	r2,fp,-35
 1008008:	00c00404 	movi	r3,16
 100800c:	180d883a 	mov	r6,r3
 1008010:	000b883a 	mov	r5,zero
 1008014:	1009883a 	mov	r4,r2
 1008018:	1009b1c0 	call	1009b1c <memset>
  for (int i = 0; i < length; i++)
 100801c:	e03ff615 	stw	zero,-40(fp)
 1008020:	00000c06 	br	1008054 <SIGMA_SAFELOAD_WRITE_DATA+0x78>
  {
	  wdata[i + 1] = pData[i];
 1008024:	e0bff617 	ldw	r2,-40(fp)
 1008028:	10800044 	addi	r2,r2,1
 100802c:	e0fff617 	ldw	r3,-40(fp)
 1008030:	e13fff17 	ldw	r4,-4(fp)
 1008034:	20c7883a 	add	r3,r4,r3
 1008038:	18c00003 	ldbu	r3,0(r3)
 100803c:	e13ff744 	addi	r4,fp,-35
 1008040:	2085883a 	add	r2,r4,r2
 1008044:	10c00005 	stb	r3,0(r2)
  ret = I2CSPM_Transfer(I2C0, &seq);
#endif

  bool ret;
  uint8_t wdata[16] = {0};
  for (int i = 0; i < length; i++)
 1008048:	e0bff617 	ldw	r2,-40(fp)
 100804c:	10800044 	addi	r2,r2,1
 1008050:	e0bff615 	stw	r2,-40(fp)
 1008054:	e0bffe0b 	ldhu	r2,-8(fp)
 1008058:	e0fff617 	ldw	r3,-40(fp)
 100805c:	18bff116 	blt	r3,r2,1008024 <__alt_data_end+0xff808024>
  {
	  wdata[i + 1] = pData[i];
  }

  //ret = i2c_multiple_write(PIO_2_BASE, PIO_3_BASE, devAddress, dataAddress, wdata, length + 1);
  ret = i2c_multiple_write(devAddress, dataAddress, wdata, length + 1);
 1008060:	e0fffc03 	ldbu	r3,-16(fp)
 1008064:	e13ffd0b 	ldhu	r4,-12(fp)
 1008068:	e0bffe0b 	ldhu	r2,-8(fp)
 100806c:	10800044 	addi	r2,r2,1
 1008070:	117fffcc 	andi	r5,r2,65535
 1008074:	e0bff744 	addi	r2,fp,-35
 1008078:	280f883a 	mov	r7,r5
 100807c:	100d883a 	mov	r6,r2
 1008080:	200b883a 	mov	r5,r4
 1008084:	1809883a 	mov	r4,r3
 1008088:	1007cb80 	call	1007cb8 <i2c_multiple_write>
 100808c:	e0bff705 	stb	r2,-36(fp)

  //if (ret != i2cTransferDone)
  if (!ret)
 1008090:	e0bff703 	ldbu	r2,-36(fp)
 1008094:	1080005c 	xori	r2,r2,1
 1008098:	10803fcc 	andi	r2,r2,255
 100809c:	10000226 	beq	r2,zero,10080a8 <SIGMA_SAFELOAD_WRITE_DATA+0xcc>
  {
    //return((uint32_t) ret);
	  return false;
 10080a0:	0005883a 	mov	r2,zero
 10080a4:	00000106 	br	10080ac <SIGMA_SAFELOAD_WRITE_DATA+0xd0>
  }

  //return((uint32_t) 0);
  return true;
 10080a8:	00800044 	movi	r2,1
}
 10080ac:	e037883a 	mov	sp,fp
 10080b0:	dfc00117 	ldw	ra,4(sp)
 10080b4:	df000017 	ldw	fp,0(sp)
 10080b8:	dec00204 	addi	sp,sp,8
 10080bc:	f800283a 	ret

010080c0 <SIGMA_SAFELOAD_WRITE_TRANSFER_BIT>:

bool SIGMA_SAFELOAD_WRITE_TRANSFER_BIT(uint8_t devAddress)
{
 10080c0:	defffb04 	addi	sp,sp,-20
 10080c4:	dfc00415 	stw	ra,16(sp)
 10080c8:	df000315 	stw	fp,12(sp)
 10080cc:	df000304 	addi	fp,sp,12
 10080d0:	2005883a 	mov	r2,r4
 10080d4:	e0bfff05 	stb	r2,-4(fp)

  ret = I2CSPM_Transfer(I2C0, &seq);
#endif

  bool ret;
  uint16_t address = 0x081C;
 10080d8:	00820704 	movi	r2,2076
 10080dc:	e0bffd0d 	sth	r2,-12(fp)
  uint8_t wdata[2] = {0x00, 0x3C};
 10080e0:	e03ffdc5 	stb	zero,-9(fp)
 10080e4:	00800f04 	movi	r2,60
 10080e8:	e0bffe05 	stb	r2,-8(fp)
  //ret = i2c_multiple_write(PIO_2_BASE, PIO_3_BASE, devAddress, address, wdata, 2);
  ret = i2c_multiple_write(devAddress, address, wdata, 2);
 10080ec:	e0bfff03 	ldbu	r2,-4(fp)
 10080f0:	e0fffd0b 	ldhu	r3,-12(fp)
 10080f4:	e13ffdc4 	addi	r4,fp,-9
 10080f8:	01c00084 	movi	r7,2
 10080fc:	200d883a 	mov	r6,r4
 1008100:	180b883a 	mov	r5,r3
 1008104:	1009883a 	mov	r4,r2
 1008108:	1007cb80 	call	1007cb8 <i2c_multiple_write>
 100810c:	e0bffd85 	stb	r2,-10(fp)

  //if (ret != i2cTransferDone)
  if (!ret)
 1008110:	e0bffd83 	ldbu	r2,-10(fp)
 1008114:	1080005c 	xori	r2,r2,1
 1008118:	10803fcc 	andi	r2,r2,255
 100811c:	10000226 	beq	r2,zero,1008128 <SIGMA_SAFELOAD_WRITE_TRANSFER_BIT+0x68>
  {
    //return((uint32_t) ret);
	  return false;
 1008120:	0005883a 	mov	r2,zero
 1008124:	00000106 	br	100812c <SIGMA_SAFELOAD_WRITE_TRANSFER_BIT+0x6c>
  }

  //return((uint32_t) 0);
  return true;
 1008128:	00800044 	movi	r2,1
}
 100812c:	e037883a 	mov	sp,fp
 1008130:	dfc00117 	ldw	ra,4(sp)
 1008134:	df000017 	ldw	fp,0(sp)
 1008138:	dec00204 	addi	sp,sp,8
 100813c:	f800283a 	ret

01008140 <default_download_IC_1>:
/*
 * Default Download
 */
#define DEFAULT_DOWNLOAD_SIZE_IC_1 40

void default_download_IC_1() {
 1008140:	defffe04 	addi	sp,sp,-8
 1008144:	dfc00115 	stw	ra,4(sp)
 1008148:	df000015 	stw	fp,0(sp)
 100814c:	d839883a 	mov	fp,sp
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_SAMPLE_RATE_SETTING_IC_1_ADDR, REG_SAMPLE_RATE_SETTING_IC_1_BYTE, R0_SAMPLE_RATE_SETTING_IC_1_Default );
 1008150:	d1e00604 	addi	r7,gp,-32744
 1008154:	01800044 	movi	r6,1
 1008158:	01503ac4 	movi	r5,16619
 100815c:	01001c04 	movi	r4,112
 1008160:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_DSP_RUN_REGISTER_IC_1_ADDR, REG_DSP_RUN_REGISTER_IC_1_BYTE, R1_DSP_RUN_REGISTER_IC_1_Default );
 1008164:	d1e09604 	addi	r7,gp,-32168
 1008168:	01800044 	movi	r6,1
 100816c:	01503d84 	movi	r5,16630
 1008170:	01001c04 	movi	r4,112
 1008174:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_CLKCTRLREGISTER_IC_1_ADDR, REG_CLKCTRLREGISTER_IC_1_BYTE, R2_CLKCTRLREGISTER_IC_1_Default );
 1008178:	d1e00644 	addi	r7,gp,-32743
 100817c:	01800044 	movi	r6,1
 1008180:	01500004 	movi	r5,16384
 1008184:	01001c04 	movi	r4,112
 1008188:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_PLLCRLREGISTER_IC_1_ADDR, REG_PLLCRLREGISTER_IC_1_BYTE, R3_PLLCRLREGISTER_IC_1_Default );
 100818c:	d1e00684 	addi	r7,gp,-32742
 1008190:	01800184 	movi	r6,6
 1008194:	01500084 	movi	r5,16386
 1008198:	01001c04 	movi	r4,112
 100819c:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_DELAY( DEVICE_ADDR_IC_1, R4_DELAY_IC_1_SIZE, R4_DELAY_IC_1_Default );
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_SERIAL_PORT_CONTROL_0_IC_1_ADDR , R5_SERIAL_PORT_CONTROL_REGISTERS_IC_1_SIZE, R5_SERIAL_PORT_CONTROL_REGISTERS_IC_1_Default );
 10081a0:	d1e00884 	addi	r7,gp,-32734
 10081a4:	01800084 	movi	r6,2
 10081a8:	01500544 	movi	r5,16405
 10081ac:	01001c04 	movi	r4,112
 10081b0:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_ALC_CONTROL_0_IC_1_ADDR , R6_ALC_CONTROL_REGISTERS_IC_1_SIZE, R6_ALC_CONTROL_REGISTERS_IC_1_Default );
 10081b4:	d1e00904 	addi	r7,gp,-32732
 10081b8:	01800104 	movi	r6,4
 10081bc:	01500444 	movi	r5,16401
 10081c0:	01001c04 	movi	r4,112
 10081c4:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_MICCTRLREGISTER_IC_1_ADDR, REG_MICCTRLREGISTER_IC_1_BYTE, R7_MICCTRLREGISTER_IC_1_Default );
 10081c8:	d1e09644 	addi	r7,gp,-32167
 10081cc:	01800044 	movi	r6,1
 10081d0:	01500204 	movi	r5,16392
 10081d4:	01001c04 	movi	r4,112
 10081d8:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_RECORD_PWR_MANAGEMENT_IC_1_ADDR , R8_RECORD_INPUT_SIGNAL_PATH_REGISTERS_IC_1_SIZE, R8_RECORD_INPUT_SIGNAL_PATH_REGISTERS_IC_1_Default );
 10081dc:	d1e00a04 	addi	r7,gp,-32728
 10081e0:	01800204 	movi	r6,8
 10081e4:	01500244 	movi	r5,16393
 10081e8:	01001c04 	movi	r4,112
 10081ec:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_ADC_CONTROL_0_IC_1_ADDR , R9_ADC_CONTROL_REGISTERS_IC_1_SIZE, R9_ADC_CONTROL_REGISTERS_IC_1_Default );
 10081f0:	d1e00c04 	addi	r7,gp,-32720
 10081f4:	018000c4 	movi	r6,3
 10081f8:	01500644 	movi	r5,16409
 10081fc:	01001c04 	movi	r4,112
 1008200:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_PLAYBACK_MIXER_LEFT_CONTROL_0_IC_1_ADDR , R10_PLAYBACK_OUTPUT_SIGNAL_PATH_REGISTERS_IC_1_SIZE, R10_PLAYBACK_OUTPUT_SIGNAL_PATH_REGISTERS_IC_1_Default );
 1008204:	01c040b4 	movhi	r7,258
 1008208:	39ebe244 	addi	r7,r7,-20599
 100820c:	01800384 	movi	r6,14
 1008210:	01500704 	movi	r5,16412
 1008214:	01001c04 	movi	r4,112
 1008218:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_CONVERTER_CTRL_0_IC_1_ADDR , R11_CONVERTER_CONTROL_REGISTERS_IC_1_SIZE, R11_CONVERTER_CONTROL_REGISTERS_IC_1_Default );
 100821c:	d1e09684 	addi	r7,gp,-32166
 1008220:	01800084 	movi	r6,2
 1008224:	015005c4 	movi	r5,16407
 1008228:	01001c04 	movi	r4,112
 100822c:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_DAC_CONTROL_0_IC_1_ADDR , R12_DAC_CONTROL_REGISTERS_IC_1_SIZE, R12_DAC_CONTROL_REGISTERS_IC_1_Default );
 1008230:	d1e00cc4 	addi	r7,gp,-32717
 1008234:	018000c4 	movi	r6,3
 1008238:	01500a84 	movi	r5,16426
 100823c:	01001c04 	movi	r4,112
 1008240:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_SERIAL_PORT_PAD_CONTROL_0_IC_1_ADDR , R13_SERIAL_PORT_PAD_CONTROL_REGISTERS_IC_1_SIZE, R13_SERIAL_PORT_PAD_CONTROL_REGISTERS_IC_1_Default );
 1008244:	d1e00d84 	addi	r7,gp,-32714
 1008248:	01800044 	movi	r6,1
 100824c:	01500b44 	movi	r5,16429
 1008250:	01001c04 	movi	r4,112
 1008254:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_COMM_PORT_PAD_CTRL_0_IC_1_ADDR , R14_COMMUNICATION_PORT_PAD_CONTROL_REGISTERS_IC_1_SIZE, R14_COMMUNICATION_PORT_PAD_CONTROL_REGISTERS_IC_1_Default );
 1008258:	d1e00dc4 	addi	r7,gp,-32713
 100825c:	01800084 	movi	r6,2
 1008260:	01500bc4 	movi	r5,16431
 1008264:	01001c04 	movi	r4,112
 1008268:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_JACKREGISTER_IC_1_ADDR, REG_JACKREGISTER_IC_1_BYTE, R15_JACKREGISTER_IC_1_Default );
 100826c:	d1e00e44 	addi	r7,gp,-32711
 1008270:	01800044 	movi	r6,1
 1008274:	01500c44 	movi	r5,16433
 1008278:	01001c04 	movi	r4,112
 100827c:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, PROGRAM_ADDR_IC_1, PROGRAM_SIZE_IC_1, Program_Data_IC_1 );
 1008280:	01c040b4 	movhi	r7,258
 1008284:	39eb8504 	addi	r7,r7,-20972
 1008288:	01805144 	movi	r6,325
 100828c:	01420004 	movi	r5,2048
 1008290:	01001c04 	movi	r4,112
 1008294:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, PROGRAM_ADDR_IC_1, PROGRAM_SIZE_IC_1, Program_Data_IC_1 );
 1008298:	01c040b4 	movhi	r7,258
 100829c:	39eb8504 	addi	r7,r7,-20972
 10082a0:	01805144 	movi	r6,325
 10082a4:	01420004 	movi	r5,2048
 10082a8:	01001c04 	movi	r4,112
 10082ac:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, PROGRAM_ADDR_IC_1, PROGRAM_SIZE_IC_1, Program_Data_IC_1 );
 10082b0:	01c040b4 	movhi	r7,258
 10082b4:	39eb8504 	addi	r7,r7,-20972
 10082b8:	01805144 	movi	r6,325
 10082bc:	01420004 	movi	r5,2048
 10082c0:	01001c04 	movi	r4,112
 10082c4:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, PROGRAM_ADDR_IC_1, PROGRAM_SIZE_IC_1, Program_Data_IC_1 );
 10082c8:	01c040b4 	movhi	r7,258
 10082cc:	39eb8504 	addi	r7,r7,-20972
 10082d0:	01805144 	movi	r6,325
 10082d4:	01420004 	movi	r5,2048
 10082d8:	01001c04 	movi	r4,112
 10082dc:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, PROGRAM_ADDR_IC_1, PROGRAM_SIZE_IC_1, Program_Data_IC_1 );
 10082e0:	01c040b4 	movhi	r7,258
 10082e4:	39eb8504 	addi	r7,r7,-20972
 10082e8:	01805144 	movi	r6,325
 10082ec:	01420004 	movi	r5,2048
 10082f0:	01001c04 	movi	r4,112
 10082f4:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_DSP_ENABLE_REGISTER_IC_1_ADDR, REG_DSP_ENABLE_REGISTER_IC_1_BYTE, R21_DSP_ENABLE_REGISTER_IC_1_Default );
 10082f8:	d1e00e84 	addi	r7,gp,-32710
 10082fc:	01800044 	movi	r6,1
 1008300:	01503d44 	movi	r5,16629
 1008304:	01001c04 	movi	r4,112
 1008308:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_CRC_IDEAL_1_IC_1_ADDR , R22_CRC_REGISTERS_IC_1_SIZE, R22_CRC_REGISTERS_IC_1_Default );
 100830c:	d1e00ec4 	addi	r7,gp,-32709
 1008310:	01800144 	movi	r6,5
 1008314:	01503004 	movi	r5,16576
 1008318:	01001c04 	movi	r4,112
 100831c:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_GPIO_0_CONTROL_IC_1_ADDR , R23_GPIO_REGISTERS_IC_1_SIZE, R23_GPIO_REGISTERS_IC_1_Default );
 1008320:	d1e09704 	addi	r7,gp,-32164
 1008324:	01800104 	movi	r6,4
 1008328:	01503184 	movi	r5,16582
 100832c:	01001c04 	movi	r4,112
 1008330:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_NON_MODULO_RAM_1_IC_1_ADDR , R24_NON_MODULO_REGISTERS_IC_1_SIZE, R24_NON_MODULO_REGISTERS_IC_1_Default );
 1008334:	d1e01004 	addi	r7,gp,-32704
 1008338:	01800084 	movi	r6,2
 100833c:	01503a44 	movi	r5,16617
 1008340:	01001c04 	movi	r4,112
 1008344:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_WATCHDOG_ENABLE_IC_1_ADDR , R25_WATCHDOG_REGISTERS_IC_1_SIZE, R25_WATCHDOG_REGISTERS_IC_1_Default );
 1008348:	d1e01084 	addi	r7,gp,-32702
 100834c:	01800144 	movi	r6,5
 1008350:	01503404 	movi	r5,16592
 1008354:	01001c04 	movi	r4,112
 1008358:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_SAMPLE_RATE_SETTING_IC_1_ADDR, REG_SAMPLE_RATE_SETTING_IC_1_BYTE, R26_SAMPLE_RATE_SETTING_IC_1_Default );
 100835c:	d1e011c4 	addi	r7,gp,-32697
 1008360:	01800044 	movi	r6,1
 1008364:	01503ac4 	movi	r5,16619
 1008368:	01001c04 	movi	r4,112
 100836c:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_ROUTING_MATRIX_INPUTS_IC_1_ADDR, REG_ROUTING_MATRIX_INPUTS_IC_1_BYTE, R27_ROUTING_MATRIX_INPUTS_IC_1_Default );
 1008370:	d1e09804 	addi	r7,gp,-32160
 1008374:	01800044 	movi	r6,1
 1008378:	01503c84 	movi	r5,16626
 100837c:	01001c04 	movi	r4,112
 1008380:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_ROUTING_MATRIX_OUTPUTS_IC_1_ADDR, REG_ROUTING_MATRIX_OUTPUTS_IC_1_BYTE, R28_ROUTING_MATRIX_OUTPUTS_IC_1_Default );
 1008384:	d1e09844 	addi	r7,gp,-32159
 1008388:	01800044 	movi	r6,1
 100838c:	01503cc4 	movi	r5,16627
 1008390:	01001c04 	movi	r4,112
 1008394:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_SERIAL_DATAGPIO_PIN_CONFIG_IC_1_ADDR, REG_SERIAL_DATAGPIO_PIN_CONFIG_IC_1_BYTE, R29_SERIAL_DATAGPIO_PIN_CONFIG_IC_1_Default );
 1008398:	d1e09884 	addi	r7,gp,-32158
 100839c:	01800044 	movi	r6,1
 10083a0:	01503d04 	movi	r5,16628
 10083a4:	01001c04 	movi	r4,112
 10083a8:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_DSP_SLEW_MODES_IC_1_ADDR, REG_DSP_SLEW_MODES_IC_1_BYTE, R30_DSP_SLEW_MODES_IC_1_Default );
 10083ac:	d1e098c4 	addi	r7,gp,-32157
 10083b0:	01800044 	movi	r6,1
 10083b4:	01503dc4 	movi	r5,16631
 10083b8:	01001c04 	movi	r4,112
 10083bc:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_SERIAL_PORT_SAMPLE_RATE_SETTING_IC_1_ADDR, REG_SERIAL_PORT_SAMPLE_RATE_SETTING_IC_1_BYTE, R31_SERIAL_PORT_SAMPLE_RATE_SETTING_IC_1_Default );
 10083c0:	d1e09904 	addi	r7,gp,-32156
 10083c4:	01800044 	movi	r6,1
 10083c8:	01503e04 	movi	r5,16632
 10083cc:	01001c04 	movi	r4,112
 10083d0:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_CLOCK_ENABLE_REG_0_IC_1_ADDR , R32_CLOCK_ENABLE_REGISTERS_IC_1_SIZE, R32_CLOCK_ENABLE_REGISTERS_IC_1_Default );
 10083d4:	d1e01204 	addi	r7,gp,-32696
 10083d8:	01800084 	movi	r6,2
 10083dc:	01503e44 	movi	r5,16633
 10083e0:	01001c04 	movi	r4,112
 10083e4:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, PROGRAM_ADDR_IC_1, PROGRAM_SIZE_IC_1, Program_Data_IC_1 );
 10083e8:	01c040b4 	movhi	r7,258
 10083ec:	39eb8504 	addi	r7,r7,-20972
 10083f0:	01805144 	movi	r6,325
 10083f4:	01420004 	movi	r5,2048
 10083f8:	01001c04 	movi	r4,112
 10083fc:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, PARAM_ADDR_IC_1, PARAM_SIZE_IC_1, Param_Data_IC_1 );
 1008400:	01c040b4 	movhi	r7,258
 1008404:	39ebd644 	addi	r7,r7,-20647
 1008408:	01800c04 	movi	r6,48
 100840c:	000b883a 	mov	r5,zero
 1008410:	01001c04 	movi	r4,112
 1008414:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, NON_MODULO_RAM_ADDR_IC_1, NON_MODULO_RAM_SIZE_IC_1, NON_MODULO_RAM_Data_IC_1 );
 1008418:	d1e00404 	addi	r7,gp,-32752
 100841c:	01800204 	movi	r6,8
 1008420:	0147ff84 	movi	r5,8190
 1008424:	01001c04 	movi	r4,112
 1008428:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_SAMPLE_RATE_SETTING_IC_1_ADDR, REG_SAMPLE_RATE_SETTING_IC_1_BYTE, R36_SAMPLE_RATE_SETTING_IC_1_Default );
 100842c:	d1e01284 	addi	r7,gp,-32694
 1008430:	01800044 	movi	r6,1
 1008434:	01503ac4 	movi	r5,16619
 1008438:	01001c04 	movi	r4,112
 100843c:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_DSP_RUN_REGISTER_IC_1_ADDR, REG_DSP_RUN_REGISTER_IC_1_BYTE, R37_DSP_RUN_REGISTER_IC_1_Default );
 1008440:	d1e012c4 	addi	r7,gp,-32693
 1008444:	01800044 	movi	r6,1
 1008448:	01503d84 	movi	r5,16630
 100844c:	01001c04 	movi	r4,112
 1008450:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_DEJITTER_REGISTER_CONTROL_IC_1_ADDR, REG_DEJITTER_REGISTER_CONTROL_IC_1_BYTE, R38_DEJITTER_REGISTER_CONTROL_IC_1_Default );
 1008454:	d1e09944 	addi	r7,gp,-32155
 1008458:	01800044 	movi	r6,1
 100845c:	01500d84 	movi	r5,16438
 1008460:	01001c04 	movi	r4,112
 1008464:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_1, REG_DEJITTER_REGISTER_CONTROL_IC_1_ADDR, REG_DEJITTER_REGISTER_CONTROL_IC_1_BYTE, R39_DEJITTER_REGISTER_CONTROL_IC_1_Default );
 1008468:	d1e01304 	addi	r7,gp,-32692
 100846c:	01800044 	movi	r6,1
 1008470:	01500d84 	movi	r5,16438
 1008474:	01001c04 	movi	r4,112
 1008478:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
}
 100847c:	0001883a 	nop
 1008480:	e037883a 	mov	sp,fp
 1008484:	dfc00117 	ldw	ra,4(sp)
 1008488:	df000017 	ldw	fp,0(sp)
 100848c:	dec00204 	addi	sp,sp,8
 1008490:	f800283a 	ret

01008494 <default_download_IC_2>:
/*
 * Default Download
 */
#define DEFAULT_DOWNLOAD_SIZE_IC_2 40

void default_download_IC_2() {
 1008494:	defffe04 	addi	sp,sp,-8
 1008498:	dfc00115 	stw	ra,4(sp)
 100849c:	df000015 	stw	fp,0(sp)
 10084a0:	d839883a 	mov	fp,sp
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_2, REG_SAMPLE_RATE_SETTING_IC_2_ADDR, REG_SAMPLE_RATE_SETTING_IC_2_BYTE, R0_SAMPLE_RATE_SETTING_IC_2_Default );
 10084a4:	d1e01544 	addi	r7,gp,-32683
 10084a8:	01800044 	movi	r6,1
 10084ac:	01503ac4 	movi	r5,16619
 10084b0:	01001c84 	movi	r4,114
 10084b4:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_2, REG_DSP_RUN_REGISTER_IC_2_ADDR, REG_DSP_RUN_REGISTER_IC_2_BYTE, R1_DSP_RUN_REGISTER_IC_2_Default );
 10084b8:	d1e09984 	addi	r7,gp,-32154
 10084bc:	01800044 	movi	r6,1
 10084c0:	01503d84 	movi	r5,16630
 10084c4:	01001c84 	movi	r4,114
 10084c8:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_2, REG_CLKCTRLREGISTER_IC_2_ADDR, REG_CLKCTRLREGISTER_IC_2_BYTE, R2_CLKCTRLREGISTER_IC_2_Default );
 10084cc:	d1e01584 	addi	r7,gp,-32682
 10084d0:	01800044 	movi	r6,1
 10084d4:	01500004 	movi	r5,16384
 10084d8:	01001c84 	movi	r4,114
 10084dc:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_2, REG_PLLCRLREGISTER_IC_2_ADDR, REG_PLLCRLREGISTER_IC_2_BYTE, R3_PLLCRLREGISTER_IC_2_Default );
 10084e0:	d1e015c4 	addi	r7,gp,-32681
 10084e4:	01800184 	movi	r6,6
 10084e8:	01500084 	movi	r5,16386
 10084ec:	01001c84 	movi	r4,114
 10084f0:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_DELAY( DEVICE_ADDR_IC_2, R4_DELAY_IC_2_SIZE, R4_DELAY_IC_2_Default );
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_2, REG_SERIAL_PORT_CONTROL_0_IC_2_ADDR , R5_SERIAL_PORT_CONTROL_REGISTERS_IC_2_SIZE, R5_SERIAL_PORT_CONTROL_REGISTERS_IC_2_Default );
 10084f4:	d1e099c4 	addi	r7,gp,-32153
 10084f8:	01800084 	movi	r6,2
 10084fc:	01500544 	movi	r5,16405
 1008500:	01001c84 	movi	r4,114
 1008504:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_2, REG_ALC_CONTROL_0_IC_2_ADDR , R6_ALC_CONTROL_REGISTERS_IC_2_SIZE, R6_ALC_CONTROL_REGISTERS_IC_2_Default );
 1008508:	d1e09a44 	addi	r7,gp,-32151
 100850c:	01800104 	movi	r6,4
 1008510:	01500444 	movi	r5,16401
 1008514:	01001c84 	movi	r4,114
 1008518:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_2, REG_MICCTRLREGISTER_IC_2_ADDR, REG_MICCTRLREGISTER_IC_2_BYTE, R7_MICCTRLREGISTER_IC_2_Default );
 100851c:	d1e09b44 	addi	r7,gp,-32147
 1008520:	01800044 	movi	r6,1
 1008524:	01500204 	movi	r5,16392
 1008528:	01001c84 	movi	r4,114
 100852c:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_2, REG_RECORD_PWR_MANAGEMENT_IC_2_ADDR , R8_RECORD_INPUT_SIGNAL_PATH_REGISTERS_IC_2_SIZE, R8_RECORD_INPUT_SIGNAL_PATH_REGISTERS_IC_2_Default );
 1008530:	d1e017c4 	addi	r7,gp,-32673
 1008534:	01800204 	movi	r6,8
 1008538:	01500244 	movi	r5,16393
 100853c:	01001c84 	movi	r4,114
 1008540:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_2, REG_ADC_CONTROL_0_IC_2_ADDR , R9_ADC_CONTROL_REGISTERS_IC_2_SIZE, R9_ADC_CONTROL_REGISTERS_IC_2_Default );
 1008544:	d1e019c4 	addi	r7,gp,-32665
 1008548:	018000c4 	movi	r6,3
 100854c:	01500644 	movi	r5,16409
 1008550:	01001c84 	movi	r4,114
 1008554:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_2, REG_PLAYBACK_MIXER_LEFT_CONTROL_0_IC_2_ADDR , R10_PLAYBACK_OUTPUT_SIGNAL_PATH_REGISTERS_IC_2_SIZE, R10_PLAYBACK_OUTPUT_SIGNAL_PATH_REGISTERS_IC_2_Default );
 1008558:	01c040b4 	movhi	r7,258
 100855c:	39ec4304 	addi	r7,r7,-20212
 1008560:	01800384 	movi	r6,14
 1008564:	01500704 	movi	r5,16412
 1008568:	01001c84 	movi	r4,114
 100856c:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_2, REG_CONVERTER_CTRL_0_IC_2_ADDR , R11_CONVERTER_CONTROL_REGISTERS_IC_2_SIZE, R11_CONVERTER_CONTROL_REGISTERS_IC_2_Default );
 1008570:	d1e09b84 	addi	r7,gp,-32146
 1008574:	01800084 	movi	r6,2
 1008578:	015005c4 	movi	r5,16407
 100857c:	01001c84 	movi	r4,114
 1008580:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_2, REG_DAC_CONTROL_0_IC_2_ADDR , R12_DAC_CONTROL_REGISTERS_IC_2_SIZE, R12_DAC_CONTROL_REGISTERS_IC_2_Default );
 1008584:	d1e01a84 	addi	r7,gp,-32662
 1008588:	018000c4 	movi	r6,3
 100858c:	01500a84 	movi	r5,16426
 1008590:	01001c84 	movi	r4,114
 1008594:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_2, REG_SERIAL_PORT_PAD_CONTROL_0_IC_2_ADDR , R13_SERIAL_PORT_PAD_CONTROL_REGISTERS_IC_2_SIZE, R13_SERIAL_PORT_PAD_CONTROL_REGISTERS_IC_2_Default );
 1008598:	d1e01b44 	addi	r7,gp,-32659
 100859c:	01800044 	movi	r6,1
 10085a0:	01500b44 	movi	r5,16429
 10085a4:	01001c84 	movi	r4,114
 10085a8:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_2, REG_COMM_PORT_PAD_CTRL_0_IC_2_ADDR , R14_COMMUNICATION_PORT_PAD_CONTROL_REGISTERS_IC_2_SIZE, R14_COMMUNICATION_PORT_PAD_CONTROL_REGISTERS_IC_2_Default );
 10085ac:	d1e01b84 	addi	r7,gp,-32658
 10085b0:	01800084 	movi	r6,2
 10085b4:	01500bc4 	movi	r5,16431
 10085b8:	01001c84 	movi	r4,114
 10085bc:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_2, REG_JACKREGISTER_IC_2_ADDR, REG_JACKREGISTER_IC_2_BYTE, R15_JACKREGISTER_IC_2_Default );
 10085c0:	d1e01c04 	addi	r7,gp,-32656
 10085c4:	01800044 	movi	r6,1
 10085c8:	01500c44 	movi	r5,16433
 10085cc:	01001c84 	movi	r4,114
 10085d0:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_2, PROGRAM_ADDR_IC_2, PROGRAM_SIZE_IC_2, Program_Data_IC_2 );
 10085d4:	01c040b4 	movhi	r7,258
 10085d8:	39ebe5c4 	addi	r7,r7,-20585
 10085dc:	01805144 	movi	r6,325
 10085e0:	01420004 	movi	r5,2048
 10085e4:	01001c84 	movi	r4,114
 10085e8:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_2, PROGRAM_ADDR_IC_2, PROGRAM_SIZE_IC_2, Program_Data_IC_2 );
 10085ec:	01c040b4 	movhi	r7,258
 10085f0:	39ebe5c4 	addi	r7,r7,-20585
 10085f4:	01805144 	movi	r6,325
 10085f8:	01420004 	movi	r5,2048
 10085fc:	01001c84 	movi	r4,114
 1008600:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_2, PROGRAM_ADDR_IC_2, PROGRAM_SIZE_IC_2, Program_Data_IC_2 );
 1008604:	01c040b4 	movhi	r7,258
 1008608:	39ebe5c4 	addi	r7,r7,-20585
 100860c:	01805144 	movi	r6,325
 1008610:	01420004 	movi	r5,2048
 1008614:	01001c84 	movi	r4,114
 1008618:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_2, PROGRAM_ADDR_IC_2, PROGRAM_SIZE_IC_2, Program_Data_IC_2 );
 100861c:	01c040b4 	movhi	r7,258
 1008620:	39ebe5c4 	addi	r7,r7,-20585
 1008624:	01805144 	movi	r6,325
 1008628:	01420004 	movi	r5,2048
 100862c:	01001c84 	movi	r4,114
 1008630:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_2, PROGRAM_ADDR_IC_2, PROGRAM_SIZE_IC_2, Program_Data_IC_2 );
 1008634:	01c040b4 	movhi	r7,258
 1008638:	39ebe5c4 	addi	r7,r7,-20585
 100863c:	01805144 	movi	r6,325
 1008640:	01420004 	movi	r5,2048
 1008644:	01001c84 	movi	r4,114
 1008648:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_2, REG_DSP_ENABLE_REGISTER_IC_2_ADDR, REG_DSP_ENABLE_REGISTER_IC_2_BYTE, R21_DSP_ENABLE_REGISTER_IC_2_Default );
 100864c:	d1e01c44 	addi	r7,gp,-32655
 1008650:	01800044 	movi	r6,1
 1008654:	01503d44 	movi	r5,16629
 1008658:	01001c84 	movi	r4,114
 100865c:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_2, REG_CRC_IDEAL_1_IC_2_ADDR , R22_CRC_REGISTERS_IC_2_SIZE, R22_CRC_REGISTERS_IC_2_Default );
 1008660:	d1e01c84 	addi	r7,gp,-32654
 1008664:	01800144 	movi	r6,5
 1008668:	01503004 	movi	r5,16576
 100866c:	01001c84 	movi	r4,114
 1008670:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_2, REG_GPIO_0_CONTROL_IC_2_ADDR , R23_GPIO_REGISTERS_IC_2_SIZE, R23_GPIO_REGISTERS_IC_2_Default );
 1008674:	d1e09c04 	addi	r7,gp,-32144
 1008678:	01800104 	movi	r6,4
 100867c:	01503184 	movi	r5,16582
 1008680:	01001c84 	movi	r4,114
 1008684:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_2, REG_NON_MODULO_RAM_1_IC_2_ADDR , R24_NON_MODULO_REGISTERS_IC_2_SIZE, R24_NON_MODULO_REGISTERS_IC_2_Default );
 1008688:	d1e01dc4 	addi	r7,gp,-32649
 100868c:	01800084 	movi	r6,2
 1008690:	01503a44 	movi	r5,16617
 1008694:	01001c84 	movi	r4,114
 1008698:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_2, REG_WATCHDOG_ENABLE_IC_2_ADDR , R25_WATCHDOG_REGISTERS_IC_2_SIZE, R25_WATCHDOG_REGISTERS_IC_2_Default );
 100869c:	d1e01e44 	addi	r7,gp,-32647
 10086a0:	01800144 	movi	r6,5
 10086a4:	01503404 	movi	r5,16592
 10086a8:	01001c84 	movi	r4,114
 10086ac:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_2, REG_SAMPLE_RATE_SETTING_IC_2_ADDR, REG_SAMPLE_RATE_SETTING_IC_2_BYTE, R26_SAMPLE_RATE_SETTING_IC_2_Default );
 10086b0:	d1e01f84 	addi	r7,gp,-32642
 10086b4:	01800044 	movi	r6,1
 10086b8:	01503ac4 	movi	r5,16619
 10086bc:	01001c84 	movi	r4,114
 10086c0:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_2, REG_ROUTING_MATRIX_INPUTS_IC_2_ADDR, REG_ROUTING_MATRIX_INPUTS_IC_2_BYTE, R27_ROUTING_MATRIX_INPUTS_IC_2_Default );
 10086c4:	d1e09d04 	addi	r7,gp,-32140
 10086c8:	01800044 	movi	r6,1
 10086cc:	01503c84 	movi	r5,16626
 10086d0:	01001c84 	movi	r4,114
 10086d4:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_2, REG_ROUTING_MATRIX_OUTPUTS_IC_2_ADDR, REG_ROUTING_MATRIX_OUTPUTS_IC_2_BYTE, R28_ROUTING_MATRIX_OUTPUTS_IC_2_Default );
 10086d8:	d1e09d44 	addi	r7,gp,-32139
 10086dc:	01800044 	movi	r6,1
 10086e0:	01503cc4 	movi	r5,16627
 10086e4:	01001c84 	movi	r4,114
 10086e8:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_2, REG_SERIAL_DATAGPIO_PIN_CONFIG_IC_2_ADDR, REG_SERIAL_DATAGPIO_PIN_CONFIG_IC_2_BYTE, R29_SERIAL_DATAGPIO_PIN_CONFIG_IC_2_Default );
 10086ec:	d1e09d84 	addi	r7,gp,-32138
 10086f0:	01800044 	movi	r6,1
 10086f4:	01503d04 	movi	r5,16628
 10086f8:	01001c84 	movi	r4,114
 10086fc:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_2, REG_DSP_SLEW_MODES_IC_2_ADDR, REG_DSP_SLEW_MODES_IC_2_BYTE, R30_DSP_SLEW_MODES_IC_2_Default );
 1008700:	d1e09dc4 	addi	r7,gp,-32137
 1008704:	01800044 	movi	r6,1
 1008708:	01503dc4 	movi	r5,16631
 100870c:	01001c84 	movi	r4,114
 1008710:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_2, REG_SERIAL_PORT_SAMPLE_RATE_SETTING_IC_2_ADDR, REG_SERIAL_PORT_SAMPLE_RATE_SETTING_IC_2_BYTE, R31_SERIAL_PORT_SAMPLE_RATE_SETTING_IC_2_Default );
 1008714:	d1e09e04 	addi	r7,gp,-32136
 1008718:	01800044 	movi	r6,1
 100871c:	01503e04 	movi	r5,16632
 1008720:	01001c84 	movi	r4,114
 1008724:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_2, REG_CLOCK_ENABLE_REG_0_IC_2_ADDR , R32_CLOCK_ENABLE_REGISTERS_IC_2_SIZE, R32_CLOCK_ENABLE_REGISTERS_IC_2_Default );
 1008728:	d1e01fc4 	addi	r7,gp,-32641
 100872c:	01800084 	movi	r6,2
 1008730:	01503e44 	movi	r5,16633
 1008734:	01001c84 	movi	r4,114
 1008738:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_2, PROGRAM_ADDR_IC_2, PROGRAM_SIZE_IC_2, Program_Data_IC_2 );
 100873c:	01c040b4 	movhi	r7,258
 1008740:	39ebe5c4 	addi	r7,r7,-20585
 1008744:	01805144 	movi	r6,325
 1008748:	01420004 	movi	r5,2048
 100874c:	01001c84 	movi	r4,114
 1008750:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_2, PARAM_ADDR_IC_2, PARAM_SIZE_IC_2, Param_Data_IC_2 );
 1008754:	01c040b4 	movhi	r7,258
 1008758:	39ec3704 	addi	r7,r7,-20260
 100875c:	01800c04 	movi	r6,48
 1008760:	000b883a 	mov	r5,zero
 1008764:	01001c84 	movi	r4,114
 1008768:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_2, NON_MODULO_RAM_ADDR_IC_2, NON_MODULO_RAM_SIZE_IC_2, NON_MODULO_RAM_Data_IC_2 );
 100876c:	d1e01344 	addi	r7,gp,-32691
 1008770:	01800204 	movi	r6,8
 1008774:	0147ff84 	movi	r5,8190
 1008778:	01001c84 	movi	r4,114
 100877c:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_2, REG_SAMPLE_RATE_SETTING_IC_2_ADDR, REG_SAMPLE_RATE_SETTING_IC_2_BYTE, R36_SAMPLE_RATE_SETTING_IC_2_Default );
 1008780:	d1e02044 	addi	r7,gp,-32639
 1008784:	01800044 	movi	r6,1
 1008788:	01503ac4 	movi	r5,16619
 100878c:	01001c84 	movi	r4,114
 1008790:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_2, REG_DSP_RUN_REGISTER_IC_2_ADDR, REG_DSP_RUN_REGISTER_IC_2_BYTE, R37_DSP_RUN_REGISTER_IC_2_Default );
 1008794:	d1e02084 	addi	r7,gp,-32638
 1008798:	01800044 	movi	r6,1
 100879c:	01503d84 	movi	r5,16630
 10087a0:	01001c84 	movi	r4,114
 10087a4:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_2, REG_DEJITTER_REGISTER_CONTROL_IC_2_ADDR, REG_DEJITTER_REGISTER_CONTROL_IC_2_BYTE, R38_DEJITTER_REGISTER_CONTROL_IC_2_Default );
 10087a8:	d1e09e44 	addi	r7,gp,-32135
 10087ac:	01800044 	movi	r6,1
 10087b0:	01500d84 	movi	r5,16438
 10087b4:	01001c84 	movi	r4,114
 10087b8:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
	SIGMA_WRITE_REGISTER_BLOCK( DEVICE_ADDR_IC_2, REG_DEJITTER_REGISTER_CONTROL_IC_2_ADDR, REG_DEJITTER_REGISTER_CONTROL_IC_2_BYTE, R39_DEJITTER_REGISTER_CONTROL_IC_2_Default );
 10087bc:	d1e020c4 	addi	r7,gp,-32637
 10087c0:	01800044 	movi	r6,1
 10087c4:	01500d84 	movi	r5,16438
 10087c8:	01001c84 	movi	r4,114
 10087cc:	1007e500 	call	1007e50 <SIGMA_WRITE_REGISTER_BLOCK>
}
 10087d0:	0001883a 	nop
 10087d4:	e037883a 	mov	sp,fp
 10087d8:	dfc00117 	ldw	ra,4(sp)
 10087dc:	df000017 	ldw	fp,0(sp)
 10087e0:	dec00204 	addi	sp,sp,8
 10087e4:	f800283a 	ret

010087e8 <adc_callback>:

uint32_t adc[2] = {0};
volatile uint32_t adc_busy = 0;

void adc_callback(void *context)
{
 10087e8:	defffd04 	addi	sp,sp,-12
 10087ec:	dfc00215 	stw	ra,8(sp)
 10087f0:	df000115 	stw	fp,4(sp)
 10087f4:	df000104 	addi	fp,sp,4
 10087f8:	e13fff15 	stw	r4,-4(fp)
	alt_adc_word_read(MODULAR_ADC_0_SAMPLE_STORE_CSR_BASE, adc, 2);
 10087fc:	01800084 	movi	r6,2
 1008800:	d160a504 	addi	r5,gp,-32108
 1008804:	01060004 	movi	r4,6144
 1008808:	10182b80 	call	10182b8 <alt_adc_word_read>
	adc_busy = 0;
 100880c:	d020a715 	stw	zero,-32100(gp)
}
 1008810:	0001883a 	nop
 1008814:	e037883a 	mov	sp,fp
 1008818:	dfc00117 	ldw	ra,4(sp)
 100881c:	df000017 	ldw	fp,0(sp)
 1008820:	dec00204 	addi	sp,sp,8
 1008824:	f800283a 	ret

01008828 <adc_init>:

void adc_init(void)
{
 1008828:	defffe04 	addi	sp,sp,-8
 100882c:	dfc00115 	stw	ra,4(sp)
 1008830:	df000015 	stw	fp,0(sp)
 1008834:	d839883a 	mov	fp,sp
	adc_stop(MODULAR_ADC_0_SEQUENCER_CSR_BASE);
 1008838:	0106b004 	movi	r4,6848
 100883c:	10184b00 	call	10184b0 <adc_stop>
	adc_set_mode_run_once(MODULAR_ADC_0_SEQUENCER_CSR_BASE);
 1008840:	0106b004 	movi	r4,6848
 1008844:	10185380 	call	1018538 <adc_set_mode_run_once>
	alt_adc_register_callback
 1008848:	010040b4 	movhi	r4,258
 100884c:	212a4204 	addi	r4,r4,-22264
 1008850:	10184700 	call	1018470 <altera_modular_adc_open>
 1008854:	01c60004 	movi	r7,6144
 1008858:	000d883a 	mov	r6,zero
 100885c:	01404074 	movhi	r5,257
 1008860:	2961fa04 	addi	r5,r5,-30744
 1008864:	1009883a 	mov	r4,r2
 1008868:	10183d80 	call	10183d8 <alt_adc_register_callback>
	(
		altera_modular_adc_open(MODULAR_ADC_0_SEQUENCER_CSR_NAME),
		(alt_adc_callback) adc_callback, NULL,
		MODULAR_ADC_0_SAMPLE_STORE_CSR_BASE
	);
}
 100886c:	0001883a 	nop
 1008870:	e037883a 	mov	sp,fp
 1008874:	dfc00117 	ldw	ra,4(sp)
 1008878:	df000017 	ldw	fp,0(sp)
 100887c:	dec00204 	addi	sp,sp,8
 1008880:	f800283a 	ret

01008884 <main>:

int main()
{
 1008884:	defffa04 	addi	sp,sp,-24
 1008888:	dfc00515 	stw	ra,20(sp)
 100888c:	df000415 	stw	fp,16(sp)
 1008890:	dc000315 	stw	r16,12(sp)
 1008894:	df000404 	addi	fp,sp,16
	//I2C SCL
	//IOWR_ALTERA_AVALON_PIO_DIRECTION(PIO_2_BASE, 1);

	//CODEC RESET
	IOWR_ALTERA_AVALON_PIO_DIRECTION(PIO_4_BASE, 1);
 1008898:	00c00044 	movi	r3,1
 100889c:	0086a504 	movi	r2,6804
 10088a0:	10c00035 	stwio	r3,0(r2)
	IOWR_ALTERA_AVALON_PIO_DATA(PIO_4_BASE, 0);
 10088a4:	0007883a 	mov	r3,zero
 10088a8:	0086a404 	movi	r2,6800
 10088ac:	10c00035 	stwio	r3,0(r2)
	usleep(1000 * 20);
 10088b0:	01138804 	movi	r4,20000
 10088b4:	1016b6c0 	call	1016b6c <usleep>
	IOWR_ALTERA_AVALON_PIO_DATA(PIO_4_BASE, 1);
 10088b8:	00c00044 	movi	r3,1
 10088bc:	0086a404 	movi	r2,6800
 10088c0:	10c00035 	stwio	r3,0(r2)

	//i2c_setup(0x00, 0xC7);
	i2c_setup(0x00, 0xB3);
 10088c4:	01402cc4 	movi	r5,179
 10088c8:	0009883a 	mov	r4,zero
 10088cc:	1007a4c0 	call	1007a4c <i2c_setup>
	//i2c_setup(0x00, 0x31);

	//status = i2c_start(0x70, 0x00);
	default_download_IC_1();
 10088d0:	10081400 	call	1008140 <default_download_IC_1>
	default_download_IC_2();
 10088d4:	10084940 	call	1008494 <default_download_IC_2>

	usleep(1000);
 10088d8:	0100fa04 	movi	r4,1000
 10088dc:	1016b6c0 	call	1016b6c <usleep>
	IOWR_ALTERA_AVALON_PIO_DIRECTION(PIO_4_BASE, 0);
 10088e0:	0007883a 	mov	r3,zero
 10088e4:	0086a504 	movi	r2,6804
 10088e8:	10c00035 	stwio	r3,0(r2)

	adc_init();
 10088ec:	10088280 	call	1008828 <adc_init>
	adc_busy = 1;
 10088f0:	00800044 	movi	r2,1
 10088f4:	d0a0a715 	stw	r2,-32100(gp)
	adc_start(MODULAR_ADC_0_SEQUENCER_CSR_BASE);
 10088f8:	0106b004 	movi	r4,6848
 10088fc:	10185000 	call	1018500 <adc_start>

	itest++;
 1008900:	d0a0a117 	ldw	r2,-32124(gp)
 1008904:	10800044 	addi	r2,r2,1
 1008908:	d0a0a115 	stw	r2,-32124(gp)
	ftest = 3.14f;
 100890c:	00901274 	movhi	r2,16457
 1008910:	10bd70c4 	addi	r2,r2,-2621
 1008914:	d0a0a215 	stw	r2,-32120(gp)
	dtest = 3.141594;
 1008918:	00823eb4 	movhi	r2,2298
 100891c:	109ea144 	addi	r2,r2,31365
 1008920:	d0a0a315 	stw	r2,-32116(gp)
 1008924:	00900274 	movhi	r2,16393
 1008928:	10887f04 	addi	r2,r2,8700
 100892c:	d0a0a415 	stw	r2,-32112(gp)

	printf("Hello from Nios II! %d %f %lf\n", itest, ftest, dtest);
 1008930:	d420a117 	ldw	r16,-32124(gp)
 1008934:	d0a0a217 	ldw	r2,-32120(gp)
 1008938:	1009883a 	mov	r4,r2
 100893c:	10098600 	call	1009860 <__extendsfdf2>
 1008940:	1009883a 	mov	r4,r2
 1008944:	180b883a 	mov	r5,r3
 1008948:	d0a0a317 	ldw	r2,-32116(gp)
 100894c:	d0e0a417 	ldw	r3,-32112(gp)
 1008950:	d8800015 	stw	r2,0(sp)
 1008954:	d8c00115 	stw	r3,4(sp)
 1008958:	200d883a 	mov	r6,r4
 100895c:	280f883a 	mov	r7,r5
 1008960:	800b883a 	mov	r5,r16
 1008964:	010040b4 	movhi	r4,258
 1008968:	212a4b04 	addi	r4,r4,-22228
 100896c:	1009c740 	call	1009c74 <printf>

#if 1
	init_MAC();
 1008970:	1008d840 	call	1008d84 <init_MAC>

    xTaskCreate(prvPrintTask1, "Task1", configMINIMAL_STACK_SIZE, NULL, mainTASK1_PRIORITY, NULL);
 1008974:	d8000115 	stw	zero,4(sp)
 1008978:	00800084 	movi	r2,2
 100897c:	d8800015 	stw	r2,0(sp)
 1008980:	000f883a 	mov	r7,zero
 1008984:	01810004 	movi	r6,1024
 1008988:	014040b4 	movhi	r5,258
 100898c:	296a5304 	addi	r5,r5,-22196
 1008990:	01004074 	movhi	r4,257
 1008994:	21245604 	addi	r4,r4,-28328
 1008998:	10053600 	call	1005360 <xTaskCreate>

  	vTaskStartScheduler();
 100899c:	1005ec40 	call	1005ec4 <vTaskStartScheduler>
#endif

  	while (true)
  	{
  		if (adc_busy == 0)
 10089a0:	d0a0a717 	ldw	r2,-32100(gp)
 10089a4:	10000b1e 	bne	r2,zero,10089d4 <main+0x150>
  		{
  			printf("adc = {%lu, %lu}", adc[0], adc[1]);
 10089a8:	d0a0a517 	ldw	r2,-32108(gp)
 10089ac:	d0e0a617 	ldw	r3,-32104(gp)
 10089b0:	180d883a 	mov	r6,r3
 10089b4:	100b883a 	mov	r5,r2
 10089b8:	010040b4 	movhi	r4,258
 10089bc:	212a5504 	addi	r4,r4,-22188
 10089c0:	1009c740 	call	1009c74 <printf>

  			adc_busy = 1;
 10089c4:	00800044 	movi	r2,1
 10089c8:	d0a0a715 	stw	r2,-32100(gp)
  			adc_start(MODULAR_ADC_0_SEQUENCER_CSR_BASE);
 10089cc:	0106b004 	movi	r4,6848
 10089d0:	10185000 	call	1018500 <adc_start>
  		}

#if 1
  		for (int i = 0; i < 1000; i++)
 10089d4:	e03ffe15 	stw	zero,-8(fp)
 10089d8:	00000506 	br	10089f0 <main+0x16c>
  		{
  			usleep(1000);
 10089dc:	0100fa04 	movi	r4,1000
 10089e0:	1016b6c0 	call	1016b6c <usleep>
  			adc_busy = 1;
  			adc_start(MODULAR_ADC_0_SEQUENCER_CSR_BASE);
  		}

#if 1
  		for (int i = 0; i < 1000; i++)
 10089e4:	e0bffe17 	ldw	r2,-8(fp)
 10089e8:	10800044 	addi	r2,r2,1
 10089ec:	e0bffe15 	stw	r2,-8(fp)
 10089f0:	e0bffe17 	ldw	r2,-8(fp)
 10089f4:	1080fa10 	cmplti	r2,r2,1000
 10089f8:	103ff81e 	bne	r2,zero,10089dc <__alt_data_end+0xff8089dc>
  		{
  			usleep(1000);
  		}
#endif
  	}
 10089fc:	003fe806 	br	10089a0 <__alt_data_end+0xff8089a0>

01008a00 <eth_ocm_isr>:

  	return 0;
}

static void eth_ocm_isr()
{
 1008a00:	defffd04 	addi	sp,sp,-12
 1008a04:	dfc00215 	stw	ra,8(sp)
 1008a08:	df000115 	stw	fp,4(sp)
 1008a0c:	df000104 	addi	fp,sp,4
	int result;

	result = IORD_ETH_OCM_INT_SOURCE(EMAC_BASEADDR);
 1008a10:	00802234 	movhi	r2,136
 1008a14:	10800104 	addi	r2,r2,4
 1008a18:	10800037 	ldwio	r2,0(r2)
 1008a1c:	e0bfff15 	stw	r2,-4(fp)

	IOWR_ALTERA_AVALON_PIO_DATA(PIO_0_BASE, 0x00);
 1008a20:	0007883a 	mov	r3,zero
 1008a24:	0086a804 	movi	r2,6816
 1008a28:	10c00035 	stwio	r3,0(r2)

	while (result)
 1008a2c:	00000c06 	br	1008a60 <eth_ocm_isr+0x60>
	{
		IOWR_ETH_OCM_INT_SOURCE(EMAC_BASEADDR, result);
 1008a30:	00802234 	movhi	r2,136
 1008a34:	10800104 	addi	r2,r2,4
 1008a38:	e0ffff17 	ldw	r3,-4(fp)
 1008a3c:	10c00035 	stwio	r3,0(r2)

		if (result & (ETH_OCM_INT_MASK_RXB_MSK | ETH_OCM_INT_MASK_RXE_MSK))
 1008a40:	e0bfff17 	ldw	r2,-4(fp)
 1008a44:	1080030c 	andi	r2,r2,12
 1008a48:	10000126 	beq	r2,zero,1008a50 <eth_ocm_isr+0x50>
		{
			eth_ocm_rx_isr();
 1008a4c:	1008af00 	call	1008af0 <eth_ocm_rx_isr>

		if (result & (ETH_OCM_INT_MASK_TXB_MSK | ETH_OCM_INT_MASK_TXE_MSK))
		{
		}

		result = IORD_ETH_OCM_INT_SOURCE(EMAC_BASEADDR);
 1008a50:	00802234 	movhi	r2,136
 1008a54:	10800104 	addi	r2,r2,4
 1008a58:	10800037 	ldwio	r2,0(r2)
 1008a5c:	e0bfff15 	stw	r2,-4(fp)

	result = IORD_ETH_OCM_INT_SOURCE(EMAC_BASEADDR);

	IOWR_ALTERA_AVALON_PIO_DATA(PIO_0_BASE, 0x00);

	while (result)
 1008a60:	e0bfff17 	ldw	r2,-4(fp)
 1008a64:	103ff21e 	bne	r2,zero,1008a30 <__alt_data_end+0xff808a30>
		{
		}

		result = IORD_ETH_OCM_INT_SOURCE(EMAC_BASEADDR);
	}
}
 1008a68:	0001883a 	nop
 1008a6c:	e037883a 	mov	sp,fp
 1008a70:	dfc00117 	ldw	ra,4(sp)
 1008a74:	df000017 	ldw	fp,0(sp)
 1008a78:	dec00204 	addi	sp,sp,8
 1008a7c:	f800283a 	ret

01008a80 <eth_ocm_read_init>:

static int eth_ocm_read_init()
{
 1008a80:	defffd04 	addi	sp,sp,-12
 1008a84:	dfc00215 	stw	ra,8(sp)
 1008a88:	df000115 	stw	fp,4(sp)
 1008a8c:	df000104 	addi	fp,sp,4
	alt_u8 *buf_ptr;

	buf_ptr = (alt_u8*)alt_remap_cached((volatile void*)pkt, 4);
 1008a90:	01400104 	movi	r5,4
 1008a94:	01005cf4 	movhi	r4,371
 1008a98:	2129e104 	addi	r4,r4,-22652
 1008a9c:	1016a880 	call	1016a88 <alt_remap_cached>
 1008aa0:	e0bfff15 	stw	r2,-4(fp)
	buf_ptr = (alt_u8*)(((unsigned int)buf_ptr) + ETHHDR_BIAS);

	if (!(IORD_ETH_OCM_DESC_CTRL(EMAC_BASEADDR, 1) & ETH_OCM_RXDESC_EMPTY_MSK))
 1008aa4:	00802234 	movhi	r2,136
 1008aa8:	10810204 	addi	r2,r2,1032
 1008aac:	10800037 	ldwio	r2,0(r2)
 1008ab0:	10a0000c 	andi	r2,r2,32768
 1008ab4:	1000081e 	bne	r2,zero,1008ad8 <eth_ocm_read_init+0x58>
	{
#if 1
		IOWR_ETH_OCM_DESC_PTR(EMAC_BASEADDR, 1, (alt_u32)buf_ptr);
 1008ab8:	e0ffff17 	ldw	r3,-4(fp)
 1008abc:	00802234 	movhi	r2,136
 1008ac0:	10810304 	addi	r2,r2,1036
 1008ac4:	10c00035 	stwio	r3,0(r2)
		IOWR_ETH_OCM_DESC_CTRL(EMAC_BASEADDR, 1, ETH_OCM_RXDESC_EMPTY_MSK |
 1008ac8:	00f80014 	movui	r3,57344
 1008acc:	00802234 	movhi	r2,136
 1008ad0:	10810204 	addi	r2,r2,1032
 1008ad4:	10c00035 	stwio	r3,0(r2)
												  ETH_OCM_RXDESC_IRQ_MSK |
												  ETH_OCM_RXDESC_WRAP_MSK);
#endif
	}

	return 0;
 1008ad8:	0005883a 	mov	r2,zero
}
 1008adc:	e037883a 	mov	sp,fp
 1008ae0:	dfc00117 	ldw	ra,4(sp)
 1008ae4:	df000017 	ldw	fp,0(sp)
 1008ae8:	dec00204 	addi	sp,sp,8
 1008aec:	f800283a 	ret

01008af0 <eth_ocm_rx_isr>:

static int eth_ocm_rx_isr()
{
 1008af0:	defffb04 	addi	sp,sp,-20
 1008af4:	dfc00415 	stw	ra,16(sp)
 1008af8:	df000315 	stw	fp,12(sp)
 1008afc:	df000304 	addi	fp,sp,12
	alt_u32 stat;
	alt_u8 *buf_ptr;
	int pklen;

	stat = IORD_ETH_OCM_DESC_CTRL(EMAC_BASEADDR, 1);
 1008b00:	00802234 	movhi	r2,136
 1008b04:	10810204 	addi	r2,r2,1032
 1008b08:	10800037 	ldwio	r2,0(r2)
 1008b0c:	e0bffd15 	stw	r2,-12(fp)
	while (!(stat & ETH_OCM_RXDESC_EMPTY_MSK))
 1008b10:	00001f06 	br	1008b90 <eth_ocm_rx_isr+0xa0>
	{
		pklen = stat & ETH_OCM_RXDESC_LEN_MSK;
 1008b14:	e0bffd17 	ldw	r2,-12(fp)
 1008b18:	10bfffec 	andhi	r2,r2,65535
 1008b1c:	e0bffe15 	stw	r2,-8(fp)
		pklen = pklen >> ETH_OCM_RXDESC_LEN_OFST;
 1008b20:	e0bffe17 	ldw	r2,-8(fp)
 1008b24:	1005d43a 	srai	r2,r2,16
 1008b28:	e0bffe15 	stw	r2,-8(fp)

		if (pklen < 1550)
 1008b2c:	e0bffe17 	ldw	r2,-8(fp)
 1008b30:	10818388 	cmpgei	r2,r2,1550
 1008b34:	1000051e 	bne	r2,zero,1008b4c <eth_ocm_rx_isr+0x5c>
		{
			if (!(stat & ETH_OCM_RXDESC_ERROR_MSK))
 1008b38:	e0bffd17 	ldw	r2,-12(fp)
 1008b3c:	10801fcc 	andi	r2,r2,127
 1008b40:	1000021e 	bne	r2,zero,1008b4c <eth_ocm_rx_isr+0x5c>
			{
				start = 1;
 1008b44:	00800044 	movi	r2,1
 1008b48:	d0a09e85 	stb	r2,-32134(gp)
			}
		}

		buf_ptr = (alt_u8*)alt_remap_cached((volatile void*)pkt, 4);
 1008b4c:	01400104 	movi	r5,4
 1008b50:	01005cf4 	movhi	r4,371
 1008b54:	2129e104 	addi	r4,r4,-22652
 1008b58:	1016a880 	call	1016a88 <alt_remap_cached>
 1008b5c:	e0bfff15 	stw	r2,-4(fp)
		buf_ptr = (alt_u8*)(((unsigned int)buf_ptr) + ETHHDR_BIAS);
		IOWR_ETH_OCM_DESC_PTR(EMAC_BASEADDR, 1, (alt_u32)buf_ptr);
 1008b60:	e0ffff17 	ldw	r3,-4(fp)
 1008b64:	00802234 	movhi	r2,136
 1008b68:	10810304 	addi	r2,r2,1036
 1008b6c:	10c00035 	stwio	r3,0(r2)
		IOWR_ETH_OCM_DESC_CTRL(EMAC_BASEADDR, 1, ETH_OCM_RXDESC_EMPTY_MSK |
 1008b70:	00f80014 	movui	r3,57344
 1008b74:	00802234 	movhi	r2,136
 1008b78:	10810204 	addi	r2,r2,1032
 1008b7c:	10c00035 	stwio	r3,0(r2)
												  ETH_OCM_RXDESC_IRQ_MSK |
												  ETH_OCM_RXDESC_WRAP_MSK);
		stat = IORD_ETH_OCM_DESC_CTRL(EMAC_BASEADDR, 1);
 1008b80:	00802234 	movhi	r2,136
 1008b84:	10810204 	addi	r2,r2,1032
 1008b88:	10800037 	ldwio	r2,0(r2)
 1008b8c:	e0bffd15 	stw	r2,-12(fp)
	alt_u32 stat;
	alt_u8 *buf_ptr;
	int pklen;

	stat = IORD_ETH_OCM_DESC_CTRL(EMAC_BASEADDR, 1);
	while (!(stat & ETH_OCM_RXDESC_EMPTY_MSK))
 1008b90:	e0bffd17 	ldw	r2,-12(fp)
 1008b94:	10a0000c 	andi	r2,r2,32768
 1008b98:	103fde26 	beq	r2,zero,1008b14 <__alt_data_end+0xff808b14>
												  ETH_OCM_RXDESC_IRQ_MSK |
												  ETH_OCM_RXDESC_WRAP_MSK);
		stat = IORD_ETH_OCM_DESC_CTRL(EMAC_BASEADDR, 1);
	}

	return 0;
 1008b9c:	0005883a 	mov	r2,zero
}
 1008ba0:	e037883a 	mov	sp,fp
 1008ba4:	dfc00117 	ldw	ra,4(sp)
 1008ba8:	df000017 	ldw	fp,0(sp)
 1008bac:	dec00204 	addi	sp,sp,8
 1008bb0:	f800283a 	ret

01008bb4 <eth_ocm_set_phy_addr>:

void eth_ocm_set_phy_addr(int base, int phyad, int reg)
{
 1008bb4:	defffb04 	addi	sp,sp,-20
 1008bb8:	dfc00415 	stw	ra,16(sp)
 1008bbc:	df000315 	stw	fp,12(sp)
 1008bc0:	df000304 	addi	fp,sp,12
 1008bc4:	e13ffd15 	stw	r4,-12(fp)
 1008bc8:	e17ffe15 	stw	r5,-8(fp)
 1008bcc:	e1bfff15 	stw	r6,-4(fp)
	phyad = (phyad & ETH_OCM_MIIADDRESS_FIAD_MSK) | ((reg << ETH_OCM_MIIADDRESS_RGAD_OFST) & ETH_OCM_MIIADDRESS_RGAD_MSK);
 1008bd0:	e0bffe17 	ldw	r2,-8(fp)
 1008bd4:	10c007cc 	andi	r3,r2,31
 1008bd8:	e0bfff17 	ldw	r2,-4(fp)
 1008bdc:	1004923a 	slli	r2,r2,8
 1008be0:	1087c00c 	andi	r2,r2,7936
 1008be4:	1884b03a 	or	r2,r3,r2
 1008be8:	e0bffe15 	stw	r2,-8(fp)
	phyad &= ETH_OCM_MIIADDRESS_FIAD_MSK;
	reg = reg << ETH_OCM_MIIADDRESS_RGAD_OFST;
	reg &= ETH_OCM_MIIADDRESS_RGAD_MSK;
	phyad |= reg;
#endif
	printf("phyad = %x", phyad);
 1008bec:	e17ffe17 	ldw	r5,-8(fp)
 1008bf0:	010040b4 	movhi	r4,258
 1008bf4:	212a5a04 	addi	r4,r4,-22168
 1008bf8:	1009c740 	call	1009c74 <printf>
	IOWR_ETH_OCM_MIIADDRESS(base, phyad);
 1008bfc:	e0bffd17 	ldw	r2,-12(fp)
 1008c00:	10800c04 	addi	r2,r2,48
 1008c04:	1007883a 	mov	r3,r2
 1008c08:	e0bffe17 	ldw	r2,-8(fp)
 1008c0c:	18800035 	stwio	r2,0(r3)
}
 1008c10:	0001883a 	nop
 1008c14:	e037883a 	mov	sp,fp
 1008c18:	dfc00117 	ldw	ra,4(sp)
 1008c1c:	df000017 	ldw	fp,0(sp)
 1008c20:	dec00204 	addi	sp,sp,8
 1008c24:	f800283a 	ret

01008c28 <eth_ocm_write_phy_reg>:

void eth_ocm_write_phy_reg(int base, int phyad, int reg, int data)
{
 1008c28:	defffa04 	addi	sp,sp,-24
 1008c2c:	dfc00515 	stw	ra,20(sp)
 1008c30:	df000415 	stw	fp,16(sp)
 1008c34:	df000404 	addi	fp,sp,16
 1008c38:	e13ffc15 	stw	r4,-16(fp)
 1008c3c:	e17ffd15 	stw	r5,-12(fp)
 1008c40:	e1bffe15 	stw	r6,-8(fp)
 1008c44:	e1ffff15 	stw	r7,-4(fp)
	eth_ocm_set_phy_addr(base, phyad, reg);
 1008c48:	e1bffe17 	ldw	r6,-8(fp)
 1008c4c:	e17ffd17 	ldw	r5,-12(fp)
 1008c50:	e13ffc17 	ldw	r4,-16(fp)
 1008c54:	1008bb40 	call	1008bb4 <eth_ocm_set_phy_addr>
	IOWR_ETH_OCM_MIITX_DATA(base, data);
 1008c58:	e0bffc17 	ldw	r2,-16(fp)
 1008c5c:	10800d04 	addi	r2,r2,52
 1008c60:	1007883a 	mov	r3,r2
 1008c64:	e0bfff17 	ldw	r2,-4(fp)
 1008c68:	18800035 	stwio	r2,0(r3)
	IOWR_ETH_OCM_MIICOMMAND(base, ETH_OCM_MIICOMMAND_WCTRLDATA_MSK);
 1008c6c:	e0bffc17 	ldw	r2,-16(fp)
 1008c70:	10800b04 	addi	r2,r2,44
 1008c74:	1007883a 	mov	r3,r2
 1008c78:	00800104 	movi	r2,4
 1008c7c:	18800035 	stwio	r2,0(r3)
	eth_ocm_wait(base);
 1008c80:	e13ffc17 	ldw	r4,-16(fp)
 1008c84:	1008d1c0 	call	1008d1c <eth_ocm_wait>
}
 1008c88:	0001883a 	nop
 1008c8c:	e037883a 	mov	sp,fp
 1008c90:	dfc00117 	ldw	ra,4(sp)
 1008c94:	df000017 	ldw	fp,0(sp)
 1008c98:	dec00204 	addi	sp,sp,8
 1008c9c:	f800283a 	ret

01008ca0 <eth_ocm_read_phy_reg>:

int eth_ocm_read_phy_reg(int base, int phyad, int reg)
{
 1008ca0:	defff904 	addi	sp,sp,-28
 1008ca4:	dfc00615 	stw	ra,24(sp)
 1008ca8:	df000515 	stw	fp,20(sp)
 1008cac:	df000504 	addi	fp,sp,20
 1008cb0:	e13ffd15 	stw	r4,-12(fp)
 1008cb4:	e17ffe15 	stw	r5,-8(fp)
 1008cb8:	e1bfff15 	stw	r6,-4(fp)
	int result;
	int err = 1;
 1008cbc:	00800044 	movi	r2,1
 1008cc0:	e0bffb15 	stw	r2,-20(fp)

	eth_ocm_set_phy_addr(base, phyad, reg);
 1008cc4:	e1bfff17 	ldw	r6,-4(fp)
 1008cc8:	e17ffe17 	ldw	r5,-8(fp)
 1008ccc:	e13ffd17 	ldw	r4,-12(fp)
 1008cd0:	1008bb40 	call	1008bb4 <eth_ocm_set_phy_addr>
	IOWR_ETH_OCM_MIICOMMAND(base, ETH_OCM_MIICOMMAND_RSTAT_MSK);
 1008cd4:	e0bffd17 	ldw	r2,-12(fp)
 1008cd8:	10800b04 	addi	r2,r2,44
 1008cdc:	1007883a 	mov	r3,r2
 1008ce0:	00800084 	movi	r2,2
 1008ce4:	18800035 	stwio	r2,0(r3)
	err = eth_ocm_wait(base);
 1008ce8:	e13ffd17 	ldw	r4,-12(fp)
 1008cec:	1008d1c0 	call	1008d1c <eth_ocm_wait>
 1008cf0:	e0bffb15 	stw	r2,-20(fp)
	result = IORD_ETH_OCM_MIIRX_DATA(base);
 1008cf4:	e0bffd17 	ldw	r2,-12(fp)
 1008cf8:	10800e04 	addi	r2,r2,56
 1008cfc:	10800037 	ldwio	r2,0(r2)
 1008d00:	e0bffc15 	stw	r2,-16(fp)

	return result;
 1008d04:	e0bffc17 	ldw	r2,-16(fp)
}
 1008d08:	e037883a 	mov	sp,fp
 1008d0c:	dfc00117 	ldw	ra,4(sp)
 1008d10:	df000017 	ldw	fp,0(sp)
 1008d14:	dec00204 	addi	sp,sp,8
 1008d18:	f800283a 	ret

01008d1c <eth_ocm_wait>:

static int eth_ocm_wait(int base){
 1008d1c:	defffc04 	addi	sp,sp,-16
 1008d20:	df000315 	stw	fp,12(sp)
 1008d24:	df000304 	addi	fp,sp,12
 1008d28:	e13fff15 	stw	r4,-4(fp)
    int temp = 1;
 1008d2c:	00800044 	movi	r2,1
 1008d30:	e0bffd15 	stw	r2,-12(fp)
    int i = 0;
 1008d34:	e03ffe15 	stw	zero,-8(fp)

    while (temp && i < 1000)
 1008d38:	00000806 	br	1008d5c <eth_ocm_wait+0x40>
    {
        temp = IORD_ETH_OCM_MIISTATUS(base) & ETH_OCM_MIISTATUS_BUSY_MSK;
 1008d3c:	e0bfff17 	ldw	r2,-4(fp)
 1008d40:	10800f04 	addi	r2,r2,60
 1008d44:	10800037 	ldwio	r2,0(r2)
 1008d48:	1080008c 	andi	r2,r2,2
 1008d4c:	e0bffd15 	stw	r2,-12(fp)
        i++;
 1008d50:	e0bffe17 	ldw	r2,-8(fp)
 1008d54:	10800044 	addi	r2,r2,1
 1008d58:	e0bffe15 	stw	r2,-8(fp)

static int eth_ocm_wait(int base){
    int temp = 1;
    int i = 0;

    while (temp && i < 1000)
 1008d5c:	e0bffd17 	ldw	r2,-12(fp)
 1008d60:	10000326 	beq	r2,zero,1008d70 <eth_ocm_wait+0x54>
 1008d64:	e0bffe17 	ldw	r2,-8(fp)
 1008d68:	1080fa10 	cmplti	r2,r2,1000
 1008d6c:	103ff31e 	bne	r2,zero,1008d3c <__alt_data_end+0xff808d3c>
    {
        temp = IORD_ETH_OCM_MIISTATUS(base) & ETH_OCM_MIISTATUS_BUSY_MSK;
        i++;
    }

    return temp;
 1008d70:	e0bffd17 	ldw	r2,-12(fp)
}
 1008d74:	e037883a 	mov	sp,fp
 1008d78:	df000017 	ldw	fp,0(sp)
 1008d7c:	dec00104 	addi	sp,sp,4
 1008d80:	f800283a 	ret

01008d84 <init_MAC>:

int init_MAC()
{
 1008d84:	defff404 	addi	sp,sp,-48
 1008d88:	dfc00b15 	stw	ra,44(sp)
 1008d8c:	df000a15 	stw	fp,40(sp)
 1008d90:	df000a04 	addi	fp,sp,40
	uint32_t tmp0 = 0x0;
 1008d94:	e03ff915 	stw	zero,-28(fp)
	uint32_t tmp1 = 0x0;
 1008d98:	e03ffa15 	stw	zero,-24(fp)

	int phyid = 0;
 1008d9c:	e03ffb15 	stw	zero,-20(fp)
	int phyid2 = 0;
 1008da0:	e03ffc15 	stw	zero,-16(fp)
		eth_ocm_write_phy_reg(ETH_OCM_0_BASE, PHY_ADR, 0x0, 0xB300);
		usleep(10000);
	}
#endif

	IOWR_ETH_OCM_MIIMODER(EMAC_BASEADDR, 0x200);
 1008da4:	00c08004 	movi	r3,512
 1008da8:	00802234 	movhi	r2,136
 1008dac:	10800a04 	addi	r2,r2,40
 1008db0:	10c00035 	stwio	r3,0(r2)
	IOWR_ETH_OCM_MIIMODER(EMAC_BASEADDR, 0x000);
 1008db4:	0007883a 	mov	r3,zero
 1008db8:	00802234 	movhi	r2,136
 1008dbc:	10800a04 	addi	r2,r2,40
 1008dc0:	10c00035 	stwio	r3,0(r2)
	IOWR_ETH_OCM_MIIMODER(EMAC_BASEADDR, 0x064);
 1008dc4:	00c01904 	movi	r3,100
 1008dc8:	00802234 	movhi	r2,136
 1008dcc:	10800a04 	addi	r2,r2,40
 1008dd0:	10c00035 	stwio	r3,0(r2)

	do {
		tmp0 = IORD_ETH_OCM_MIIMODER(EMAC_BASEADDR);
 1008dd4:	00802234 	movhi	r2,136
 1008dd8:	10800a04 	addi	r2,r2,40
 1008ddc:	10800037 	ldwio	r2,0(r2)
 1008de0:	e0bff915 	stw	r2,-28(fp)
	} while (tmp0 == 0);
 1008de4:	e0bff917 	ldw	r2,-28(fp)
 1008de8:	103ffa26 	beq	r2,zero,1008dd4 <__alt_data_end+0xff808dd4>

	phyid = eth_ocm_read_phy_reg(EMAC_BASEADDR, 0, ETH_OCM_PHY_ADDR_PHY_ID1);
 1008dec:	01800084 	movi	r6,2
 1008df0:	000b883a 	mov	r5,zero
 1008df4:	01002234 	movhi	r4,136
 1008df8:	1008ca00 	call	1008ca0 <eth_ocm_read_phy_reg>
 1008dfc:	e0bffb15 	stw	r2,-20(fp)
	for (int dat = 0; dat < 0xFF; dat++)
 1008e00:	e03ff715 	stw	zero,-36(fp)
 1008e04:	00003a06 	br	1008ef0 <init_MAC+0x16c>
	{
		phyid = eth_ocm_read_phy_reg(EMAC_BASEADDR, dat, ETH_OCM_PHY_ADDR_PHY_ID1);
 1008e08:	01800084 	movi	r6,2
 1008e0c:	e17ff717 	ldw	r5,-36(fp)
 1008e10:	01002234 	movhi	r4,136
 1008e14:	1008ca00 	call	1008ca0 <eth_ocm_read_phy_reg>
 1008e18:	e0bffb15 	stw	r2,-20(fp)
		phyid2 = eth_ocm_read_phy_reg(EMAC_BASEADDR, dat, ETH_OCM_PHY_ADDR_PHY_ID2);
 1008e1c:	018000c4 	movi	r6,3
 1008e20:	e17ff717 	ldw	r5,-36(fp)
 1008e24:	01002234 	movhi	r4,136
 1008e28:	1008ca00 	call	1008ca0 <eth_ocm_read_phy_reg>
 1008e2c:	e0bffc15 	stw	r2,-16(fp)

		if (phyid != phyid2 && (phyid2 != 0xffff)){
 1008e30:	e0fffb17 	ldw	r3,-20(fp)
 1008e34:	e0bffc17 	ldw	r2,-16(fp)
 1008e38:	18802a26 	beq	r3,r2,1008ee4 <init_MAC+0x160>
 1008e3c:	e0fffc17 	ldw	r3,-16(fp)
 1008e40:	00bfffd4 	movui	r2,65535
 1008e44:	18802726 	beq	r3,r2,1008ee4 <init_MAC+0x160>
			phy_adr = dat;
 1008e48:	e0bff717 	ldw	r2,-36(fp)
 1008e4c:	d0a09f15 	stw	r2,-32132(gp)

			printf("phyid1 = %x %d\n", phyid, phyid);
 1008e50:	e1bffb17 	ldw	r6,-20(fp)
 1008e54:	e17ffb17 	ldw	r5,-20(fp)
 1008e58:	010040b4 	movhi	r4,258
 1008e5c:	212a5d04 	addi	r4,r4,-22156
 1008e60:	1009c740 	call	1009c74 <printf>
			printf("phyid2 = %x %d\n", phyid2, phyid2);
 1008e64:	e1bffc17 	ldw	r6,-16(fp)
 1008e68:	e17ffc17 	ldw	r5,-16(fp)
 1008e6c:	010040b4 	movhi	r4,258
 1008e70:	212a6104 	addi	r4,r4,-22140
 1008e74:	1009c740 	call	1009c74 <printf>
			printf("\n");
 1008e78:	01000284 	movi	r4,10
 1008e7c:	1009cb80 	call	1009cb8 <putchar>

			int oui = phyid << 6;
 1008e80:	e0bffb17 	ldw	r2,-20(fp)
 1008e84:	100491ba 	slli	r2,r2,6
 1008e88:	e0bffd15 	stw	r2,-12(fp)
			oui |= ((phyid2 >> 10) & 0x003F);
 1008e8c:	e0bffc17 	ldw	r2,-16(fp)
 1008e90:	1005d2ba 	srai	r2,r2,10
 1008e94:	10800fcc 	andi	r2,r2,63
 1008e98:	e0fffd17 	ldw	r3,-12(fp)
 1008e9c:	1884b03a 	or	r2,r3,r2
 1008ea0:	e0bffd15 	stw	r2,-12(fp)
			int mdl = ((phyid2 >> 4) & 0x03F);
 1008ea4:	e0bffc17 	ldw	r2,-16(fp)
 1008ea8:	1005d13a 	srai	r2,r2,4
 1008eac:	10800fcc 	andi	r2,r2,63
 1008eb0:	e0bffe15 	stw	r2,-8(fp)
			int rev = (phyid2 & 0x00F);
 1008eb4:	e0bffc17 	ldw	r2,-16(fp)
 1008eb8:	108003cc 	andi	r2,r2,15
 1008ebc:	e0bfff15 	stw	r2,-4(fp)

			printf("[eth_ocm_phy_init] Found PHY:\n"
 1008ec0:	e0bfff17 	ldw	r2,-4(fp)
 1008ec4:	d8800015 	stw	r2,0(sp)
 1008ec8:	e1fffe17 	ldw	r7,-8(fp)
 1008ecc:	e1bffd17 	ldw	r6,-12(fp)
 1008ed0:	e17ff717 	ldw	r5,-36(fp)
 1008ed4:	010040b4 	movhi	r4,258
 1008ed8:	212a6504 	addi	r4,r4,-22124
 1008edc:	1009c740 	call	1009c74 <printf>
					"  Address: 0x0%X\n"
					"  OUI: 0x%X\n"
					"  Model: 0x%X\n"
					"  Rev: 0x%X\n", dat, oui, mdl, rev);

			break;
 1008ee0:	00000606 	br	1008efc <init_MAC+0x178>
	do {
		tmp0 = IORD_ETH_OCM_MIIMODER(EMAC_BASEADDR);
	} while (tmp0 == 0);

	phyid = eth_ocm_read_phy_reg(EMAC_BASEADDR, 0, ETH_OCM_PHY_ADDR_PHY_ID1);
	for (int dat = 0; dat < 0xFF; dat++)
 1008ee4:	e0bff717 	ldw	r2,-36(fp)
 1008ee8:	10800044 	addi	r2,r2,1
 1008eec:	e0bff715 	stw	r2,-36(fp)
 1008ef0:	e0bff717 	ldw	r2,-36(fp)
 1008ef4:	10803fd0 	cmplti	r2,r2,255
 1008ef8:	103fc31e 	bne	r2,zero,1008e08 <__alt_data_end+0xff808e08>
					"  Rev: 0x%X\n", dat, oui, mdl, rev);

			break;
		}
	}
	printf("search completed.");
 1008efc:	010040b4 	movhi	r4,258
 1008f00:	212a7b04 	addi	r4,r4,-22036
 1008f04:	1009c740 	call	1009c74 <printf>

	tmp0 = eth_ocm_read_phy_reg(EMAC_BASEADDR, phy_adr, 0x01);
 1008f08:	d0a09f17 	ldw	r2,-32132(gp)
 1008f0c:	01800044 	movi	r6,1
 1008f10:	100b883a 	mov	r5,r2
 1008f14:	01002234 	movhi	r4,136
 1008f18:	1008ca00 	call	1008ca0 <eth_ocm_read_phy_reg>
 1008f1c:	e0bff915 	stw	r2,-28(fp)
	//while ((tmp0 & 0x04) == 0)
	//{
		eth_ocm_write_phy_reg(EMAC_BASEADDR, phy_adr, 0x00, 0xB300);
 1008f20:	d0a09f17 	ldw	r2,-32132(gp)
 1008f24:	01ecc014 	movui	r7,45824
 1008f28:	000d883a 	mov	r6,zero
 1008f2c:	100b883a 	mov	r5,r2
 1008f30:	01002234 	movhi	r4,136
 1008f34:	1008c280 	call	1008c28 <eth_ocm_write_phy_reg>
	//	tmp0 = eth_ocm_read_phy_reg(ETH_OCM_0_BASE, phy_adr, 0x01);
	//	usleep(1000000);
	//}

	do {
		tmp0 = IORD_ETH_OCM_MIISTATUS(EMAC_BASEADDR) & 0x2;
 1008f38:	00802234 	movhi	r2,136
 1008f3c:	10800f04 	addi	r2,r2,60
 1008f40:	10800037 	ldwio	r2,0(r2)
 1008f44:	1080008c 	andi	r2,r2,2
 1008f48:	e0bff915 	stw	r2,-28(fp)
		printf("writing... %lx\n", tmp0);
 1008f4c:	e17ff917 	ldw	r5,-28(fp)
 1008f50:	010040b4 	movhi	r4,258
 1008f54:	212a8004 	addi	r4,r4,-22016
 1008f58:	1009c740 	call	1009c74 <printf>
	} while (tmp0 != 0);
 1008f5c:	e0bff917 	ldw	r2,-28(fp)
 1008f60:	103ff51e 	bne	r2,zero,1008f38 <__alt_data_end+0xff808f38>
	printf("MDIO write\n");
 1008f64:	010040b4 	movhi	r4,258
 1008f68:	212a8404 	addi	r4,r4,-22000
 1008f6c:	1009d900 	call	1009d90 <puts>
	printf("\n");
 1008f70:	01000284 	movi	r4,10
 1008f74:	1009cb80 	call	1009cb8 <putchar>

	IOWR_ETH_OCM_MIIADDRESS(EMAC_BASEADDR, phy_adr | 0x100);
 1008f78:	d0a09f17 	ldw	r2,-32132(gp)
 1008f7c:	10c04014 	ori	r3,r2,256
 1008f80:	00802234 	movhi	r2,136
 1008f84:	10800c04 	addi	r2,r2,48
 1008f88:	10c00035 	stwio	r3,0(r2)
	IOWR_ETH_OCM_MIICOMMAND(EMAC_BASEADDR, 0x2);
 1008f8c:	00c00084 	movi	r3,2
 1008f90:	00802234 	movhi	r2,136
 1008f94:	10800b04 	addi	r2,r2,44
 1008f98:	10c00035 	stwio	r3,0(r2)

	do {
		tmp0 = IORD_ETH_OCM_MIISTATUS(EMAC_BASEADDR) & 0x2;
 1008f9c:	00802234 	movhi	r2,136
 1008fa0:	10800f04 	addi	r2,r2,60
 1008fa4:	10800037 	ldwio	r2,0(r2)
 1008fa8:	1080008c 	andi	r2,r2,2
 1008fac:	e0bff915 	stw	r2,-28(fp)
	} while (tmp0 != 0);
 1008fb0:	e0bff917 	ldw	r2,-28(fp)
 1008fb4:	103ff91e 	bne	r2,zero,1008f9c <__alt_data_end+0xff808f9c>

	printf("MDIO read status = ");
 1008fb8:	010040b4 	movhi	r4,258
 1008fbc:	212a8704 	addi	r4,r4,-21988
 1008fc0:	1009c740 	call	1009c74 <printf>
	tmp0 = IORD_ETH_OCM_MIIRX_DATA(EMAC_BASEADDR);
 1008fc4:	00802234 	movhi	r2,136
 1008fc8:	10800e04 	addi	r2,r2,56
 1008fcc:	10800037 	ldwio	r2,0(r2)
 1008fd0:	e0bff915 	stw	r2,-28(fp)
	printf("%lx\n", tmp0);
 1008fd4:	e17ff917 	ldw	r5,-28(fp)
 1008fd8:	010040b4 	movhi	r4,258
 1008fdc:	212a8c04 	addi	r4,r4,-21968
 1008fe0:	1009c740 	call	1009c74 <printf>
	printf("\n");
 1008fe4:	01000284 	movi	r4,10
 1008fe8:	1009cb80 	call	1009cb8 <putchar>

	for (int i = ETH_OCM_DESC_START; i < ETH_OCM_DESC_END; i++) {
 1008fec:	00804004 	movi	r2,256
 1008ff0:	e0bff815 	stw	r2,-32(fp)
 1008ff4:	00000b06 	br	1009024 <init_MAC+0x2a0>
		IOWR(EMAC_BASEADDR, i, 0);
 1008ff8:	e0bff817 	ldw	r2,-32(fp)
 1008ffc:	1085883a 	add	r2,r2,r2
 1009000:	1085883a 	add	r2,r2,r2
 1009004:	1007883a 	mov	r3,r2
 1009008:	00802234 	movhi	r2,136
 100900c:	1885883a 	add	r2,r3,r2
 1009010:	0007883a 	mov	r3,zero
 1009014:	10c00035 	stwio	r3,0(r2)
	printf("MDIO read status = ");
	tmp0 = IORD_ETH_OCM_MIIRX_DATA(EMAC_BASEADDR);
	printf("%lx\n", tmp0);
	printf("\n");

	for (int i = ETH_OCM_DESC_START; i < ETH_OCM_DESC_END; i++) {
 1009018:	e0bff817 	ldw	r2,-32(fp)
 100901c:	10800044 	addi	r2,r2,1
 1009020:	e0bff815 	stw	r2,-32(fp)
 1009024:	e0bff817 	ldw	r2,-32(fp)
 1009028:	10807fd0 	cmplti	r2,r2,511
 100902c:	103ff21e 	bne	r2,zero,1008ff8 <__alt_data_end+0xff808ff8>
		IOWR(EMAC_BASEADDR, i, 0);
	}
	IOWR_ETH_OCM_MODER(EMAC_BASEADDR, 0);
 1009030:	0007883a 	mov	r3,zero
 1009034:	00802234 	movhi	r2,136
 1009038:	10c00035 	stwio	r3,0(r2)
	//IOWR_ETH_OCM_TX_BD_NUM(ETH_OCM_0_BASE, 0x40);
	IOWR_ETH_OCM_TX_BD_NUM(EMAC_BASEADDR, 1);
 100903c:	00c00044 	movi	r3,1
 1009040:	00802234 	movhi	r2,136
 1009044:	10800804 	addi	r2,r2,32
 1009048:	10c00035 	stwio	r3,0(r2)

	IOWR_ETH_OCM_INT_MASK(EMAC_BASEADDR, 0x0000007F);
 100904c:	00c01fc4 	movi	r3,127
 1009050:	00802234 	movhi	r2,136
 1009054:	10800204 	addi	r2,r2,8
 1009058:	10c00035 	stwio	r3,0(r2)
	tmp1 = IORD_ETH_OCM_INT_MASK(EMAC_BASEADDR);
 100905c:	00802234 	movhi	r2,136
 1009060:	10800204 	addi	r2,r2,8
 1009064:	10800037 	ldwio	r2,0(r2)
 1009068:	e0bffa15 	stw	r2,-24(fp)
	IOWR_ETH_OCM_INT_SOURCE(EMAC_BASEADDR, 0x0000007F);
 100906c:	00c01fc4 	movi	r3,127
 1009070:	00802234 	movhi	r2,136
 1009074:	10800104 	addi	r2,r2,4
 1009078:	10c00035 	stwio	r3,0(r2)
	tmp1 = IORD_ETH_OCM_INT_SOURCE(EMAC_BASEADDR);
 100907c:	00802234 	movhi	r2,136
 1009080:	10800104 	addi	r2,r2,4
 1009084:	10800037 	ldwio	r2,0(r2)
 1009088:	e0bffa15 	stw	r2,-24(fp)
	IOWR_ETH_OCM_IPGT(EMAC_BASEADDR, 0x15); // 0x12
 100908c:	00c00544 	movi	r3,21
 1009090:	00802234 	movhi	r2,136
 1009094:	10800304 	addi	r2,r2,12
 1009098:	10c00035 	stwio	r3,0(r2)
	IOWR_ETH_OCM_IPGR1(EMAC_BASEADDR, 0x0000000C);
 100909c:	00c00304 	movi	r3,12
 10090a0:	00802234 	movhi	r2,136
 10090a4:	10800404 	addi	r2,r2,16
 10090a8:	10c00035 	stwio	r3,0(r2)
	IOWR_ETH_OCM_IPGR2(EMAC_BASEADDR, 0x00000012);
 10090ac:	00c00484 	movi	r3,18
 10090b0:	00802234 	movhi	r2,136
 10090b4:	10800504 	addi	r2,r2,20
 10090b8:	10c00035 	stwio	r3,0(r2)
	IOWR_ETH_OCM_PACKETLEN(EMAC_BASEADDR, 0x00400600);
 10090bc:	00c01034 	movhi	r3,64
 10090c0:	18c18004 	addi	r3,r3,1536
 10090c4:	00802234 	movhi	r2,136
 10090c8:	10800604 	addi	r2,r2,24
 10090cc:	10c00035 	stwio	r3,0(r2)
	IOWR_ETH_OCM_COLLCONF(EMAC_BASEADDR, 0x000F003F);
 10090d0:	00c003f4 	movhi	r3,15
 10090d4:	18c00fc4 	addi	r3,r3,63
 10090d8:	00802234 	movhi	r2,136
 10090dc:	10800704 	addi	r2,r2,28
 10090e0:	10c00035 	stwio	r3,0(r2)
	IOWR_ETH_OCM_CTRLMODER(EMAC_BASEADDR, 0x0);
 10090e4:	0007883a 	mov	r3,zero
 10090e8:	00802234 	movhi	r2,136
 10090ec:	10800904 	addi	r2,r2,36
 10090f0:	10c00035 	stwio	r3,0(r2)

	IOWR_ETH_OCM_MAC_ADDR1(EMAC_BASEADDR, ETH_MACADDR0 << 8 | ETH_MACADDR1);
 10090f4:	00dc2cc4 	movi	r3,28851
 10090f8:	00802234 	movhi	r2,136
 10090fc:	10801104 	addi	r2,r2,68
 1009100:	10c00035 	stwio	r3,0(r2)
	IOWR_ETH_OCM_MAC_ADDR0(EMAC_BASEADDR, ETH_MACADDR2 << 24 | ETH_MACADDR3 << 16 | ETH_MACADDR4 << 8 | ETH_MACADDR5);
 1009104:	00f57834 	movhi	r3,54752
 1009108:	18ec0004 	addi	r3,r3,-20480
 100910c:	00802234 	movhi	r2,136
 1009110:	10801004 	addi	r2,r2,64
 1009114:	10c00035 	stwio	r3,0(r2)

	IOWR_ETH_OCM_MODER(EMAC_BASEADDR, ETH_OCM_MODER_PAD_MSK |
 1009118:	00e908d4 	movui	r3,42019
 100911c:	00802234 	movhi	r2,136
 1009120:	10c00035 	stwio	r3,0(r2)
									  ETH_OCM_MODER_CRCEN_MSK |
									  ETH_OCM_MODER_RXEN_MSK |
									  ETH_OCM_MODER_TXEN_MSK |
									  ETH_OCM_MODER_FULLD_MSK);

	tmp1 = alt_irq_register(ETH_OCM_0_IRQ, ETH_OCM_0_BASE, eth_ocm_isr);
 1009124:	01804074 	movhi	r6,257
 1009128:	31a28004 	addi	r6,r6,-30208
 100912c:	01402234 	movhi	r5,136
 1009130:	0009883a 	mov	r4,zero
 1009134:	1003ce40 	call	1003ce4 <alt_irq_register>
 1009138:	e0bffa15 	stw	r2,-24(fp)
	//xTaskCreate(eth_ocm_isr, "Task2", configMINIMAL_STACK_SIZE, NULL, mainTASK2_PRIORITY, NULL);

	eth_ocm_read_init();
 100913c:	1008a800 	call	1008a80 <eth_ocm_read_init>
	printf("MDIO read status = ");
	tmp0 = IORD_ETH_OCM_MIIRX_DATA(EMAC_BASEADDR);
	printf("%lx\n", tmp0);
	printf("\n");
#endif
}
 1009140:	0001883a 	nop
 1009144:	e037883a 	mov	sp,fp
 1009148:	dfc00117 	ldw	ra,4(sp)
 100914c:	df000017 	ldw	fp,0(sp)
 1009150:	dec00204 	addi	sp,sp,8
 1009154:	f800283a 	ret

01009158 <prvPrintTask1>:

static void prvPrintTask1(void *pvParameters)
{
 1009158:	defff804 	addi	sp,sp,-32
 100915c:	dfc00715 	stw	ra,28(sp)
 1009160:	df000615 	stw	fp,24(sp)
 1009164:	df000604 	addi	fp,sp,24
 1009168:	e13fff15 	stw	r4,-4(fp)
	uint32_t tmp0 = 0x0;
 100916c:	e03ffc15 	stw	zero,-16(fp)
	uint32_t tmp1 = 0x0;
 1009170:	e03ffd15 	stw	zero,-12(fp)
	test[14] = 0x00000000;
#endif

#if 1
	//Dest Address: ARP => FF-FF-FF-FF-FF-FF
	test[0]  = 0xff;
 1009174:	00805cf4 	movhi	r2,371
 1009178:	10a8d684 	addi	r2,r2,-23718
 100917c:	00ffffc4 	movi	r3,-1
 1009180:	10c00005 	stb	r3,0(r2)
	test[1]  = 0xff;
 1009184:	00805cf4 	movhi	r2,371
 1009188:	10a8d684 	addi	r2,r2,-23718
 100918c:	00ffffc4 	movi	r3,-1
 1009190:	10c00045 	stb	r3,1(r2)
	test[2]  = 0xff;
 1009194:	00805cf4 	movhi	r2,371
 1009198:	10a8d684 	addi	r2,r2,-23718
 100919c:	00ffffc4 	movi	r3,-1
 10091a0:	10c00085 	stb	r3,2(r2)
	test[3]  = 0xff;
 10091a4:	00805cf4 	movhi	r2,371
 10091a8:	10a8d684 	addi	r2,r2,-23718
 10091ac:	00ffffc4 	movi	r3,-1
 10091b0:	10c000c5 	stb	r3,3(r2)
	test[4]  = 0xff;
 10091b4:	00805cf4 	movhi	r2,371
 10091b8:	10a8d684 	addi	r2,r2,-23718
 10091bc:	00ffffc4 	movi	r3,-1
 10091c0:	10c00105 	stb	r3,4(r2)
	test[5]  = 0xff;
 10091c4:	00805cf4 	movhi	r2,371
 10091c8:	10a8d684 	addi	r2,r2,-23718
 10091cc:	00ffffc4 	movi	r3,-1
 10091d0:	10c00145 	stb	r3,5(r2)

	//Source Address
	test[6]  = 0x70;
 10091d4:	00805cf4 	movhi	r2,371
 10091d8:	10a8d684 	addi	r2,r2,-23718
 10091dc:	00c01c04 	movi	r3,112
 10091e0:	10c00185 	stb	r3,6(r2)
	test[7]  = 0xB3;
 10091e4:	00805cf4 	movhi	r2,371
 10091e8:	10a8d684 	addi	r2,r2,-23718
 10091ec:	00ffecc4 	movi	r3,-77
 10091f0:	10c001c5 	stb	r3,7(r2)
	test[8]  = 0xD5;
 10091f4:	00805cf4 	movhi	r2,371
 10091f8:	10a8d684 	addi	r2,r2,-23718
 10091fc:	00fff544 	movi	r3,-43
 1009200:	10c00205 	stb	r3,8(r2)
	test[9]  = 0xDF;
 1009204:	00805cf4 	movhi	r2,371
 1009208:	10a8d684 	addi	r2,r2,-23718
 100920c:	00fff7c4 	movi	r3,-33
 1009210:	10c00245 	stb	r3,9(r2)
	test[10] = 0xB0;
 1009214:	00805cf4 	movhi	r2,371
 1009218:	10a8d684 	addi	r2,r2,-23718
 100921c:	00ffec04 	movi	r3,-80
 1009220:	10c00285 	stb	r3,10(r2)
	test[11] = 0x00;
 1009224:	00805cf4 	movhi	r2,371
 1009228:	10a8d684 	addi	r2,r2,-23718
 100922c:	100002c5 	stb	zero,11(r2)

	//Type
	test[12] = 0x08;
 1009230:	00805cf4 	movhi	r2,371
 1009234:	10a8d684 	addi	r2,r2,-23718
 1009238:	00c00204 	movi	r3,8
 100923c:	10c00305 	stb	r3,12(r2)
	test[13] = 0x06;
 1009240:	00805cf4 	movhi	r2,371
 1009244:	10a8d684 	addi	r2,r2,-23718
 1009248:	00c00184 	movi	r3,6
 100924c:	10c00345 	stb	r3,13(r2)

	//Hardware Type: Ethernet => 1(fixed)
	test[14] = 0x00;
 1009250:	00805cf4 	movhi	r2,371
 1009254:	10a8d684 	addi	r2,r2,-23718
 1009258:	10000385 	stb	zero,14(r2)
	test[15] = 0x01;
 100925c:	00805cf4 	movhi	r2,371
 1009260:	10a8d684 	addi	r2,r2,-23718
 1009264:	00c00044 	movi	r3,1
 1009268:	10c003c5 	stb	r3,15(r2)

	//Protocol Type: TCP/IP => 0x0800(fixed)
	test[16] = 0x08;
 100926c:	00805cf4 	movhi	r2,371
 1009270:	10a8d684 	addi	r2,r2,-23718
 1009274:	00c00204 	movi	r3,8
 1009278:	10c00405 	stb	r3,16(r2)
	test[17] = 0x00;
 100927c:	00805cf4 	movhi	r2,371
 1009280:	10a8d684 	addi	r2,r2,-23718
 1009284:	10000445 	stb	zero,17(r2)

	//Hardware Length: MAC Address Length => 6(fixed)
	test[18] = 0x06;
 1009288:	00805cf4 	movhi	r2,371
 100928c:	10a8d684 	addi	r2,r2,-23718
 1009290:	00c00184 	movi	r3,6
 1009294:	10c00485 	stb	r3,18(r2)

	//Protocol Length: IP Address Length => 4(fixed)
	test[19] = 0x04;
 1009298:	00805cf4 	movhi	r2,371
 100929c:	10a8d684 	addi	r2,r2,-23718
 10092a0:	00c00104 	movi	r3,4
 10092a4:	10c004c5 	stb	r3,19(r2)

	//Operation: ARP Request(1) / ARP Reply(2)
	test[20] = 0x00;
 10092a8:	00805cf4 	movhi	r2,371
 10092ac:	10a8d684 	addi	r2,r2,-23718
 10092b0:	10000505 	stb	zero,20(r2)
	test[21] = 0x01;
 10092b4:	00805cf4 	movhi	r2,371
 10092b8:	10a8d684 	addi	r2,r2,-23718
 10092bc:	00c00044 	movi	r3,1
 10092c0:	10c00545 	stb	r3,21(r2)

	//Source Hardware Address
	test[22] = 0x70;
 10092c4:	00805cf4 	movhi	r2,371
 10092c8:	10a8d684 	addi	r2,r2,-23718
 10092cc:	00c01c04 	movi	r3,112
 10092d0:	10c00585 	stb	r3,22(r2)
	test[23] = 0xB3;
 10092d4:	00805cf4 	movhi	r2,371
 10092d8:	10a8d684 	addi	r2,r2,-23718
 10092dc:	00ffecc4 	movi	r3,-77
 10092e0:	10c005c5 	stb	r3,23(r2)
	test[24] = 0xD5;
 10092e4:	00805cf4 	movhi	r2,371
 10092e8:	10a8d684 	addi	r2,r2,-23718
 10092ec:	00fff544 	movi	r3,-43
 10092f0:	10c00605 	stb	r3,24(r2)
	test[25] = 0xDF;
 10092f4:	00805cf4 	movhi	r2,371
 10092f8:	10a8d684 	addi	r2,r2,-23718
 10092fc:	00fff7c4 	movi	r3,-33
 1009300:	10c00645 	stb	r3,25(r2)
	test[26] = 0xB0;
 1009304:	00805cf4 	movhi	r2,371
 1009308:	10a8d684 	addi	r2,r2,-23718
 100930c:	00ffec04 	movi	r3,-80
 1009310:	10c00685 	stb	r3,26(r2)
	test[27] = 0x00;
 1009314:	00805cf4 	movhi	r2,371
 1009318:	10a8d684 	addi	r2,r2,-23718
 100931c:	100006c5 	stb	zero,27(r2)

	//Source Protocol Address
	test[28] = 0xc0;
 1009320:	00805cf4 	movhi	r2,371
 1009324:	10a8d684 	addi	r2,r2,-23718
 1009328:	00fff004 	movi	r3,-64
 100932c:	10c00705 	stb	r3,28(r2)
	test[29] = 0xa8;
 1009330:	00805cf4 	movhi	r2,371
 1009334:	10a8d684 	addi	r2,r2,-23718
 1009338:	00ffea04 	movi	r3,-88
 100933c:	10c00745 	stb	r3,29(r2)
	test[30] = 0x00;
 1009340:	00805cf4 	movhi	r2,371
 1009344:	10a8d684 	addi	r2,r2,-23718
 1009348:	10000785 	stb	zero,30(r2)
	test[31] = 0x01;
 100934c:	00805cf4 	movhi	r2,371
 1009350:	10a8d684 	addi	r2,r2,-23718
 1009354:	00c00044 	movi	r3,1
 1009358:	10c007c5 	stb	r3,31(r2)

	//Dest Hardware Address
	test[32] = 0x00;
 100935c:	00805cf4 	movhi	r2,371
 1009360:	10a8d684 	addi	r2,r2,-23718
 1009364:	10000805 	stb	zero,32(r2)
	test[33] = 0x00;
 1009368:	00805cf4 	movhi	r2,371
 100936c:	10a8d684 	addi	r2,r2,-23718
 1009370:	10000845 	stb	zero,33(r2)
	test[34] = 0x00;
 1009374:	00805cf4 	movhi	r2,371
 1009378:	10a8d684 	addi	r2,r2,-23718
 100937c:	10000885 	stb	zero,34(r2)
	test[35] = 0x00;
 1009380:	00805cf4 	movhi	r2,371
 1009384:	10a8d684 	addi	r2,r2,-23718
 1009388:	100008c5 	stb	zero,35(r2)
	test[36] = 0x00;
 100938c:	00805cf4 	movhi	r2,371
 1009390:	10a8d684 	addi	r2,r2,-23718
 1009394:	10000905 	stb	zero,36(r2)
	test[37] = 0x00;
 1009398:	00805cf4 	movhi	r2,371
 100939c:	10a8d684 	addi	r2,r2,-23718
 10093a0:	10000945 	stb	zero,37(r2)

	//Dest Protocol Address
	test[38] = 0xc0;
 10093a4:	00805cf4 	movhi	r2,371
 10093a8:	10a8d684 	addi	r2,r2,-23718
 10093ac:	00fff004 	movi	r3,-64
 10093b0:	10c00985 	stb	r3,38(r2)
	test[39] = 0xa8;
 10093b4:	00805cf4 	movhi	r2,371
 10093b8:	10a8d684 	addi	r2,r2,-23718
 10093bc:	00ffea04 	movi	r3,-88
 10093c0:	10c009c5 	stb	r3,39(r2)
	test[40] = 0x00;
 10093c4:	00805cf4 	movhi	r2,371
 10093c8:	10a8d684 	addi	r2,r2,-23718
 10093cc:	10000a05 	stb	zero,40(r2)
	test[41] = 0x03;
 10093d0:	00805cf4 	movhi	r2,371
 10093d4:	10a8d684 	addi	r2,r2,-23718
 10093d8:	00c000c4 	movi	r3,3
 10093dc:	10c00a45 	stb	r3,41(r2)

	test[42] = 0x00;
 10093e0:	00805cf4 	movhi	r2,371
 10093e4:	10a8d684 	addi	r2,r2,-23718
 10093e8:	10000a85 	stb	zero,42(r2)
	test[43] = 0x00;
 10093ec:	00805cf4 	movhi	r2,371
 10093f0:	10a8d684 	addi	r2,r2,-23718
 10093f4:	10000ac5 	stb	zero,43(r2)
	test[44] = 0x00;
 10093f8:	00805cf4 	movhi	r2,371
 10093fc:	10a8d684 	addi	r2,r2,-23718
 1009400:	10000b05 	stb	zero,44(r2)
	test[45] = 0x00;
 1009404:	00805cf4 	movhi	r2,371
 1009408:	10a8d684 	addi	r2,r2,-23718
 100940c:	10000b45 	stb	zero,45(r2)
	test[46] = 0x00;
 1009410:	00805cf4 	movhi	r2,371
 1009414:	10a8d684 	addi	r2,r2,-23718
 1009418:	10000b85 	stb	zero,46(r2)
	test[47] = 0x00;
 100941c:	00805cf4 	movhi	r2,371
 1009420:	10a8d684 	addi	r2,r2,-23718
 1009424:	10000bc5 	stb	zero,47(r2)
	test[48] = 0x00;
 1009428:	00805cf4 	movhi	r2,371
 100942c:	10a8d684 	addi	r2,r2,-23718
 1009430:	10000c05 	stb	zero,48(r2)
	test[49] = 0x00;
 1009434:	00805cf4 	movhi	r2,371
 1009438:	10a8d684 	addi	r2,r2,-23718
 100943c:	10000c45 	stb	zero,49(r2)
	test[50] = 0x00;
 1009440:	00805cf4 	movhi	r2,371
 1009444:	10a8d684 	addi	r2,r2,-23718
 1009448:	10000c85 	stb	zero,50(r2)
	test[51] = 0x00;
 100944c:	00805cf4 	movhi	r2,371
 1009450:	10a8d684 	addi	r2,r2,-23718
 1009454:	10000cc5 	stb	zero,51(r2)
	test[52] = 0x00;
 1009458:	00805cf4 	movhi	r2,371
 100945c:	10a8d684 	addi	r2,r2,-23718
 1009460:	10000d05 	stb	zero,52(r2)
	test[53] = 0x00;
 1009464:	00805cf4 	movhi	r2,371
 1009468:	10a8d684 	addi	r2,r2,-23718
 100946c:	10000d45 	stb	zero,53(r2)
	test[54] = 0x00;
 1009470:	00805cf4 	movhi	r2,371
 1009474:	10a8d684 	addi	r2,r2,-23718
 1009478:	10000d85 	stb	zero,54(r2)
	test[55] = 0x00;
 100947c:	00805cf4 	movhi	r2,371
 1009480:	10a8d684 	addi	r2,r2,-23718
 1009484:	10000dc5 	stb	zero,55(r2)
	test[56] = 0x00;
 1009488:	00805cf4 	movhi	r2,371
 100948c:	10a8d684 	addi	r2,r2,-23718
 1009490:	10000e05 	stb	zero,56(r2)
	test[57] = 0x00;
 1009494:	00805cf4 	movhi	r2,371
 1009498:	10a8d684 	addi	r2,r2,-23718
 100949c:	10000e45 	stb	zero,57(r2)
	test[58] = 0x00;
 10094a0:	00805cf4 	movhi	r2,371
 10094a4:	10a8d684 	addi	r2,r2,-23718
 10094a8:	10000e85 	stb	zero,58(r2)
	test[59] = 0x00;
 10094ac:	00805cf4 	movhi	r2,371
 10094b0:	10a8d684 	addi	r2,r2,-23718
 10094b4:	10000ec5 	stb	zero,59(r2)
#endif

#if 1
	for (;;)
	{
		vTaskDelay(mainTASK1_PERIOD / portTICK_PERIOD_MS);
 10094b8:	01007d04 	movi	r4,500
 10094bc:	10058ec0 	call	10058ec <vTaskDelay>

		switch (led_toggle)
 10094c0:	d0a0a017 	ldw	r2,-32128(gp)
 10094c4:	10000326 	beq	r2,zero,10094d4 <prvPrintTask1+0x37c>
 10094c8:	10800060 	cmpeqi	r2,r2,1
 10094cc:	1000701e 	bne	r2,zero,1009690 <prvPrintTask1+0x538>
 10094d0:	00007506 	br	10096a8 <prvPrintTask1+0x550>
		{
		case 0:
			IOWR_ALTERA_AVALON_PIO_DATA(PIO_0_BASE, 0x01);
 10094d4:	00c00044 	movi	r3,1
 10094d8:	0086a804 	movi	r2,6816
 10094dc:	10c00035 	stwio	r3,0(r2)
			led_toggle = 1;
 10094e0:	00800044 	movi	r2,1
 10094e4:	d0a0a015 	stw	r2,-32128(gp)

			//tmp1 = IORD_ETH_OCM_INT_SOURCE(EMAC_BASEADDR);
			tmp0 = IORD_ETH_OCM_DESC_CTRL(EMAC_BASEADDR, 0);
 10094e8:	00802234 	movhi	r2,136
 10094ec:	10810004 	addi	r2,r2,1024
 10094f0:	10800037 	ldwio	r2,0(r2)
 10094f4:	e0bffc15 	stw	r2,-16(fp)
			tmp1 = IORD_ETH_OCM_MODER(EMAC_BASEADDR);
 10094f8:	00802234 	movhi	r2,136
 10094fc:	10800037 	ldwio	r2,0(r2)
 1009500:	e0bffd15 	stw	r2,-12(fp)

			if (!(tmp0 & ETH_OCM_TXDESC_READY_MSK))
 1009504:	e0bffc17 	ldw	r2,-16(fp)
 1009508:	10a0000c 	andi	r2,r2,32768
 100950c:	1000651e 	bne	r2,zero,10096a4 <prvPrintTask1+0x54c>
			{
				printf("address 0 = %lx\n", test);
 1009510:	01405cf4 	movhi	r5,371
 1009514:	2968d684 	addi	r5,r5,-23718
 1009518:	010040b4 	movhi	r4,258
 100951c:	212a8e04 	addi	r4,r4,-21960
 1009520:	1009c740 	call	1009c74 <printf>
				alt_u8 *buf = (alt_u8 *)alt_remap_cached((volatile void *)test, 4);
 1009524:	01400104 	movi	r5,4
 1009528:	01005cf4 	movhi	r4,371
 100952c:	2128d684 	addi	r4,r4,-23718
 1009530:	1016a880 	call	1016a88 <alt_remap_cached>
 1009534:	e0bffe15 	stw	r2,-8(fp)
				printf("address 1 = %lx\n", buf);
 1009538:	e17ffe17 	ldw	r5,-8(fp)
 100953c:	010040b4 	movhi	r4,258
 1009540:	212a9304 	addi	r4,r4,-21940
 1009544:	1009c740 	call	1009c74 <printf>
				printf("size = %d\n", sizeof(test));
 1009548:	01410004 	movi	r5,1024
 100954c:	010040b4 	movhi	r4,258
 1009550:	212a9804 	addi	r4,r4,-21920
 1009554:	1009c740 	call	1009c74 <printf>
				printf("buf = %x %x %x %x\n", buf[0], buf[4], buf[8], buf[12]);
 1009558:	e0bffe17 	ldw	r2,-8(fp)
 100955c:	10800003 	ldbu	r2,0(r2)
 1009560:	10c03fcc 	andi	r3,r2,255
 1009564:	e0bffe17 	ldw	r2,-8(fp)
 1009568:	10800104 	addi	r2,r2,4
 100956c:	10800003 	ldbu	r2,0(r2)
 1009570:	11003fcc 	andi	r4,r2,255
 1009574:	e0bffe17 	ldw	r2,-8(fp)
 1009578:	10800204 	addi	r2,r2,8
 100957c:	10800003 	ldbu	r2,0(r2)
 1009580:	11403fcc 	andi	r5,r2,255
 1009584:	e0bffe17 	ldw	r2,-8(fp)
 1009588:	10800304 	addi	r2,r2,12
 100958c:	10800003 	ldbu	r2,0(r2)
 1009590:	10803fcc 	andi	r2,r2,255
 1009594:	d8800015 	stw	r2,0(sp)
 1009598:	280f883a 	mov	r7,r5
 100959c:	200d883a 	mov	r6,r4
 10095a0:	180b883a 	mov	r5,r3
 10095a4:	010040b4 	movhi	r4,258
 10095a8:	212a9b04 	addi	r4,r4,-21908
 10095ac:	1009c740 	call	1009c74 <printf>

				IOWR_ETH_OCM_DESC_PTR(EMAC_BASEADDR, 0, buf);
 10095b0:	e0fffe17 	ldw	r3,-8(fp)
 10095b4:	00802234 	movhi	r2,136
 10095b8:	10810104 	addi	r2,r2,1028
 10095bc:	10c00035 	stwio	r3,0(r2)
				//IOWR_ETH_OCM_DESC_PTR(EMAC_BASEADDR, 0, BUFMEM_BASEADDR);
				IOWR_ETH_OCM_DESC_CTRL(EMAC_BASEADDR, 0, (sizeof(test) << ETH_OCM_TXDESC_LEN_OFST) |
 10095c0:	00c10074 	movhi	r3,1025
 10095c4:	18f80004 	addi	r3,r3,-8192
 10095c8:	00802234 	movhi	r2,136
 10095cc:	10810004 	addi	r2,r2,1024
 10095d0:	10c00035 	stwio	r3,0(r2)
																		  ETH_OCM_TXDESC_WRAP_MSK
																		  //ETH_OCM_TXDESC_PAD_MSK |
																		  //ETH_OCM_TXDESC_CRC_MSK
													  	  );

				tmp0 = IORD_ETH_OCM_DESC_CTRL(EMAC_BASEADDR, 0);
 10095d4:	00802234 	movhi	r2,136
 10095d8:	10810004 	addi	r2,r2,1024
 10095dc:	10800037 	ldwio	r2,0(r2)
 10095e0:	e0bffc15 	stw	r2,-16(fp)
				printf("TX start TXBD1=%08lx \n",tmp0);
 10095e4:	e17ffc17 	ldw	r5,-16(fp)
 10095e8:	010040b4 	movhi	r4,258
 10095ec:	212aa004 	addi	r4,r4,-21888
 10095f0:	1009c740 	call	1009c74 <printf>

				//tmp1 = IORD_ETH_OCM_DESC_CTRL(EMAC_BASEADDR, 1);

				long timeout_count = 0;
 10095f4:	e03ffb15 	stw	zero,-20(fp)
				do {
					tmp0 = IORD_ETH_OCM_DESC_CTRL(EMAC_BASEADDR, 0);
 10095f8:	00802234 	movhi	r2,136
 10095fc:	10810004 	addi	r2,r2,1024
 1009600:	10800037 	ldwio	r2,0(r2)
 1009604:	e0bffc15 	stw	r2,-16(fp)
					tmp1 = IORD_ETH_OCM_INT_SOURCE(EMAC_BASEADDR);
 1009608:	00802234 	movhi	r2,136
 100960c:	10800104 	addi	r2,r2,4
 1009610:	10800037 	ldwio	r2,0(r2)
 1009614:	e0bffd15 	stw	r2,-12(fp)
					timeout_count++;
 1009618:	e0bffb17 	ldw	r2,-20(fp)
 100961c:	10800044 	addi	r2,r2,1
 1009620:	e0bffb15 	stw	r2,-20(fp)
				} while ((tmp0 & ETH_OCM_TXDESC_READY_MSK) && timeout_count < 1000000);
 1009624:	e0bffc17 	ldw	r2,-16(fp)
 1009628:	10a0000c 	andi	r2,r2,32768
 100962c:	10000426 	beq	r2,zero,1009640 <prvPrintTask1+0x4e8>
 1009630:	e0fffb17 	ldw	r3,-20(fp)
 1009634:	008003f4 	movhi	r2,15
 1009638:	10908fc4 	addi	r2,r2,16959
 100963c:	10ffee0e 	bge	r2,r3,10095f8 <__alt_data_end+0xff8095f8>

				if (timeout_count < 1000000)
 1009640:	e0fffb17 	ldw	r3,-20(fp)
 1009644:	008003f4 	movhi	r2,15
 1009648:	10908fc4 	addi	r2,r2,16959
 100964c:	10c00416 	blt	r2,r3,1009660 <prvPrintTask1+0x508>
				{
					printf("TX succeeded!");
 1009650:	010040b4 	movhi	r4,258
 1009654:	212aa604 	addi	r4,r4,-21864
 1009658:	1009c740 	call	1009c74 <printf>
 100965c:	00000306 	br	100966c <prvPrintTask1+0x514>
				}
				else
				{
					printf("TX timeout...");
 1009660:	010040b4 	movhi	r4,258
 1009664:	212aaa04 	addi	r4,r4,-21848
 1009668:	1009c740 	call	1009c74 <printf>
				}

				tmp0 =  IORD_ETH_OCM_DESC_CTRL(EMAC_BASEADDR, 0);
 100966c:	00802234 	movhi	r2,136
 1009670:	10810004 	addi	r2,r2,1024
 1009674:	10800037 	ldwio	r2,0(r2)
 1009678:	e0bffc15 	stw	r2,-16(fp)
				printf("TX end   TXBD1=%08lx \n",tmp0);
 100967c:	e17ffc17 	ldw	r5,-16(fp)
 1009680:	010040b4 	movhi	r4,258
 1009684:	212aae04 	addi	r4,r4,-21832
 1009688:	1009c740 	call	1009c74 <printf>
			}
			break;
 100968c:	00000506 	br	10096a4 <prvPrintTask1+0x54c>
		case 1:
			IOWR_ALTERA_AVALON_PIO_DATA(PIO_0_BASE, 0x02);
 1009690:	00c00084 	movi	r3,2
 1009694:	0086a804 	movi	r2,6816
 1009698:	10c00035 	stwio	r3,0(r2)
			led_toggle = 0;
 100969c:	d020a015 	stw	zero,-32128(gp)
			break;
 10096a0:	00000106 	br	10096a8 <prvPrintTask1+0x550>
				}

				tmp0 =  IORD_ETH_OCM_DESC_CTRL(EMAC_BASEADDR, 0);
				printf("TX end   TXBD1=%08lx \n",tmp0);
			}
			break;
 10096a4:	0001883a 	nop
		case 1:
			IOWR_ALTERA_AVALON_PIO_DATA(PIO_0_BASE, 0x02);
			led_toggle = 0;
			break;
		}
	}
 10096a8:	003f8306 	br	10094b8 <__alt_data_end+0xff8094b8>

010096ac <__divsi3>:
 10096ac:	20001b16 	blt	r4,zero,100971c <__divsi3+0x70>
 10096b0:	000f883a 	mov	r7,zero
 10096b4:	28001616 	blt	r5,zero,1009710 <__divsi3+0x64>
 10096b8:	200d883a 	mov	r6,r4
 10096bc:	29001a2e 	bgeu	r5,r4,1009728 <__divsi3+0x7c>
 10096c0:	00800804 	movi	r2,32
 10096c4:	00c00044 	movi	r3,1
 10096c8:	00000106 	br	10096d0 <__divsi3+0x24>
 10096cc:	10000d26 	beq	r2,zero,1009704 <__divsi3+0x58>
 10096d0:	294b883a 	add	r5,r5,r5
 10096d4:	10bfffc4 	addi	r2,r2,-1
 10096d8:	18c7883a 	add	r3,r3,r3
 10096dc:	293ffb36 	bltu	r5,r4,10096cc <__alt_data_end+0xff8096cc>
 10096e0:	0005883a 	mov	r2,zero
 10096e4:	18000726 	beq	r3,zero,1009704 <__divsi3+0x58>
 10096e8:	0005883a 	mov	r2,zero
 10096ec:	31400236 	bltu	r6,r5,10096f8 <__divsi3+0x4c>
 10096f0:	314dc83a 	sub	r6,r6,r5
 10096f4:	10c4b03a 	or	r2,r2,r3
 10096f8:	1806d07a 	srli	r3,r3,1
 10096fc:	280ad07a 	srli	r5,r5,1
 1009700:	183ffa1e 	bne	r3,zero,10096ec <__alt_data_end+0xff8096ec>
 1009704:	38000126 	beq	r7,zero,100970c <__divsi3+0x60>
 1009708:	0085c83a 	sub	r2,zero,r2
 100970c:	f800283a 	ret
 1009710:	014bc83a 	sub	r5,zero,r5
 1009714:	39c0005c 	xori	r7,r7,1
 1009718:	003fe706 	br	10096b8 <__alt_data_end+0xff8096b8>
 100971c:	0109c83a 	sub	r4,zero,r4
 1009720:	01c00044 	movi	r7,1
 1009724:	003fe306 	br	10096b4 <__alt_data_end+0xff8096b4>
 1009728:	00c00044 	movi	r3,1
 100972c:	003fee06 	br	10096e8 <__alt_data_end+0xff8096e8>

01009730 <__modsi3>:
 1009730:	20001716 	blt	r4,zero,1009790 <__modsi3+0x60>
 1009734:	000f883a 	mov	r7,zero
 1009738:	2005883a 	mov	r2,r4
 100973c:	28001216 	blt	r5,zero,1009788 <__modsi3+0x58>
 1009740:	2900162e 	bgeu	r5,r4,100979c <__modsi3+0x6c>
 1009744:	01800804 	movi	r6,32
 1009748:	00c00044 	movi	r3,1
 100974c:	00000106 	br	1009754 <__modsi3+0x24>
 1009750:	30000a26 	beq	r6,zero,100977c <__modsi3+0x4c>
 1009754:	294b883a 	add	r5,r5,r5
 1009758:	31bfffc4 	addi	r6,r6,-1
 100975c:	18c7883a 	add	r3,r3,r3
 1009760:	293ffb36 	bltu	r5,r4,1009750 <__alt_data_end+0xff809750>
 1009764:	18000526 	beq	r3,zero,100977c <__modsi3+0x4c>
 1009768:	1806d07a 	srli	r3,r3,1
 100976c:	11400136 	bltu	r2,r5,1009774 <__modsi3+0x44>
 1009770:	1145c83a 	sub	r2,r2,r5
 1009774:	280ad07a 	srli	r5,r5,1
 1009778:	183ffb1e 	bne	r3,zero,1009768 <__alt_data_end+0xff809768>
 100977c:	38000126 	beq	r7,zero,1009784 <__modsi3+0x54>
 1009780:	0085c83a 	sub	r2,zero,r2
 1009784:	f800283a 	ret
 1009788:	014bc83a 	sub	r5,zero,r5
 100978c:	003fec06 	br	1009740 <__alt_data_end+0xff809740>
 1009790:	0109c83a 	sub	r4,zero,r4
 1009794:	01c00044 	movi	r7,1
 1009798:	003fe706 	br	1009738 <__alt_data_end+0xff809738>
 100979c:	00c00044 	movi	r3,1
 10097a0:	003ff106 	br	1009768 <__alt_data_end+0xff809768>

010097a4 <__udivsi3>:
 10097a4:	200d883a 	mov	r6,r4
 10097a8:	2900152e 	bgeu	r5,r4,1009800 <__udivsi3+0x5c>
 10097ac:	28001416 	blt	r5,zero,1009800 <__udivsi3+0x5c>
 10097b0:	00800804 	movi	r2,32
 10097b4:	00c00044 	movi	r3,1
 10097b8:	00000206 	br	10097c4 <__udivsi3+0x20>
 10097bc:	10000e26 	beq	r2,zero,10097f8 <__udivsi3+0x54>
 10097c0:	28000516 	blt	r5,zero,10097d8 <__udivsi3+0x34>
 10097c4:	294b883a 	add	r5,r5,r5
 10097c8:	10bfffc4 	addi	r2,r2,-1
 10097cc:	18c7883a 	add	r3,r3,r3
 10097d0:	293ffa36 	bltu	r5,r4,10097bc <__alt_data_end+0xff8097bc>
 10097d4:	18000826 	beq	r3,zero,10097f8 <__udivsi3+0x54>
 10097d8:	0005883a 	mov	r2,zero
 10097dc:	31400236 	bltu	r6,r5,10097e8 <__udivsi3+0x44>
 10097e0:	314dc83a 	sub	r6,r6,r5
 10097e4:	10c4b03a 	or	r2,r2,r3
 10097e8:	1806d07a 	srli	r3,r3,1
 10097ec:	280ad07a 	srli	r5,r5,1
 10097f0:	183ffa1e 	bne	r3,zero,10097dc <__alt_data_end+0xff8097dc>
 10097f4:	f800283a 	ret
 10097f8:	0005883a 	mov	r2,zero
 10097fc:	f800283a 	ret
 1009800:	00c00044 	movi	r3,1
 1009804:	003ff406 	br	10097d8 <__alt_data_end+0xff8097d8>

01009808 <__umodsi3>:
 1009808:	2005883a 	mov	r2,r4
 100980c:	2900122e 	bgeu	r5,r4,1009858 <__umodsi3+0x50>
 1009810:	28001116 	blt	r5,zero,1009858 <__umodsi3+0x50>
 1009814:	01800804 	movi	r6,32
 1009818:	00c00044 	movi	r3,1
 100981c:	00000206 	br	1009828 <__umodsi3+0x20>
 1009820:	30000c26 	beq	r6,zero,1009854 <__umodsi3+0x4c>
 1009824:	28000516 	blt	r5,zero,100983c <__umodsi3+0x34>
 1009828:	294b883a 	add	r5,r5,r5
 100982c:	31bfffc4 	addi	r6,r6,-1
 1009830:	18c7883a 	add	r3,r3,r3
 1009834:	293ffa36 	bltu	r5,r4,1009820 <__alt_data_end+0xff809820>
 1009838:	18000626 	beq	r3,zero,1009854 <__umodsi3+0x4c>
 100983c:	1806d07a 	srli	r3,r3,1
 1009840:	11400136 	bltu	r2,r5,1009848 <__umodsi3+0x40>
 1009844:	1145c83a 	sub	r2,r2,r5
 1009848:	280ad07a 	srli	r5,r5,1
 100984c:	183ffb1e 	bne	r3,zero,100983c <__alt_data_end+0xff80983c>
 1009850:	f800283a 	ret
 1009854:	f800283a 	ret
 1009858:	00c00044 	movi	r3,1
 100985c:	003ff706 	br	100983c <__alt_data_end+0xff80983c>

01009860 <__extendsfdf2>:
 1009860:	200ad5fa 	srli	r5,r4,23
 1009864:	defffd04 	addi	sp,sp,-12
 1009868:	dc400115 	stw	r17,4(sp)
 100986c:	29403fcc 	andi	r5,r5,255
 1009870:	29800044 	addi	r6,r5,1
 1009874:	04402034 	movhi	r17,128
 1009878:	dc000015 	stw	r16,0(sp)
 100987c:	8c7fffc4 	addi	r17,r17,-1
 1009880:	dfc00215 	stw	ra,8(sp)
 1009884:	31803fcc 	andi	r6,r6,255
 1009888:	00800044 	movi	r2,1
 100988c:	8922703a 	and	r17,r17,r4
 1009890:	2020d7fa 	srli	r16,r4,31
 1009894:	1180110e 	bge	r2,r6,10098dc <__extendsfdf2+0x7c>
 1009898:	880cd0fa 	srli	r6,r17,3
 100989c:	8822977a 	slli	r17,r17,29
 10098a0:	2940e004 	addi	r5,r5,896
 10098a4:	2941ffcc 	andi	r5,r5,2047
 10098a8:	2804953a 	slli	r2,r5,20
 10098ac:	01400434 	movhi	r5,16
 10098b0:	800697fa 	slli	r3,r16,31
 10098b4:	297fffc4 	addi	r5,r5,-1
 10098b8:	314a703a 	and	r5,r6,r5
 10098bc:	288ab03a 	or	r5,r5,r2
 10098c0:	28c6b03a 	or	r3,r5,r3
 10098c4:	8805883a 	mov	r2,r17
 10098c8:	dfc00217 	ldw	ra,8(sp)
 10098cc:	dc400117 	ldw	r17,4(sp)
 10098d0:	dc000017 	ldw	r16,0(sp)
 10098d4:	dec00304 	addi	sp,sp,12
 10098d8:	f800283a 	ret
 10098dc:	2800111e 	bne	r5,zero,1009924 <__extendsfdf2+0xc4>
 10098e0:	88001c26 	beq	r17,zero,1009954 <__extendsfdf2+0xf4>
 10098e4:	8809883a 	mov	r4,r17
 10098e8:	10099700 	call	1009970 <__clzsi2>
 10098ec:	00c00284 	movi	r3,10
 10098f0:	18801b16 	blt	r3,r2,1009960 <__extendsfdf2+0x100>
 10098f4:	018002c4 	movi	r6,11
 10098f8:	308dc83a 	sub	r6,r6,r2
 10098fc:	11000544 	addi	r4,r2,21
 1009900:	8986d83a 	srl	r3,r17,r6
 1009904:	8922983a 	sll	r17,r17,r4
 1009908:	0180e244 	movi	r6,905
 100990c:	01400434 	movhi	r5,16
 1009910:	3085c83a 	sub	r2,r6,r2
 1009914:	297fffc4 	addi	r5,r5,-1
 1009918:	194c703a 	and	r6,r3,r5
 100991c:	1141ffcc 	andi	r5,r2,2047
 1009920:	003fe006 	br	10098a4 <__alt_data_end+0xff8098a4>
 1009924:	88000826 	beq	r17,zero,1009948 <__extendsfdf2+0xe8>
 1009928:	880cd0fa 	srli	r6,r17,3
 100992c:	00800434 	movhi	r2,16
 1009930:	10bfffc4 	addi	r2,r2,-1
 1009934:	31800234 	orhi	r6,r6,8
 1009938:	8822977a 	slli	r17,r17,29
 100993c:	308c703a 	and	r6,r6,r2
 1009940:	0141ffc4 	movi	r5,2047
 1009944:	003fd706 	br	10098a4 <__alt_data_end+0xff8098a4>
 1009948:	0141ffc4 	movi	r5,2047
 100994c:	000d883a 	mov	r6,zero
 1009950:	003fd406 	br	10098a4 <__alt_data_end+0xff8098a4>
 1009954:	000b883a 	mov	r5,zero
 1009958:	000d883a 	mov	r6,zero
 100995c:	003fd106 	br	10098a4 <__alt_data_end+0xff8098a4>
 1009960:	11bffd44 	addi	r6,r2,-11
 1009964:	8986983a 	sll	r3,r17,r6
 1009968:	0023883a 	mov	r17,zero
 100996c:	003fe606 	br	1009908 <__alt_data_end+0xff809908>

01009970 <__clzsi2>:
 1009970:	00bfffd4 	movui	r2,65535
 1009974:	11000536 	bltu	r2,r4,100998c <__clzsi2+0x1c>
 1009978:	00803fc4 	movi	r2,255
 100997c:	11000f36 	bltu	r2,r4,10099bc <__clzsi2+0x4c>
 1009980:	00800804 	movi	r2,32
 1009984:	0007883a 	mov	r3,zero
 1009988:	00000506 	br	10099a0 <__clzsi2+0x30>
 100998c:	00804034 	movhi	r2,256
 1009990:	10bfffc4 	addi	r2,r2,-1
 1009994:	11000c2e 	bgeu	r2,r4,10099c8 <__clzsi2+0x58>
 1009998:	00800204 	movi	r2,8
 100999c:	00c00604 	movi	r3,24
 10099a0:	20c8d83a 	srl	r4,r4,r3
 10099a4:	00c040b4 	movhi	r3,258
 10099a8:	18eab3c4 	addi	r3,r3,-21809
 10099ac:	1909883a 	add	r4,r3,r4
 10099b0:	20c00003 	ldbu	r3,0(r4)
 10099b4:	10c5c83a 	sub	r2,r2,r3
 10099b8:	f800283a 	ret
 10099bc:	00800604 	movi	r2,24
 10099c0:	00c00204 	movi	r3,8
 10099c4:	003ff606 	br	10099a0 <__alt_data_end+0xff8099a0>
 10099c8:	00800404 	movi	r2,16
 10099cc:	1007883a 	mov	r3,r2
 10099d0:	003ff306 	br	10099a0 <__alt_data_end+0xff8099a0>

010099d4 <memcpy>:
 10099d4:	defffd04 	addi	sp,sp,-12
 10099d8:	dfc00215 	stw	ra,8(sp)
 10099dc:	dc400115 	stw	r17,4(sp)
 10099e0:	dc000015 	stw	r16,0(sp)
 10099e4:	00c003c4 	movi	r3,15
 10099e8:	2005883a 	mov	r2,r4
 10099ec:	1980452e 	bgeu	r3,r6,1009b04 <memcpy+0x130>
 10099f0:	2906b03a 	or	r3,r5,r4
 10099f4:	18c000cc 	andi	r3,r3,3
 10099f8:	1800441e 	bne	r3,zero,1009b0c <memcpy+0x138>
 10099fc:	347ffc04 	addi	r17,r6,-16
 1009a00:	8822d13a 	srli	r17,r17,4
 1009a04:	28c00104 	addi	r3,r5,4
 1009a08:	23400104 	addi	r13,r4,4
 1009a0c:	8820913a 	slli	r16,r17,4
 1009a10:	2b000204 	addi	r12,r5,8
 1009a14:	22c00204 	addi	r11,r4,8
 1009a18:	84000504 	addi	r16,r16,20
 1009a1c:	2a800304 	addi	r10,r5,12
 1009a20:	22400304 	addi	r9,r4,12
 1009a24:	2c21883a 	add	r16,r5,r16
 1009a28:	2811883a 	mov	r8,r5
 1009a2c:	200f883a 	mov	r7,r4
 1009a30:	41000017 	ldw	r4,0(r8)
 1009a34:	1fc00017 	ldw	ra,0(r3)
 1009a38:	63c00017 	ldw	r15,0(r12)
 1009a3c:	39000015 	stw	r4,0(r7)
 1009a40:	53800017 	ldw	r14,0(r10)
 1009a44:	6fc00015 	stw	ra,0(r13)
 1009a48:	5bc00015 	stw	r15,0(r11)
 1009a4c:	4b800015 	stw	r14,0(r9)
 1009a50:	18c00404 	addi	r3,r3,16
 1009a54:	39c00404 	addi	r7,r7,16
 1009a58:	42000404 	addi	r8,r8,16
 1009a5c:	6b400404 	addi	r13,r13,16
 1009a60:	63000404 	addi	r12,r12,16
 1009a64:	5ac00404 	addi	r11,r11,16
 1009a68:	52800404 	addi	r10,r10,16
 1009a6c:	4a400404 	addi	r9,r9,16
 1009a70:	1c3fef1e 	bne	r3,r16,1009a30 <__alt_data_end+0xff809a30>
 1009a74:	89c00044 	addi	r7,r17,1
 1009a78:	380e913a 	slli	r7,r7,4
 1009a7c:	310003cc 	andi	r4,r6,15
 1009a80:	02c000c4 	movi	r11,3
 1009a84:	11c7883a 	add	r3,r2,r7
 1009a88:	29cb883a 	add	r5,r5,r7
 1009a8c:	5900212e 	bgeu	r11,r4,1009b14 <memcpy+0x140>
 1009a90:	1813883a 	mov	r9,r3
 1009a94:	2811883a 	mov	r8,r5
 1009a98:	200f883a 	mov	r7,r4
 1009a9c:	42800017 	ldw	r10,0(r8)
 1009aa0:	4a400104 	addi	r9,r9,4
 1009aa4:	39ffff04 	addi	r7,r7,-4
 1009aa8:	4abfff15 	stw	r10,-4(r9)
 1009aac:	42000104 	addi	r8,r8,4
 1009ab0:	59fffa36 	bltu	r11,r7,1009a9c <__alt_data_end+0xff809a9c>
 1009ab4:	213fff04 	addi	r4,r4,-4
 1009ab8:	2008d0ba 	srli	r4,r4,2
 1009abc:	318000cc 	andi	r6,r6,3
 1009ac0:	21000044 	addi	r4,r4,1
 1009ac4:	2109883a 	add	r4,r4,r4
 1009ac8:	2109883a 	add	r4,r4,r4
 1009acc:	1907883a 	add	r3,r3,r4
 1009ad0:	290b883a 	add	r5,r5,r4
 1009ad4:	30000626 	beq	r6,zero,1009af0 <memcpy+0x11c>
 1009ad8:	198d883a 	add	r6,r3,r6
 1009adc:	29c00003 	ldbu	r7,0(r5)
 1009ae0:	18c00044 	addi	r3,r3,1
 1009ae4:	29400044 	addi	r5,r5,1
 1009ae8:	19ffffc5 	stb	r7,-1(r3)
 1009aec:	19bffb1e 	bne	r3,r6,1009adc <__alt_data_end+0xff809adc>
 1009af0:	dfc00217 	ldw	ra,8(sp)
 1009af4:	dc400117 	ldw	r17,4(sp)
 1009af8:	dc000017 	ldw	r16,0(sp)
 1009afc:	dec00304 	addi	sp,sp,12
 1009b00:	f800283a 	ret
 1009b04:	2007883a 	mov	r3,r4
 1009b08:	003ff206 	br	1009ad4 <__alt_data_end+0xff809ad4>
 1009b0c:	2007883a 	mov	r3,r4
 1009b10:	003ff106 	br	1009ad8 <__alt_data_end+0xff809ad8>
 1009b14:	200d883a 	mov	r6,r4
 1009b18:	003fee06 	br	1009ad4 <__alt_data_end+0xff809ad4>

01009b1c <memset>:
 1009b1c:	20c000cc 	andi	r3,r4,3
 1009b20:	2005883a 	mov	r2,r4
 1009b24:	18004426 	beq	r3,zero,1009c38 <memset+0x11c>
 1009b28:	31ffffc4 	addi	r7,r6,-1
 1009b2c:	30004026 	beq	r6,zero,1009c30 <memset+0x114>
 1009b30:	2813883a 	mov	r9,r5
 1009b34:	200d883a 	mov	r6,r4
 1009b38:	2007883a 	mov	r3,r4
 1009b3c:	00000406 	br	1009b50 <memset+0x34>
 1009b40:	3a3fffc4 	addi	r8,r7,-1
 1009b44:	31800044 	addi	r6,r6,1
 1009b48:	38003926 	beq	r7,zero,1009c30 <memset+0x114>
 1009b4c:	400f883a 	mov	r7,r8
 1009b50:	18c00044 	addi	r3,r3,1
 1009b54:	32400005 	stb	r9,0(r6)
 1009b58:	1a0000cc 	andi	r8,r3,3
 1009b5c:	403ff81e 	bne	r8,zero,1009b40 <__alt_data_end+0xff809b40>
 1009b60:	010000c4 	movi	r4,3
 1009b64:	21c02d2e 	bgeu	r4,r7,1009c1c <memset+0x100>
 1009b68:	29003fcc 	andi	r4,r5,255
 1009b6c:	200c923a 	slli	r6,r4,8
 1009b70:	3108b03a 	or	r4,r6,r4
 1009b74:	200c943a 	slli	r6,r4,16
 1009b78:	218cb03a 	or	r6,r4,r6
 1009b7c:	010003c4 	movi	r4,15
 1009b80:	21c0182e 	bgeu	r4,r7,1009be4 <memset+0xc8>
 1009b84:	3b3ffc04 	addi	r12,r7,-16
 1009b88:	6018d13a 	srli	r12,r12,4
 1009b8c:	1a000104 	addi	r8,r3,4
 1009b90:	1ac00204 	addi	r11,r3,8
 1009b94:	6008913a 	slli	r4,r12,4
 1009b98:	1a800304 	addi	r10,r3,12
 1009b9c:	1813883a 	mov	r9,r3
 1009ba0:	21000504 	addi	r4,r4,20
 1009ba4:	1909883a 	add	r4,r3,r4
 1009ba8:	49800015 	stw	r6,0(r9)
 1009bac:	41800015 	stw	r6,0(r8)
 1009bb0:	59800015 	stw	r6,0(r11)
 1009bb4:	51800015 	stw	r6,0(r10)
 1009bb8:	42000404 	addi	r8,r8,16
 1009bbc:	4a400404 	addi	r9,r9,16
 1009bc0:	5ac00404 	addi	r11,r11,16
 1009bc4:	52800404 	addi	r10,r10,16
 1009bc8:	413ff71e 	bne	r8,r4,1009ba8 <__alt_data_end+0xff809ba8>
 1009bcc:	63000044 	addi	r12,r12,1
 1009bd0:	6018913a 	slli	r12,r12,4
 1009bd4:	39c003cc 	andi	r7,r7,15
 1009bd8:	010000c4 	movi	r4,3
 1009bdc:	1b07883a 	add	r3,r3,r12
 1009be0:	21c00e2e 	bgeu	r4,r7,1009c1c <memset+0x100>
 1009be4:	1813883a 	mov	r9,r3
 1009be8:	3811883a 	mov	r8,r7
 1009bec:	010000c4 	movi	r4,3
 1009bf0:	49800015 	stw	r6,0(r9)
 1009bf4:	423fff04 	addi	r8,r8,-4
 1009bf8:	4a400104 	addi	r9,r9,4
 1009bfc:	223ffc36 	bltu	r4,r8,1009bf0 <__alt_data_end+0xff809bf0>
 1009c00:	393fff04 	addi	r4,r7,-4
 1009c04:	2008d0ba 	srli	r4,r4,2
 1009c08:	39c000cc 	andi	r7,r7,3
 1009c0c:	21000044 	addi	r4,r4,1
 1009c10:	2109883a 	add	r4,r4,r4
 1009c14:	2109883a 	add	r4,r4,r4
 1009c18:	1907883a 	add	r3,r3,r4
 1009c1c:	38000526 	beq	r7,zero,1009c34 <memset+0x118>
 1009c20:	19cf883a 	add	r7,r3,r7
 1009c24:	19400005 	stb	r5,0(r3)
 1009c28:	18c00044 	addi	r3,r3,1
 1009c2c:	38fffd1e 	bne	r7,r3,1009c24 <__alt_data_end+0xff809c24>
 1009c30:	f800283a 	ret
 1009c34:	f800283a 	ret
 1009c38:	2007883a 	mov	r3,r4
 1009c3c:	300f883a 	mov	r7,r6
 1009c40:	003fc706 	br	1009b60 <__alt_data_end+0xff809b60>

01009c44 <_printf_r>:
 1009c44:	defffd04 	addi	sp,sp,-12
 1009c48:	2805883a 	mov	r2,r5
 1009c4c:	dfc00015 	stw	ra,0(sp)
 1009c50:	d9800115 	stw	r6,4(sp)
 1009c54:	d9c00215 	stw	r7,8(sp)
 1009c58:	21400217 	ldw	r5,8(r4)
 1009c5c:	d9c00104 	addi	r7,sp,4
 1009c60:	100d883a 	mov	r6,r2
 1009c64:	1009e3c0 	call	1009e3c <___vfprintf_internal_r>
 1009c68:	dfc00017 	ldw	ra,0(sp)
 1009c6c:	dec00304 	addi	sp,sp,12
 1009c70:	f800283a 	ret

01009c74 <printf>:
 1009c74:	defffc04 	addi	sp,sp,-16
 1009c78:	dfc00015 	stw	ra,0(sp)
 1009c7c:	d9400115 	stw	r5,4(sp)
 1009c80:	d9800215 	stw	r6,8(sp)
 1009c84:	d9c00315 	stw	r7,12(sp)
 1009c88:	008040b4 	movhi	r2,258
 1009c8c:	10b39b04 	addi	r2,r2,-12692
 1009c90:	10800017 	ldw	r2,0(r2)
 1009c94:	200b883a 	mov	r5,r4
 1009c98:	d9800104 	addi	r6,sp,4
 1009c9c:	11000217 	ldw	r4,8(r2)
 1009ca0:	100c0340 	call	100c034 <__vfprintf_internal>
 1009ca4:	dfc00017 	ldw	ra,0(sp)
 1009ca8:	dec00404 	addi	sp,sp,16
 1009cac:	f800283a 	ret

01009cb0 <_putchar_r>:
 1009cb0:	21800217 	ldw	r6,8(r4)
 1009cb4:	10108881 	jmpi	1010888 <_putc_r>

01009cb8 <putchar>:
 1009cb8:	008040b4 	movhi	r2,258
 1009cbc:	10b39b04 	addi	r2,r2,-12692
 1009cc0:	200b883a 	mov	r5,r4
 1009cc4:	11000017 	ldw	r4,0(r2)
 1009cc8:	21800217 	ldw	r6,8(r4)
 1009ccc:	10108881 	jmpi	1010888 <_putc_r>

01009cd0 <_puts_r>:
 1009cd0:	defff604 	addi	sp,sp,-40
 1009cd4:	dc000715 	stw	r16,28(sp)
 1009cd8:	2021883a 	mov	r16,r4
 1009cdc:	2809883a 	mov	r4,r5
 1009ce0:	dc400815 	stw	r17,32(sp)
 1009ce4:	dfc00915 	stw	ra,36(sp)
 1009ce8:	2823883a 	mov	r17,r5
 1009cec:	1009da40 	call	1009da4 <strlen>
 1009cf0:	10c00044 	addi	r3,r2,1
 1009cf4:	d8800115 	stw	r2,4(sp)
 1009cf8:	008040b4 	movhi	r2,258
 1009cfc:	10aaf404 	addi	r2,r2,-21552
 1009d00:	d8800215 	stw	r2,8(sp)
 1009d04:	00800044 	movi	r2,1
 1009d08:	d8800315 	stw	r2,12(sp)
 1009d0c:	00800084 	movi	r2,2
 1009d10:	dc400015 	stw	r17,0(sp)
 1009d14:	d8c00615 	stw	r3,24(sp)
 1009d18:	dec00415 	stw	sp,16(sp)
 1009d1c:	d8800515 	stw	r2,20(sp)
 1009d20:	80000226 	beq	r16,zero,1009d2c <_puts_r+0x5c>
 1009d24:	80800e17 	ldw	r2,56(r16)
 1009d28:	10001426 	beq	r2,zero,1009d7c <_puts_r+0xac>
 1009d2c:	81400217 	ldw	r5,8(r16)
 1009d30:	2880030b 	ldhu	r2,12(r5)
 1009d34:	10c8000c 	andi	r3,r2,8192
 1009d38:	1800061e 	bne	r3,zero,1009d54 <_puts_r+0x84>
 1009d3c:	29001917 	ldw	r4,100(r5)
 1009d40:	00f7ffc4 	movi	r3,-8193
 1009d44:	10880014 	ori	r2,r2,8192
 1009d48:	20c6703a 	and	r3,r4,r3
 1009d4c:	2880030d 	sth	r2,12(r5)
 1009d50:	28c01915 	stw	r3,100(r5)
 1009d54:	d9800404 	addi	r6,sp,16
 1009d58:	8009883a 	mov	r4,r16
 1009d5c:	100e5640 	call	100e564 <__sfvwrite_r>
 1009d60:	1000091e 	bne	r2,zero,1009d88 <_puts_r+0xb8>
 1009d64:	00800284 	movi	r2,10
 1009d68:	dfc00917 	ldw	ra,36(sp)
 1009d6c:	dc400817 	ldw	r17,32(sp)
 1009d70:	dc000717 	ldw	r16,28(sp)
 1009d74:	dec00a04 	addi	sp,sp,40
 1009d78:	f800283a 	ret
 1009d7c:	8009883a 	mov	r4,r16
 1009d80:	100e0e00 	call	100e0e0 <__sinit>
 1009d84:	003fe906 	br	1009d2c <__alt_data_end+0xff809d2c>
 1009d88:	00bfffc4 	movi	r2,-1
 1009d8c:	003ff606 	br	1009d68 <__alt_data_end+0xff809d68>

01009d90 <puts>:
 1009d90:	008040b4 	movhi	r2,258
 1009d94:	10b39b04 	addi	r2,r2,-12692
 1009d98:	200b883a 	mov	r5,r4
 1009d9c:	11000017 	ldw	r4,0(r2)
 1009da0:	1009cd01 	jmpi	1009cd0 <_puts_r>

01009da4 <strlen>:
 1009da4:	208000cc 	andi	r2,r4,3
 1009da8:	10002026 	beq	r2,zero,1009e2c <strlen+0x88>
 1009dac:	20800007 	ldb	r2,0(r4)
 1009db0:	10002026 	beq	r2,zero,1009e34 <strlen+0x90>
 1009db4:	2005883a 	mov	r2,r4
 1009db8:	00000206 	br	1009dc4 <strlen+0x20>
 1009dbc:	10c00007 	ldb	r3,0(r2)
 1009dc0:	18001826 	beq	r3,zero,1009e24 <strlen+0x80>
 1009dc4:	10800044 	addi	r2,r2,1
 1009dc8:	10c000cc 	andi	r3,r2,3
 1009dcc:	183ffb1e 	bne	r3,zero,1009dbc <__alt_data_end+0xff809dbc>
 1009dd0:	10c00017 	ldw	r3,0(r2)
 1009dd4:	01ffbff4 	movhi	r7,65279
 1009dd8:	39ffbfc4 	addi	r7,r7,-257
 1009ddc:	00ca303a 	nor	r5,zero,r3
 1009de0:	01a02074 	movhi	r6,32897
 1009de4:	19c7883a 	add	r3,r3,r7
 1009de8:	31a02004 	addi	r6,r6,-32640
 1009dec:	1946703a 	and	r3,r3,r5
 1009df0:	1986703a 	and	r3,r3,r6
 1009df4:	1800091e 	bne	r3,zero,1009e1c <strlen+0x78>
 1009df8:	10800104 	addi	r2,r2,4
 1009dfc:	10c00017 	ldw	r3,0(r2)
 1009e00:	19cb883a 	add	r5,r3,r7
 1009e04:	00c6303a 	nor	r3,zero,r3
 1009e08:	28c6703a 	and	r3,r5,r3
 1009e0c:	1986703a 	and	r3,r3,r6
 1009e10:	183ff926 	beq	r3,zero,1009df8 <__alt_data_end+0xff809df8>
 1009e14:	00000106 	br	1009e1c <strlen+0x78>
 1009e18:	10800044 	addi	r2,r2,1
 1009e1c:	10c00007 	ldb	r3,0(r2)
 1009e20:	183ffd1e 	bne	r3,zero,1009e18 <__alt_data_end+0xff809e18>
 1009e24:	1105c83a 	sub	r2,r2,r4
 1009e28:	f800283a 	ret
 1009e2c:	2005883a 	mov	r2,r4
 1009e30:	003fe706 	br	1009dd0 <__alt_data_end+0xff809dd0>
 1009e34:	0005883a 	mov	r2,zero
 1009e38:	f800283a 	ret

01009e3c <___vfprintf_internal_r>:
 1009e3c:	deffb804 	addi	sp,sp,-288
 1009e40:	dfc04715 	stw	ra,284(sp)
 1009e44:	ddc04515 	stw	r23,276(sp)
 1009e48:	dd404315 	stw	r21,268(sp)
 1009e4c:	d9002c15 	stw	r4,176(sp)
 1009e50:	282f883a 	mov	r23,r5
 1009e54:	302b883a 	mov	r21,r6
 1009e58:	d9c02d15 	stw	r7,180(sp)
 1009e5c:	df004615 	stw	fp,280(sp)
 1009e60:	dd804415 	stw	r22,272(sp)
 1009e64:	dd004215 	stw	r20,264(sp)
 1009e68:	dcc04115 	stw	r19,260(sp)
 1009e6c:	dc804015 	stw	r18,256(sp)
 1009e70:	dc403f15 	stw	r17,252(sp)
 1009e74:	dc003e15 	stw	r16,248(sp)
 1009e78:	100ec540 	call	100ec54 <_localeconv_r>
 1009e7c:	10800017 	ldw	r2,0(r2)
 1009e80:	1009883a 	mov	r4,r2
 1009e84:	d8803415 	stw	r2,208(sp)
 1009e88:	1009da40 	call	1009da4 <strlen>
 1009e8c:	d8803715 	stw	r2,220(sp)
 1009e90:	d8802c17 	ldw	r2,176(sp)
 1009e94:	10000226 	beq	r2,zero,1009ea0 <___vfprintf_internal_r+0x64>
 1009e98:	10800e17 	ldw	r2,56(r2)
 1009e9c:	1000f926 	beq	r2,zero,100a284 <___vfprintf_internal_r+0x448>
 1009ea0:	b880030b 	ldhu	r2,12(r23)
 1009ea4:	10c8000c 	andi	r3,r2,8192
 1009ea8:	1800061e 	bne	r3,zero,1009ec4 <___vfprintf_internal_r+0x88>
 1009eac:	b9001917 	ldw	r4,100(r23)
 1009eb0:	00f7ffc4 	movi	r3,-8193
 1009eb4:	10880014 	ori	r2,r2,8192
 1009eb8:	20c6703a 	and	r3,r4,r3
 1009ebc:	b880030d 	sth	r2,12(r23)
 1009ec0:	b8c01915 	stw	r3,100(r23)
 1009ec4:	10c0020c 	andi	r3,r2,8
 1009ec8:	1800c126 	beq	r3,zero,100a1d0 <___vfprintf_internal_r+0x394>
 1009ecc:	b8c00417 	ldw	r3,16(r23)
 1009ed0:	1800bf26 	beq	r3,zero,100a1d0 <___vfprintf_internal_r+0x394>
 1009ed4:	1080068c 	andi	r2,r2,26
 1009ed8:	00c00284 	movi	r3,10
 1009edc:	10c0c426 	beq	r2,r3,100a1f0 <___vfprintf_internal_r+0x3b4>
 1009ee0:	d8c00404 	addi	r3,sp,16
 1009ee4:	050040b4 	movhi	r20,258
 1009ee8:	d9001e04 	addi	r4,sp,120
 1009eec:	a52b0584 	addi	r20,r20,-21482
 1009ef0:	d8c01e15 	stw	r3,120(sp)
 1009ef4:	d8002015 	stw	zero,128(sp)
 1009ef8:	d8001f15 	stw	zero,124(sp)
 1009efc:	d8003315 	stw	zero,204(sp)
 1009f00:	d8003615 	stw	zero,216(sp)
 1009f04:	d8003815 	stw	zero,224(sp)
 1009f08:	1811883a 	mov	r8,r3
 1009f0c:	d8003915 	stw	zero,228(sp)
 1009f10:	d8003a15 	stw	zero,232(sp)
 1009f14:	d8002f15 	stw	zero,188(sp)
 1009f18:	d9002815 	stw	r4,160(sp)
 1009f1c:	a8800007 	ldb	r2,0(r21)
 1009f20:	10027b26 	beq	r2,zero,100a910 <___vfprintf_internal_r+0xad4>
 1009f24:	00c00944 	movi	r3,37
 1009f28:	a821883a 	mov	r16,r21
 1009f2c:	10c0021e 	bne	r2,r3,1009f38 <___vfprintf_internal_r+0xfc>
 1009f30:	00001406 	br	1009f84 <___vfprintf_internal_r+0x148>
 1009f34:	10c00326 	beq	r2,r3,1009f44 <___vfprintf_internal_r+0x108>
 1009f38:	84000044 	addi	r16,r16,1
 1009f3c:	80800007 	ldb	r2,0(r16)
 1009f40:	103ffc1e 	bne	r2,zero,1009f34 <__alt_data_end+0xff809f34>
 1009f44:	8563c83a 	sub	r17,r16,r21
 1009f48:	88000e26 	beq	r17,zero,1009f84 <___vfprintf_internal_r+0x148>
 1009f4c:	d8c02017 	ldw	r3,128(sp)
 1009f50:	d8801f17 	ldw	r2,124(sp)
 1009f54:	45400015 	stw	r21,0(r8)
 1009f58:	1c47883a 	add	r3,r3,r17
 1009f5c:	10800044 	addi	r2,r2,1
 1009f60:	d8c02015 	stw	r3,128(sp)
 1009f64:	44400115 	stw	r17,4(r8)
 1009f68:	d8801f15 	stw	r2,124(sp)
 1009f6c:	00c001c4 	movi	r3,7
 1009f70:	1880a716 	blt	r3,r2,100a210 <___vfprintf_internal_r+0x3d4>
 1009f74:	42000204 	addi	r8,r8,8
 1009f78:	d9402f17 	ldw	r5,188(sp)
 1009f7c:	2c4b883a 	add	r5,r5,r17
 1009f80:	d9402f15 	stw	r5,188(sp)
 1009f84:	80800007 	ldb	r2,0(r16)
 1009f88:	1000a826 	beq	r2,zero,100a22c <___vfprintf_internal_r+0x3f0>
 1009f8c:	84400047 	ldb	r17,1(r16)
 1009f90:	00bfffc4 	movi	r2,-1
 1009f94:	85400044 	addi	r21,r16,1
 1009f98:	d8002785 	stb	zero,158(sp)
 1009f9c:	0007883a 	mov	r3,zero
 1009fa0:	000f883a 	mov	r7,zero
 1009fa4:	d8802915 	stw	r2,164(sp)
 1009fa8:	d8003115 	stw	zero,196(sp)
 1009fac:	0025883a 	mov	r18,zero
 1009fb0:	01401604 	movi	r5,88
 1009fb4:	01800244 	movi	r6,9
 1009fb8:	02800a84 	movi	r10,42
 1009fbc:	02401b04 	movi	r9,108
 1009fc0:	ad400044 	addi	r21,r21,1
 1009fc4:	88bff804 	addi	r2,r17,-32
 1009fc8:	28830436 	bltu	r5,r2,100abdc <___vfprintf_internal_r+0xda0>
 1009fcc:	100490ba 	slli	r2,r2,2
 1009fd0:	01004074 	movhi	r4,257
 1009fd4:	2127f904 	addi	r4,r4,-24604
 1009fd8:	1105883a 	add	r2,r2,r4
 1009fdc:	10800017 	ldw	r2,0(r2)
 1009fe0:	1000683a 	jmp	r2
 1009fe4:	0100aafc 	xorhi	r4,zero,683
 1009fe8:	0100abdc 	xori	r4,zero,687
 1009fec:	0100abdc 	xori	r4,zero,687
 1009ff0:	0100ab1c 	xori	r4,zero,684
 1009ff4:	0100abdc 	xori	r4,zero,687
 1009ff8:	0100abdc 	xori	r4,zero,687
 1009ffc:	0100abdc 	xori	r4,zero,687
 100a000:	0100abdc 	xori	r4,zero,687
 100a004:	0100abdc 	xori	r4,zero,687
 100a008:	0100abdc 	xori	r4,zero,687
 100a00c:	0100a290 	cmplti	r4,zero,650
 100a010:	0100aa38 	rdprs	r4,zero,680
 100a014:	0100abdc 	xori	r4,zero,687
 100a018:	0100a158 	cmpnei	r4,zero,645
 100a01c:	0100a2b8 	rdprs	r4,zero,650
 100a020:	0100abdc 	xori	r4,zero,687
 100a024:	0100a2f8 	rdprs	r4,zero,651
 100a028:	0100a304 	movi	r4,652
 100a02c:	0100a304 	movi	r4,652
 100a030:	0100a304 	movi	r4,652
 100a034:	0100a304 	movi	r4,652
 100a038:	0100a304 	movi	r4,652
 100a03c:	0100a304 	movi	r4,652
 100a040:	0100a304 	movi	r4,652
 100a044:	0100a304 	movi	r4,652
 100a048:	0100a304 	movi	r4,652
 100a04c:	0100abdc 	xori	r4,zero,687
 100a050:	0100abdc 	xori	r4,zero,687
 100a054:	0100abdc 	xori	r4,zero,687
 100a058:	0100abdc 	xori	r4,zero,687
 100a05c:	0100abdc 	xori	r4,zero,687
 100a060:	0100abdc 	xori	r4,zero,687
 100a064:	0100abdc 	xori	r4,zero,687
 100a068:	0100abdc 	xori	r4,zero,687
 100a06c:	0100abdc 	xori	r4,zero,687
 100a070:	0100abdc 	xori	r4,zero,687
 100a074:	0100a338 	rdprs	r4,zero,652
 100a078:	0100a3f4 	movhi	r4,655
 100a07c:	0100abdc 	xori	r4,zero,687
 100a080:	0100a3f4 	movhi	r4,655
 100a084:	0100abdc 	xori	r4,zero,687
 100a088:	0100abdc 	xori	r4,zero,687
 100a08c:	0100abdc 	xori	r4,zero,687
 100a090:	0100abdc 	xori	r4,zero,687
 100a094:	0100a494 	movui	r4,658
 100a098:	0100abdc 	xori	r4,zero,687
 100a09c:	0100abdc 	xori	r4,zero,687
 100a0a0:	0100a4a0 	cmpeqi	r4,zero,658
 100a0a4:	0100abdc 	xori	r4,zero,687
 100a0a8:	0100abdc 	xori	r4,zero,687
 100a0ac:	0100abdc 	xori	r4,zero,687
 100a0b0:	0100abdc 	xori	r4,zero,687
 100a0b4:	0100abdc 	xori	r4,zero,687
 100a0b8:	0100a918 	cmpnei	r4,zero,676
 100a0bc:	0100abdc 	xori	r4,zero,687
 100a0c0:	0100abdc 	xori	r4,zero,687
 100a0c4:	0100a978 	rdprs	r4,zero,677
 100a0c8:	0100abdc 	xori	r4,zero,687
 100a0cc:	0100abdc 	xori	r4,zero,687
 100a0d0:	0100abdc 	xori	r4,zero,687
 100a0d4:	0100abdc 	xori	r4,zero,687
 100a0d8:	0100abdc 	xori	r4,zero,687
 100a0dc:	0100abdc 	xori	r4,zero,687
 100a0e0:	0100abdc 	xori	r4,zero,687
 100a0e4:	0100abdc 	xori	r4,zero,687
 100a0e8:	0100abdc 	xori	r4,zero,687
 100a0ec:	0100abdc 	xori	r4,zero,687
 100a0f0:	0100ab88 	cmpgei	r4,zero,686
 100a0f4:	0100ab28 	cmpgeui	r4,zero,684
 100a0f8:	0100a3f4 	movhi	r4,655
 100a0fc:	0100a3f4 	movhi	r4,655
 100a100:	0100a3f4 	movhi	r4,655
 100a104:	0100ab38 	rdprs	r4,zero,684
 100a108:	0100ab28 	cmpgeui	r4,zero,684
 100a10c:	0100abdc 	xori	r4,zero,687
 100a110:	0100abdc 	xori	r4,zero,687
 100a114:	0100ab44 	movi	r4,685
 100a118:	0100abdc 	xori	r4,zero,687
 100a11c:	0100ab54 	movui	r4,685
 100a120:	0100aa28 	cmpgeui	r4,zero,680
 100a124:	0100a164 	muli	r4,zero,645
 100a128:	0100aa48 	cmpgei	r4,zero,681
 100a12c:	0100abdc 	xori	r4,zero,687
 100a130:	0100aa54 	movui	r4,681
 100a134:	0100abdc 	xori	r4,zero,687
 100a138:	0100aab0 	cmpltui	r4,zero,682
 100a13c:	0100abdc 	xori	r4,zero,687
 100a140:	0100abdc 	xori	r4,zero,687
 100a144:	0100aac0 	call	100aac <__reset+0x80aac>
 100a148:	d9003117 	ldw	r4,196(sp)
 100a14c:	d8802d15 	stw	r2,180(sp)
 100a150:	0109c83a 	sub	r4,zero,r4
 100a154:	d9003115 	stw	r4,196(sp)
 100a158:	94800114 	ori	r18,r18,4
 100a15c:	ac400007 	ldb	r17,0(r21)
 100a160:	003f9706 	br	1009fc0 <__alt_data_end+0xff809fc0>
 100a164:	00800c04 	movi	r2,48
 100a168:	d9002d17 	ldw	r4,180(sp)
 100a16c:	d9402917 	ldw	r5,164(sp)
 100a170:	d8802705 	stb	r2,156(sp)
 100a174:	00801e04 	movi	r2,120
 100a178:	d8802745 	stb	r2,157(sp)
 100a17c:	d8002785 	stb	zero,158(sp)
 100a180:	20c00104 	addi	r3,r4,4
 100a184:	24c00017 	ldw	r19,0(r4)
 100a188:	002d883a 	mov	r22,zero
 100a18c:	90800094 	ori	r2,r18,2
 100a190:	28029a16 	blt	r5,zero,100abfc <___vfprintf_internal_r+0xdc0>
 100a194:	00bfdfc4 	movi	r2,-129
 100a198:	90a4703a 	and	r18,r18,r2
 100a19c:	d8c02d15 	stw	r3,180(sp)
 100a1a0:	94800094 	ori	r18,r18,2
 100a1a4:	9802871e 	bne	r19,zero,100abc4 <___vfprintf_internal_r+0xd88>
 100a1a8:	008040b4 	movhi	r2,258
 100a1ac:	10aafe04 	addi	r2,r2,-21512
 100a1b0:	d8803915 	stw	r2,228(sp)
 100a1b4:	04401e04 	movi	r17,120
 100a1b8:	d8802917 	ldw	r2,164(sp)
 100a1bc:	0039883a 	mov	fp,zero
 100a1c0:	1001e926 	beq	r2,zero,100a968 <___vfprintf_internal_r+0xb2c>
 100a1c4:	0027883a 	mov	r19,zero
 100a1c8:	002d883a 	mov	r22,zero
 100a1cc:	00020506 	br	100a9e4 <___vfprintf_internal_r+0xba8>
 100a1d0:	d9002c17 	ldw	r4,176(sp)
 100a1d4:	b80b883a 	mov	r5,r23
 100a1d8:	100c10c0 	call	100c10c <__swsetup_r>
 100a1dc:	1005ac1e 	bne	r2,zero,100b890 <___vfprintf_internal_r+0x1a54>
 100a1e0:	b880030b 	ldhu	r2,12(r23)
 100a1e4:	00c00284 	movi	r3,10
 100a1e8:	1080068c 	andi	r2,r2,26
 100a1ec:	10ff3c1e 	bne	r2,r3,1009ee0 <__alt_data_end+0xff809ee0>
 100a1f0:	b880038f 	ldh	r2,14(r23)
 100a1f4:	103f3a16 	blt	r2,zero,1009ee0 <__alt_data_end+0xff809ee0>
 100a1f8:	d9c02d17 	ldw	r7,180(sp)
 100a1fc:	d9002c17 	ldw	r4,176(sp)
 100a200:	a80d883a 	mov	r6,r21
 100a204:	b80b883a 	mov	r5,r23
 100a208:	100c0500 	call	100c050 <__sbprintf>
 100a20c:	00001106 	br	100a254 <___vfprintf_internal_r+0x418>
 100a210:	d9002c17 	ldw	r4,176(sp)
 100a214:	d9801e04 	addi	r6,sp,120
 100a218:	b80b883a 	mov	r5,r23
 100a21c:	10113300 	call	1011330 <__sprint_r>
 100a220:	1000081e 	bne	r2,zero,100a244 <___vfprintf_internal_r+0x408>
 100a224:	da000404 	addi	r8,sp,16
 100a228:	003f5306 	br	1009f78 <__alt_data_end+0xff809f78>
 100a22c:	d8802017 	ldw	r2,128(sp)
 100a230:	10000426 	beq	r2,zero,100a244 <___vfprintf_internal_r+0x408>
 100a234:	d9002c17 	ldw	r4,176(sp)
 100a238:	d9801e04 	addi	r6,sp,120
 100a23c:	b80b883a 	mov	r5,r23
 100a240:	10113300 	call	1011330 <__sprint_r>
 100a244:	b880030b 	ldhu	r2,12(r23)
 100a248:	1080100c 	andi	r2,r2,64
 100a24c:	1005901e 	bne	r2,zero,100b890 <___vfprintf_internal_r+0x1a54>
 100a250:	d8802f17 	ldw	r2,188(sp)
 100a254:	dfc04717 	ldw	ra,284(sp)
 100a258:	df004617 	ldw	fp,280(sp)
 100a25c:	ddc04517 	ldw	r23,276(sp)
 100a260:	dd804417 	ldw	r22,272(sp)
 100a264:	dd404317 	ldw	r21,268(sp)
 100a268:	dd004217 	ldw	r20,264(sp)
 100a26c:	dcc04117 	ldw	r19,260(sp)
 100a270:	dc804017 	ldw	r18,256(sp)
 100a274:	dc403f17 	ldw	r17,252(sp)
 100a278:	dc003e17 	ldw	r16,248(sp)
 100a27c:	dec04804 	addi	sp,sp,288
 100a280:	f800283a 	ret
 100a284:	d9002c17 	ldw	r4,176(sp)
 100a288:	100e0e00 	call	100e0e0 <__sinit>
 100a28c:	003f0406 	br	1009ea0 <__alt_data_end+0xff809ea0>
 100a290:	d8802d17 	ldw	r2,180(sp)
 100a294:	d9002d17 	ldw	r4,180(sp)
 100a298:	10800017 	ldw	r2,0(r2)
 100a29c:	d8803115 	stw	r2,196(sp)
 100a2a0:	20800104 	addi	r2,r4,4
 100a2a4:	d9003117 	ldw	r4,196(sp)
 100a2a8:	203fa716 	blt	r4,zero,100a148 <__alt_data_end+0xff80a148>
 100a2ac:	d8802d15 	stw	r2,180(sp)
 100a2b0:	ac400007 	ldb	r17,0(r21)
 100a2b4:	003f4206 	br	1009fc0 <__alt_data_end+0xff809fc0>
 100a2b8:	ac400007 	ldb	r17,0(r21)
 100a2bc:	aac00044 	addi	r11,r21,1
 100a2c0:	8a872826 	beq	r17,r10,100bf64 <___vfprintf_internal_r+0x2128>
 100a2c4:	88bff404 	addi	r2,r17,-48
 100a2c8:	0009883a 	mov	r4,zero
 100a2cc:	30867d36 	bltu	r6,r2,100bcc4 <___vfprintf_internal_r+0x1e88>
 100a2d0:	5c400007 	ldb	r17,0(r11)
 100a2d4:	210002a4 	muli	r4,r4,10
 100a2d8:	5d400044 	addi	r21,r11,1
 100a2dc:	a817883a 	mov	r11,r21
 100a2e0:	2089883a 	add	r4,r4,r2
 100a2e4:	88bff404 	addi	r2,r17,-48
 100a2e8:	30bff92e 	bgeu	r6,r2,100a2d0 <__alt_data_end+0xff80a2d0>
 100a2ec:	2005c916 	blt	r4,zero,100ba14 <___vfprintf_internal_r+0x1bd8>
 100a2f0:	d9002915 	stw	r4,164(sp)
 100a2f4:	003f3306 	br	1009fc4 <__alt_data_end+0xff809fc4>
 100a2f8:	94802014 	ori	r18,r18,128
 100a2fc:	ac400007 	ldb	r17,0(r21)
 100a300:	003f2f06 	br	1009fc0 <__alt_data_end+0xff809fc0>
 100a304:	a809883a 	mov	r4,r21
 100a308:	d8003115 	stw	zero,196(sp)
 100a30c:	88bff404 	addi	r2,r17,-48
 100a310:	0017883a 	mov	r11,zero
 100a314:	24400007 	ldb	r17,0(r4)
 100a318:	5ac002a4 	muli	r11,r11,10
 100a31c:	ad400044 	addi	r21,r21,1
 100a320:	a809883a 	mov	r4,r21
 100a324:	12d7883a 	add	r11,r2,r11
 100a328:	88bff404 	addi	r2,r17,-48
 100a32c:	30bff92e 	bgeu	r6,r2,100a314 <__alt_data_end+0xff80a314>
 100a330:	dac03115 	stw	r11,196(sp)
 100a334:	003f2306 	br	1009fc4 <__alt_data_end+0xff809fc4>
 100a338:	18c03fcc 	andi	r3,r3,255
 100a33c:	18072b1e 	bne	r3,zero,100bfec <___vfprintf_internal_r+0x21b0>
 100a340:	94800414 	ori	r18,r18,16
 100a344:	9080080c 	andi	r2,r18,32
 100a348:	10037b26 	beq	r2,zero,100b138 <___vfprintf_internal_r+0x12fc>
 100a34c:	d9402d17 	ldw	r5,180(sp)
 100a350:	28800117 	ldw	r2,4(r5)
 100a354:	2cc00017 	ldw	r19,0(r5)
 100a358:	29400204 	addi	r5,r5,8
 100a35c:	d9402d15 	stw	r5,180(sp)
 100a360:	102d883a 	mov	r22,r2
 100a364:	10044b16 	blt	r2,zero,100b494 <___vfprintf_internal_r+0x1658>
 100a368:	d9402917 	ldw	r5,164(sp)
 100a36c:	df002783 	ldbu	fp,158(sp)
 100a370:	2803bc16 	blt	r5,zero,100b264 <___vfprintf_internal_r+0x1428>
 100a374:	00ffdfc4 	movi	r3,-129
 100a378:	9d84b03a 	or	r2,r19,r22
 100a37c:	90e4703a 	and	r18,r18,r3
 100a380:	10017726 	beq	r2,zero,100a960 <___vfprintf_internal_r+0xb24>
 100a384:	b0038326 	beq	r22,zero,100b194 <___vfprintf_internal_r+0x1358>
 100a388:	dc402a15 	stw	r17,168(sp)
 100a38c:	dc001e04 	addi	r16,sp,120
 100a390:	b023883a 	mov	r17,r22
 100a394:	402d883a 	mov	r22,r8
 100a398:	9809883a 	mov	r4,r19
 100a39c:	880b883a 	mov	r5,r17
 100a3a0:	01800284 	movi	r6,10
 100a3a4:	000f883a 	mov	r7,zero
 100a3a8:	10137280 	call	1013728 <__umoddi3>
 100a3ac:	10800c04 	addi	r2,r2,48
 100a3b0:	843fffc4 	addi	r16,r16,-1
 100a3b4:	9809883a 	mov	r4,r19
 100a3b8:	880b883a 	mov	r5,r17
 100a3bc:	80800005 	stb	r2,0(r16)
 100a3c0:	01800284 	movi	r6,10
 100a3c4:	000f883a 	mov	r7,zero
 100a3c8:	10131b00 	call	10131b0 <__udivdi3>
 100a3cc:	1027883a 	mov	r19,r2
 100a3d0:	10c4b03a 	or	r2,r2,r3
 100a3d4:	1823883a 	mov	r17,r3
 100a3d8:	103fef1e 	bne	r2,zero,100a398 <__alt_data_end+0xff80a398>
 100a3dc:	d8c02817 	ldw	r3,160(sp)
 100a3e0:	dc402a17 	ldw	r17,168(sp)
 100a3e4:	b011883a 	mov	r8,r22
 100a3e8:	1c07c83a 	sub	r3,r3,r16
 100a3ec:	d8c02e15 	stw	r3,184(sp)
 100a3f0:	00005906 	br	100a558 <___vfprintf_internal_r+0x71c>
 100a3f4:	18c03fcc 	andi	r3,r3,255
 100a3f8:	1806fa1e 	bne	r3,zero,100bfe4 <___vfprintf_internal_r+0x21a8>
 100a3fc:	9080020c 	andi	r2,r18,8
 100a400:	10048a26 	beq	r2,zero,100b62c <___vfprintf_internal_r+0x17f0>
 100a404:	d8c02d17 	ldw	r3,180(sp)
 100a408:	d9002d17 	ldw	r4,180(sp)
 100a40c:	d9402d17 	ldw	r5,180(sp)
 100a410:	18c00017 	ldw	r3,0(r3)
 100a414:	21000117 	ldw	r4,4(r4)
 100a418:	29400204 	addi	r5,r5,8
 100a41c:	d8c03615 	stw	r3,216(sp)
 100a420:	d9003815 	stw	r4,224(sp)
 100a424:	d9402d15 	stw	r5,180(sp)
 100a428:	d9003617 	ldw	r4,216(sp)
 100a42c:	d9403817 	ldw	r5,224(sp)
 100a430:	da003d15 	stw	r8,244(sp)
 100a434:	04000044 	movi	r16,1
 100a438:	1010f540 	call	1010f54 <__fpclassifyd>
 100a43c:	da003d17 	ldw	r8,244(sp)
 100a440:	14041f1e 	bne	r2,r16,100b4c0 <___vfprintf_internal_r+0x1684>
 100a444:	d9003617 	ldw	r4,216(sp)
 100a448:	d9403817 	ldw	r5,224(sp)
 100a44c:	000d883a 	mov	r6,zero
 100a450:	000f883a 	mov	r7,zero
 100a454:	1014f580 	call	1014f58 <__ledf2>
 100a458:	da003d17 	ldw	r8,244(sp)
 100a45c:	1005be16 	blt	r2,zero,100bb58 <___vfprintf_internal_r+0x1d1c>
 100a460:	df002783 	ldbu	fp,158(sp)
 100a464:	008011c4 	movi	r2,71
 100a468:	1445330e 	bge	r2,r17,100b938 <___vfprintf_internal_r+0x1afc>
 100a46c:	040040b4 	movhi	r16,258
 100a470:	842af604 	addi	r16,r16,-21544
 100a474:	00c000c4 	movi	r3,3
 100a478:	00bfdfc4 	movi	r2,-129
 100a47c:	d8c02a15 	stw	r3,168(sp)
 100a480:	90a4703a 	and	r18,r18,r2
 100a484:	d8c02e15 	stw	r3,184(sp)
 100a488:	d8002915 	stw	zero,164(sp)
 100a48c:	d8003215 	stw	zero,200(sp)
 100a490:	00003706 	br	100a570 <___vfprintf_internal_r+0x734>
 100a494:	94800214 	ori	r18,r18,8
 100a498:	ac400007 	ldb	r17,0(r21)
 100a49c:	003ec806 	br	1009fc0 <__alt_data_end+0xff809fc0>
 100a4a0:	18c03fcc 	andi	r3,r3,255
 100a4a4:	1806db1e 	bne	r3,zero,100c014 <___vfprintf_internal_r+0x21d8>
 100a4a8:	94800414 	ori	r18,r18,16
 100a4ac:	9080080c 	andi	r2,r18,32
 100a4b0:	1002d826 	beq	r2,zero,100b014 <___vfprintf_internal_r+0x11d8>
 100a4b4:	d9402d17 	ldw	r5,180(sp)
 100a4b8:	d8c02917 	ldw	r3,164(sp)
 100a4bc:	d8002785 	stb	zero,158(sp)
 100a4c0:	28800204 	addi	r2,r5,8
 100a4c4:	2cc00017 	ldw	r19,0(r5)
 100a4c8:	2d800117 	ldw	r22,4(r5)
 100a4cc:	18048f16 	blt	r3,zero,100b70c <___vfprintf_internal_r+0x18d0>
 100a4d0:	013fdfc4 	movi	r4,-129
 100a4d4:	9d86b03a 	or	r3,r19,r22
 100a4d8:	d8802d15 	stw	r2,180(sp)
 100a4dc:	9124703a 	and	r18,r18,r4
 100a4e0:	1802d91e 	bne	r3,zero,100b048 <___vfprintf_internal_r+0x120c>
 100a4e4:	d8c02917 	ldw	r3,164(sp)
 100a4e8:	0039883a 	mov	fp,zero
 100a4ec:	1805c326 	beq	r3,zero,100bbfc <___vfprintf_internal_r+0x1dc0>
 100a4f0:	0027883a 	mov	r19,zero
 100a4f4:	002d883a 	mov	r22,zero
 100a4f8:	dc001e04 	addi	r16,sp,120
 100a4fc:	9806d0fa 	srli	r3,r19,3
 100a500:	b008977a 	slli	r4,r22,29
 100a504:	b02cd0fa 	srli	r22,r22,3
 100a508:	9cc001cc 	andi	r19,r19,7
 100a50c:	98800c04 	addi	r2,r19,48
 100a510:	843fffc4 	addi	r16,r16,-1
 100a514:	20e6b03a 	or	r19,r4,r3
 100a518:	80800005 	stb	r2,0(r16)
 100a51c:	9d86b03a 	or	r3,r19,r22
 100a520:	183ff61e 	bne	r3,zero,100a4fc <__alt_data_end+0xff80a4fc>
 100a524:	90c0004c 	andi	r3,r18,1
 100a528:	18013b26 	beq	r3,zero,100aa18 <___vfprintf_internal_r+0xbdc>
 100a52c:	10803fcc 	andi	r2,r2,255
 100a530:	1080201c 	xori	r2,r2,128
 100a534:	10bfe004 	addi	r2,r2,-128
 100a538:	00c00c04 	movi	r3,48
 100a53c:	10c13626 	beq	r2,r3,100aa18 <___vfprintf_internal_r+0xbdc>
 100a540:	80ffffc5 	stb	r3,-1(r16)
 100a544:	d8c02817 	ldw	r3,160(sp)
 100a548:	80bfffc4 	addi	r2,r16,-1
 100a54c:	1021883a 	mov	r16,r2
 100a550:	1887c83a 	sub	r3,r3,r2
 100a554:	d8c02e15 	stw	r3,184(sp)
 100a558:	d8802e17 	ldw	r2,184(sp)
 100a55c:	d9002917 	ldw	r4,164(sp)
 100a560:	1100010e 	bge	r2,r4,100a568 <___vfprintf_internal_r+0x72c>
 100a564:	2005883a 	mov	r2,r4
 100a568:	d8802a15 	stw	r2,168(sp)
 100a56c:	d8003215 	stw	zero,200(sp)
 100a570:	e7003fcc 	andi	fp,fp,255
 100a574:	e700201c 	xori	fp,fp,128
 100a578:	e73fe004 	addi	fp,fp,-128
 100a57c:	e0000326 	beq	fp,zero,100a58c <___vfprintf_internal_r+0x750>
 100a580:	d8c02a17 	ldw	r3,168(sp)
 100a584:	18c00044 	addi	r3,r3,1
 100a588:	d8c02a15 	stw	r3,168(sp)
 100a58c:	90c0008c 	andi	r3,r18,2
 100a590:	d8c02b15 	stw	r3,172(sp)
 100a594:	18000326 	beq	r3,zero,100a5a4 <___vfprintf_internal_r+0x768>
 100a598:	d8c02a17 	ldw	r3,168(sp)
 100a59c:	18c00084 	addi	r3,r3,2
 100a5a0:	d8c02a15 	stw	r3,168(sp)
 100a5a4:	90c0210c 	andi	r3,r18,132
 100a5a8:	d8c03015 	stw	r3,192(sp)
 100a5ac:	1801a31e 	bne	r3,zero,100ac3c <___vfprintf_internal_r+0xe00>
 100a5b0:	d9003117 	ldw	r4,196(sp)
 100a5b4:	d8c02a17 	ldw	r3,168(sp)
 100a5b8:	20e7c83a 	sub	r19,r4,r3
 100a5bc:	04c19f0e 	bge	zero,r19,100ac3c <___vfprintf_internal_r+0xe00>
 100a5c0:	02400404 	movi	r9,16
 100a5c4:	d8c02017 	ldw	r3,128(sp)
 100a5c8:	d8801f17 	ldw	r2,124(sp)
 100a5cc:	4cc50d0e 	bge	r9,r19,100ba04 <___vfprintf_internal_r+0x1bc8>
 100a5d0:	014040b4 	movhi	r5,258
 100a5d4:	296b0984 	addi	r5,r5,-21466
 100a5d8:	dc403b15 	stw	r17,236(sp)
 100a5dc:	d9403515 	stw	r5,212(sp)
 100a5e0:	9823883a 	mov	r17,r19
 100a5e4:	482d883a 	mov	r22,r9
 100a5e8:	9027883a 	mov	r19,r18
 100a5ec:	070001c4 	movi	fp,7
 100a5f0:	8025883a 	mov	r18,r16
 100a5f4:	dc002c17 	ldw	r16,176(sp)
 100a5f8:	00000306 	br	100a608 <___vfprintf_internal_r+0x7cc>
 100a5fc:	8c7ffc04 	addi	r17,r17,-16
 100a600:	42000204 	addi	r8,r8,8
 100a604:	b440130e 	bge	r22,r17,100a654 <___vfprintf_internal_r+0x818>
 100a608:	010040b4 	movhi	r4,258
 100a60c:	18c00404 	addi	r3,r3,16
 100a610:	10800044 	addi	r2,r2,1
 100a614:	212b0984 	addi	r4,r4,-21466
 100a618:	41000015 	stw	r4,0(r8)
 100a61c:	45800115 	stw	r22,4(r8)
 100a620:	d8c02015 	stw	r3,128(sp)
 100a624:	d8801f15 	stw	r2,124(sp)
 100a628:	e0bff40e 	bge	fp,r2,100a5fc <__alt_data_end+0xff80a5fc>
 100a62c:	d9801e04 	addi	r6,sp,120
 100a630:	b80b883a 	mov	r5,r23
 100a634:	8009883a 	mov	r4,r16
 100a638:	10113300 	call	1011330 <__sprint_r>
 100a63c:	103f011e 	bne	r2,zero,100a244 <__alt_data_end+0xff80a244>
 100a640:	8c7ffc04 	addi	r17,r17,-16
 100a644:	d8c02017 	ldw	r3,128(sp)
 100a648:	d8801f17 	ldw	r2,124(sp)
 100a64c:	da000404 	addi	r8,sp,16
 100a650:	b47fed16 	blt	r22,r17,100a608 <__alt_data_end+0xff80a608>
 100a654:	9021883a 	mov	r16,r18
 100a658:	9825883a 	mov	r18,r19
 100a65c:	8827883a 	mov	r19,r17
 100a660:	dc403b17 	ldw	r17,236(sp)
 100a664:	d9403517 	ldw	r5,212(sp)
 100a668:	98c7883a 	add	r3,r19,r3
 100a66c:	10800044 	addi	r2,r2,1
 100a670:	41400015 	stw	r5,0(r8)
 100a674:	44c00115 	stw	r19,4(r8)
 100a678:	d8c02015 	stw	r3,128(sp)
 100a67c:	d8801f15 	stw	r2,124(sp)
 100a680:	010001c4 	movi	r4,7
 100a684:	2082a316 	blt	r4,r2,100b114 <___vfprintf_internal_r+0x12d8>
 100a688:	df002787 	ldb	fp,158(sp)
 100a68c:	42000204 	addi	r8,r8,8
 100a690:	e0000c26 	beq	fp,zero,100a6c4 <___vfprintf_internal_r+0x888>
 100a694:	d8801f17 	ldw	r2,124(sp)
 100a698:	d9002784 	addi	r4,sp,158
 100a69c:	18c00044 	addi	r3,r3,1
 100a6a0:	10800044 	addi	r2,r2,1
 100a6a4:	41000015 	stw	r4,0(r8)
 100a6a8:	01000044 	movi	r4,1
 100a6ac:	41000115 	stw	r4,4(r8)
 100a6b0:	d8c02015 	stw	r3,128(sp)
 100a6b4:	d8801f15 	stw	r2,124(sp)
 100a6b8:	010001c4 	movi	r4,7
 100a6bc:	20823c16 	blt	r4,r2,100afb0 <___vfprintf_internal_r+0x1174>
 100a6c0:	42000204 	addi	r8,r8,8
 100a6c4:	d8802b17 	ldw	r2,172(sp)
 100a6c8:	10000c26 	beq	r2,zero,100a6fc <___vfprintf_internal_r+0x8c0>
 100a6cc:	d8801f17 	ldw	r2,124(sp)
 100a6d0:	d9002704 	addi	r4,sp,156
 100a6d4:	18c00084 	addi	r3,r3,2
 100a6d8:	10800044 	addi	r2,r2,1
 100a6dc:	41000015 	stw	r4,0(r8)
 100a6e0:	01000084 	movi	r4,2
 100a6e4:	41000115 	stw	r4,4(r8)
 100a6e8:	d8c02015 	stw	r3,128(sp)
 100a6ec:	d8801f15 	stw	r2,124(sp)
 100a6f0:	010001c4 	movi	r4,7
 100a6f4:	20823616 	blt	r4,r2,100afd0 <___vfprintf_internal_r+0x1194>
 100a6f8:	42000204 	addi	r8,r8,8
 100a6fc:	d9003017 	ldw	r4,192(sp)
 100a700:	00802004 	movi	r2,128
 100a704:	20819926 	beq	r4,r2,100ad6c <___vfprintf_internal_r+0xf30>
 100a708:	d9402917 	ldw	r5,164(sp)
 100a70c:	d8802e17 	ldw	r2,184(sp)
 100a710:	28adc83a 	sub	r22,r5,r2
 100a714:	0580310e 	bge	zero,r22,100a7dc <___vfprintf_internal_r+0x9a0>
 100a718:	07000404 	movi	fp,16
 100a71c:	d8801f17 	ldw	r2,124(sp)
 100a720:	e584140e 	bge	fp,r22,100b774 <___vfprintf_internal_r+0x1938>
 100a724:	014040b4 	movhi	r5,258
 100a728:	296b0584 	addi	r5,r5,-21482
 100a72c:	dc402915 	stw	r17,164(sp)
 100a730:	d9402b15 	stw	r5,172(sp)
 100a734:	b023883a 	mov	r17,r22
 100a738:	04c001c4 	movi	r19,7
 100a73c:	a82d883a 	mov	r22,r21
 100a740:	902b883a 	mov	r21,r18
 100a744:	8025883a 	mov	r18,r16
 100a748:	dc002c17 	ldw	r16,176(sp)
 100a74c:	00000306 	br	100a75c <___vfprintf_internal_r+0x920>
 100a750:	8c7ffc04 	addi	r17,r17,-16
 100a754:	42000204 	addi	r8,r8,8
 100a758:	e440110e 	bge	fp,r17,100a7a0 <___vfprintf_internal_r+0x964>
 100a75c:	18c00404 	addi	r3,r3,16
 100a760:	10800044 	addi	r2,r2,1
 100a764:	45000015 	stw	r20,0(r8)
 100a768:	47000115 	stw	fp,4(r8)
 100a76c:	d8c02015 	stw	r3,128(sp)
 100a770:	d8801f15 	stw	r2,124(sp)
 100a774:	98bff60e 	bge	r19,r2,100a750 <__alt_data_end+0xff80a750>
 100a778:	d9801e04 	addi	r6,sp,120
 100a77c:	b80b883a 	mov	r5,r23
 100a780:	8009883a 	mov	r4,r16
 100a784:	10113300 	call	1011330 <__sprint_r>
 100a788:	103eae1e 	bne	r2,zero,100a244 <__alt_data_end+0xff80a244>
 100a78c:	8c7ffc04 	addi	r17,r17,-16
 100a790:	d8c02017 	ldw	r3,128(sp)
 100a794:	d8801f17 	ldw	r2,124(sp)
 100a798:	da000404 	addi	r8,sp,16
 100a79c:	e47fef16 	blt	fp,r17,100a75c <__alt_data_end+0xff80a75c>
 100a7a0:	9021883a 	mov	r16,r18
 100a7a4:	a825883a 	mov	r18,r21
 100a7a8:	b02b883a 	mov	r21,r22
 100a7ac:	882d883a 	mov	r22,r17
 100a7b0:	dc402917 	ldw	r17,164(sp)
 100a7b4:	d9002b17 	ldw	r4,172(sp)
 100a7b8:	1d87883a 	add	r3,r3,r22
 100a7bc:	10800044 	addi	r2,r2,1
 100a7c0:	41000015 	stw	r4,0(r8)
 100a7c4:	45800115 	stw	r22,4(r8)
 100a7c8:	d8c02015 	stw	r3,128(sp)
 100a7cc:	d8801f15 	stw	r2,124(sp)
 100a7d0:	010001c4 	movi	r4,7
 100a7d4:	2081ee16 	blt	r4,r2,100af90 <___vfprintf_internal_r+0x1154>
 100a7d8:	42000204 	addi	r8,r8,8
 100a7dc:	9080400c 	andi	r2,r18,256
 100a7e0:	1001181e 	bne	r2,zero,100ac44 <___vfprintf_internal_r+0xe08>
 100a7e4:	d9402e17 	ldw	r5,184(sp)
 100a7e8:	d8801f17 	ldw	r2,124(sp)
 100a7ec:	44000015 	stw	r16,0(r8)
 100a7f0:	1947883a 	add	r3,r3,r5
 100a7f4:	10800044 	addi	r2,r2,1
 100a7f8:	41400115 	stw	r5,4(r8)
 100a7fc:	d8c02015 	stw	r3,128(sp)
 100a800:	d8801f15 	stw	r2,124(sp)
 100a804:	010001c4 	movi	r4,7
 100a808:	2081d316 	blt	r4,r2,100af58 <___vfprintf_internal_r+0x111c>
 100a80c:	42000204 	addi	r8,r8,8
 100a810:	9480010c 	andi	r18,r18,4
 100a814:	90003226 	beq	r18,zero,100a8e0 <___vfprintf_internal_r+0xaa4>
 100a818:	d9403117 	ldw	r5,196(sp)
 100a81c:	d8802a17 	ldw	r2,168(sp)
 100a820:	28a1c83a 	sub	r16,r5,r2
 100a824:	04002e0e 	bge	zero,r16,100a8e0 <___vfprintf_internal_r+0xaa4>
 100a828:	04400404 	movi	r17,16
 100a82c:	d8801f17 	ldw	r2,124(sp)
 100a830:	8c04a20e 	bge	r17,r16,100babc <___vfprintf_internal_r+0x1c80>
 100a834:	014040b4 	movhi	r5,258
 100a838:	296b0984 	addi	r5,r5,-21466
 100a83c:	d9403515 	stw	r5,212(sp)
 100a840:	048001c4 	movi	r18,7
 100a844:	dcc02c17 	ldw	r19,176(sp)
 100a848:	00000306 	br	100a858 <___vfprintf_internal_r+0xa1c>
 100a84c:	843ffc04 	addi	r16,r16,-16
 100a850:	42000204 	addi	r8,r8,8
 100a854:	8c00130e 	bge	r17,r16,100a8a4 <___vfprintf_internal_r+0xa68>
 100a858:	010040b4 	movhi	r4,258
 100a85c:	18c00404 	addi	r3,r3,16
 100a860:	10800044 	addi	r2,r2,1
 100a864:	212b0984 	addi	r4,r4,-21466
 100a868:	41000015 	stw	r4,0(r8)
 100a86c:	44400115 	stw	r17,4(r8)
 100a870:	d8c02015 	stw	r3,128(sp)
 100a874:	d8801f15 	stw	r2,124(sp)
 100a878:	90bff40e 	bge	r18,r2,100a84c <__alt_data_end+0xff80a84c>
 100a87c:	d9801e04 	addi	r6,sp,120
 100a880:	b80b883a 	mov	r5,r23
 100a884:	9809883a 	mov	r4,r19
 100a888:	10113300 	call	1011330 <__sprint_r>
 100a88c:	103e6d1e 	bne	r2,zero,100a244 <__alt_data_end+0xff80a244>
 100a890:	843ffc04 	addi	r16,r16,-16
 100a894:	d8c02017 	ldw	r3,128(sp)
 100a898:	d8801f17 	ldw	r2,124(sp)
 100a89c:	da000404 	addi	r8,sp,16
 100a8a0:	8c3fed16 	blt	r17,r16,100a858 <__alt_data_end+0xff80a858>
 100a8a4:	d9403517 	ldw	r5,212(sp)
 100a8a8:	1c07883a 	add	r3,r3,r16
 100a8ac:	10800044 	addi	r2,r2,1
 100a8b0:	41400015 	stw	r5,0(r8)
 100a8b4:	44000115 	stw	r16,4(r8)
 100a8b8:	d8c02015 	stw	r3,128(sp)
 100a8bc:	d8801f15 	stw	r2,124(sp)
 100a8c0:	010001c4 	movi	r4,7
 100a8c4:	2080060e 	bge	r4,r2,100a8e0 <___vfprintf_internal_r+0xaa4>
 100a8c8:	d9002c17 	ldw	r4,176(sp)
 100a8cc:	d9801e04 	addi	r6,sp,120
 100a8d0:	b80b883a 	mov	r5,r23
 100a8d4:	10113300 	call	1011330 <__sprint_r>
 100a8d8:	103e5a1e 	bne	r2,zero,100a244 <__alt_data_end+0xff80a244>
 100a8dc:	d8c02017 	ldw	r3,128(sp)
 100a8e0:	d8803117 	ldw	r2,196(sp)
 100a8e4:	d9002a17 	ldw	r4,168(sp)
 100a8e8:	1100010e 	bge	r2,r4,100a8f0 <___vfprintf_internal_r+0xab4>
 100a8ec:	2005883a 	mov	r2,r4
 100a8f0:	d9402f17 	ldw	r5,188(sp)
 100a8f4:	288b883a 	add	r5,r5,r2
 100a8f8:	d9402f15 	stw	r5,188(sp)
 100a8fc:	18019e1e 	bne	r3,zero,100af78 <___vfprintf_internal_r+0x113c>
 100a900:	a8800007 	ldb	r2,0(r21)
 100a904:	d8001f15 	stw	zero,124(sp)
 100a908:	da000404 	addi	r8,sp,16
 100a90c:	103d851e 	bne	r2,zero,1009f24 <__alt_data_end+0xff809f24>
 100a910:	a821883a 	mov	r16,r21
 100a914:	003d9b06 	br	1009f84 <__alt_data_end+0xff809f84>
 100a918:	18c03fcc 	andi	r3,r3,255
 100a91c:	1805c11e 	bne	r3,zero,100c024 <___vfprintf_internal_r+0x21e8>
 100a920:	94800414 	ori	r18,r18,16
 100a924:	9080080c 	andi	r2,r18,32
 100a928:	10020c26 	beq	r2,zero,100b15c <___vfprintf_internal_r+0x1320>
 100a92c:	d8802d17 	ldw	r2,180(sp)
 100a930:	d9002917 	ldw	r4,164(sp)
 100a934:	d8002785 	stb	zero,158(sp)
 100a938:	10c00204 	addi	r3,r2,8
 100a93c:	14c00017 	ldw	r19,0(r2)
 100a940:	15800117 	ldw	r22,4(r2)
 100a944:	20040f16 	blt	r4,zero,100b984 <___vfprintf_internal_r+0x1b48>
 100a948:	013fdfc4 	movi	r4,-129
 100a94c:	9d84b03a 	or	r2,r19,r22
 100a950:	d8c02d15 	stw	r3,180(sp)
 100a954:	9124703a 	and	r18,r18,r4
 100a958:	0039883a 	mov	fp,zero
 100a95c:	103e891e 	bne	r2,zero,100a384 <__alt_data_end+0xff80a384>
 100a960:	d9002917 	ldw	r4,164(sp)
 100a964:	2002c11e 	bne	r4,zero,100b46c <___vfprintf_internal_r+0x1630>
 100a968:	d8002915 	stw	zero,164(sp)
 100a96c:	d8002e15 	stw	zero,184(sp)
 100a970:	dc001e04 	addi	r16,sp,120
 100a974:	003ef806 	br	100a558 <__alt_data_end+0xff80a558>
 100a978:	18c03fcc 	andi	r3,r3,255
 100a97c:	18059d1e 	bne	r3,zero,100bff4 <___vfprintf_internal_r+0x21b8>
 100a980:	014040b4 	movhi	r5,258
 100a984:	296af904 	addi	r5,r5,-21532
 100a988:	d9403915 	stw	r5,228(sp)
 100a98c:	9080080c 	andi	r2,r18,32
 100a990:	10005226 	beq	r2,zero,100aadc <___vfprintf_internal_r+0xca0>
 100a994:	d8802d17 	ldw	r2,180(sp)
 100a998:	14c00017 	ldw	r19,0(r2)
 100a99c:	15800117 	ldw	r22,4(r2)
 100a9a0:	10800204 	addi	r2,r2,8
 100a9a4:	d8802d15 	stw	r2,180(sp)
 100a9a8:	9080004c 	andi	r2,r18,1
 100a9ac:	10019026 	beq	r2,zero,100aff0 <___vfprintf_internal_r+0x11b4>
 100a9b0:	9d84b03a 	or	r2,r19,r22
 100a9b4:	10036926 	beq	r2,zero,100b75c <___vfprintf_internal_r+0x1920>
 100a9b8:	d8c02917 	ldw	r3,164(sp)
 100a9bc:	00800c04 	movi	r2,48
 100a9c0:	d8802705 	stb	r2,156(sp)
 100a9c4:	dc402745 	stb	r17,157(sp)
 100a9c8:	d8002785 	stb	zero,158(sp)
 100a9cc:	90800094 	ori	r2,r18,2
 100a9d0:	18045d16 	blt	r3,zero,100bb48 <___vfprintf_internal_r+0x1d0c>
 100a9d4:	00bfdfc4 	movi	r2,-129
 100a9d8:	90a4703a 	and	r18,r18,r2
 100a9dc:	94800094 	ori	r18,r18,2
 100a9e0:	0039883a 	mov	fp,zero
 100a9e4:	d9003917 	ldw	r4,228(sp)
 100a9e8:	dc001e04 	addi	r16,sp,120
 100a9ec:	988003cc 	andi	r2,r19,15
 100a9f0:	b006973a 	slli	r3,r22,28
 100a9f4:	2085883a 	add	r2,r4,r2
 100a9f8:	9826d13a 	srli	r19,r19,4
 100a9fc:	10800003 	ldbu	r2,0(r2)
 100aa00:	b02cd13a 	srli	r22,r22,4
 100aa04:	843fffc4 	addi	r16,r16,-1
 100aa08:	1ce6b03a 	or	r19,r3,r19
 100aa0c:	80800005 	stb	r2,0(r16)
 100aa10:	9d84b03a 	or	r2,r19,r22
 100aa14:	103ff51e 	bne	r2,zero,100a9ec <__alt_data_end+0xff80a9ec>
 100aa18:	d8c02817 	ldw	r3,160(sp)
 100aa1c:	1c07c83a 	sub	r3,r3,r16
 100aa20:	d8c02e15 	stw	r3,184(sp)
 100aa24:	003ecc06 	br	100a558 <__alt_data_end+0xff80a558>
 100aa28:	18c03fcc 	andi	r3,r3,255
 100aa2c:	183e9f26 	beq	r3,zero,100a4ac <__alt_data_end+0xff80a4ac>
 100aa30:	d9c02785 	stb	r7,158(sp)
 100aa34:	003e9d06 	br	100a4ac <__alt_data_end+0xff80a4ac>
 100aa38:	00c00044 	movi	r3,1
 100aa3c:	01c00ac4 	movi	r7,43
 100aa40:	ac400007 	ldb	r17,0(r21)
 100aa44:	003d5e06 	br	1009fc0 <__alt_data_end+0xff809fc0>
 100aa48:	94800814 	ori	r18,r18,32
 100aa4c:	ac400007 	ldb	r17,0(r21)
 100aa50:	003d5b06 	br	1009fc0 <__alt_data_end+0xff809fc0>
 100aa54:	d8c02d17 	ldw	r3,180(sp)
 100aa58:	d8002785 	stb	zero,158(sp)
 100aa5c:	1c000017 	ldw	r16,0(r3)
 100aa60:	1cc00104 	addi	r19,r3,4
 100aa64:	80041926 	beq	r16,zero,100bacc <___vfprintf_internal_r+0x1c90>
 100aa68:	d9002917 	ldw	r4,164(sp)
 100aa6c:	2003d016 	blt	r4,zero,100b9b0 <___vfprintf_internal_r+0x1b74>
 100aa70:	200d883a 	mov	r6,r4
 100aa74:	000b883a 	mov	r5,zero
 100aa78:	8009883a 	mov	r4,r16
 100aa7c:	da003d15 	stw	r8,244(sp)
 100aa80:	100f64c0 	call	100f64c <memchr>
 100aa84:	da003d17 	ldw	r8,244(sp)
 100aa88:	10045426 	beq	r2,zero,100bbdc <___vfprintf_internal_r+0x1da0>
 100aa8c:	1405c83a 	sub	r2,r2,r16
 100aa90:	d8802e15 	stw	r2,184(sp)
 100aa94:	1003cc16 	blt	r2,zero,100b9c8 <___vfprintf_internal_r+0x1b8c>
 100aa98:	df002783 	ldbu	fp,158(sp)
 100aa9c:	d8802a15 	stw	r2,168(sp)
 100aaa0:	dcc02d15 	stw	r19,180(sp)
 100aaa4:	d8002915 	stw	zero,164(sp)
 100aaa8:	d8003215 	stw	zero,200(sp)
 100aaac:	003eb006 	br	100a570 <__alt_data_end+0xff80a570>
 100aab0:	18c03fcc 	andi	r3,r3,255
 100aab4:	183f9b26 	beq	r3,zero,100a924 <__alt_data_end+0xff80a924>
 100aab8:	d9c02785 	stb	r7,158(sp)
 100aabc:	003f9906 	br	100a924 <__alt_data_end+0xff80a924>
 100aac0:	18c03fcc 	andi	r3,r3,255
 100aac4:	1805551e 	bne	r3,zero,100c01c <___vfprintf_internal_r+0x21e0>
 100aac8:	014040b4 	movhi	r5,258
 100aacc:	296afe04 	addi	r5,r5,-21512
 100aad0:	d9403915 	stw	r5,228(sp)
 100aad4:	9080080c 	andi	r2,r18,32
 100aad8:	103fae1e 	bne	r2,zero,100a994 <__alt_data_end+0xff80a994>
 100aadc:	9080040c 	andi	r2,r18,16
 100aae0:	1002de26 	beq	r2,zero,100b65c <___vfprintf_internal_r+0x1820>
 100aae4:	d8c02d17 	ldw	r3,180(sp)
 100aae8:	002d883a 	mov	r22,zero
 100aaec:	1cc00017 	ldw	r19,0(r3)
 100aaf0:	18c00104 	addi	r3,r3,4
 100aaf4:	d8c02d15 	stw	r3,180(sp)
 100aaf8:	003fab06 	br	100a9a8 <__alt_data_end+0xff80a9a8>
 100aafc:	38803fcc 	andi	r2,r7,255
 100ab00:	1080201c 	xori	r2,r2,128
 100ab04:	10bfe004 	addi	r2,r2,-128
 100ab08:	1002d21e 	bne	r2,zero,100b654 <___vfprintf_internal_r+0x1818>
 100ab0c:	00c00044 	movi	r3,1
 100ab10:	01c00804 	movi	r7,32
 100ab14:	ac400007 	ldb	r17,0(r21)
 100ab18:	003d2906 	br	1009fc0 <__alt_data_end+0xff809fc0>
 100ab1c:	94800054 	ori	r18,r18,1
 100ab20:	ac400007 	ldb	r17,0(r21)
 100ab24:	003d2606 	br	1009fc0 <__alt_data_end+0xff809fc0>
 100ab28:	18c03fcc 	andi	r3,r3,255
 100ab2c:	183e0526 	beq	r3,zero,100a344 <__alt_data_end+0xff80a344>
 100ab30:	d9c02785 	stb	r7,158(sp)
 100ab34:	003e0306 	br	100a344 <__alt_data_end+0xff80a344>
 100ab38:	94801014 	ori	r18,r18,64
 100ab3c:	ac400007 	ldb	r17,0(r21)
 100ab40:	003d1f06 	br	1009fc0 <__alt_data_end+0xff809fc0>
 100ab44:	ac400007 	ldb	r17,0(r21)
 100ab48:	8a438726 	beq	r17,r9,100b968 <___vfprintf_internal_r+0x1b2c>
 100ab4c:	94800414 	ori	r18,r18,16
 100ab50:	003d1b06 	br	1009fc0 <__alt_data_end+0xff809fc0>
 100ab54:	18c03fcc 	andi	r3,r3,255
 100ab58:	1805341e 	bne	r3,zero,100c02c <___vfprintf_internal_r+0x21f0>
 100ab5c:	9080080c 	andi	r2,r18,32
 100ab60:	1002cd26 	beq	r2,zero,100b698 <___vfprintf_internal_r+0x185c>
 100ab64:	d9402d17 	ldw	r5,180(sp)
 100ab68:	d9002f17 	ldw	r4,188(sp)
 100ab6c:	28800017 	ldw	r2,0(r5)
 100ab70:	2007d7fa 	srai	r3,r4,31
 100ab74:	29400104 	addi	r5,r5,4
 100ab78:	d9402d15 	stw	r5,180(sp)
 100ab7c:	11000015 	stw	r4,0(r2)
 100ab80:	10c00115 	stw	r3,4(r2)
 100ab84:	003ce506 	br	1009f1c <__alt_data_end+0xff809f1c>
 100ab88:	d8c02d17 	ldw	r3,180(sp)
 100ab8c:	d9002d17 	ldw	r4,180(sp)
 100ab90:	d8002785 	stb	zero,158(sp)
 100ab94:	18800017 	ldw	r2,0(r3)
 100ab98:	21000104 	addi	r4,r4,4
 100ab9c:	00c00044 	movi	r3,1
 100aba0:	d8c02a15 	stw	r3,168(sp)
 100aba4:	d8801405 	stb	r2,80(sp)
 100aba8:	d9002d15 	stw	r4,180(sp)
 100abac:	d8c02e15 	stw	r3,184(sp)
 100abb0:	d8002915 	stw	zero,164(sp)
 100abb4:	d8003215 	stw	zero,200(sp)
 100abb8:	dc001404 	addi	r16,sp,80
 100abbc:	0039883a 	mov	fp,zero
 100abc0:	003e7206 	br	100a58c <__alt_data_end+0xff80a58c>
 100abc4:	010040b4 	movhi	r4,258
 100abc8:	212afe04 	addi	r4,r4,-21512
 100abcc:	0039883a 	mov	fp,zero
 100abd0:	d9003915 	stw	r4,228(sp)
 100abd4:	04401e04 	movi	r17,120
 100abd8:	003f8206 	br	100a9e4 <__alt_data_end+0xff80a9e4>
 100abdc:	18c03fcc 	andi	r3,r3,255
 100abe0:	1805061e 	bne	r3,zero,100bffc <___vfprintf_internal_r+0x21c0>
 100abe4:	883d9126 	beq	r17,zero,100a22c <__alt_data_end+0xff80a22c>
 100abe8:	00c00044 	movi	r3,1
 100abec:	d8c02a15 	stw	r3,168(sp)
 100abf0:	dc401405 	stb	r17,80(sp)
 100abf4:	d8002785 	stb	zero,158(sp)
 100abf8:	003fec06 	br	100abac <__alt_data_end+0xff80abac>
 100abfc:	014040b4 	movhi	r5,258
 100ac00:	296afe04 	addi	r5,r5,-21512
 100ac04:	d9403915 	stw	r5,228(sp)
 100ac08:	d8c02d15 	stw	r3,180(sp)
 100ac0c:	1025883a 	mov	r18,r2
 100ac10:	04401e04 	movi	r17,120
 100ac14:	9d84b03a 	or	r2,r19,r22
 100ac18:	1000fc1e 	bne	r2,zero,100b00c <___vfprintf_internal_r+0x11d0>
 100ac1c:	0039883a 	mov	fp,zero
 100ac20:	00800084 	movi	r2,2
 100ac24:	10803fcc 	andi	r2,r2,255
 100ac28:	00c00044 	movi	r3,1
 100ac2c:	10c20f26 	beq	r2,r3,100b46c <___vfprintf_internal_r+0x1630>
 100ac30:	00c00084 	movi	r3,2
 100ac34:	10fd6326 	beq	r2,r3,100a1c4 <__alt_data_end+0xff80a1c4>
 100ac38:	003e2d06 	br	100a4f0 <__alt_data_end+0xff80a4f0>
 100ac3c:	d8c02017 	ldw	r3,128(sp)
 100ac40:	003e9306 	br	100a690 <__alt_data_end+0xff80a690>
 100ac44:	00801944 	movi	r2,101
 100ac48:	14407e0e 	bge	r2,r17,100ae44 <___vfprintf_internal_r+0x1008>
 100ac4c:	d9003617 	ldw	r4,216(sp)
 100ac50:	d9403817 	ldw	r5,224(sp)
 100ac54:	000d883a 	mov	r6,zero
 100ac58:	000f883a 	mov	r7,zero
 100ac5c:	d8c03c15 	stw	r3,240(sp)
 100ac60:	da003d15 	stw	r8,244(sp)
 100ac64:	1014df40 	call	1014df4 <__eqdf2>
 100ac68:	d8c03c17 	ldw	r3,240(sp)
 100ac6c:	da003d17 	ldw	r8,244(sp)
 100ac70:	1000f71e 	bne	r2,zero,100b050 <___vfprintf_internal_r+0x1214>
 100ac74:	d8801f17 	ldw	r2,124(sp)
 100ac78:	010040b4 	movhi	r4,258
 100ac7c:	212b0504 	addi	r4,r4,-21484
 100ac80:	18c00044 	addi	r3,r3,1
 100ac84:	10800044 	addi	r2,r2,1
 100ac88:	41000015 	stw	r4,0(r8)
 100ac8c:	01000044 	movi	r4,1
 100ac90:	41000115 	stw	r4,4(r8)
 100ac94:	d8c02015 	stw	r3,128(sp)
 100ac98:	d8801f15 	stw	r2,124(sp)
 100ac9c:	010001c4 	movi	r4,7
 100aca0:	2082b816 	blt	r4,r2,100b784 <___vfprintf_internal_r+0x1948>
 100aca4:	42000204 	addi	r8,r8,8
 100aca8:	d8802617 	ldw	r2,152(sp)
 100acac:	d9403317 	ldw	r5,204(sp)
 100acb0:	11400216 	blt	r2,r5,100acbc <___vfprintf_internal_r+0xe80>
 100acb4:	9080004c 	andi	r2,r18,1
 100acb8:	103ed526 	beq	r2,zero,100a810 <__alt_data_end+0xff80a810>
 100acbc:	d8803717 	ldw	r2,220(sp)
 100acc0:	d9003417 	ldw	r4,208(sp)
 100acc4:	d9403717 	ldw	r5,220(sp)
 100acc8:	1887883a 	add	r3,r3,r2
 100accc:	d8801f17 	ldw	r2,124(sp)
 100acd0:	41000015 	stw	r4,0(r8)
 100acd4:	41400115 	stw	r5,4(r8)
 100acd8:	10800044 	addi	r2,r2,1
 100acdc:	d8c02015 	stw	r3,128(sp)
 100ace0:	d8801f15 	stw	r2,124(sp)
 100ace4:	010001c4 	movi	r4,7
 100ace8:	20832916 	blt	r4,r2,100b990 <___vfprintf_internal_r+0x1b54>
 100acec:	42000204 	addi	r8,r8,8
 100acf0:	d8803317 	ldw	r2,204(sp)
 100acf4:	143fffc4 	addi	r16,r2,-1
 100acf8:	043ec50e 	bge	zero,r16,100a810 <__alt_data_end+0xff80a810>
 100acfc:	04400404 	movi	r17,16
 100ad00:	d8801f17 	ldw	r2,124(sp)
 100ad04:	8c00880e 	bge	r17,r16,100af28 <___vfprintf_internal_r+0x10ec>
 100ad08:	014040b4 	movhi	r5,258
 100ad0c:	296b0584 	addi	r5,r5,-21482
 100ad10:	d9402b15 	stw	r5,172(sp)
 100ad14:	058001c4 	movi	r22,7
 100ad18:	dcc02c17 	ldw	r19,176(sp)
 100ad1c:	00000306 	br	100ad2c <___vfprintf_internal_r+0xef0>
 100ad20:	42000204 	addi	r8,r8,8
 100ad24:	843ffc04 	addi	r16,r16,-16
 100ad28:	8c00820e 	bge	r17,r16,100af34 <___vfprintf_internal_r+0x10f8>
 100ad2c:	18c00404 	addi	r3,r3,16
 100ad30:	10800044 	addi	r2,r2,1
 100ad34:	45000015 	stw	r20,0(r8)
 100ad38:	44400115 	stw	r17,4(r8)
 100ad3c:	d8c02015 	stw	r3,128(sp)
 100ad40:	d8801f15 	stw	r2,124(sp)
 100ad44:	b0bff60e 	bge	r22,r2,100ad20 <__alt_data_end+0xff80ad20>
 100ad48:	d9801e04 	addi	r6,sp,120
 100ad4c:	b80b883a 	mov	r5,r23
 100ad50:	9809883a 	mov	r4,r19
 100ad54:	10113300 	call	1011330 <__sprint_r>
 100ad58:	103d3a1e 	bne	r2,zero,100a244 <__alt_data_end+0xff80a244>
 100ad5c:	d8c02017 	ldw	r3,128(sp)
 100ad60:	d8801f17 	ldw	r2,124(sp)
 100ad64:	da000404 	addi	r8,sp,16
 100ad68:	003fee06 	br	100ad24 <__alt_data_end+0xff80ad24>
 100ad6c:	d9403117 	ldw	r5,196(sp)
 100ad70:	d8802a17 	ldw	r2,168(sp)
 100ad74:	28adc83a 	sub	r22,r5,r2
 100ad78:	05be630e 	bge	zero,r22,100a708 <__alt_data_end+0xff80a708>
 100ad7c:	07000404 	movi	fp,16
 100ad80:	d8801f17 	ldw	r2,124(sp)
 100ad84:	e5838f0e 	bge	fp,r22,100bbc4 <___vfprintf_internal_r+0x1d88>
 100ad88:	014040b4 	movhi	r5,258
 100ad8c:	296b0584 	addi	r5,r5,-21482
 100ad90:	dc403015 	stw	r17,192(sp)
 100ad94:	d9402b15 	stw	r5,172(sp)
 100ad98:	b023883a 	mov	r17,r22
 100ad9c:	04c001c4 	movi	r19,7
 100ada0:	a82d883a 	mov	r22,r21
 100ada4:	902b883a 	mov	r21,r18
 100ada8:	8025883a 	mov	r18,r16
 100adac:	dc002c17 	ldw	r16,176(sp)
 100adb0:	00000306 	br	100adc0 <___vfprintf_internal_r+0xf84>
 100adb4:	8c7ffc04 	addi	r17,r17,-16
 100adb8:	42000204 	addi	r8,r8,8
 100adbc:	e440110e 	bge	fp,r17,100ae04 <___vfprintf_internal_r+0xfc8>
 100adc0:	18c00404 	addi	r3,r3,16
 100adc4:	10800044 	addi	r2,r2,1
 100adc8:	45000015 	stw	r20,0(r8)
 100adcc:	47000115 	stw	fp,4(r8)
 100add0:	d8c02015 	stw	r3,128(sp)
 100add4:	d8801f15 	stw	r2,124(sp)
 100add8:	98bff60e 	bge	r19,r2,100adb4 <__alt_data_end+0xff80adb4>
 100addc:	d9801e04 	addi	r6,sp,120
 100ade0:	b80b883a 	mov	r5,r23
 100ade4:	8009883a 	mov	r4,r16
 100ade8:	10113300 	call	1011330 <__sprint_r>
 100adec:	103d151e 	bne	r2,zero,100a244 <__alt_data_end+0xff80a244>
 100adf0:	8c7ffc04 	addi	r17,r17,-16
 100adf4:	d8c02017 	ldw	r3,128(sp)
 100adf8:	d8801f17 	ldw	r2,124(sp)
 100adfc:	da000404 	addi	r8,sp,16
 100ae00:	e47fef16 	blt	fp,r17,100adc0 <__alt_data_end+0xff80adc0>
 100ae04:	9021883a 	mov	r16,r18
 100ae08:	a825883a 	mov	r18,r21
 100ae0c:	b02b883a 	mov	r21,r22
 100ae10:	882d883a 	mov	r22,r17
 100ae14:	dc403017 	ldw	r17,192(sp)
 100ae18:	d9002b17 	ldw	r4,172(sp)
 100ae1c:	1d87883a 	add	r3,r3,r22
 100ae20:	10800044 	addi	r2,r2,1
 100ae24:	41000015 	stw	r4,0(r8)
 100ae28:	45800115 	stw	r22,4(r8)
 100ae2c:	d8c02015 	stw	r3,128(sp)
 100ae30:	d8801f15 	stw	r2,124(sp)
 100ae34:	010001c4 	movi	r4,7
 100ae38:	20818e16 	blt	r4,r2,100b474 <___vfprintf_internal_r+0x1638>
 100ae3c:	42000204 	addi	r8,r8,8
 100ae40:	003e3106 	br	100a708 <__alt_data_end+0xff80a708>
 100ae44:	d9403317 	ldw	r5,204(sp)
 100ae48:	00800044 	movi	r2,1
 100ae4c:	18c00044 	addi	r3,r3,1
 100ae50:	1141530e 	bge	r2,r5,100b3a0 <___vfprintf_internal_r+0x1564>
 100ae54:	dc401f17 	ldw	r17,124(sp)
 100ae58:	00800044 	movi	r2,1
 100ae5c:	40800115 	stw	r2,4(r8)
 100ae60:	8c400044 	addi	r17,r17,1
 100ae64:	44000015 	stw	r16,0(r8)
 100ae68:	d8c02015 	stw	r3,128(sp)
 100ae6c:	dc401f15 	stw	r17,124(sp)
 100ae70:	008001c4 	movi	r2,7
 100ae74:	14416b16 	blt	r2,r17,100b424 <___vfprintf_internal_r+0x15e8>
 100ae78:	42000204 	addi	r8,r8,8
 100ae7c:	d8803717 	ldw	r2,220(sp)
 100ae80:	d9003417 	ldw	r4,208(sp)
 100ae84:	8c400044 	addi	r17,r17,1
 100ae88:	10c7883a 	add	r3,r2,r3
 100ae8c:	40800115 	stw	r2,4(r8)
 100ae90:	41000015 	stw	r4,0(r8)
 100ae94:	d8c02015 	stw	r3,128(sp)
 100ae98:	dc401f15 	stw	r17,124(sp)
 100ae9c:	008001c4 	movi	r2,7
 100aea0:	14416916 	blt	r2,r17,100b448 <___vfprintf_internal_r+0x160c>
 100aea4:	45800204 	addi	r22,r8,8
 100aea8:	d9003617 	ldw	r4,216(sp)
 100aeac:	d9403817 	ldw	r5,224(sp)
 100aeb0:	000d883a 	mov	r6,zero
 100aeb4:	000f883a 	mov	r7,zero
 100aeb8:	d8c03c15 	stw	r3,240(sp)
 100aebc:	1014df40 	call	1014df4 <__eqdf2>
 100aec0:	d8c03c17 	ldw	r3,240(sp)
 100aec4:	1000bc26 	beq	r2,zero,100b1b8 <___vfprintf_internal_r+0x137c>
 100aec8:	d9403317 	ldw	r5,204(sp)
 100aecc:	84000044 	addi	r16,r16,1
 100aed0:	8c400044 	addi	r17,r17,1
 100aed4:	28bfffc4 	addi	r2,r5,-1
 100aed8:	1887883a 	add	r3,r3,r2
 100aedc:	b0800115 	stw	r2,4(r22)
 100aee0:	b4000015 	stw	r16,0(r22)
 100aee4:	d8c02015 	stw	r3,128(sp)
 100aee8:	dc401f15 	stw	r17,124(sp)
 100aeec:	008001c4 	movi	r2,7
 100aef0:	14414316 	blt	r2,r17,100b400 <___vfprintf_internal_r+0x15c4>
 100aef4:	b5800204 	addi	r22,r22,8
 100aef8:	d9003a17 	ldw	r4,232(sp)
 100aefc:	df0022c4 	addi	fp,sp,139
 100af00:	8c400044 	addi	r17,r17,1
 100af04:	20c7883a 	add	r3,r4,r3
 100af08:	b7000015 	stw	fp,0(r22)
 100af0c:	b1000115 	stw	r4,4(r22)
 100af10:	d8c02015 	stw	r3,128(sp)
 100af14:	dc401f15 	stw	r17,124(sp)
 100af18:	008001c4 	movi	r2,7
 100af1c:	14400e16 	blt	r2,r17,100af58 <___vfprintf_internal_r+0x111c>
 100af20:	b2000204 	addi	r8,r22,8
 100af24:	003e3a06 	br	100a810 <__alt_data_end+0xff80a810>
 100af28:	010040b4 	movhi	r4,258
 100af2c:	212b0584 	addi	r4,r4,-21482
 100af30:	d9002b15 	stw	r4,172(sp)
 100af34:	d9002b17 	ldw	r4,172(sp)
 100af38:	1c07883a 	add	r3,r3,r16
 100af3c:	44000115 	stw	r16,4(r8)
 100af40:	41000015 	stw	r4,0(r8)
 100af44:	10800044 	addi	r2,r2,1
 100af48:	d8c02015 	stw	r3,128(sp)
 100af4c:	d8801f15 	stw	r2,124(sp)
 100af50:	010001c4 	movi	r4,7
 100af54:	20be2d0e 	bge	r4,r2,100a80c <__alt_data_end+0xff80a80c>
 100af58:	d9002c17 	ldw	r4,176(sp)
 100af5c:	d9801e04 	addi	r6,sp,120
 100af60:	b80b883a 	mov	r5,r23
 100af64:	10113300 	call	1011330 <__sprint_r>
 100af68:	103cb61e 	bne	r2,zero,100a244 <__alt_data_end+0xff80a244>
 100af6c:	d8c02017 	ldw	r3,128(sp)
 100af70:	da000404 	addi	r8,sp,16
 100af74:	003e2606 	br	100a810 <__alt_data_end+0xff80a810>
 100af78:	d9002c17 	ldw	r4,176(sp)
 100af7c:	d9801e04 	addi	r6,sp,120
 100af80:	b80b883a 	mov	r5,r23
 100af84:	10113300 	call	1011330 <__sprint_r>
 100af88:	103e5d26 	beq	r2,zero,100a900 <__alt_data_end+0xff80a900>
 100af8c:	003cad06 	br	100a244 <__alt_data_end+0xff80a244>
 100af90:	d9002c17 	ldw	r4,176(sp)
 100af94:	d9801e04 	addi	r6,sp,120
 100af98:	b80b883a 	mov	r5,r23
 100af9c:	10113300 	call	1011330 <__sprint_r>
 100afa0:	103ca81e 	bne	r2,zero,100a244 <__alt_data_end+0xff80a244>
 100afa4:	d8c02017 	ldw	r3,128(sp)
 100afa8:	da000404 	addi	r8,sp,16
 100afac:	003e0b06 	br	100a7dc <__alt_data_end+0xff80a7dc>
 100afb0:	d9002c17 	ldw	r4,176(sp)
 100afb4:	d9801e04 	addi	r6,sp,120
 100afb8:	b80b883a 	mov	r5,r23
 100afbc:	10113300 	call	1011330 <__sprint_r>
 100afc0:	103ca01e 	bne	r2,zero,100a244 <__alt_data_end+0xff80a244>
 100afc4:	d8c02017 	ldw	r3,128(sp)
 100afc8:	da000404 	addi	r8,sp,16
 100afcc:	003dbd06 	br	100a6c4 <__alt_data_end+0xff80a6c4>
 100afd0:	d9002c17 	ldw	r4,176(sp)
 100afd4:	d9801e04 	addi	r6,sp,120
 100afd8:	b80b883a 	mov	r5,r23
 100afdc:	10113300 	call	1011330 <__sprint_r>
 100afe0:	103c981e 	bne	r2,zero,100a244 <__alt_data_end+0xff80a244>
 100afe4:	d8c02017 	ldw	r3,128(sp)
 100afe8:	da000404 	addi	r8,sp,16
 100afec:	003dc306 	br	100a6fc <__alt_data_end+0xff80a6fc>
 100aff0:	d8802917 	ldw	r2,164(sp)
 100aff4:	d8002785 	stb	zero,158(sp)
 100aff8:	103f0616 	blt	r2,zero,100ac14 <__alt_data_end+0xff80ac14>
 100affc:	00ffdfc4 	movi	r3,-129
 100b000:	9d84b03a 	or	r2,r19,r22
 100b004:	90e4703a 	and	r18,r18,r3
 100b008:	103c6b26 	beq	r2,zero,100a1b8 <__alt_data_end+0xff80a1b8>
 100b00c:	0039883a 	mov	fp,zero
 100b010:	003e7406 	br	100a9e4 <__alt_data_end+0xff80a9e4>
 100b014:	9080040c 	andi	r2,r18,16
 100b018:	1001b326 	beq	r2,zero,100b6e8 <___vfprintf_internal_r+0x18ac>
 100b01c:	d9002d17 	ldw	r4,180(sp)
 100b020:	d9402917 	ldw	r5,164(sp)
 100b024:	d8002785 	stb	zero,158(sp)
 100b028:	20800104 	addi	r2,r4,4
 100b02c:	24c00017 	ldw	r19,0(r4)
 100b030:	002d883a 	mov	r22,zero
 100b034:	2801b516 	blt	r5,zero,100b70c <___vfprintf_internal_r+0x18d0>
 100b038:	00ffdfc4 	movi	r3,-129
 100b03c:	d8802d15 	stw	r2,180(sp)
 100b040:	90e4703a 	and	r18,r18,r3
 100b044:	983d2726 	beq	r19,zero,100a4e4 <__alt_data_end+0xff80a4e4>
 100b048:	0039883a 	mov	fp,zero
 100b04c:	003d2a06 	br	100a4f8 <__alt_data_end+0xff80a4f8>
 100b050:	dc402617 	ldw	r17,152(sp)
 100b054:	0441d30e 	bge	zero,r17,100b7a4 <___vfprintf_internal_r+0x1968>
 100b058:	dc403217 	ldw	r17,200(sp)
 100b05c:	d8803317 	ldw	r2,204(sp)
 100b060:	1440010e 	bge	r2,r17,100b068 <___vfprintf_internal_r+0x122c>
 100b064:	1023883a 	mov	r17,r2
 100b068:	04400a0e 	bge	zero,r17,100b094 <___vfprintf_internal_r+0x1258>
 100b06c:	d8801f17 	ldw	r2,124(sp)
 100b070:	1c47883a 	add	r3,r3,r17
 100b074:	44000015 	stw	r16,0(r8)
 100b078:	10800044 	addi	r2,r2,1
 100b07c:	44400115 	stw	r17,4(r8)
 100b080:	d8c02015 	stw	r3,128(sp)
 100b084:	d8801f15 	stw	r2,124(sp)
 100b088:	010001c4 	movi	r4,7
 100b08c:	20826516 	blt	r4,r2,100ba24 <___vfprintf_internal_r+0x1be8>
 100b090:	42000204 	addi	r8,r8,8
 100b094:	88026116 	blt	r17,zero,100ba1c <___vfprintf_internal_r+0x1be0>
 100b098:	d9003217 	ldw	r4,200(sp)
 100b09c:	2463c83a 	sub	r17,r4,r17
 100b0a0:	04407b0e 	bge	zero,r17,100b290 <___vfprintf_internal_r+0x1454>
 100b0a4:	05800404 	movi	r22,16
 100b0a8:	d8801f17 	ldw	r2,124(sp)
 100b0ac:	b4419d0e 	bge	r22,r17,100b724 <___vfprintf_internal_r+0x18e8>
 100b0b0:	010040b4 	movhi	r4,258
 100b0b4:	212b0584 	addi	r4,r4,-21482
 100b0b8:	d9002b15 	stw	r4,172(sp)
 100b0bc:	070001c4 	movi	fp,7
 100b0c0:	dcc02c17 	ldw	r19,176(sp)
 100b0c4:	00000306 	br	100b0d4 <___vfprintf_internal_r+0x1298>
 100b0c8:	42000204 	addi	r8,r8,8
 100b0cc:	8c7ffc04 	addi	r17,r17,-16
 100b0d0:	b441970e 	bge	r22,r17,100b730 <___vfprintf_internal_r+0x18f4>
 100b0d4:	18c00404 	addi	r3,r3,16
 100b0d8:	10800044 	addi	r2,r2,1
 100b0dc:	45000015 	stw	r20,0(r8)
 100b0e0:	45800115 	stw	r22,4(r8)
 100b0e4:	d8c02015 	stw	r3,128(sp)
 100b0e8:	d8801f15 	stw	r2,124(sp)
 100b0ec:	e0bff60e 	bge	fp,r2,100b0c8 <__alt_data_end+0xff80b0c8>
 100b0f0:	d9801e04 	addi	r6,sp,120
 100b0f4:	b80b883a 	mov	r5,r23
 100b0f8:	9809883a 	mov	r4,r19
 100b0fc:	10113300 	call	1011330 <__sprint_r>
 100b100:	103c501e 	bne	r2,zero,100a244 <__alt_data_end+0xff80a244>
 100b104:	d8c02017 	ldw	r3,128(sp)
 100b108:	d8801f17 	ldw	r2,124(sp)
 100b10c:	da000404 	addi	r8,sp,16
 100b110:	003fee06 	br	100b0cc <__alt_data_end+0xff80b0cc>
 100b114:	d9002c17 	ldw	r4,176(sp)
 100b118:	d9801e04 	addi	r6,sp,120
 100b11c:	b80b883a 	mov	r5,r23
 100b120:	10113300 	call	1011330 <__sprint_r>
 100b124:	103c471e 	bne	r2,zero,100a244 <__alt_data_end+0xff80a244>
 100b128:	d8c02017 	ldw	r3,128(sp)
 100b12c:	df002787 	ldb	fp,158(sp)
 100b130:	da000404 	addi	r8,sp,16
 100b134:	003d5606 	br	100a690 <__alt_data_end+0xff80a690>
 100b138:	9080040c 	andi	r2,r18,16
 100b13c:	10016126 	beq	r2,zero,100b6c4 <___vfprintf_internal_r+0x1888>
 100b140:	d8802d17 	ldw	r2,180(sp)
 100b144:	14c00017 	ldw	r19,0(r2)
 100b148:	10800104 	addi	r2,r2,4
 100b14c:	d8802d15 	stw	r2,180(sp)
 100b150:	982dd7fa 	srai	r22,r19,31
 100b154:	b005883a 	mov	r2,r22
 100b158:	003c8206 	br	100a364 <__alt_data_end+0xff80a364>
 100b15c:	9080040c 	andi	r2,r18,16
 100b160:	10003526 	beq	r2,zero,100b238 <___vfprintf_internal_r+0x13fc>
 100b164:	d9402d17 	ldw	r5,180(sp)
 100b168:	d8c02917 	ldw	r3,164(sp)
 100b16c:	d8002785 	stb	zero,158(sp)
 100b170:	28800104 	addi	r2,r5,4
 100b174:	2cc00017 	ldw	r19,0(r5)
 100b178:	002d883a 	mov	r22,zero
 100b17c:	18003716 	blt	r3,zero,100b25c <___vfprintf_internal_r+0x1420>
 100b180:	00ffdfc4 	movi	r3,-129
 100b184:	d8802d15 	stw	r2,180(sp)
 100b188:	90e4703a 	and	r18,r18,r3
 100b18c:	0039883a 	mov	fp,zero
 100b190:	983df326 	beq	r19,zero,100a960 <__alt_data_end+0xff80a960>
 100b194:	00800244 	movi	r2,9
 100b198:	14fc7b36 	bltu	r2,r19,100a388 <__alt_data_end+0xff80a388>
 100b19c:	d8c02817 	ldw	r3,160(sp)
 100b1a0:	dc001dc4 	addi	r16,sp,119
 100b1a4:	9cc00c04 	addi	r19,r19,48
 100b1a8:	1c07c83a 	sub	r3,r3,r16
 100b1ac:	dcc01dc5 	stb	r19,119(sp)
 100b1b0:	d8c02e15 	stw	r3,184(sp)
 100b1b4:	003ce806 	br	100a558 <__alt_data_end+0xff80a558>
 100b1b8:	d8803317 	ldw	r2,204(sp)
 100b1bc:	143fffc4 	addi	r16,r2,-1
 100b1c0:	043f4d0e 	bge	zero,r16,100aef8 <__alt_data_end+0xff80aef8>
 100b1c4:	07000404 	movi	fp,16
 100b1c8:	e400810e 	bge	fp,r16,100b3d0 <___vfprintf_internal_r+0x1594>
 100b1cc:	014040b4 	movhi	r5,258
 100b1d0:	296b0584 	addi	r5,r5,-21482
 100b1d4:	d9402b15 	stw	r5,172(sp)
 100b1d8:	01c001c4 	movi	r7,7
 100b1dc:	dcc02c17 	ldw	r19,176(sp)
 100b1e0:	00000306 	br	100b1f0 <___vfprintf_internal_r+0x13b4>
 100b1e4:	b5800204 	addi	r22,r22,8
 100b1e8:	843ffc04 	addi	r16,r16,-16
 100b1ec:	e4007b0e 	bge	fp,r16,100b3dc <___vfprintf_internal_r+0x15a0>
 100b1f0:	18c00404 	addi	r3,r3,16
 100b1f4:	8c400044 	addi	r17,r17,1
 100b1f8:	b5000015 	stw	r20,0(r22)
 100b1fc:	b7000115 	stw	fp,4(r22)
 100b200:	d8c02015 	stw	r3,128(sp)
 100b204:	dc401f15 	stw	r17,124(sp)
 100b208:	3c7ff60e 	bge	r7,r17,100b1e4 <__alt_data_end+0xff80b1e4>
 100b20c:	d9801e04 	addi	r6,sp,120
 100b210:	b80b883a 	mov	r5,r23
 100b214:	9809883a 	mov	r4,r19
 100b218:	d9c03c15 	stw	r7,240(sp)
 100b21c:	10113300 	call	1011330 <__sprint_r>
 100b220:	d9c03c17 	ldw	r7,240(sp)
 100b224:	103c071e 	bne	r2,zero,100a244 <__alt_data_end+0xff80a244>
 100b228:	d8c02017 	ldw	r3,128(sp)
 100b22c:	dc401f17 	ldw	r17,124(sp)
 100b230:	dd800404 	addi	r22,sp,16
 100b234:	003fec06 	br	100b1e8 <__alt_data_end+0xff80b1e8>
 100b238:	9080100c 	andi	r2,r18,64
 100b23c:	d8002785 	stb	zero,158(sp)
 100b240:	10010e26 	beq	r2,zero,100b67c <___vfprintf_internal_r+0x1840>
 100b244:	d9002d17 	ldw	r4,180(sp)
 100b248:	d9402917 	ldw	r5,164(sp)
 100b24c:	002d883a 	mov	r22,zero
 100b250:	20800104 	addi	r2,r4,4
 100b254:	24c0000b 	ldhu	r19,0(r4)
 100b258:	283fc90e 	bge	r5,zero,100b180 <__alt_data_end+0xff80b180>
 100b25c:	d8802d15 	stw	r2,180(sp)
 100b260:	0039883a 	mov	fp,zero
 100b264:	9d84b03a 	or	r2,r19,r22
 100b268:	103c461e 	bne	r2,zero,100a384 <__alt_data_end+0xff80a384>
 100b26c:	00800044 	movi	r2,1
 100b270:	003e6c06 	br	100ac24 <__alt_data_end+0xff80ac24>
 100b274:	d9002c17 	ldw	r4,176(sp)
 100b278:	d9801e04 	addi	r6,sp,120
 100b27c:	b80b883a 	mov	r5,r23
 100b280:	10113300 	call	1011330 <__sprint_r>
 100b284:	103bef1e 	bne	r2,zero,100a244 <__alt_data_end+0xff80a244>
 100b288:	d8c02017 	ldw	r3,128(sp)
 100b28c:	da000404 	addi	r8,sp,16
 100b290:	d9003217 	ldw	r4,200(sp)
 100b294:	d8802617 	ldw	r2,152(sp)
 100b298:	d9403317 	ldw	r5,204(sp)
 100b29c:	8123883a 	add	r17,r16,r4
 100b2a0:	11400216 	blt	r2,r5,100b2ac <___vfprintf_internal_r+0x1470>
 100b2a4:	9100004c 	andi	r4,r18,1
 100b2a8:	20000d26 	beq	r4,zero,100b2e0 <___vfprintf_internal_r+0x14a4>
 100b2ac:	d9003717 	ldw	r4,220(sp)
 100b2b0:	d9403417 	ldw	r5,208(sp)
 100b2b4:	1907883a 	add	r3,r3,r4
 100b2b8:	d9001f17 	ldw	r4,124(sp)
 100b2bc:	41400015 	stw	r5,0(r8)
 100b2c0:	d9403717 	ldw	r5,220(sp)
 100b2c4:	21000044 	addi	r4,r4,1
 100b2c8:	d8c02015 	stw	r3,128(sp)
 100b2cc:	41400115 	stw	r5,4(r8)
 100b2d0:	d9001f15 	stw	r4,124(sp)
 100b2d4:	014001c4 	movi	r5,7
 100b2d8:	2901e816 	blt	r5,r4,100ba7c <___vfprintf_internal_r+0x1c40>
 100b2dc:	42000204 	addi	r8,r8,8
 100b2e0:	d9003317 	ldw	r4,204(sp)
 100b2e4:	8121883a 	add	r16,r16,r4
 100b2e8:	2085c83a 	sub	r2,r4,r2
 100b2ec:	8461c83a 	sub	r16,r16,r17
 100b2f0:	1400010e 	bge	r2,r16,100b2f8 <___vfprintf_internal_r+0x14bc>
 100b2f4:	1021883a 	mov	r16,r2
 100b2f8:	04000a0e 	bge	zero,r16,100b324 <___vfprintf_internal_r+0x14e8>
 100b2fc:	d9001f17 	ldw	r4,124(sp)
 100b300:	1c07883a 	add	r3,r3,r16
 100b304:	44400015 	stw	r17,0(r8)
 100b308:	21000044 	addi	r4,r4,1
 100b30c:	44000115 	stw	r16,4(r8)
 100b310:	d8c02015 	stw	r3,128(sp)
 100b314:	d9001f15 	stw	r4,124(sp)
 100b318:	014001c4 	movi	r5,7
 100b31c:	2901fb16 	blt	r5,r4,100bb0c <___vfprintf_internal_r+0x1cd0>
 100b320:	42000204 	addi	r8,r8,8
 100b324:	8001f716 	blt	r16,zero,100bb04 <___vfprintf_internal_r+0x1cc8>
 100b328:	1421c83a 	sub	r16,r2,r16
 100b32c:	043d380e 	bge	zero,r16,100a810 <__alt_data_end+0xff80a810>
 100b330:	04400404 	movi	r17,16
 100b334:	d8801f17 	ldw	r2,124(sp)
 100b338:	8c3efb0e 	bge	r17,r16,100af28 <__alt_data_end+0xff80af28>
 100b33c:	014040b4 	movhi	r5,258
 100b340:	296b0584 	addi	r5,r5,-21482
 100b344:	d9402b15 	stw	r5,172(sp)
 100b348:	058001c4 	movi	r22,7
 100b34c:	dcc02c17 	ldw	r19,176(sp)
 100b350:	00000306 	br	100b360 <___vfprintf_internal_r+0x1524>
 100b354:	42000204 	addi	r8,r8,8
 100b358:	843ffc04 	addi	r16,r16,-16
 100b35c:	8c3ef50e 	bge	r17,r16,100af34 <__alt_data_end+0xff80af34>
 100b360:	18c00404 	addi	r3,r3,16
 100b364:	10800044 	addi	r2,r2,1
 100b368:	45000015 	stw	r20,0(r8)
 100b36c:	44400115 	stw	r17,4(r8)
 100b370:	d8c02015 	stw	r3,128(sp)
 100b374:	d8801f15 	stw	r2,124(sp)
 100b378:	b0bff60e 	bge	r22,r2,100b354 <__alt_data_end+0xff80b354>
 100b37c:	d9801e04 	addi	r6,sp,120
 100b380:	b80b883a 	mov	r5,r23
 100b384:	9809883a 	mov	r4,r19
 100b388:	10113300 	call	1011330 <__sprint_r>
 100b38c:	103bad1e 	bne	r2,zero,100a244 <__alt_data_end+0xff80a244>
 100b390:	d8c02017 	ldw	r3,128(sp)
 100b394:	d8801f17 	ldw	r2,124(sp)
 100b398:	da000404 	addi	r8,sp,16
 100b39c:	003fee06 	br	100b358 <__alt_data_end+0xff80b358>
 100b3a0:	9088703a 	and	r4,r18,r2
 100b3a4:	203eab1e 	bne	r4,zero,100ae54 <__alt_data_end+0xff80ae54>
 100b3a8:	dc401f17 	ldw	r17,124(sp)
 100b3ac:	40800115 	stw	r2,4(r8)
 100b3b0:	44000015 	stw	r16,0(r8)
 100b3b4:	8c400044 	addi	r17,r17,1
 100b3b8:	d8c02015 	stw	r3,128(sp)
 100b3bc:	dc401f15 	stw	r17,124(sp)
 100b3c0:	008001c4 	movi	r2,7
 100b3c4:	14400e16 	blt	r2,r17,100b400 <___vfprintf_internal_r+0x15c4>
 100b3c8:	45800204 	addi	r22,r8,8
 100b3cc:	003eca06 	br	100aef8 <__alt_data_end+0xff80aef8>
 100b3d0:	010040b4 	movhi	r4,258
 100b3d4:	212b0584 	addi	r4,r4,-21482
 100b3d8:	d9002b15 	stw	r4,172(sp)
 100b3dc:	d8802b17 	ldw	r2,172(sp)
 100b3e0:	1c07883a 	add	r3,r3,r16
 100b3e4:	8c400044 	addi	r17,r17,1
 100b3e8:	b0800015 	stw	r2,0(r22)
 100b3ec:	b4000115 	stw	r16,4(r22)
 100b3f0:	d8c02015 	stw	r3,128(sp)
 100b3f4:	dc401f15 	stw	r17,124(sp)
 100b3f8:	008001c4 	movi	r2,7
 100b3fc:	147ebd0e 	bge	r2,r17,100aef4 <__alt_data_end+0xff80aef4>
 100b400:	d9002c17 	ldw	r4,176(sp)
 100b404:	d9801e04 	addi	r6,sp,120
 100b408:	b80b883a 	mov	r5,r23
 100b40c:	10113300 	call	1011330 <__sprint_r>
 100b410:	103b8c1e 	bne	r2,zero,100a244 <__alt_data_end+0xff80a244>
 100b414:	d8c02017 	ldw	r3,128(sp)
 100b418:	dc401f17 	ldw	r17,124(sp)
 100b41c:	dd800404 	addi	r22,sp,16
 100b420:	003eb506 	br	100aef8 <__alt_data_end+0xff80aef8>
 100b424:	d9002c17 	ldw	r4,176(sp)
 100b428:	d9801e04 	addi	r6,sp,120
 100b42c:	b80b883a 	mov	r5,r23
 100b430:	10113300 	call	1011330 <__sprint_r>
 100b434:	103b831e 	bne	r2,zero,100a244 <__alt_data_end+0xff80a244>
 100b438:	d8c02017 	ldw	r3,128(sp)
 100b43c:	dc401f17 	ldw	r17,124(sp)
 100b440:	da000404 	addi	r8,sp,16
 100b444:	003e8d06 	br	100ae7c <__alt_data_end+0xff80ae7c>
 100b448:	d9002c17 	ldw	r4,176(sp)
 100b44c:	d9801e04 	addi	r6,sp,120
 100b450:	b80b883a 	mov	r5,r23
 100b454:	10113300 	call	1011330 <__sprint_r>
 100b458:	103b7a1e 	bne	r2,zero,100a244 <__alt_data_end+0xff80a244>
 100b45c:	d8c02017 	ldw	r3,128(sp)
 100b460:	dc401f17 	ldw	r17,124(sp)
 100b464:	dd800404 	addi	r22,sp,16
 100b468:	003e8f06 	br	100aea8 <__alt_data_end+0xff80aea8>
 100b46c:	0027883a 	mov	r19,zero
 100b470:	003f4a06 	br	100b19c <__alt_data_end+0xff80b19c>
 100b474:	d9002c17 	ldw	r4,176(sp)
 100b478:	d9801e04 	addi	r6,sp,120
 100b47c:	b80b883a 	mov	r5,r23
 100b480:	10113300 	call	1011330 <__sprint_r>
 100b484:	103b6f1e 	bne	r2,zero,100a244 <__alt_data_end+0xff80a244>
 100b488:	d8c02017 	ldw	r3,128(sp)
 100b48c:	da000404 	addi	r8,sp,16
 100b490:	003c9d06 	br	100a708 <__alt_data_end+0xff80a708>
 100b494:	04e7c83a 	sub	r19,zero,r19
 100b498:	9804c03a 	cmpne	r2,r19,zero
 100b49c:	05adc83a 	sub	r22,zero,r22
 100b4a0:	b0adc83a 	sub	r22,r22,r2
 100b4a4:	d8802917 	ldw	r2,164(sp)
 100b4a8:	07000b44 	movi	fp,45
 100b4ac:	df002785 	stb	fp,158(sp)
 100b4b0:	10017b16 	blt	r2,zero,100baa0 <___vfprintf_internal_r+0x1c64>
 100b4b4:	00bfdfc4 	movi	r2,-129
 100b4b8:	90a4703a 	and	r18,r18,r2
 100b4bc:	003bb106 	br	100a384 <__alt_data_end+0xff80a384>
 100b4c0:	d9003617 	ldw	r4,216(sp)
 100b4c4:	d9403817 	ldw	r5,224(sp)
 100b4c8:	da003d15 	stw	r8,244(sp)
 100b4cc:	1010f540 	call	1010f54 <__fpclassifyd>
 100b4d0:	da003d17 	ldw	r8,244(sp)
 100b4d4:	1000f026 	beq	r2,zero,100b898 <___vfprintf_internal_r+0x1a5c>
 100b4d8:	d9002917 	ldw	r4,164(sp)
 100b4dc:	05bff7c4 	movi	r22,-33
 100b4e0:	00bfffc4 	movi	r2,-1
 100b4e4:	8dac703a 	and	r22,r17,r22
 100b4e8:	20820026 	beq	r4,r2,100bcec <___vfprintf_internal_r+0x1eb0>
 100b4ec:	008011c4 	movi	r2,71
 100b4f0:	b081f726 	beq	r22,r2,100bcd0 <___vfprintf_internal_r+0x1e94>
 100b4f4:	d9003817 	ldw	r4,224(sp)
 100b4f8:	90c04014 	ori	r3,r18,256
 100b4fc:	d8c02b15 	stw	r3,172(sp)
 100b500:	20021516 	blt	r4,zero,100bd58 <___vfprintf_internal_r+0x1f1c>
 100b504:	dcc03817 	ldw	r19,224(sp)
 100b508:	d8002a05 	stb	zero,168(sp)
 100b50c:	00801984 	movi	r2,102
 100b510:	8881f926 	beq	r17,r2,100bcf8 <___vfprintf_internal_r+0x1ebc>
 100b514:	00801184 	movi	r2,70
 100b518:	88821c26 	beq	r17,r2,100bd8c <___vfprintf_internal_r+0x1f50>
 100b51c:	00801144 	movi	r2,69
 100b520:	b081ef26 	beq	r22,r2,100bce0 <___vfprintf_internal_r+0x1ea4>
 100b524:	d8c02917 	ldw	r3,164(sp)
 100b528:	d8802104 	addi	r2,sp,132
 100b52c:	d8800315 	stw	r2,12(sp)
 100b530:	d9403617 	ldw	r5,216(sp)
 100b534:	d8802504 	addi	r2,sp,148
 100b538:	d9002c17 	ldw	r4,176(sp)
 100b53c:	d8800215 	stw	r2,8(sp)
 100b540:	d8802604 	addi	r2,sp,152
 100b544:	d8c00015 	stw	r3,0(sp)
 100b548:	d8800115 	stw	r2,4(sp)
 100b54c:	01c00084 	movi	r7,2
 100b550:	980d883a 	mov	r6,r19
 100b554:	d8c03c15 	stw	r3,240(sp)
 100b558:	da003d15 	stw	r8,244(sp)
 100b55c:	100c4600 	call	100c460 <_dtoa_r>
 100b560:	1021883a 	mov	r16,r2
 100b564:	008019c4 	movi	r2,103
 100b568:	d8c03c17 	ldw	r3,240(sp)
 100b56c:	da003d17 	ldw	r8,244(sp)
 100b570:	88817126 	beq	r17,r2,100bb38 <___vfprintf_internal_r+0x1cfc>
 100b574:	008011c4 	movi	r2,71
 100b578:	88829226 	beq	r17,r2,100bfc4 <___vfprintf_internal_r+0x2188>
 100b57c:	80f9883a 	add	fp,r16,r3
 100b580:	d9003617 	ldw	r4,216(sp)
 100b584:	000d883a 	mov	r6,zero
 100b588:	000f883a 	mov	r7,zero
 100b58c:	980b883a 	mov	r5,r19
 100b590:	da003d15 	stw	r8,244(sp)
 100b594:	1014df40 	call	1014df4 <__eqdf2>
 100b598:	da003d17 	ldw	r8,244(sp)
 100b59c:	10018d26 	beq	r2,zero,100bbd4 <___vfprintf_internal_r+0x1d98>
 100b5a0:	d8802117 	ldw	r2,132(sp)
 100b5a4:	1700062e 	bgeu	r2,fp,100b5c0 <___vfprintf_internal_r+0x1784>
 100b5a8:	01000c04 	movi	r4,48
 100b5ac:	10c00044 	addi	r3,r2,1
 100b5b0:	d8c02115 	stw	r3,132(sp)
 100b5b4:	11000005 	stb	r4,0(r2)
 100b5b8:	d8802117 	ldw	r2,132(sp)
 100b5bc:	173ffb36 	bltu	r2,fp,100b5ac <__alt_data_end+0xff80b5ac>
 100b5c0:	1405c83a 	sub	r2,r2,r16
 100b5c4:	d8803315 	stw	r2,204(sp)
 100b5c8:	008011c4 	movi	r2,71
 100b5cc:	b0817626 	beq	r22,r2,100bba8 <___vfprintf_internal_r+0x1d6c>
 100b5d0:	00801944 	movi	r2,101
 100b5d4:	1442810e 	bge	r2,r17,100bfdc <___vfprintf_internal_r+0x21a0>
 100b5d8:	d8c02617 	ldw	r3,152(sp)
 100b5dc:	00801984 	movi	r2,102
 100b5e0:	d8c03215 	stw	r3,200(sp)
 100b5e4:	8881fe26 	beq	r17,r2,100bde0 <___vfprintf_internal_r+0x1fa4>
 100b5e8:	d8c03217 	ldw	r3,200(sp)
 100b5ec:	d9003317 	ldw	r4,204(sp)
 100b5f0:	1901dd16 	blt	r3,r4,100bd68 <___vfprintf_internal_r+0x1f2c>
 100b5f4:	9480004c 	andi	r18,r18,1
 100b5f8:	90022b1e 	bne	r18,zero,100bea8 <___vfprintf_internal_r+0x206c>
 100b5fc:	1805883a 	mov	r2,r3
 100b600:	18028016 	blt	r3,zero,100c004 <___vfprintf_internal_r+0x21c8>
 100b604:	d8c03217 	ldw	r3,200(sp)
 100b608:	044019c4 	movi	r17,103
 100b60c:	d8c02e15 	stw	r3,184(sp)
 100b610:	df002a07 	ldb	fp,168(sp)
 100b614:	e001531e 	bne	fp,zero,100bb64 <___vfprintf_internal_r+0x1d28>
 100b618:	df002783 	ldbu	fp,158(sp)
 100b61c:	d8802a15 	stw	r2,168(sp)
 100b620:	dc802b17 	ldw	r18,172(sp)
 100b624:	d8002915 	stw	zero,164(sp)
 100b628:	003bd106 	br	100a570 <__alt_data_end+0xff80a570>
 100b62c:	d8802d17 	ldw	r2,180(sp)
 100b630:	d8c02d17 	ldw	r3,180(sp)
 100b634:	d9002d17 	ldw	r4,180(sp)
 100b638:	10800017 	ldw	r2,0(r2)
 100b63c:	18c00117 	ldw	r3,4(r3)
 100b640:	21000204 	addi	r4,r4,8
 100b644:	d8803615 	stw	r2,216(sp)
 100b648:	d8c03815 	stw	r3,224(sp)
 100b64c:	d9002d15 	stw	r4,180(sp)
 100b650:	003b7506 	br	100a428 <__alt_data_end+0xff80a428>
 100b654:	ac400007 	ldb	r17,0(r21)
 100b658:	003a5906 	br	1009fc0 <__alt_data_end+0xff809fc0>
 100b65c:	9080100c 	andi	r2,r18,64
 100b660:	1000a826 	beq	r2,zero,100b904 <___vfprintf_internal_r+0x1ac8>
 100b664:	d9002d17 	ldw	r4,180(sp)
 100b668:	002d883a 	mov	r22,zero
 100b66c:	24c0000b 	ldhu	r19,0(r4)
 100b670:	21000104 	addi	r4,r4,4
 100b674:	d9002d15 	stw	r4,180(sp)
 100b678:	003ccb06 	br	100a9a8 <__alt_data_end+0xff80a9a8>
 100b67c:	d8c02d17 	ldw	r3,180(sp)
 100b680:	d9002917 	ldw	r4,164(sp)
 100b684:	002d883a 	mov	r22,zero
 100b688:	18800104 	addi	r2,r3,4
 100b68c:	1cc00017 	ldw	r19,0(r3)
 100b690:	203ebb0e 	bge	r4,zero,100b180 <__alt_data_end+0xff80b180>
 100b694:	003ef106 	br	100b25c <__alt_data_end+0xff80b25c>
 100b698:	9080040c 	andi	r2,r18,16
 100b69c:	1000921e 	bne	r2,zero,100b8e8 <___vfprintf_internal_r+0x1aac>
 100b6a0:	9480100c 	andi	r18,r18,64
 100b6a4:	90013926 	beq	r18,zero,100bb8c <___vfprintf_internal_r+0x1d50>
 100b6a8:	d9002d17 	ldw	r4,180(sp)
 100b6ac:	d9402f17 	ldw	r5,188(sp)
 100b6b0:	20800017 	ldw	r2,0(r4)
 100b6b4:	21000104 	addi	r4,r4,4
 100b6b8:	d9002d15 	stw	r4,180(sp)
 100b6bc:	1140000d 	sth	r5,0(r2)
 100b6c0:	003a1606 	br	1009f1c <__alt_data_end+0xff809f1c>
 100b6c4:	9080100c 	andi	r2,r18,64
 100b6c8:	10008026 	beq	r2,zero,100b8cc <___vfprintf_internal_r+0x1a90>
 100b6cc:	d8c02d17 	ldw	r3,180(sp)
 100b6d0:	1cc0000f 	ldh	r19,0(r3)
 100b6d4:	18c00104 	addi	r3,r3,4
 100b6d8:	d8c02d15 	stw	r3,180(sp)
 100b6dc:	982dd7fa 	srai	r22,r19,31
 100b6e0:	b005883a 	mov	r2,r22
 100b6e4:	003b1f06 	br	100a364 <__alt_data_end+0xff80a364>
 100b6e8:	9080100c 	andi	r2,r18,64
 100b6ec:	d8002785 	stb	zero,158(sp)
 100b6f0:	10008a1e 	bne	r2,zero,100b91c <___vfprintf_internal_r+0x1ae0>
 100b6f4:	d9402d17 	ldw	r5,180(sp)
 100b6f8:	d8c02917 	ldw	r3,164(sp)
 100b6fc:	002d883a 	mov	r22,zero
 100b700:	28800104 	addi	r2,r5,4
 100b704:	2cc00017 	ldw	r19,0(r5)
 100b708:	183e4b0e 	bge	r3,zero,100b038 <__alt_data_end+0xff80b038>
 100b70c:	9d86b03a 	or	r3,r19,r22
 100b710:	d8802d15 	stw	r2,180(sp)
 100b714:	183e4c1e 	bne	r3,zero,100b048 <__alt_data_end+0xff80b048>
 100b718:	0039883a 	mov	fp,zero
 100b71c:	0005883a 	mov	r2,zero
 100b720:	003d4006 	br	100ac24 <__alt_data_end+0xff80ac24>
 100b724:	014040b4 	movhi	r5,258
 100b728:	296b0584 	addi	r5,r5,-21482
 100b72c:	d9402b15 	stw	r5,172(sp)
 100b730:	d9402b17 	ldw	r5,172(sp)
 100b734:	1c47883a 	add	r3,r3,r17
 100b738:	10800044 	addi	r2,r2,1
 100b73c:	41400015 	stw	r5,0(r8)
 100b740:	44400115 	stw	r17,4(r8)
 100b744:	d8c02015 	stw	r3,128(sp)
 100b748:	d8801f15 	stw	r2,124(sp)
 100b74c:	010001c4 	movi	r4,7
 100b750:	20bec816 	blt	r4,r2,100b274 <__alt_data_end+0xff80b274>
 100b754:	42000204 	addi	r8,r8,8
 100b758:	003ecd06 	br	100b290 <__alt_data_end+0xff80b290>
 100b75c:	d9002917 	ldw	r4,164(sp)
 100b760:	d8002785 	stb	zero,158(sp)
 100b764:	203d2d16 	blt	r4,zero,100ac1c <__alt_data_end+0xff80ac1c>
 100b768:	00bfdfc4 	movi	r2,-129
 100b76c:	90a4703a 	and	r18,r18,r2
 100b770:	003a9106 	br	100a1b8 <__alt_data_end+0xff80a1b8>
 100b774:	010040b4 	movhi	r4,258
 100b778:	212b0584 	addi	r4,r4,-21482
 100b77c:	d9002b15 	stw	r4,172(sp)
 100b780:	003c0c06 	br	100a7b4 <__alt_data_end+0xff80a7b4>
 100b784:	d9002c17 	ldw	r4,176(sp)
 100b788:	d9801e04 	addi	r6,sp,120
 100b78c:	b80b883a 	mov	r5,r23
 100b790:	10113300 	call	1011330 <__sprint_r>
 100b794:	103aab1e 	bne	r2,zero,100a244 <__alt_data_end+0xff80a244>
 100b798:	d8c02017 	ldw	r3,128(sp)
 100b79c:	da000404 	addi	r8,sp,16
 100b7a0:	003d4106 	br	100aca8 <__alt_data_end+0xff80aca8>
 100b7a4:	d8801f17 	ldw	r2,124(sp)
 100b7a8:	014040b4 	movhi	r5,258
 100b7ac:	01000044 	movi	r4,1
 100b7b0:	18c00044 	addi	r3,r3,1
 100b7b4:	10800044 	addi	r2,r2,1
 100b7b8:	296b0504 	addi	r5,r5,-21484
 100b7bc:	41000115 	stw	r4,4(r8)
 100b7c0:	41400015 	stw	r5,0(r8)
 100b7c4:	d8c02015 	stw	r3,128(sp)
 100b7c8:	d8801f15 	stw	r2,124(sp)
 100b7cc:	010001c4 	movi	r4,7
 100b7d0:	20805c16 	blt	r4,r2,100b944 <___vfprintf_internal_r+0x1b08>
 100b7d4:	42000204 	addi	r8,r8,8
 100b7d8:	8800041e 	bne	r17,zero,100b7ec <___vfprintf_internal_r+0x19b0>
 100b7dc:	d8803317 	ldw	r2,204(sp)
 100b7e0:	1000021e 	bne	r2,zero,100b7ec <___vfprintf_internal_r+0x19b0>
 100b7e4:	9080004c 	andi	r2,r18,1
 100b7e8:	103c0926 	beq	r2,zero,100a810 <__alt_data_end+0xff80a810>
 100b7ec:	d9003717 	ldw	r4,220(sp)
 100b7f0:	d8801f17 	ldw	r2,124(sp)
 100b7f4:	d9403417 	ldw	r5,208(sp)
 100b7f8:	20c7883a 	add	r3,r4,r3
 100b7fc:	10800044 	addi	r2,r2,1
 100b800:	41000115 	stw	r4,4(r8)
 100b804:	41400015 	stw	r5,0(r8)
 100b808:	d8c02015 	stw	r3,128(sp)
 100b80c:	d8801f15 	stw	r2,124(sp)
 100b810:	010001c4 	movi	r4,7
 100b814:	20812116 	blt	r4,r2,100bc9c <___vfprintf_internal_r+0x1e60>
 100b818:	42000204 	addi	r8,r8,8
 100b81c:	0463c83a 	sub	r17,zero,r17
 100b820:	0440730e 	bge	zero,r17,100b9f0 <___vfprintf_internal_r+0x1bb4>
 100b824:	05800404 	movi	r22,16
 100b828:	b440860e 	bge	r22,r17,100ba44 <___vfprintf_internal_r+0x1c08>
 100b82c:	014040b4 	movhi	r5,258
 100b830:	296b0584 	addi	r5,r5,-21482
 100b834:	d9402b15 	stw	r5,172(sp)
 100b838:	070001c4 	movi	fp,7
 100b83c:	dcc02c17 	ldw	r19,176(sp)
 100b840:	00000306 	br	100b850 <___vfprintf_internal_r+0x1a14>
 100b844:	42000204 	addi	r8,r8,8
 100b848:	8c7ffc04 	addi	r17,r17,-16
 100b84c:	b440800e 	bge	r22,r17,100ba50 <___vfprintf_internal_r+0x1c14>
 100b850:	18c00404 	addi	r3,r3,16
 100b854:	10800044 	addi	r2,r2,1
 100b858:	45000015 	stw	r20,0(r8)
 100b85c:	45800115 	stw	r22,4(r8)
 100b860:	d8c02015 	stw	r3,128(sp)
 100b864:	d8801f15 	stw	r2,124(sp)
 100b868:	e0bff60e 	bge	fp,r2,100b844 <__alt_data_end+0xff80b844>
 100b86c:	d9801e04 	addi	r6,sp,120
 100b870:	b80b883a 	mov	r5,r23
 100b874:	9809883a 	mov	r4,r19
 100b878:	10113300 	call	1011330 <__sprint_r>
 100b87c:	103a711e 	bne	r2,zero,100a244 <__alt_data_end+0xff80a244>
 100b880:	d8c02017 	ldw	r3,128(sp)
 100b884:	d8801f17 	ldw	r2,124(sp)
 100b888:	da000404 	addi	r8,sp,16
 100b88c:	003fee06 	br	100b848 <__alt_data_end+0xff80b848>
 100b890:	00bfffc4 	movi	r2,-1
 100b894:	003a6f06 	br	100a254 <__alt_data_end+0xff80a254>
 100b898:	008011c4 	movi	r2,71
 100b89c:	1440b816 	blt	r2,r17,100bb80 <___vfprintf_internal_r+0x1d44>
 100b8a0:	040040b4 	movhi	r16,258
 100b8a4:	842af704 	addi	r16,r16,-21540
 100b8a8:	00c000c4 	movi	r3,3
 100b8ac:	00bfdfc4 	movi	r2,-129
 100b8b0:	d8c02a15 	stw	r3,168(sp)
 100b8b4:	90a4703a 	and	r18,r18,r2
 100b8b8:	df002783 	ldbu	fp,158(sp)
 100b8bc:	d8c02e15 	stw	r3,184(sp)
 100b8c0:	d8002915 	stw	zero,164(sp)
 100b8c4:	d8003215 	stw	zero,200(sp)
 100b8c8:	003b2906 	br	100a570 <__alt_data_end+0xff80a570>
 100b8cc:	d9002d17 	ldw	r4,180(sp)
 100b8d0:	24c00017 	ldw	r19,0(r4)
 100b8d4:	21000104 	addi	r4,r4,4
 100b8d8:	d9002d15 	stw	r4,180(sp)
 100b8dc:	982dd7fa 	srai	r22,r19,31
 100b8e0:	b005883a 	mov	r2,r22
 100b8e4:	003a9f06 	br	100a364 <__alt_data_end+0xff80a364>
 100b8e8:	d9402d17 	ldw	r5,180(sp)
 100b8ec:	d8c02f17 	ldw	r3,188(sp)
 100b8f0:	28800017 	ldw	r2,0(r5)
 100b8f4:	29400104 	addi	r5,r5,4
 100b8f8:	d9402d15 	stw	r5,180(sp)
 100b8fc:	10c00015 	stw	r3,0(r2)
 100b900:	00398606 	br	1009f1c <__alt_data_end+0xff809f1c>
 100b904:	d9402d17 	ldw	r5,180(sp)
 100b908:	002d883a 	mov	r22,zero
 100b90c:	2cc00017 	ldw	r19,0(r5)
 100b910:	29400104 	addi	r5,r5,4
 100b914:	d9402d15 	stw	r5,180(sp)
 100b918:	003c2306 	br	100a9a8 <__alt_data_end+0xff80a9a8>
 100b91c:	d8c02d17 	ldw	r3,180(sp)
 100b920:	d9002917 	ldw	r4,164(sp)
 100b924:	002d883a 	mov	r22,zero
 100b928:	18800104 	addi	r2,r3,4
 100b92c:	1cc0000b 	ldhu	r19,0(r3)
 100b930:	203dc10e 	bge	r4,zero,100b038 <__alt_data_end+0xff80b038>
 100b934:	003f7506 	br	100b70c <__alt_data_end+0xff80b70c>
 100b938:	040040b4 	movhi	r16,258
 100b93c:	842af504 	addi	r16,r16,-21548
 100b940:	003acc06 	br	100a474 <__alt_data_end+0xff80a474>
 100b944:	d9002c17 	ldw	r4,176(sp)
 100b948:	d9801e04 	addi	r6,sp,120
 100b94c:	b80b883a 	mov	r5,r23
 100b950:	10113300 	call	1011330 <__sprint_r>
 100b954:	103a3b1e 	bne	r2,zero,100a244 <__alt_data_end+0xff80a244>
 100b958:	dc402617 	ldw	r17,152(sp)
 100b95c:	d8c02017 	ldw	r3,128(sp)
 100b960:	da000404 	addi	r8,sp,16
 100b964:	003f9c06 	br	100b7d8 <__alt_data_end+0xff80b7d8>
 100b968:	ac400043 	ldbu	r17,1(r21)
 100b96c:	94800814 	ori	r18,r18,32
 100b970:	ad400044 	addi	r21,r21,1
 100b974:	8c403fcc 	andi	r17,r17,255
 100b978:	8c40201c 	xori	r17,r17,128
 100b97c:	8c7fe004 	addi	r17,r17,-128
 100b980:	00398f06 	br	1009fc0 <__alt_data_end+0xff809fc0>
 100b984:	d8c02d15 	stw	r3,180(sp)
 100b988:	0039883a 	mov	fp,zero
 100b98c:	003e3506 	br	100b264 <__alt_data_end+0xff80b264>
 100b990:	d9002c17 	ldw	r4,176(sp)
 100b994:	d9801e04 	addi	r6,sp,120
 100b998:	b80b883a 	mov	r5,r23
 100b99c:	10113300 	call	1011330 <__sprint_r>
 100b9a0:	103a281e 	bne	r2,zero,100a244 <__alt_data_end+0xff80a244>
 100b9a4:	d8c02017 	ldw	r3,128(sp)
 100b9a8:	da000404 	addi	r8,sp,16
 100b9ac:	003cd006 	br	100acf0 <__alt_data_end+0xff80acf0>
 100b9b0:	8009883a 	mov	r4,r16
 100b9b4:	da003d15 	stw	r8,244(sp)
 100b9b8:	1009da40 	call	1009da4 <strlen>
 100b9bc:	d8802e15 	stw	r2,184(sp)
 100b9c0:	da003d17 	ldw	r8,244(sp)
 100b9c4:	103c340e 	bge	r2,zero,100aa98 <__alt_data_end+0xff80aa98>
 100b9c8:	0005883a 	mov	r2,zero
 100b9cc:	003c3206 	br	100aa98 <__alt_data_end+0xff80aa98>
 100b9d0:	d9002c17 	ldw	r4,176(sp)
 100b9d4:	d9801e04 	addi	r6,sp,120
 100b9d8:	b80b883a 	mov	r5,r23
 100b9dc:	10113300 	call	1011330 <__sprint_r>
 100b9e0:	103a181e 	bne	r2,zero,100a244 <__alt_data_end+0xff80a244>
 100b9e4:	d8c02017 	ldw	r3,128(sp)
 100b9e8:	d8801f17 	ldw	r2,124(sp)
 100b9ec:	da000404 	addi	r8,sp,16
 100b9f0:	d9403317 	ldw	r5,204(sp)
 100b9f4:	10800044 	addi	r2,r2,1
 100b9f8:	44000015 	stw	r16,0(r8)
 100b9fc:	28c7883a 	add	r3,r5,r3
 100ba00:	003b7d06 	br	100a7f8 <__alt_data_end+0xff80a7f8>
 100ba04:	010040b4 	movhi	r4,258
 100ba08:	212b0984 	addi	r4,r4,-21466
 100ba0c:	d9003515 	stw	r4,212(sp)
 100ba10:	003b1406 	br	100a664 <__alt_data_end+0xff80a664>
 100ba14:	013fffc4 	movi	r4,-1
 100ba18:	003a3506 	br	100a2f0 <__alt_data_end+0xff80a2f0>
 100ba1c:	0023883a 	mov	r17,zero
 100ba20:	003d9d06 	br	100b098 <__alt_data_end+0xff80b098>
 100ba24:	d9002c17 	ldw	r4,176(sp)
 100ba28:	d9801e04 	addi	r6,sp,120
 100ba2c:	b80b883a 	mov	r5,r23
 100ba30:	10113300 	call	1011330 <__sprint_r>
 100ba34:	103a031e 	bne	r2,zero,100a244 <__alt_data_end+0xff80a244>
 100ba38:	d8c02017 	ldw	r3,128(sp)
 100ba3c:	da000404 	addi	r8,sp,16
 100ba40:	003d9406 	br	100b094 <__alt_data_end+0xff80b094>
 100ba44:	010040b4 	movhi	r4,258
 100ba48:	212b0584 	addi	r4,r4,-21482
 100ba4c:	d9002b15 	stw	r4,172(sp)
 100ba50:	d9002b17 	ldw	r4,172(sp)
 100ba54:	1c47883a 	add	r3,r3,r17
 100ba58:	10800044 	addi	r2,r2,1
 100ba5c:	41000015 	stw	r4,0(r8)
 100ba60:	44400115 	stw	r17,4(r8)
 100ba64:	d8c02015 	stw	r3,128(sp)
 100ba68:	d8801f15 	stw	r2,124(sp)
 100ba6c:	010001c4 	movi	r4,7
 100ba70:	20bfd716 	blt	r4,r2,100b9d0 <__alt_data_end+0xff80b9d0>
 100ba74:	42000204 	addi	r8,r8,8
 100ba78:	003fdd06 	br	100b9f0 <__alt_data_end+0xff80b9f0>
 100ba7c:	d9002c17 	ldw	r4,176(sp)
 100ba80:	d9801e04 	addi	r6,sp,120
 100ba84:	b80b883a 	mov	r5,r23
 100ba88:	10113300 	call	1011330 <__sprint_r>
 100ba8c:	1039ed1e 	bne	r2,zero,100a244 <__alt_data_end+0xff80a244>
 100ba90:	d8802617 	ldw	r2,152(sp)
 100ba94:	d8c02017 	ldw	r3,128(sp)
 100ba98:	da000404 	addi	r8,sp,16
 100ba9c:	003e1006 	br	100b2e0 <__alt_data_end+0xff80b2e0>
 100baa0:	00800044 	movi	r2,1
 100baa4:	10803fcc 	andi	r2,r2,255
 100baa8:	00c00044 	movi	r3,1
 100baac:	10fa3526 	beq	r2,r3,100a384 <__alt_data_end+0xff80a384>
 100bab0:	00c00084 	movi	r3,2
 100bab4:	10fbcb26 	beq	r2,r3,100a9e4 <__alt_data_end+0xff80a9e4>
 100bab8:	003a8f06 	br	100a4f8 <__alt_data_end+0xff80a4f8>
 100babc:	010040b4 	movhi	r4,258
 100bac0:	212b0984 	addi	r4,r4,-21466
 100bac4:	d9003515 	stw	r4,212(sp)
 100bac8:	003b7606 	br	100a8a4 <__alt_data_end+0xff80a8a4>
 100bacc:	d8802917 	ldw	r2,164(sp)
 100bad0:	00c00184 	movi	r3,6
 100bad4:	1880012e 	bgeu	r3,r2,100badc <___vfprintf_internal_r+0x1ca0>
 100bad8:	1805883a 	mov	r2,r3
 100badc:	d8802e15 	stw	r2,184(sp)
 100bae0:	1000ef16 	blt	r2,zero,100bea0 <___vfprintf_internal_r+0x2064>
 100bae4:	040040b4 	movhi	r16,258
 100bae8:	d8802a15 	stw	r2,168(sp)
 100baec:	dcc02d15 	stw	r19,180(sp)
 100baf0:	d8002915 	stw	zero,164(sp)
 100baf4:	d8003215 	stw	zero,200(sp)
 100baf8:	842b0304 	addi	r16,r16,-21492
 100bafc:	0039883a 	mov	fp,zero
 100bb00:	003aa206 	br	100a58c <__alt_data_end+0xff80a58c>
 100bb04:	0021883a 	mov	r16,zero
 100bb08:	003e0706 	br	100b328 <__alt_data_end+0xff80b328>
 100bb0c:	d9002c17 	ldw	r4,176(sp)
 100bb10:	d9801e04 	addi	r6,sp,120
 100bb14:	b80b883a 	mov	r5,r23
 100bb18:	10113300 	call	1011330 <__sprint_r>
 100bb1c:	1039c91e 	bne	r2,zero,100a244 <__alt_data_end+0xff80a244>
 100bb20:	d8802617 	ldw	r2,152(sp)
 100bb24:	d9403317 	ldw	r5,204(sp)
 100bb28:	d8c02017 	ldw	r3,128(sp)
 100bb2c:	da000404 	addi	r8,sp,16
 100bb30:	2885c83a 	sub	r2,r5,r2
 100bb34:	003dfb06 	br	100b324 <__alt_data_end+0xff80b324>
 100bb38:	9080004c 	andi	r2,r18,1
 100bb3c:	103e8f1e 	bne	r2,zero,100b57c <__alt_data_end+0xff80b57c>
 100bb40:	d8802117 	ldw	r2,132(sp)
 100bb44:	003e9e06 	br	100b5c0 <__alt_data_end+0xff80b5c0>
 100bb48:	1025883a 	mov	r18,r2
 100bb4c:	0039883a 	mov	fp,zero
 100bb50:	00800084 	movi	r2,2
 100bb54:	003fd306 	br	100baa4 <__alt_data_end+0xff80baa4>
 100bb58:	07000b44 	movi	fp,45
 100bb5c:	df002785 	stb	fp,158(sp)
 100bb60:	003a4006 	br	100a464 <__alt_data_end+0xff80a464>
 100bb64:	00c00b44 	movi	r3,45
 100bb68:	d8c02785 	stb	r3,158(sp)
 100bb6c:	d8802a15 	stw	r2,168(sp)
 100bb70:	dc802b17 	ldw	r18,172(sp)
 100bb74:	d8002915 	stw	zero,164(sp)
 100bb78:	07000b44 	movi	fp,45
 100bb7c:	003a8006 	br	100a580 <__alt_data_end+0xff80a580>
 100bb80:	040040b4 	movhi	r16,258
 100bb84:	842af804 	addi	r16,r16,-21536
 100bb88:	003f4706 	br	100b8a8 <__alt_data_end+0xff80b8a8>
 100bb8c:	d8c02d17 	ldw	r3,180(sp)
 100bb90:	d9002f17 	ldw	r4,188(sp)
 100bb94:	18800017 	ldw	r2,0(r3)
 100bb98:	18c00104 	addi	r3,r3,4
 100bb9c:	d8c02d15 	stw	r3,180(sp)
 100bba0:	11000015 	stw	r4,0(r2)
 100bba4:	0038dd06 	br	1009f1c <__alt_data_end+0xff809f1c>
 100bba8:	dd802617 	ldw	r22,152(sp)
 100bbac:	00bfff44 	movi	r2,-3
 100bbb0:	b0801c16 	blt	r22,r2,100bc24 <___vfprintf_internal_r+0x1de8>
 100bbb4:	d9402917 	ldw	r5,164(sp)
 100bbb8:	2d801a16 	blt	r5,r22,100bc24 <___vfprintf_internal_r+0x1de8>
 100bbbc:	dd803215 	stw	r22,200(sp)
 100bbc0:	003e8906 	br	100b5e8 <__alt_data_end+0xff80b5e8>
 100bbc4:	010040b4 	movhi	r4,258
 100bbc8:	212b0584 	addi	r4,r4,-21482
 100bbcc:	d9002b15 	stw	r4,172(sp)
 100bbd0:	003c9106 	br	100ae18 <__alt_data_end+0xff80ae18>
 100bbd4:	e005883a 	mov	r2,fp
 100bbd8:	003e7906 	br	100b5c0 <__alt_data_end+0xff80b5c0>
 100bbdc:	d9402917 	ldw	r5,164(sp)
 100bbe0:	df002783 	ldbu	fp,158(sp)
 100bbe4:	dcc02d15 	stw	r19,180(sp)
 100bbe8:	d9402a15 	stw	r5,168(sp)
 100bbec:	d9402e15 	stw	r5,184(sp)
 100bbf0:	d8002915 	stw	zero,164(sp)
 100bbf4:	d8003215 	stw	zero,200(sp)
 100bbf8:	003a5d06 	br	100a570 <__alt_data_end+0xff80a570>
 100bbfc:	9080004c 	andi	r2,r18,1
 100bc00:	0039883a 	mov	fp,zero
 100bc04:	10000426 	beq	r2,zero,100bc18 <___vfprintf_internal_r+0x1ddc>
 100bc08:	00800c04 	movi	r2,48
 100bc0c:	dc001dc4 	addi	r16,sp,119
 100bc10:	d8801dc5 	stb	r2,119(sp)
 100bc14:	003b8006 	br	100aa18 <__alt_data_end+0xff80aa18>
 100bc18:	d8002e15 	stw	zero,184(sp)
 100bc1c:	dc001e04 	addi	r16,sp,120
 100bc20:	003a4d06 	br	100a558 <__alt_data_end+0xff80a558>
 100bc24:	8c7fff84 	addi	r17,r17,-2
 100bc28:	b5bfffc4 	addi	r22,r22,-1
 100bc2c:	dd802615 	stw	r22,152(sp)
 100bc30:	dc4022c5 	stb	r17,139(sp)
 100bc34:	b000bf16 	blt	r22,zero,100bf34 <___vfprintf_internal_r+0x20f8>
 100bc38:	00800ac4 	movi	r2,43
 100bc3c:	d8802305 	stb	r2,140(sp)
 100bc40:	00800244 	movi	r2,9
 100bc44:	15807016 	blt	r2,r22,100be08 <___vfprintf_internal_r+0x1fcc>
 100bc48:	00800c04 	movi	r2,48
 100bc4c:	b5800c04 	addi	r22,r22,48
 100bc50:	d8802345 	stb	r2,141(sp)
 100bc54:	dd802385 	stb	r22,142(sp)
 100bc58:	d88023c4 	addi	r2,sp,143
 100bc5c:	df0022c4 	addi	fp,sp,139
 100bc60:	d8c03317 	ldw	r3,204(sp)
 100bc64:	1739c83a 	sub	fp,r2,fp
 100bc68:	d9003317 	ldw	r4,204(sp)
 100bc6c:	e0c7883a 	add	r3,fp,r3
 100bc70:	df003a15 	stw	fp,232(sp)
 100bc74:	d8c02e15 	stw	r3,184(sp)
 100bc78:	00800044 	movi	r2,1
 100bc7c:	1100b30e 	bge	r2,r4,100bf4c <___vfprintf_internal_r+0x2110>
 100bc80:	d8c02e17 	ldw	r3,184(sp)
 100bc84:	18c00044 	addi	r3,r3,1
 100bc88:	d8c02e15 	stw	r3,184(sp)
 100bc8c:	1805883a 	mov	r2,r3
 100bc90:	1800ac16 	blt	r3,zero,100bf44 <___vfprintf_internal_r+0x2108>
 100bc94:	d8003215 	stw	zero,200(sp)
 100bc98:	003e5d06 	br	100b610 <__alt_data_end+0xff80b610>
 100bc9c:	d9002c17 	ldw	r4,176(sp)
 100bca0:	d9801e04 	addi	r6,sp,120
 100bca4:	b80b883a 	mov	r5,r23
 100bca8:	10113300 	call	1011330 <__sprint_r>
 100bcac:	1039651e 	bne	r2,zero,100a244 <__alt_data_end+0xff80a244>
 100bcb0:	dc402617 	ldw	r17,152(sp)
 100bcb4:	d8c02017 	ldw	r3,128(sp)
 100bcb8:	d8801f17 	ldw	r2,124(sp)
 100bcbc:	da000404 	addi	r8,sp,16
 100bcc0:	003ed606 	br	100b81c <__alt_data_end+0xff80b81c>
 100bcc4:	582b883a 	mov	r21,r11
 100bcc8:	d8002915 	stw	zero,164(sp)
 100bccc:	0038bd06 	br	1009fc4 <__alt_data_end+0xff809fc4>
 100bcd0:	d8802917 	ldw	r2,164(sp)
 100bcd4:	103e071e 	bne	r2,zero,100b4f4 <__alt_data_end+0xff80b4f4>
 100bcd8:	dc002915 	stw	r16,164(sp)
 100bcdc:	003e0506 	br	100b4f4 <__alt_data_end+0xff80b4f4>
 100bce0:	d9002917 	ldw	r4,164(sp)
 100bce4:	20c00044 	addi	r3,r4,1
 100bce8:	003e0f06 	br	100b528 <__alt_data_end+0xff80b528>
 100bcec:	01400184 	movi	r5,6
 100bcf0:	d9402915 	stw	r5,164(sp)
 100bcf4:	003dff06 	br	100b4f4 <__alt_data_end+0xff80b4f4>
 100bcf8:	d8802104 	addi	r2,sp,132
 100bcfc:	d8800315 	stw	r2,12(sp)
 100bd00:	d8802504 	addi	r2,sp,148
 100bd04:	d8800215 	stw	r2,8(sp)
 100bd08:	d8802604 	addi	r2,sp,152
 100bd0c:	d8800115 	stw	r2,4(sp)
 100bd10:	d8802917 	ldw	r2,164(sp)
 100bd14:	d9403617 	ldw	r5,216(sp)
 100bd18:	d9002c17 	ldw	r4,176(sp)
 100bd1c:	d8800015 	stw	r2,0(sp)
 100bd20:	01c000c4 	movi	r7,3
 100bd24:	980d883a 	mov	r6,r19
 100bd28:	da003d15 	stw	r8,244(sp)
 100bd2c:	100c4600 	call	100c460 <_dtoa_r>
 100bd30:	d8c02917 	ldw	r3,164(sp)
 100bd34:	da003d17 	ldw	r8,244(sp)
 100bd38:	1021883a 	mov	r16,r2
 100bd3c:	10f9883a 	add	fp,r2,r3
 100bd40:	81000007 	ldb	r4,0(r16)
 100bd44:	00800c04 	movi	r2,48
 100bd48:	20805e26 	beq	r4,r2,100bec4 <___vfprintf_internal_r+0x2088>
 100bd4c:	d8c02617 	ldw	r3,152(sp)
 100bd50:	e0f9883a 	add	fp,fp,r3
 100bd54:	003e0a06 	br	100b580 <__alt_data_end+0xff80b580>
 100bd58:	00c00b44 	movi	r3,45
 100bd5c:	24e0003c 	xorhi	r19,r4,32768
 100bd60:	d8c02a05 	stb	r3,168(sp)
 100bd64:	003de906 	br	100b50c <__alt_data_end+0xff80b50c>
 100bd68:	d8c03217 	ldw	r3,200(sp)
 100bd6c:	00c07a0e 	bge	zero,r3,100bf58 <___vfprintf_internal_r+0x211c>
 100bd70:	00800044 	movi	r2,1
 100bd74:	d9003317 	ldw	r4,204(sp)
 100bd78:	1105883a 	add	r2,r2,r4
 100bd7c:	d8802e15 	stw	r2,184(sp)
 100bd80:	10004e16 	blt	r2,zero,100bebc <___vfprintf_internal_r+0x2080>
 100bd84:	044019c4 	movi	r17,103
 100bd88:	003e2106 	br	100b610 <__alt_data_end+0xff80b610>
 100bd8c:	d9002917 	ldw	r4,164(sp)
 100bd90:	d8802104 	addi	r2,sp,132
 100bd94:	d8800315 	stw	r2,12(sp)
 100bd98:	d9000015 	stw	r4,0(sp)
 100bd9c:	d8802504 	addi	r2,sp,148
 100bda0:	d9403617 	ldw	r5,216(sp)
 100bda4:	d9002c17 	ldw	r4,176(sp)
 100bda8:	d8800215 	stw	r2,8(sp)
 100bdac:	d8802604 	addi	r2,sp,152
 100bdb0:	d8800115 	stw	r2,4(sp)
 100bdb4:	01c000c4 	movi	r7,3
 100bdb8:	980d883a 	mov	r6,r19
 100bdbc:	da003d15 	stw	r8,244(sp)
 100bdc0:	100c4600 	call	100c460 <_dtoa_r>
 100bdc4:	d8c02917 	ldw	r3,164(sp)
 100bdc8:	da003d17 	ldw	r8,244(sp)
 100bdcc:	1021883a 	mov	r16,r2
 100bdd0:	00801184 	movi	r2,70
 100bdd4:	80f9883a 	add	fp,r16,r3
 100bdd8:	88bfd926 	beq	r17,r2,100bd40 <__alt_data_end+0xff80bd40>
 100bddc:	003de806 	br	100b580 <__alt_data_end+0xff80b580>
 100bde0:	d9002917 	ldw	r4,164(sp)
 100bde4:	00c04d0e 	bge	zero,r3,100bf1c <___vfprintf_internal_r+0x20e0>
 100bde8:	2000441e 	bne	r4,zero,100befc <___vfprintf_internal_r+0x20c0>
 100bdec:	9480004c 	andi	r18,r18,1
 100bdf0:	9000421e 	bne	r18,zero,100befc <___vfprintf_internal_r+0x20c0>
 100bdf4:	1805883a 	mov	r2,r3
 100bdf8:	18007016 	blt	r3,zero,100bfbc <___vfprintf_internal_r+0x2180>
 100bdfc:	d8c03217 	ldw	r3,200(sp)
 100be00:	d8c02e15 	stw	r3,184(sp)
 100be04:	003e0206 	br	100b610 <__alt_data_end+0xff80b610>
 100be08:	df0022c4 	addi	fp,sp,139
 100be0c:	dc002915 	stw	r16,164(sp)
 100be10:	4027883a 	mov	r19,r8
 100be14:	e021883a 	mov	r16,fp
 100be18:	b009883a 	mov	r4,r22
 100be1c:	01400284 	movi	r5,10
 100be20:	10097300 	call	1009730 <__modsi3>
 100be24:	10800c04 	addi	r2,r2,48
 100be28:	843fffc4 	addi	r16,r16,-1
 100be2c:	b009883a 	mov	r4,r22
 100be30:	01400284 	movi	r5,10
 100be34:	80800005 	stb	r2,0(r16)
 100be38:	10096ac0 	call	10096ac <__divsi3>
 100be3c:	102d883a 	mov	r22,r2
 100be40:	00800244 	movi	r2,9
 100be44:	15bff416 	blt	r2,r22,100be18 <__alt_data_end+0xff80be18>
 100be48:	9811883a 	mov	r8,r19
 100be4c:	b0800c04 	addi	r2,r22,48
 100be50:	8027883a 	mov	r19,r16
 100be54:	997fffc4 	addi	r5,r19,-1
 100be58:	98bfffc5 	stb	r2,-1(r19)
 100be5c:	dc002917 	ldw	r16,164(sp)
 100be60:	2f006a2e 	bgeu	r5,fp,100c00c <___vfprintf_internal_r+0x21d0>
 100be64:	d9c02384 	addi	r7,sp,142
 100be68:	3ccfc83a 	sub	r7,r7,r19
 100be6c:	d9002344 	addi	r4,sp,141
 100be70:	e1cf883a 	add	r7,fp,r7
 100be74:	00000106 	br	100be7c <___vfprintf_internal_r+0x2040>
 100be78:	28800003 	ldbu	r2,0(r5)
 100be7c:	20800005 	stb	r2,0(r4)
 100be80:	21000044 	addi	r4,r4,1
 100be84:	29400044 	addi	r5,r5,1
 100be88:	393ffb1e 	bne	r7,r4,100be78 <__alt_data_end+0xff80be78>
 100be8c:	d8802304 	addi	r2,sp,140
 100be90:	14c5c83a 	sub	r2,r2,r19
 100be94:	d8c02344 	addi	r3,sp,141
 100be98:	1885883a 	add	r2,r3,r2
 100be9c:	003f7006 	br	100bc60 <__alt_data_end+0xff80bc60>
 100bea0:	0005883a 	mov	r2,zero
 100bea4:	003f0f06 	br	100bae4 <__alt_data_end+0xff80bae4>
 100bea8:	d8c03217 	ldw	r3,200(sp)
 100beac:	18c00044 	addi	r3,r3,1
 100beb0:	d8c02e15 	stw	r3,184(sp)
 100beb4:	1805883a 	mov	r2,r3
 100beb8:	183fb20e 	bge	r3,zero,100bd84 <__alt_data_end+0xff80bd84>
 100bebc:	0005883a 	mov	r2,zero
 100bec0:	003fb006 	br	100bd84 <__alt_data_end+0xff80bd84>
 100bec4:	d9003617 	ldw	r4,216(sp)
 100bec8:	000d883a 	mov	r6,zero
 100becc:	000f883a 	mov	r7,zero
 100bed0:	980b883a 	mov	r5,r19
 100bed4:	d8c03c15 	stw	r3,240(sp)
 100bed8:	da003d15 	stw	r8,244(sp)
 100bedc:	1014df40 	call	1014df4 <__eqdf2>
 100bee0:	d8c03c17 	ldw	r3,240(sp)
 100bee4:	da003d17 	ldw	r8,244(sp)
 100bee8:	103f9826 	beq	r2,zero,100bd4c <__alt_data_end+0xff80bd4c>
 100beec:	00800044 	movi	r2,1
 100bef0:	10c7c83a 	sub	r3,r2,r3
 100bef4:	d8c02615 	stw	r3,152(sp)
 100bef8:	003f9506 	br	100bd50 <__alt_data_end+0xff80bd50>
 100befc:	d9002917 	ldw	r4,164(sp)
 100bf00:	d8c03217 	ldw	r3,200(sp)
 100bf04:	20800044 	addi	r2,r4,1
 100bf08:	1885883a 	add	r2,r3,r2
 100bf0c:	d8802e15 	stw	r2,184(sp)
 100bf10:	103dbf0e 	bge	r2,zero,100b610 <__alt_data_end+0xff80b610>
 100bf14:	0005883a 	mov	r2,zero
 100bf18:	003dbd06 	br	100b610 <__alt_data_end+0xff80b610>
 100bf1c:	2000211e 	bne	r4,zero,100bfa4 <___vfprintf_internal_r+0x2168>
 100bf20:	9480004c 	andi	r18,r18,1
 100bf24:	90001f1e 	bne	r18,zero,100bfa4 <___vfprintf_internal_r+0x2168>
 100bf28:	00800044 	movi	r2,1
 100bf2c:	d8802e15 	stw	r2,184(sp)
 100bf30:	003db706 	br	100b610 <__alt_data_end+0xff80b610>
 100bf34:	00800b44 	movi	r2,45
 100bf38:	05adc83a 	sub	r22,zero,r22
 100bf3c:	d8802305 	stb	r2,140(sp)
 100bf40:	003f3f06 	br	100bc40 <__alt_data_end+0xff80bc40>
 100bf44:	0005883a 	mov	r2,zero
 100bf48:	003f5206 	br	100bc94 <__alt_data_end+0xff80bc94>
 100bf4c:	90a4703a 	and	r18,r18,r2
 100bf50:	903f4e26 	beq	r18,zero,100bc8c <__alt_data_end+0xff80bc8c>
 100bf54:	003f4a06 	br	100bc80 <__alt_data_end+0xff80bc80>
 100bf58:	00800084 	movi	r2,2
 100bf5c:	10c5c83a 	sub	r2,r2,r3
 100bf60:	003f8406 	br	100bd74 <__alt_data_end+0xff80bd74>
 100bf64:	d8802d17 	ldw	r2,180(sp)
 100bf68:	d9002d17 	ldw	r4,180(sp)
 100bf6c:	ac400043 	ldbu	r17,1(r21)
 100bf70:	10800017 	ldw	r2,0(r2)
 100bf74:	582b883a 	mov	r21,r11
 100bf78:	d8802915 	stw	r2,164(sp)
 100bf7c:	20800104 	addi	r2,r4,4
 100bf80:	d9002917 	ldw	r4,164(sp)
 100bf84:	d8802d15 	stw	r2,180(sp)
 100bf88:	203e7a0e 	bge	r4,zero,100b974 <__alt_data_end+0xff80b974>
 100bf8c:	8c403fcc 	andi	r17,r17,255
 100bf90:	00bfffc4 	movi	r2,-1
 100bf94:	8c40201c 	xori	r17,r17,128
 100bf98:	d8802915 	stw	r2,164(sp)
 100bf9c:	8c7fe004 	addi	r17,r17,-128
 100bfa0:	00380706 	br	1009fc0 <__alt_data_end+0xff809fc0>
 100bfa4:	d8c02917 	ldw	r3,164(sp)
 100bfa8:	18c00084 	addi	r3,r3,2
 100bfac:	d8c02e15 	stw	r3,184(sp)
 100bfb0:	1805883a 	mov	r2,r3
 100bfb4:	183d960e 	bge	r3,zero,100b610 <__alt_data_end+0xff80b610>
 100bfb8:	003fd606 	br	100bf14 <__alt_data_end+0xff80bf14>
 100bfbc:	0005883a 	mov	r2,zero
 100bfc0:	003f8e06 	br	100bdfc <__alt_data_end+0xff80bdfc>
 100bfc4:	9080004c 	andi	r2,r18,1
 100bfc8:	103f811e 	bne	r2,zero,100bdd0 <__alt_data_end+0xff80bdd0>
 100bfcc:	d8802117 	ldw	r2,132(sp)
 100bfd0:	1405c83a 	sub	r2,r2,r16
 100bfd4:	d8803315 	stw	r2,204(sp)
 100bfd8:	b47ef326 	beq	r22,r17,100bba8 <__alt_data_end+0xff80bba8>
 100bfdc:	dd802617 	ldw	r22,152(sp)
 100bfe0:	003f1106 	br	100bc28 <__alt_data_end+0xff80bc28>
 100bfe4:	d9c02785 	stb	r7,158(sp)
 100bfe8:	00390406 	br	100a3fc <__alt_data_end+0xff80a3fc>
 100bfec:	d9c02785 	stb	r7,158(sp)
 100bff0:	0038d306 	br	100a340 <__alt_data_end+0xff80a340>
 100bff4:	d9c02785 	stb	r7,158(sp)
 100bff8:	003a6106 	br	100a980 <__alt_data_end+0xff80a980>
 100bffc:	d9c02785 	stb	r7,158(sp)
 100c000:	003af806 	br	100abe4 <__alt_data_end+0xff80abe4>
 100c004:	0005883a 	mov	r2,zero
 100c008:	003d7e06 	br	100b604 <__alt_data_end+0xff80b604>
 100c00c:	d8802344 	addi	r2,sp,141
 100c010:	003f1306 	br	100bc60 <__alt_data_end+0xff80bc60>
 100c014:	d9c02785 	stb	r7,158(sp)
 100c018:	00392306 	br	100a4a8 <__alt_data_end+0xff80a4a8>
 100c01c:	d9c02785 	stb	r7,158(sp)
 100c020:	003aa906 	br	100aac8 <__alt_data_end+0xff80aac8>
 100c024:	d9c02785 	stb	r7,158(sp)
 100c028:	003a3d06 	br	100a920 <__alt_data_end+0xff80a920>
 100c02c:	d9c02785 	stb	r7,158(sp)
 100c030:	003aca06 	br	100ab5c <__alt_data_end+0xff80ab5c>

0100c034 <__vfprintf_internal>:
 100c034:	008040b4 	movhi	r2,258
 100c038:	10b39b04 	addi	r2,r2,-12692
 100c03c:	300f883a 	mov	r7,r6
 100c040:	280d883a 	mov	r6,r5
 100c044:	200b883a 	mov	r5,r4
 100c048:	11000017 	ldw	r4,0(r2)
 100c04c:	1009e3c1 	jmpi	1009e3c <___vfprintf_internal_r>

0100c050 <__sbprintf>:
 100c050:	2880030b 	ldhu	r2,12(r5)
 100c054:	2ac01917 	ldw	r11,100(r5)
 100c058:	2a80038b 	ldhu	r10,14(r5)
 100c05c:	2a400717 	ldw	r9,28(r5)
 100c060:	2a000917 	ldw	r8,36(r5)
 100c064:	defee204 	addi	sp,sp,-1144
 100c068:	00c10004 	movi	r3,1024
 100c06c:	dc011a15 	stw	r16,1128(sp)
 100c070:	10bfff4c 	andi	r2,r2,65533
 100c074:	2821883a 	mov	r16,r5
 100c078:	d8cb883a 	add	r5,sp,r3
 100c07c:	dc811c15 	stw	r18,1136(sp)
 100c080:	dc411b15 	stw	r17,1132(sp)
 100c084:	dfc11d15 	stw	ra,1140(sp)
 100c088:	2025883a 	mov	r18,r4
 100c08c:	d881030d 	sth	r2,1036(sp)
 100c090:	dac11915 	stw	r11,1124(sp)
 100c094:	da81038d 	sth	r10,1038(sp)
 100c098:	da410715 	stw	r9,1052(sp)
 100c09c:	da010915 	stw	r8,1060(sp)
 100c0a0:	dec10015 	stw	sp,1024(sp)
 100c0a4:	dec10415 	stw	sp,1040(sp)
 100c0a8:	d8c10215 	stw	r3,1032(sp)
 100c0ac:	d8c10515 	stw	r3,1044(sp)
 100c0b0:	d8010615 	stw	zero,1048(sp)
 100c0b4:	1009e3c0 	call	1009e3c <___vfprintf_internal_r>
 100c0b8:	1023883a 	mov	r17,r2
 100c0bc:	10000416 	blt	r2,zero,100c0d0 <__sbprintf+0x80>
 100c0c0:	d9410004 	addi	r5,sp,1024
 100c0c4:	9009883a 	mov	r4,r18
 100c0c8:	100dd040 	call	100dd04 <_fflush_r>
 100c0cc:	10000d1e 	bne	r2,zero,100c104 <__sbprintf+0xb4>
 100c0d0:	d881030b 	ldhu	r2,1036(sp)
 100c0d4:	1080100c 	andi	r2,r2,64
 100c0d8:	10000326 	beq	r2,zero,100c0e8 <__sbprintf+0x98>
 100c0dc:	8080030b 	ldhu	r2,12(r16)
 100c0e0:	10801014 	ori	r2,r2,64
 100c0e4:	8080030d 	sth	r2,12(r16)
 100c0e8:	8805883a 	mov	r2,r17
 100c0ec:	dfc11d17 	ldw	ra,1140(sp)
 100c0f0:	dc811c17 	ldw	r18,1136(sp)
 100c0f4:	dc411b17 	ldw	r17,1132(sp)
 100c0f8:	dc011a17 	ldw	r16,1128(sp)
 100c0fc:	dec11e04 	addi	sp,sp,1144
 100c100:	f800283a 	ret
 100c104:	047fffc4 	movi	r17,-1
 100c108:	003ff106 	br	100c0d0 <__alt_data_end+0xff80c0d0>

0100c10c <__swsetup_r>:
 100c10c:	008040b4 	movhi	r2,258
 100c110:	defffd04 	addi	sp,sp,-12
 100c114:	10b39b04 	addi	r2,r2,-12692
 100c118:	dc400115 	stw	r17,4(sp)
 100c11c:	2023883a 	mov	r17,r4
 100c120:	11000017 	ldw	r4,0(r2)
 100c124:	dc000015 	stw	r16,0(sp)
 100c128:	dfc00215 	stw	ra,8(sp)
 100c12c:	2821883a 	mov	r16,r5
 100c130:	20000226 	beq	r4,zero,100c13c <__swsetup_r+0x30>
 100c134:	20800e17 	ldw	r2,56(r4)
 100c138:	10003126 	beq	r2,zero,100c200 <__swsetup_r+0xf4>
 100c13c:	8080030b 	ldhu	r2,12(r16)
 100c140:	10c0020c 	andi	r3,r2,8
 100c144:	1009883a 	mov	r4,r2
 100c148:	18000f26 	beq	r3,zero,100c188 <__swsetup_r+0x7c>
 100c14c:	80c00417 	ldw	r3,16(r16)
 100c150:	18001526 	beq	r3,zero,100c1a8 <__swsetup_r+0x9c>
 100c154:	1100004c 	andi	r4,r2,1
 100c158:	20001c1e 	bne	r4,zero,100c1cc <__swsetup_r+0xc0>
 100c15c:	1080008c 	andi	r2,r2,2
 100c160:	1000291e 	bne	r2,zero,100c208 <__swsetup_r+0xfc>
 100c164:	80800517 	ldw	r2,20(r16)
 100c168:	80800215 	stw	r2,8(r16)
 100c16c:	18001c26 	beq	r3,zero,100c1e0 <__swsetup_r+0xd4>
 100c170:	0005883a 	mov	r2,zero
 100c174:	dfc00217 	ldw	ra,8(sp)
 100c178:	dc400117 	ldw	r17,4(sp)
 100c17c:	dc000017 	ldw	r16,0(sp)
 100c180:	dec00304 	addi	sp,sp,12
 100c184:	f800283a 	ret
 100c188:	2080040c 	andi	r2,r4,16
 100c18c:	10002e26 	beq	r2,zero,100c248 <__swsetup_r+0x13c>
 100c190:	2080010c 	andi	r2,r4,4
 100c194:	10001e1e 	bne	r2,zero,100c210 <__swsetup_r+0x104>
 100c198:	80c00417 	ldw	r3,16(r16)
 100c19c:	20800214 	ori	r2,r4,8
 100c1a0:	8080030d 	sth	r2,12(r16)
 100c1a4:	183feb1e 	bne	r3,zero,100c154 <__alt_data_end+0xff80c154>
 100c1a8:	1100a00c 	andi	r4,r2,640
 100c1ac:	01408004 	movi	r5,512
 100c1b0:	217fe826 	beq	r4,r5,100c154 <__alt_data_end+0xff80c154>
 100c1b4:	800b883a 	mov	r5,r16
 100c1b8:	8809883a 	mov	r4,r17
 100c1bc:	100ec840 	call	100ec84 <__smakebuf_r>
 100c1c0:	8080030b 	ldhu	r2,12(r16)
 100c1c4:	80c00417 	ldw	r3,16(r16)
 100c1c8:	003fe206 	br	100c154 <__alt_data_end+0xff80c154>
 100c1cc:	80800517 	ldw	r2,20(r16)
 100c1d0:	80000215 	stw	zero,8(r16)
 100c1d4:	0085c83a 	sub	r2,zero,r2
 100c1d8:	80800615 	stw	r2,24(r16)
 100c1dc:	183fe41e 	bne	r3,zero,100c170 <__alt_data_end+0xff80c170>
 100c1e0:	80c0030b 	ldhu	r3,12(r16)
 100c1e4:	0005883a 	mov	r2,zero
 100c1e8:	1900200c 	andi	r4,r3,128
 100c1ec:	203fe126 	beq	r4,zero,100c174 <__alt_data_end+0xff80c174>
 100c1f0:	18c01014 	ori	r3,r3,64
 100c1f4:	80c0030d 	sth	r3,12(r16)
 100c1f8:	00bfffc4 	movi	r2,-1
 100c1fc:	003fdd06 	br	100c174 <__alt_data_end+0xff80c174>
 100c200:	100e0e00 	call	100e0e0 <__sinit>
 100c204:	003fcd06 	br	100c13c <__alt_data_end+0xff80c13c>
 100c208:	0005883a 	mov	r2,zero
 100c20c:	003fd606 	br	100c168 <__alt_data_end+0xff80c168>
 100c210:	81400c17 	ldw	r5,48(r16)
 100c214:	28000626 	beq	r5,zero,100c230 <__swsetup_r+0x124>
 100c218:	80801004 	addi	r2,r16,64
 100c21c:	28800326 	beq	r5,r2,100c22c <__swsetup_r+0x120>
 100c220:	8809883a 	mov	r4,r17
 100c224:	100e2540 	call	100e254 <_free_r>
 100c228:	8100030b 	ldhu	r4,12(r16)
 100c22c:	80000c15 	stw	zero,48(r16)
 100c230:	80c00417 	ldw	r3,16(r16)
 100c234:	00bff6c4 	movi	r2,-37
 100c238:	1108703a 	and	r4,r2,r4
 100c23c:	80000115 	stw	zero,4(r16)
 100c240:	80c00015 	stw	r3,0(r16)
 100c244:	003fd506 	br	100c19c <__alt_data_end+0xff80c19c>
 100c248:	00800244 	movi	r2,9
 100c24c:	88800015 	stw	r2,0(r17)
 100c250:	20801014 	ori	r2,r4,64
 100c254:	8080030d 	sth	r2,12(r16)
 100c258:	00bfffc4 	movi	r2,-1
 100c25c:	003fc506 	br	100c174 <__alt_data_end+0xff80c174>

0100c260 <quorem>:
 100c260:	defff704 	addi	sp,sp,-36
 100c264:	dc800215 	stw	r18,8(sp)
 100c268:	20800417 	ldw	r2,16(r4)
 100c26c:	2c800417 	ldw	r18,16(r5)
 100c270:	dfc00815 	stw	ra,32(sp)
 100c274:	ddc00715 	stw	r23,28(sp)
 100c278:	dd800615 	stw	r22,24(sp)
 100c27c:	dd400515 	stw	r21,20(sp)
 100c280:	dd000415 	stw	r20,16(sp)
 100c284:	dcc00315 	stw	r19,12(sp)
 100c288:	dc400115 	stw	r17,4(sp)
 100c28c:	dc000015 	stw	r16,0(sp)
 100c290:	14807116 	blt	r2,r18,100c458 <quorem+0x1f8>
 100c294:	94bfffc4 	addi	r18,r18,-1
 100c298:	94ad883a 	add	r22,r18,r18
 100c29c:	b5ad883a 	add	r22,r22,r22
 100c2a0:	2c400504 	addi	r17,r5,20
 100c2a4:	8da9883a 	add	r20,r17,r22
 100c2a8:	25400504 	addi	r21,r4,20
 100c2ac:	282f883a 	mov	r23,r5
 100c2b0:	adad883a 	add	r22,r21,r22
 100c2b4:	a1400017 	ldw	r5,0(r20)
 100c2b8:	2021883a 	mov	r16,r4
 100c2bc:	b1000017 	ldw	r4,0(r22)
 100c2c0:	29400044 	addi	r5,r5,1
 100c2c4:	10097a40 	call	10097a4 <__udivsi3>
 100c2c8:	1027883a 	mov	r19,r2
 100c2cc:	10002c26 	beq	r2,zero,100c380 <quorem+0x120>
 100c2d0:	a813883a 	mov	r9,r21
 100c2d4:	880b883a 	mov	r5,r17
 100c2d8:	0009883a 	mov	r4,zero
 100c2dc:	000d883a 	mov	r6,zero
 100c2e0:	2a000017 	ldw	r8,0(r5)
 100c2e4:	49c00017 	ldw	r7,0(r9)
 100c2e8:	29400104 	addi	r5,r5,4
 100c2ec:	40bfffcc 	andi	r2,r8,65535
 100c2f0:	14c5383a 	mul	r2,r2,r19
 100c2f4:	4010d43a 	srli	r8,r8,16
 100c2f8:	38ffffcc 	andi	r3,r7,65535
 100c2fc:	1105883a 	add	r2,r2,r4
 100c300:	1008d43a 	srli	r4,r2,16
 100c304:	44d1383a 	mul	r8,r8,r19
 100c308:	198d883a 	add	r6,r3,r6
 100c30c:	10ffffcc 	andi	r3,r2,65535
 100c310:	30c7c83a 	sub	r3,r6,r3
 100c314:	380ed43a 	srli	r7,r7,16
 100c318:	4105883a 	add	r2,r8,r4
 100c31c:	180dd43a 	srai	r6,r3,16
 100c320:	113fffcc 	andi	r4,r2,65535
 100c324:	390fc83a 	sub	r7,r7,r4
 100c328:	398d883a 	add	r6,r7,r6
 100c32c:	300e943a 	slli	r7,r6,16
 100c330:	18ffffcc 	andi	r3,r3,65535
 100c334:	1008d43a 	srli	r4,r2,16
 100c338:	38ceb03a 	or	r7,r7,r3
 100c33c:	49c00015 	stw	r7,0(r9)
 100c340:	300dd43a 	srai	r6,r6,16
 100c344:	4a400104 	addi	r9,r9,4
 100c348:	a17fe52e 	bgeu	r20,r5,100c2e0 <__alt_data_end+0xff80c2e0>
 100c34c:	b0800017 	ldw	r2,0(r22)
 100c350:	10000b1e 	bne	r2,zero,100c380 <quorem+0x120>
 100c354:	b0bfff04 	addi	r2,r22,-4
 100c358:	a880082e 	bgeu	r21,r2,100c37c <quorem+0x11c>
 100c35c:	b0ffff17 	ldw	r3,-4(r22)
 100c360:	18000326 	beq	r3,zero,100c370 <quorem+0x110>
 100c364:	00000506 	br	100c37c <quorem+0x11c>
 100c368:	10c00017 	ldw	r3,0(r2)
 100c36c:	1800031e 	bne	r3,zero,100c37c <quorem+0x11c>
 100c370:	10bfff04 	addi	r2,r2,-4
 100c374:	94bfffc4 	addi	r18,r18,-1
 100c378:	a8bffb36 	bltu	r21,r2,100c368 <__alt_data_end+0xff80c368>
 100c37c:	84800415 	stw	r18,16(r16)
 100c380:	b80b883a 	mov	r5,r23
 100c384:	8009883a 	mov	r4,r16
 100c388:	10101540 	call	1010154 <__mcmp>
 100c38c:	10002616 	blt	r2,zero,100c428 <quorem+0x1c8>
 100c390:	9cc00044 	addi	r19,r19,1
 100c394:	a805883a 	mov	r2,r21
 100c398:	000b883a 	mov	r5,zero
 100c39c:	11000017 	ldw	r4,0(r2)
 100c3a0:	89800017 	ldw	r6,0(r17)
 100c3a4:	10800104 	addi	r2,r2,4
 100c3a8:	20ffffcc 	andi	r3,r4,65535
 100c3ac:	194b883a 	add	r5,r3,r5
 100c3b0:	30ffffcc 	andi	r3,r6,65535
 100c3b4:	28c7c83a 	sub	r3,r5,r3
 100c3b8:	300cd43a 	srli	r6,r6,16
 100c3bc:	2008d43a 	srli	r4,r4,16
 100c3c0:	180bd43a 	srai	r5,r3,16
 100c3c4:	18ffffcc 	andi	r3,r3,65535
 100c3c8:	2189c83a 	sub	r4,r4,r6
 100c3cc:	2149883a 	add	r4,r4,r5
 100c3d0:	200c943a 	slli	r6,r4,16
 100c3d4:	8c400104 	addi	r17,r17,4
 100c3d8:	200bd43a 	srai	r5,r4,16
 100c3dc:	30c6b03a 	or	r3,r6,r3
 100c3e0:	10ffff15 	stw	r3,-4(r2)
 100c3e4:	a47fed2e 	bgeu	r20,r17,100c39c <__alt_data_end+0xff80c39c>
 100c3e8:	9485883a 	add	r2,r18,r18
 100c3ec:	1085883a 	add	r2,r2,r2
 100c3f0:	a887883a 	add	r3,r21,r2
 100c3f4:	18800017 	ldw	r2,0(r3)
 100c3f8:	10000b1e 	bne	r2,zero,100c428 <quorem+0x1c8>
 100c3fc:	18bfff04 	addi	r2,r3,-4
 100c400:	a880082e 	bgeu	r21,r2,100c424 <quorem+0x1c4>
 100c404:	18ffff17 	ldw	r3,-4(r3)
 100c408:	18000326 	beq	r3,zero,100c418 <quorem+0x1b8>
 100c40c:	00000506 	br	100c424 <quorem+0x1c4>
 100c410:	10c00017 	ldw	r3,0(r2)
 100c414:	1800031e 	bne	r3,zero,100c424 <quorem+0x1c4>
 100c418:	10bfff04 	addi	r2,r2,-4
 100c41c:	94bfffc4 	addi	r18,r18,-1
 100c420:	a8bffb36 	bltu	r21,r2,100c410 <__alt_data_end+0xff80c410>
 100c424:	84800415 	stw	r18,16(r16)
 100c428:	9805883a 	mov	r2,r19
 100c42c:	dfc00817 	ldw	ra,32(sp)
 100c430:	ddc00717 	ldw	r23,28(sp)
 100c434:	dd800617 	ldw	r22,24(sp)
 100c438:	dd400517 	ldw	r21,20(sp)
 100c43c:	dd000417 	ldw	r20,16(sp)
 100c440:	dcc00317 	ldw	r19,12(sp)
 100c444:	dc800217 	ldw	r18,8(sp)
 100c448:	dc400117 	ldw	r17,4(sp)
 100c44c:	dc000017 	ldw	r16,0(sp)
 100c450:	dec00904 	addi	sp,sp,36
 100c454:	f800283a 	ret
 100c458:	0005883a 	mov	r2,zero
 100c45c:	003ff306 	br	100c42c <__alt_data_end+0xff80c42c>

0100c460 <_dtoa_r>:
 100c460:	20801017 	ldw	r2,64(r4)
 100c464:	deffde04 	addi	sp,sp,-136
 100c468:	df002015 	stw	fp,128(sp)
 100c46c:	dcc01b15 	stw	r19,108(sp)
 100c470:	dc801a15 	stw	r18,104(sp)
 100c474:	dc401915 	stw	r17,100(sp)
 100c478:	dc001815 	stw	r16,96(sp)
 100c47c:	dfc02115 	stw	ra,132(sp)
 100c480:	ddc01f15 	stw	r23,124(sp)
 100c484:	dd801e15 	stw	r22,120(sp)
 100c488:	dd401d15 	stw	r21,116(sp)
 100c48c:	dd001c15 	stw	r20,112(sp)
 100c490:	d9c00315 	stw	r7,12(sp)
 100c494:	2039883a 	mov	fp,r4
 100c498:	3023883a 	mov	r17,r6
 100c49c:	2825883a 	mov	r18,r5
 100c4a0:	dc002417 	ldw	r16,144(sp)
 100c4a4:	3027883a 	mov	r19,r6
 100c4a8:	10000826 	beq	r2,zero,100c4cc <_dtoa_r+0x6c>
 100c4ac:	21801117 	ldw	r6,68(r4)
 100c4b0:	00c00044 	movi	r3,1
 100c4b4:	100b883a 	mov	r5,r2
 100c4b8:	1986983a 	sll	r3,r3,r6
 100c4bc:	11800115 	stw	r6,4(r2)
 100c4c0:	10c00215 	stw	r3,8(r2)
 100c4c4:	100f9340 	call	100f934 <_Bfree>
 100c4c8:	e0001015 	stw	zero,64(fp)
 100c4cc:	88002e16 	blt	r17,zero,100c588 <_dtoa_r+0x128>
 100c4d0:	80000015 	stw	zero,0(r16)
 100c4d4:	889ffc2c 	andhi	r2,r17,32752
 100c4d8:	00dffc34 	movhi	r3,32752
 100c4dc:	10c01c26 	beq	r2,r3,100c550 <_dtoa_r+0xf0>
 100c4e0:	000d883a 	mov	r6,zero
 100c4e4:	000f883a 	mov	r7,zero
 100c4e8:	9009883a 	mov	r4,r18
 100c4ec:	980b883a 	mov	r5,r19
 100c4f0:	1014df40 	call	1014df4 <__eqdf2>
 100c4f4:	10002b1e 	bne	r2,zero,100c5a4 <_dtoa_r+0x144>
 100c4f8:	d9c02317 	ldw	r7,140(sp)
 100c4fc:	00800044 	movi	r2,1
 100c500:	38800015 	stw	r2,0(r7)
 100c504:	d8802517 	ldw	r2,148(sp)
 100c508:	10019e26 	beq	r2,zero,100cb84 <_dtoa_r+0x724>
 100c50c:	d8c02517 	ldw	r3,148(sp)
 100c510:	008040b4 	movhi	r2,258
 100c514:	10ab0544 	addi	r2,r2,-21483
 100c518:	18800015 	stw	r2,0(r3)
 100c51c:	10bfffc4 	addi	r2,r2,-1
 100c520:	dfc02117 	ldw	ra,132(sp)
 100c524:	df002017 	ldw	fp,128(sp)
 100c528:	ddc01f17 	ldw	r23,124(sp)
 100c52c:	dd801e17 	ldw	r22,120(sp)
 100c530:	dd401d17 	ldw	r21,116(sp)
 100c534:	dd001c17 	ldw	r20,112(sp)
 100c538:	dcc01b17 	ldw	r19,108(sp)
 100c53c:	dc801a17 	ldw	r18,104(sp)
 100c540:	dc401917 	ldw	r17,100(sp)
 100c544:	dc001817 	ldw	r16,96(sp)
 100c548:	dec02204 	addi	sp,sp,136
 100c54c:	f800283a 	ret
 100c550:	d8c02317 	ldw	r3,140(sp)
 100c554:	0089c3c4 	movi	r2,9999
 100c558:	18800015 	stw	r2,0(r3)
 100c55c:	90017726 	beq	r18,zero,100cb3c <_dtoa_r+0x6dc>
 100c560:	008040b4 	movhi	r2,258
 100c564:	10ab1104 	addi	r2,r2,-21436
 100c568:	d9002517 	ldw	r4,148(sp)
 100c56c:	203fec26 	beq	r4,zero,100c520 <__alt_data_end+0xff80c520>
 100c570:	10c000c7 	ldb	r3,3(r2)
 100c574:	1801781e 	bne	r3,zero,100cb58 <_dtoa_r+0x6f8>
 100c578:	10c000c4 	addi	r3,r2,3
 100c57c:	d9802517 	ldw	r6,148(sp)
 100c580:	30c00015 	stw	r3,0(r6)
 100c584:	003fe606 	br	100c520 <__alt_data_end+0xff80c520>
 100c588:	04e00034 	movhi	r19,32768
 100c58c:	9cffffc4 	addi	r19,r19,-1
 100c590:	00800044 	movi	r2,1
 100c594:	8ce6703a 	and	r19,r17,r19
 100c598:	80800015 	stw	r2,0(r16)
 100c59c:	9823883a 	mov	r17,r19
 100c5a0:	003fcc06 	br	100c4d4 <__alt_data_end+0xff80c4d4>
 100c5a4:	d8800204 	addi	r2,sp,8
 100c5a8:	d8800015 	stw	r2,0(sp)
 100c5ac:	d9c00104 	addi	r7,sp,4
 100c5b0:	900b883a 	mov	r5,r18
 100c5b4:	980d883a 	mov	r6,r19
 100c5b8:	e009883a 	mov	r4,fp
 100c5bc:	8820d53a 	srli	r16,r17,20
 100c5c0:	10105200 	call	1010520 <__d2b>
 100c5c4:	d8800915 	stw	r2,36(sp)
 100c5c8:	8001651e 	bne	r16,zero,100cb60 <_dtoa_r+0x700>
 100c5cc:	dd800217 	ldw	r22,8(sp)
 100c5d0:	dc000117 	ldw	r16,4(sp)
 100c5d4:	00800804 	movi	r2,32
 100c5d8:	b421883a 	add	r16,r22,r16
 100c5dc:	80c10c84 	addi	r3,r16,1074
 100c5e0:	10c2d10e 	bge	r2,r3,100d128 <_dtoa_r+0xcc8>
 100c5e4:	00801004 	movi	r2,64
 100c5e8:	81010484 	addi	r4,r16,1042
 100c5ec:	10c7c83a 	sub	r3,r2,r3
 100c5f0:	9108d83a 	srl	r4,r18,r4
 100c5f4:	88e2983a 	sll	r17,r17,r3
 100c5f8:	2448b03a 	or	r4,r4,r17
 100c5fc:	10161bc0 	call	10161bc <__floatunsidf>
 100c600:	017f8434 	movhi	r5,65040
 100c604:	01800044 	movi	r6,1
 100c608:	1009883a 	mov	r4,r2
 100c60c:	194b883a 	add	r5,r3,r5
 100c610:	843fffc4 	addi	r16,r16,-1
 100c614:	d9801115 	stw	r6,68(sp)
 100c618:	000d883a 	mov	r6,zero
 100c61c:	01cffe34 	movhi	r7,16376
 100c620:	10157640 	call	1015764 <__subdf3>
 100c624:	0198dbf4 	movhi	r6,25455
 100c628:	01cff4f4 	movhi	r7,16339
 100c62c:	3190d844 	addi	r6,r6,17249
 100c630:	39e1e9c4 	addi	r7,r7,-30809
 100c634:	1009883a 	mov	r4,r2
 100c638:	180b883a 	mov	r5,r3
 100c63c:	101504c0 	call	101504c <__muldf3>
 100c640:	01a2d874 	movhi	r6,35681
 100c644:	01cff1f4 	movhi	r7,16327
 100c648:	31b22cc4 	addi	r6,r6,-14157
 100c64c:	39e28a04 	addi	r7,r7,-30168
 100c650:	180b883a 	mov	r5,r3
 100c654:	1009883a 	mov	r4,r2
 100c658:	1013c600 	call	1013c60 <__adddf3>
 100c65c:	8009883a 	mov	r4,r16
 100c660:	1029883a 	mov	r20,r2
 100c664:	1823883a 	mov	r17,r3
 100c668:	10160e00 	call	10160e0 <__floatsidf>
 100c66c:	019427f4 	movhi	r6,20639
 100c670:	01cff4f4 	movhi	r7,16339
 100c674:	319e7ec4 	addi	r6,r6,31227
 100c678:	39d104c4 	addi	r7,r7,17427
 100c67c:	1009883a 	mov	r4,r2
 100c680:	180b883a 	mov	r5,r3
 100c684:	101504c0 	call	101504c <__muldf3>
 100c688:	100d883a 	mov	r6,r2
 100c68c:	180f883a 	mov	r7,r3
 100c690:	a009883a 	mov	r4,r20
 100c694:	880b883a 	mov	r5,r17
 100c698:	1013c600 	call	1013c60 <__adddf3>
 100c69c:	1009883a 	mov	r4,r2
 100c6a0:	180b883a 	mov	r5,r3
 100c6a4:	1029883a 	mov	r20,r2
 100c6a8:	1823883a 	mov	r17,r3
 100c6ac:	10160600 	call	1016060 <__fixdfsi>
 100c6b0:	000d883a 	mov	r6,zero
 100c6b4:	000f883a 	mov	r7,zero
 100c6b8:	a009883a 	mov	r4,r20
 100c6bc:	880b883a 	mov	r5,r17
 100c6c0:	d8800515 	stw	r2,20(sp)
 100c6c4:	1014f580 	call	1014f58 <__ledf2>
 100c6c8:	10028716 	blt	r2,zero,100d0e8 <_dtoa_r+0xc88>
 100c6cc:	d8c00517 	ldw	r3,20(sp)
 100c6d0:	00800584 	movi	r2,22
 100c6d4:	10c27536 	bltu	r2,r3,100d0ac <_dtoa_r+0xc4c>
 100c6d8:	180490fa 	slli	r2,r3,3
 100c6dc:	00c040b4 	movhi	r3,258
 100c6e0:	18eb2d04 	addi	r3,r3,-21324
 100c6e4:	1885883a 	add	r2,r3,r2
 100c6e8:	11000017 	ldw	r4,0(r2)
 100c6ec:	11400117 	ldw	r5,4(r2)
 100c6f0:	900d883a 	mov	r6,r18
 100c6f4:	980f883a 	mov	r7,r19
 100c6f8:	1014e7c0 	call	1014e7c <__gedf2>
 100c6fc:	00828d0e 	bge	zero,r2,100d134 <_dtoa_r+0xcd4>
 100c700:	d9000517 	ldw	r4,20(sp)
 100c704:	d8000e15 	stw	zero,56(sp)
 100c708:	213fffc4 	addi	r4,r4,-1
 100c70c:	d9000515 	stw	r4,20(sp)
 100c710:	b42dc83a 	sub	r22,r22,r16
 100c714:	b5bfffc4 	addi	r22,r22,-1
 100c718:	b0026f16 	blt	r22,zero,100d0d8 <_dtoa_r+0xc78>
 100c71c:	d8000815 	stw	zero,32(sp)
 100c720:	d9c00517 	ldw	r7,20(sp)
 100c724:	38026416 	blt	r7,zero,100d0b8 <_dtoa_r+0xc58>
 100c728:	b1ed883a 	add	r22,r22,r7
 100c72c:	d9c00d15 	stw	r7,52(sp)
 100c730:	d8000a15 	stw	zero,40(sp)
 100c734:	d9800317 	ldw	r6,12(sp)
 100c738:	00800244 	movi	r2,9
 100c73c:	11811436 	bltu	r2,r6,100cb90 <_dtoa_r+0x730>
 100c740:	00800144 	movi	r2,5
 100c744:	1184e10e 	bge	r2,r6,100dacc <_dtoa_r+0x166c>
 100c748:	31bfff04 	addi	r6,r6,-4
 100c74c:	d9800315 	stw	r6,12(sp)
 100c750:	0023883a 	mov	r17,zero
 100c754:	d9800317 	ldw	r6,12(sp)
 100c758:	008000c4 	movi	r2,3
 100c75c:	30836726 	beq	r6,r2,100d4fc <_dtoa_r+0x109c>
 100c760:	1183410e 	bge	r2,r6,100d468 <_dtoa_r+0x1008>
 100c764:	d9c00317 	ldw	r7,12(sp)
 100c768:	00800104 	movi	r2,4
 100c76c:	38827c26 	beq	r7,r2,100d160 <_dtoa_r+0xd00>
 100c770:	00800144 	movi	r2,5
 100c774:	3884c41e 	bne	r7,r2,100da88 <_dtoa_r+0x1628>
 100c778:	00800044 	movi	r2,1
 100c77c:	d8800b15 	stw	r2,44(sp)
 100c780:	d8c00517 	ldw	r3,20(sp)
 100c784:	d9002217 	ldw	r4,136(sp)
 100c788:	1907883a 	add	r3,r3,r4
 100c78c:	19800044 	addi	r6,r3,1
 100c790:	d8c00c15 	stw	r3,48(sp)
 100c794:	d9800615 	stw	r6,24(sp)
 100c798:	0183a40e 	bge	zero,r6,100d62c <_dtoa_r+0x11cc>
 100c79c:	d9800617 	ldw	r6,24(sp)
 100c7a0:	3021883a 	mov	r16,r6
 100c7a4:	e0001115 	stw	zero,68(fp)
 100c7a8:	008005c4 	movi	r2,23
 100c7ac:	1184c92e 	bgeu	r2,r6,100dad4 <_dtoa_r+0x1674>
 100c7b0:	00c00044 	movi	r3,1
 100c7b4:	00800104 	movi	r2,4
 100c7b8:	1085883a 	add	r2,r2,r2
 100c7bc:	11000504 	addi	r4,r2,20
 100c7c0:	180b883a 	mov	r5,r3
 100c7c4:	18c00044 	addi	r3,r3,1
 100c7c8:	313ffb2e 	bgeu	r6,r4,100c7b8 <__alt_data_end+0xff80c7b8>
 100c7cc:	e1401115 	stw	r5,68(fp)
 100c7d0:	e009883a 	mov	r4,fp
 100c7d4:	100f88c0 	call	100f88c <_Balloc>
 100c7d8:	d8800715 	stw	r2,28(sp)
 100c7dc:	e0801015 	stw	r2,64(fp)
 100c7e0:	00800384 	movi	r2,14
 100c7e4:	1400f736 	bltu	r2,r16,100cbc4 <_dtoa_r+0x764>
 100c7e8:	8800f626 	beq	r17,zero,100cbc4 <_dtoa_r+0x764>
 100c7ec:	d9c00517 	ldw	r7,20(sp)
 100c7f0:	01c39a0e 	bge	zero,r7,100d65c <_dtoa_r+0x11fc>
 100c7f4:	388003cc 	andi	r2,r7,15
 100c7f8:	100490fa 	slli	r2,r2,3
 100c7fc:	382bd13a 	srai	r21,r7,4
 100c800:	00c040b4 	movhi	r3,258
 100c804:	18eb2d04 	addi	r3,r3,-21324
 100c808:	1885883a 	add	r2,r3,r2
 100c80c:	a8c0040c 	andi	r3,r21,16
 100c810:	12400017 	ldw	r9,0(r2)
 100c814:	12000117 	ldw	r8,4(r2)
 100c818:	18037926 	beq	r3,zero,100d600 <_dtoa_r+0x11a0>
 100c81c:	008040b4 	movhi	r2,258
 100c820:	10ab2304 	addi	r2,r2,-21364
 100c824:	11800817 	ldw	r6,32(r2)
 100c828:	11c00917 	ldw	r7,36(r2)
 100c82c:	9009883a 	mov	r4,r18
 100c830:	980b883a 	mov	r5,r19
 100c834:	da001715 	stw	r8,92(sp)
 100c838:	da401615 	stw	r9,88(sp)
 100c83c:	101450c0 	call	101450c <__divdf3>
 100c840:	da001717 	ldw	r8,92(sp)
 100c844:	da401617 	ldw	r9,88(sp)
 100c848:	ad4003cc 	andi	r21,r21,15
 100c84c:	040000c4 	movi	r16,3
 100c850:	1023883a 	mov	r17,r2
 100c854:	1829883a 	mov	r20,r3
 100c858:	a8001126 	beq	r21,zero,100c8a0 <_dtoa_r+0x440>
 100c85c:	05c040b4 	movhi	r23,258
 100c860:	bdeb2304 	addi	r23,r23,-21364
 100c864:	4805883a 	mov	r2,r9
 100c868:	4007883a 	mov	r3,r8
 100c86c:	a980004c 	andi	r6,r21,1
 100c870:	1009883a 	mov	r4,r2
 100c874:	a82bd07a 	srai	r21,r21,1
 100c878:	180b883a 	mov	r5,r3
 100c87c:	30000426 	beq	r6,zero,100c890 <_dtoa_r+0x430>
 100c880:	b9800017 	ldw	r6,0(r23)
 100c884:	b9c00117 	ldw	r7,4(r23)
 100c888:	84000044 	addi	r16,r16,1
 100c88c:	101504c0 	call	101504c <__muldf3>
 100c890:	bdc00204 	addi	r23,r23,8
 100c894:	a83ff51e 	bne	r21,zero,100c86c <__alt_data_end+0xff80c86c>
 100c898:	1013883a 	mov	r9,r2
 100c89c:	1811883a 	mov	r8,r3
 100c8a0:	480d883a 	mov	r6,r9
 100c8a4:	400f883a 	mov	r7,r8
 100c8a8:	8809883a 	mov	r4,r17
 100c8ac:	a00b883a 	mov	r5,r20
 100c8b0:	101450c0 	call	101450c <__divdf3>
 100c8b4:	d8800f15 	stw	r2,60(sp)
 100c8b8:	d8c01015 	stw	r3,64(sp)
 100c8bc:	d8c00e17 	ldw	r3,56(sp)
 100c8c0:	18000626 	beq	r3,zero,100c8dc <_dtoa_r+0x47c>
 100c8c4:	d9000f17 	ldw	r4,60(sp)
 100c8c8:	d9401017 	ldw	r5,64(sp)
 100c8cc:	000d883a 	mov	r6,zero
 100c8d0:	01cffc34 	movhi	r7,16368
 100c8d4:	1014f580 	call	1014f58 <__ledf2>
 100c8d8:	10040b16 	blt	r2,zero,100d908 <_dtoa_r+0x14a8>
 100c8dc:	8009883a 	mov	r4,r16
 100c8e0:	10160e00 	call	10160e0 <__floatsidf>
 100c8e4:	d9800f17 	ldw	r6,60(sp)
 100c8e8:	d9c01017 	ldw	r7,64(sp)
 100c8ec:	1009883a 	mov	r4,r2
 100c8f0:	180b883a 	mov	r5,r3
 100c8f4:	101504c0 	call	101504c <__muldf3>
 100c8f8:	000d883a 	mov	r6,zero
 100c8fc:	01d00734 	movhi	r7,16412
 100c900:	1009883a 	mov	r4,r2
 100c904:	180b883a 	mov	r5,r3
 100c908:	1013c600 	call	1013c60 <__adddf3>
 100c90c:	1021883a 	mov	r16,r2
 100c910:	d8800617 	ldw	r2,24(sp)
 100c914:	047f3034 	movhi	r17,64704
 100c918:	1c63883a 	add	r17,r3,r17
 100c91c:	10031826 	beq	r2,zero,100d580 <_dtoa_r+0x1120>
 100c920:	d8c00517 	ldw	r3,20(sp)
 100c924:	db000617 	ldw	r12,24(sp)
 100c928:	d8c01315 	stw	r3,76(sp)
 100c92c:	d9000b17 	ldw	r4,44(sp)
 100c930:	20038f26 	beq	r4,zero,100d770 <_dtoa_r+0x1310>
 100c934:	60bfffc4 	addi	r2,r12,-1
 100c938:	100490fa 	slli	r2,r2,3
 100c93c:	00c040b4 	movhi	r3,258
 100c940:	18eb2d04 	addi	r3,r3,-21324
 100c944:	1885883a 	add	r2,r3,r2
 100c948:	11800017 	ldw	r6,0(r2)
 100c94c:	11c00117 	ldw	r7,4(r2)
 100c950:	d8800717 	ldw	r2,28(sp)
 100c954:	0009883a 	mov	r4,zero
 100c958:	014ff834 	movhi	r5,16352
 100c95c:	db001615 	stw	r12,88(sp)
 100c960:	15c00044 	addi	r23,r2,1
 100c964:	101450c0 	call	101450c <__divdf3>
 100c968:	800d883a 	mov	r6,r16
 100c96c:	880f883a 	mov	r7,r17
 100c970:	1009883a 	mov	r4,r2
 100c974:	180b883a 	mov	r5,r3
 100c978:	10157640 	call	1015764 <__subdf3>
 100c97c:	d9401017 	ldw	r5,64(sp)
 100c980:	d9000f17 	ldw	r4,60(sp)
 100c984:	102b883a 	mov	r21,r2
 100c988:	d8c01215 	stw	r3,72(sp)
 100c98c:	10160600 	call	1016060 <__fixdfsi>
 100c990:	1009883a 	mov	r4,r2
 100c994:	1029883a 	mov	r20,r2
 100c998:	10160e00 	call	10160e0 <__floatsidf>
 100c99c:	d9000f17 	ldw	r4,60(sp)
 100c9a0:	d9401017 	ldw	r5,64(sp)
 100c9a4:	100d883a 	mov	r6,r2
 100c9a8:	180f883a 	mov	r7,r3
 100c9ac:	10157640 	call	1015764 <__subdf3>
 100c9b0:	1823883a 	mov	r17,r3
 100c9b4:	d8c00717 	ldw	r3,28(sp)
 100c9b8:	d9401217 	ldw	r5,72(sp)
 100c9bc:	a2000c04 	addi	r8,r20,48
 100c9c0:	1021883a 	mov	r16,r2
 100c9c4:	1a000005 	stb	r8,0(r3)
 100c9c8:	800d883a 	mov	r6,r16
 100c9cc:	880f883a 	mov	r7,r17
 100c9d0:	a809883a 	mov	r4,r21
 100c9d4:	4029883a 	mov	r20,r8
 100c9d8:	1014e7c0 	call	1014e7c <__gedf2>
 100c9dc:	00841d16 	blt	zero,r2,100da54 <_dtoa_r+0x15f4>
 100c9e0:	800d883a 	mov	r6,r16
 100c9e4:	880f883a 	mov	r7,r17
 100c9e8:	0009883a 	mov	r4,zero
 100c9ec:	014ffc34 	movhi	r5,16368
 100c9f0:	10157640 	call	1015764 <__subdf3>
 100c9f4:	d9401217 	ldw	r5,72(sp)
 100c9f8:	100d883a 	mov	r6,r2
 100c9fc:	180f883a 	mov	r7,r3
 100ca00:	a809883a 	mov	r4,r21
 100ca04:	1014e7c0 	call	1014e7c <__gedf2>
 100ca08:	db001617 	ldw	r12,88(sp)
 100ca0c:	00840e16 	blt	zero,r2,100da48 <_dtoa_r+0x15e8>
 100ca10:	00800044 	movi	r2,1
 100ca14:	13006b0e 	bge	r2,r12,100cbc4 <_dtoa_r+0x764>
 100ca18:	d9000717 	ldw	r4,28(sp)
 100ca1c:	dd800f15 	stw	r22,60(sp)
 100ca20:	dcc01015 	stw	r19,64(sp)
 100ca24:	2319883a 	add	r12,r4,r12
 100ca28:	dcc01217 	ldw	r19,72(sp)
 100ca2c:	602d883a 	mov	r22,r12
 100ca30:	dc801215 	stw	r18,72(sp)
 100ca34:	b825883a 	mov	r18,r23
 100ca38:	00000906 	br	100ca60 <_dtoa_r+0x600>
 100ca3c:	10157640 	call	1015764 <__subdf3>
 100ca40:	a80d883a 	mov	r6,r21
 100ca44:	980f883a 	mov	r7,r19
 100ca48:	1009883a 	mov	r4,r2
 100ca4c:	180b883a 	mov	r5,r3
 100ca50:	1014f580 	call	1014f58 <__ledf2>
 100ca54:	1003e816 	blt	r2,zero,100d9f8 <_dtoa_r+0x1598>
 100ca58:	b825883a 	mov	r18,r23
 100ca5c:	bd83e926 	beq	r23,r22,100da04 <_dtoa_r+0x15a4>
 100ca60:	a809883a 	mov	r4,r21
 100ca64:	980b883a 	mov	r5,r19
 100ca68:	000d883a 	mov	r6,zero
 100ca6c:	01d00934 	movhi	r7,16420
 100ca70:	101504c0 	call	101504c <__muldf3>
 100ca74:	000d883a 	mov	r6,zero
 100ca78:	01d00934 	movhi	r7,16420
 100ca7c:	8009883a 	mov	r4,r16
 100ca80:	880b883a 	mov	r5,r17
 100ca84:	102b883a 	mov	r21,r2
 100ca88:	1827883a 	mov	r19,r3
 100ca8c:	101504c0 	call	101504c <__muldf3>
 100ca90:	180b883a 	mov	r5,r3
 100ca94:	1009883a 	mov	r4,r2
 100ca98:	1821883a 	mov	r16,r3
 100ca9c:	1023883a 	mov	r17,r2
 100caa0:	10160600 	call	1016060 <__fixdfsi>
 100caa4:	1009883a 	mov	r4,r2
 100caa8:	1029883a 	mov	r20,r2
 100caac:	10160e00 	call	10160e0 <__floatsidf>
 100cab0:	8809883a 	mov	r4,r17
 100cab4:	800b883a 	mov	r5,r16
 100cab8:	100d883a 	mov	r6,r2
 100cabc:	180f883a 	mov	r7,r3
 100cac0:	10157640 	call	1015764 <__subdf3>
 100cac4:	a5000c04 	addi	r20,r20,48
 100cac8:	a80d883a 	mov	r6,r21
 100cacc:	980f883a 	mov	r7,r19
 100cad0:	1009883a 	mov	r4,r2
 100cad4:	180b883a 	mov	r5,r3
 100cad8:	95000005 	stb	r20,0(r18)
 100cadc:	1021883a 	mov	r16,r2
 100cae0:	1823883a 	mov	r17,r3
 100cae4:	1014f580 	call	1014f58 <__ledf2>
 100cae8:	bdc00044 	addi	r23,r23,1
 100caec:	800d883a 	mov	r6,r16
 100caf0:	880f883a 	mov	r7,r17
 100caf4:	0009883a 	mov	r4,zero
 100caf8:	014ffc34 	movhi	r5,16368
 100cafc:	103fcf0e 	bge	r2,zero,100ca3c <__alt_data_end+0xff80ca3c>
 100cb00:	d8c01317 	ldw	r3,76(sp)
 100cb04:	d8c00515 	stw	r3,20(sp)
 100cb08:	d9400917 	ldw	r5,36(sp)
 100cb0c:	e009883a 	mov	r4,fp
 100cb10:	100f9340 	call	100f934 <_Bfree>
 100cb14:	d9000517 	ldw	r4,20(sp)
 100cb18:	d9802317 	ldw	r6,140(sp)
 100cb1c:	d9c02517 	ldw	r7,148(sp)
 100cb20:	b8000005 	stb	zero,0(r23)
 100cb24:	20800044 	addi	r2,r4,1
 100cb28:	30800015 	stw	r2,0(r6)
 100cb2c:	3802aa26 	beq	r7,zero,100d5d8 <_dtoa_r+0x1178>
 100cb30:	3dc00015 	stw	r23,0(r7)
 100cb34:	d8800717 	ldw	r2,28(sp)
 100cb38:	003e7906 	br	100c520 <__alt_data_end+0xff80c520>
 100cb3c:	00800434 	movhi	r2,16
 100cb40:	10bfffc4 	addi	r2,r2,-1
 100cb44:	88a2703a 	and	r17,r17,r2
 100cb48:	883e851e 	bne	r17,zero,100c560 <__alt_data_end+0xff80c560>
 100cb4c:	008040b4 	movhi	r2,258
 100cb50:	10ab0e04 	addi	r2,r2,-21448
 100cb54:	003e8406 	br	100c568 <__alt_data_end+0xff80c568>
 100cb58:	10c00204 	addi	r3,r2,8
 100cb5c:	003e8706 	br	100c57c <__alt_data_end+0xff80c57c>
 100cb60:	01400434 	movhi	r5,16
 100cb64:	297fffc4 	addi	r5,r5,-1
 100cb68:	994a703a 	and	r5,r19,r5
 100cb6c:	9009883a 	mov	r4,r18
 100cb70:	843f0044 	addi	r16,r16,-1023
 100cb74:	294ffc34 	orhi	r5,r5,16368
 100cb78:	dd800217 	ldw	r22,8(sp)
 100cb7c:	d8001115 	stw	zero,68(sp)
 100cb80:	003ea506 	br	100c618 <__alt_data_end+0xff80c618>
 100cb84:	008040b4 	movhi	r2,258
 100cb88:	10ab0504 	addi	r2,r2,-21484
 100cb8c:	003e6406 	br	100c520 <__alt_data_end+0xff80c520>
 100cb90:	e0001115 	stw	zero,68(fp)
 100cb94:	000b883a 	mov	r5,zero
 100cb98:	e009883a 	mov	r4,fp
 100cb9c:	100f88c0 	call	100f88c <_Balloc>
 100cba0:	01bfffc4 	movi	r6,-1
 100cba4:	01c00044 	movi	r7,1
 100cba8:	d8800715 	stw	r2,28(sp)
 100cbac:	d9800c15 	stw	r6,48(sp)
 100cbb0:	e0801015 	stw	r2,64(fp)
 100cbb4:	d8000315 	stw	zero,12(sp)
 100cbb8:	d9c00b15 	stw	r7,44(sp)
 100cbbc:	d9800615 	stw	r6,24(sp)
 100cbc0:	d8002215 	stw	zero,136(sp)
 100cbc4:	d8800117 	ldw	r2,4(sp)
 100cbc8:	10008916 	blt	r2,zero,100cdf0 <_dtoa_r+0x990>
 100cbcc:	d9000517 	ldw	r4,20(sp)
 100cbd0:	00c00384 	movi	r3,14
 100cbd4:	19008616 	blt	r3,r4,100cdf0 <_dtoa_r+0x990>
 100cbd8:	200490fa 	slli	r2,r4,3
 100cbdc:	00c040b4 	movhi	r3,258
 100cbe0:	d9802217 	ldw	r6,136(sp)
 100cbe4:	18eb2d04 	addi	r3,r3,-21324
 100cbe8:	1885883a 	add	r2,r3,r2
 100cbec:	14000017 	ldw	r16,0(r2)
 100cbf0:	14400117 	ldw	r17,4(r2)
 100cbf4:	30016316 	blt	r6,zero,100d184 <_dtoa_r+0xd24>
 100cbf8:	800d883a 	mov	r6,r16
 100cbfc:	880f883a 	mov	r7,r17
 100cc00:	9009883a 	mov	r4,r18
 100cc04:	980b883a 	mov	r5,r19
 100cc08:	101450c0 	call	101450c <__divdf3>
 100cc0c:	180b883a 	mov	r5,r3
 100cc10:	1009883a 	mov	r4,r2
 100cc14:	10160600 	call	1016060 <__fixdfsi>
 100cc18:	1009883a 	mov	r4,r2
 100cc1c:	102b883a 	mov	r21,r2
 100cc20:	10160e00 	call	10160e0 <__floatsidf>
 100cc24:	800d883a 	mov	r6,r16
 100cc28:	880f883a 	mov	r7,r17
 100cc2c:	1009883a 	mov	r4,r2
 100cc30:	180b883a 	mov	r5,r3
 100cc34:	101504c0 	call	101504c <__muldf3>
 100cc38:	100d883a 	mov	r6,r2
 100cc3c:	180f883a 	mov	r7,r3
 100cc40:	9009883a 	mov	r4,r18
 100cc44:	980b883a 	mov	r5,r19
 100cc48:	10157640 	call	1015764 <__subdf3>
 100cc4c:	d9c00717 	ldw	r7,28(sp)
 100cc50:	1009883a 	mov	r4,r2
 100cc54:	a8800c04 	addi	r2,r21,48
 100cc58:	38800005 	stb	r2,0(r7)
 100cc5c:	3dc00044 	addi	r23,r7,1
 100cc60:	d9c00617 	ldw	r7,24(sp)
 100cc64:	01800044 	movi	r6,1
 100cc68:	180b883a 	mov	r5,r3
 100cc6c:	2005883a 	mov	r2,r4
 100cc70:	39803826 	beq	r7,r6,100cd54 <_dtoa_r+0x8f4>
 100cc74:	000d883a 	mov	r6,zero
 100cc78:	01d00934 	movhi	r7,16420
 100cc7c:	101504c0 	call	101504c <__muldf3>
 100cc80:	000d883a 	mov	r6,zero
 100cc84:	000f883a 	mov	r7,zero
 100cc88:	1009883a 	mov	r4,r2
 100cc8c:	180b883a 	mov	r5,r3
 100cc90:	1025883a 	mov	r18,r2
 100cc94:	1827883a 	mov	r19,r3
 100cc98:	1014df40 	call	1014df4 <__eqdf2>
 100cc9c:	103f9a26 	beq	r2,zero,100cb08 <__alt_data_end+0xff80cb08>
 100cca0:	d9c00617 	ldw	r7,24(sp)
 100cca4:	d8c00717 	ldw	r3,28(sp)
 100cca8:	b829883a 	mov	r20,r23
 100ccac:	38bfffc4 	addi	r2,r7,-1
 100ccb0:	18ad883a 	add	r22,r3,r2
 100ccb4:	00000a06 	br	100cce0 <_dtoa_r+0x880>
 100ccb8:	101504c0 	call	101504c <__muldf3>
 100ccbc:	000d883a 	mov	r6,zero
 100ccc0:	000f883a 	mov	r7,zero
 100ccc4:	1009883a 	mov	r4,r2
 100ccc8:	180b883a 	mov	r5,r3
 100cccc:	1025883a 	mov	r18,r2
 100ccd0:	1827883a 	mov	r19,r3
 100ccd4:	b829883a 	mov	r20,r23
 100ccd8:	1014df40 	call	1014df4 <__eqdf2>
 100ccdc:	103f8a26 	beq	r2,zero,100cb08 <__alt_data_end+0xff80cb08>
 100cce0:	800d883a 	mov	r6,r16
 100cce4:	880f883a 	mov	r7,r17
 100cce8:	9009883a 	mov	r4,r18
 100ccec:	980b883a 	mov	r5,r19
 100ccf0:	101450c0 	call	101450c <__divdf3>
 100ccf4:	180b883a 	mov	r5,r3
 100ccf8:	1009883a 	mov	r4,r2
 100ccfc:	10160600 	call	1016060 <__fixdfsi>
 100cd00:	1009883a 	mov	r4,r2
 100cd04:	102b883a 	mov	r21,r2
 100cd08:	10160e00 	call	10160e0 <__floatsidf>
 100cd0c:	800d883a 	mov	r6,r16
 100cd10:	880f883a 	mov	r7,r17
 100cd14:	1009883a 	mov	r4,r2
 100cd18:	180b883a 	mov	r5,r3
 100cd1c:	101504c0 	call	101504c <__muldf3>
 100cd20:	100d883a 	mov	r6,r2
 100cd24:	180f883a 	mov	r7,r3
 100cd28:	9009883a 	mov	r4,r18
 100cd2c:	980b883a 	mov	r5,r19
 100cd30:	10157640 	call	1015764 <__subdf3>
 100cd34:	aa000c04 	addi	r8,r21,48
 100cd38:	a2000005 	stb	r8,0(r20)
 100cd3c:	000d883a 	mov	r6,zero
 100cd40:	01d00934 	movhi	r7,16420
 100cd44:	1009883a 	mov	r4,r2
 100cd48:	180b883a 	mov	r5,r3
 100cd4c:	a5c00044 	addi	r23,r20,1
 100cd50:	b53fd91e 	bne	r22,r20,100ccb8 <__alt_data_end+0xff80ccb8>
 100cd54:	100d883a 	mov	r6,r2
 100cd58:	180f883a 	mov	r7,r3
 100cd5c:	1009883a 	mov	r4,r2
 100cd60:	180b883a 	mov	r5,r3
 100cd64:	1013c600 	call	1013c60 <__adddf3>
 100cd68:	100d883a 	mov	r6,r2
 100cd6c:	180f883a 	mov	r7,r3
 100cd70:	8009883a 	mov	r4,r16
 100cd74:	880b883a 	mov	r5,r17
 100cd78:	1027883a 	mov	r19,r2
 100cd7c:	1825883a 	mov	r18,r3
 100cd80:	1014f580 	call	1014f58 <__ledf2>
 100cd84:	10000816 	blt	r2,zero,100cda8 <_dtoa_r+0x948>
 100cd88:	980d883a 	mov	r6,r19
 100cd8c:	900f883a 	mov	r7,r18
 100cd90:	8009883a 	mov	r4,r16
 100cd94:	880b883a 	mov	r5,r17
 100cd98:	1014df40 	call	1014df4 <__eqdf2>
 100cd9c:	103f5a1e 	bne	r2,zero,100cb08 <__alt_data_end+0xff80cb08>
 100cda0:	ad40004c 	andi	r21,r21,1
 100cda4:	a83f5826 	beq	r21,zero,100cb08 <__alt_data_end+0xff80cb08>
 100cda8:	bd3fffc3 	ldbu	r20,-1(r23)
 100cdac:	b8bfffc4 	addi	r2,r23,-1
 100cdb0:	1007883a 	mov	r3,r2
 100cdb4:	01400e44 	movi	r5,57
 100cdb8:	d9800717 	ldw	r6,28(sp)
 100cdbc:	00000506 	br	100cdd4 <_dtoa_r+0x974>
 100cdc0:	18ffffc4 	addi	r3,r3,-1
 100cdc4:	11824726 	beq	r2,r6,100d6e4 <_dtoa_r+0x1284>
 100cdc8:	1d000003 	ldbu	r20,0(r3)
 100cdcc:	102f883a 	mov	r23,r2
 100cdd0:	10bfffc4 	addi	r2,r2,-1
 100cdd4:	a1003fcc 	andi	r4,r20,255
 100cdd8:	2100201c 	xori	r4,r4,128
 100cddc:	213fe004 	addi	r4,r4,-128
 100cde0:	217ff726 	beq	r4,r5,100cdc0 <__alt_data_end+0xff80cdc0>
 100cde4:	a2000044 	addi	r8,r20,1
 100cde8:	12000005 	stb	r8,0(r2)
 100cdec:	003f4606 	br	100cb08 <__alt_data_end+0xff80cb08>
 100cdf0:	d9000b17 	ldw	r4,44(sp)
 100cdf4:	2000c826 	beq	r4,zero,100d118 <_dtoa_r+0xcb8>
 100cdf8:	d9800317 	ldw	r6,12(sp)
 100cdfc:	00c00044 	movi	r3,1
 100ce00:	1980f90e 	bge	r3,r6,100d1e8 <_dtoa_r+0xd88>
 100ce04:	d8800617 	ldw	r2,24(sp)
 100ce08:	d8c00a17 	ldw	r3,40(sp)
 100ce0c:	157fffc4 	addi	r21,r2,-1
 100ce10:	1d41f316 	blt	r3,r21,100d5e0 <_dtoa_r+0x1180>
 100ce14:	1d6bc83a 	sub	r21,r3,r21
 100ce18:	d9c00617 	ldw	r7,24(sp)
 100ce1c:	3802aa16 	blt	r7,zero,100d8c8 <_dtoa_r+0x1468>
 100ce20:	dd000817 	ldw	r20,32(sp)
 100ce24:	d8800617 	ldw	r2,24(sp)
 100ce28:	d8c00817 	ldw	r3,32(sp)
 100ce2c:	01400044 	movi	r5,1
 100ce30:	e009883a 	mov	r4,fp
 100ce34:	1887883a 	add	r3,r3,r2
 100ce38:	d8c00815 	stw	r3,32(sp)
 100ce3c:	b0ad883a 	add	r22,r22,r2
 100ce40:	100fc980 	call	100fc98 <__i2b>
 100ce44:	1023883a 	mov	r17,r2
 100ce48:	a0000826 	beq	r20,zero,100ce6c <_dtoa_r+0xa0c>
 100ce4c:	0580070e 	bge	zero,r22,100ce6c <_dtoa_r+0xa0c>
 100ce50:	a005883a 	mov	r2,r20
 100ce54:	b500b916 	blt	r22,r20,100d13c <_dtoa_r+0xcdc>
 100ce58:	d9000817 	ldw	r4,32(sp)
 100ce5c:	a0a9c83a 	sub	r20,r20,r2
 100ce60:	b0adc83a 	sub	r22,r22,r2
 100ce64:	2089c83a 	sub	r4,r4,r2
 100ce68:	d9000815 	stw	r4,32(sp)
 100ce6c:	d9800a17 	ldw	r6,40(sp)
 100ce70:	0181810e 	bge	zero,r6,100d478 <_dtoa_r+0x1018>
 100ce74:	d9c00b17 	ldw	r7,44(sp)
 100ce78:	3800b326 	beq	r7,zero,100d148 <_dtoa_r+0xce8>
 100ce7c:	a800b226 	beq	r21,zero,100d148 <_dtoa_r+0xce8>
 100ce80:	880b883a 	mov	r5,r17
 100ce84:	a80d883a 	mov	r6,r21
 100ce88:	e009883a 	mov	r4,fp
 100ce8c:	100fecc0 	call	100fecc <__pow5mult>
 100ce90:	d9800917 	ldw	r6,36(sp)
 100ce94:	100b883a 	mov	r5,r2
 100ce98:	e009883a 	mov	r4,fp
 100ce9c:	1023883a 	mov	r17,r2
 100cea0:	100fcd40 	call	100fcd4 <__multiply>
 100cea4:	1021883a 	mov	r16,r2
 100cea8:	d8800a17 	ldw	r2,40(sp)
 100ceac:	d9400917 	ldw	r5,36(sp)
 100ceb0:	e009883a 	mov	r4,fp
 100ceb4:	1545c83a 	sub	r2,r2,r21
 100ceb8:	d8800a15 	stw	r2,40(sp)
 100cebc:	100f9340 	call	100f934 <_Bfree>
 100cec0:	d8c00a17 	ldw	r3,40(sp)
 100cec4:	18009f1e 	bne	r3,zero,100d144 <_dtoa_r+0xce4>
 100cec8:	05c00044 	movi	r23,1
 100cecc:	e009883a 	mov	r4,fp
 100ced0:	b80b883a 	mov	r5,r23
 100ced4:	100fc980 	call	100fc98 <__i2b>
 100ced8:	d9000d17 	ldw	r4,52(sp)
 100cedc:	102b883a 	mov	r21,r2
 100cee0:	2000ce26 	beq	r4,zero,100d21c <_dtoa_r+0xdbc>
 100cee4:	200d883a 	mov	r6,r4
 100cee8:	100b883a 	mov	r5,r2
 100ceec:	e009883a 	mov	r4,fp
 100cef0:	100fecc0 	call	100fecc <__pow5mult>
 100cef4:	d9800317 	ldw	r6,12(sp)
 100cef8:	102b883a 	mov	r21,r2
 100cefc:	b981810e 	bge	r23,r6,100d504 <_dtoa_r+0x10a4>
 100cf00:	0027883a 	mov	r19,zero
 100cf04:	a8800417 	ldw	r2,16(r21)
 100cf08:	05c00804 	movi	r23,32
 100cf0c:	10800104 	addi	r2,r2,4
 100cf10:	1085883a 	add	r2,r2,r2
 100cf14:	1085883a 	add	r2,r2,r2
 100cf18:	a885883a 	add	r2,r21,r2
 100cf1c:	11000017 	ldw	r4,0(r2)
 100cf20:	100fb800 	call	100fb80 <__hi0bits>
 100cf24:	b885c83a 	sub	r2,r23,r2
 100cf28:	1585883a 	add	r2,r2,r22
 100cf2c:	108007cc 	andi	r2,r2,31
 100cf30:	1000b326 	beq	r2,zero,100d200 <_dtoa_r+0xda0>
 100cf34:	00c00804 	movi	r3,32
 100cf38:	1887c83a 	sub	r3,r3,r2
 100cf3c:	01000104 	movi	r4,4
 100cf40:	20c2cd0e 	bge	r4,r3,100da78 <_dtoa_r+0x1618>
 100cf44:	00c00704 	movi	r3,28
 100cf48:	1885c83a 	sub	r2,r3,r2
 100cf4c:	d8c00817 	ldw	r3,32(sp)
 100cf50:	a0a9883a 	add	r20,r20,r2
 100cf54:	b0ad883a 	add	r22,r22,r2
 100cf58:	1887883a 	add	r3,r3,r2
 100cf5c:	d8c00815 	stw	r3,32(sp)
 100cf60:	d9800817 	ldw	r6,32(sp)
 100cf64:	0180040e 	bge	zero,r6,100cf78 <_dtoa_r+0xb18>
 100cf68:	800b883a 	mov	r5,r16
 100cf6c:	e009883a 	mov	r4,fp
 100cf70:	101000c0 	call	101000c <__lshift>
 100cf74:	1021883a 	mov	r16,r2
 100cf78:	0580050e 	bge	zero,r22,100cf90 <_dtoa_r+0xb30>
 100cf7c:	a80b883a 	mov	r5,r21
 100cf80:	b00d883a 	mov	r6,r22
 100cf84:	e009883a 	mov	r4,fp
 100cf88:	101000c0 	call	101000c <__lshift>
 100cf8c:	102b883a 	mov	r21,r2
 100cf90:	d9c00e17 	ldw	r7,56(sp)
 100cf94:	3801211e 	bne	r7,zero,100d41c <_dtoa_r+0xfbc>
 100cf98:	d9800617 	ldw	r6,24(sp)
 100cf9c:	0181380e 	bge	zero,r6,100d480 <_dtoa_r+0x1020>
 100cfa0:	d8c00b17 	ldw	r3,44(sp)
 100cfa4:	1800ab1e 	bne	r3,zero,100d254 <_dtoa_r+0xdf4>
 100cfa8:	dc800717 	ldw	r18,28(sp)
 100cfac:	dcc00617 	ldw	r19,24(sp)
 100cfb0:	9029883a 	mov	r20,r18
 100cfb4:	00000206 	br	100cfc0 <_dtoa_r+0xb60>
 100cfb8:	100f95c0 	call	100f95c <__multadd>
 100cfbc:	1021883a 	mov	r16,r2
 100cfc0:	a80b883a 	mov	r5,r21
 100cfc4:	8009883a 	mov	r4,r16
 100cfc8:	100c2600 	call	100c260 <quorem>
 100cfcc:	10800c04 	addi	r2,r2,48
 100cfd0:	90800005 	stb	r2,0(r18)
 100cfd4:	94800044 	addi	r18,r18,1
 100cfd8:	9507c83a 	sub	r3,r18,r20
 100cfdc:	000f883a 	mov	r7,zero
 100cfe0:	01800284 	movi	r6,10
 100cfe4:	800b883a 	mov	r5,r16
 100cfe8:	e009883a 	mov	r4,fp
 100cfec:	1cfff216 	blt	r3,r19,100cfb8 <__alt_data_end+0xff80cfb8>
 100cff0:	1011883a 	mov	r8,r2
 100cff4:	d8800617 	ldw	r2,24(sp)
 100cff8:	0082370e 	bge	zero,r2,100d8d8 <_dtoa_r+0x1478>
 100cffc:	d9000717 	ldw	r4,28(sp)
 100d000:	0025883a 	mov	r18,zero
 100d004:	20af883a 	add	r23,r4,r2
 100d008:	01800044 	movi	r6,1
 100d00c:	800b883a 	mov	r5,r16
 100d010:	e009883a 	mov	r4,fp
 100d014:	da001715 	stw	r8,92(sp)
 100d018:	101000c0 	call	101000c <__lshift>
 100d01c:	a80b883a 	mov	r5,r21
 100d020:	1009883a 	mov	r4,r2
 100d024:	d8800915 	stw	r2,36(sp)
 100d028:	10101540 	call	1010154 <__mcmp>
 100d02c:	da001717 	ldw	r8,92(sp)
 100d030:	0081800e 	bge	zero,r2,100d634 <_dtoa_r+0x11d4>
 100d034:	b93fffc3 	ldbu	r4,-1(r23)
 100d038:	b8bfffc4 	addi	r2,r23,-1
 100d03c:	1007883a 	mov	r3,r2
 100d040:	01800e44 	movi	r6,57
 100d044:	d9c00717 	ldw	r7,28(sp)
 100d048:	00000506 	br	100d060 <_dtoa_r+0xc00>
 100d04c:	18ffffc4 	addi	r3,r3,-1
 100d050:	11c12326 	beq	r2,r7,100d4e0 <_dtoa_r+0x1080>
 100d054:	19000003 	ldbu	r4,0(r3)
 100d058:	102f883a 	mov	r23,r2
 100d05c:	10bfffc4 	addi	r2,r2,-1
 100d060:	21403fcc 	andi	r5,r4,255
 100d064:	2940201c 	xori	r5,r5,128
 100d068:	297fe004 	addi	r5,r5,-128
 100d06c:	29bff726 	beq	r5,r6,100d04c <__alt_data_end+0xff80d04c>
 100d070:	21000044 	addi	r4,r4,1
 100d074:	11000005 	stb	r4,0(r2)
 100d078:	a80b883a 	mov	r5,r21
 100d07c:	e009883a 	mov	r4,fp
 100d080:	100f9340 	call	100f934 <_Bfree>
 100d084:	883ea026 	beq	r17,zero,100cb08 <__alt_data_end+0xff80cb08>
 100d088:	90000426 	beq	r18,zero,100d09c <_dtoa_r+0xc3c>
 100d08c:	94400326 	beq	r18,r17,100d09c <_dtoa_r+0xc3c>
 100d090:	900b883a 	mov	r5,r18
 100d094:	e009883a 	mov	r4,fp
 100d098:	100f9340 	call	100f934 <_Bfree>
 100d09c:	880b883a 	mov	r5,r17
 100d0a0:	e009883a 	mov	r4,fp
 100d0a4:	100f9340 	call	100f934 <_Bfree>
 100d0a8:	003e9706 	br	100cb08 <__alt_data_end+0xff80cb08>
 100d0ac:	01800044 	movi	r6,1
 100d0b0:	d9800e15 	stw	r6,56(sp)
 100d0b4:	003d9606 	br	100c710 <__alt_data_end+0xff80c710>
 100d0b8:	d8800817 	ldw	r2,32(sp)
 100d0bc:	d8c00517 	ldw	r3,20(sp)
 100d0c0:	d8000d15 	stw	zero,52(sp)
 100d0c4:	10c5c83a 	sub	r2,r2,r3
 100d0c8:	00c9c83a 	sub	r4,zero,r3
 100d0cc:	d8800815 	stw	r2,32(sp)
 100d0d0:	d9000a15 	stw	r4,40(sp)
 100d0d4:	003d9706 	br	100c734 <__alt_data_end+0xff80c734>
 100d0d8:	05adc83a 	sub	r22,zero,r22
 100d0dc:	dd800815 	stw	r22,32(sp)
 100d0e0:	002d883a 	mov	r22,zero
 100d0e4:	003d8e06 	br	100c720 <__alt_data_end+0xff80c720>
 100d0e8:	d9000517 	ldw	r4,20(sp)
 100d0ec:	10160e00 	call	10160e0 <__floatsidf>
 100d0f0:	100d883a 	mov	r6,r2
 100d0f4:	180f883a 	mov	r7,r3
 100d0f8:	a009883a 	mov	r4,r20
 100d0fc:	880b883a 	mov	r5,r17
 100d100:	1014df40 	call	1014df4 <__eqdf2>
 100d104:	103d7126 	beq	r2,zero,100c6cc <__alt_data_end+0xff80c6cc>
 100d108:	d9c00517 	ldw	r7,20(sp)
 100d10c:	39ffffc4 	addi	r7,r7,-1
 100d110:	d9c00515 	stw	r7,20(sp)
 100d114:	003d6d06 	br	100c6cc <__alt_data_end+0xff80c6cc>
 100d118:	dd400a17 	ldw	r21,40(sp)
 100d11c:	dd000817 	ldw	r20,32(sp)
 100d120:	0023883a 	mov	r17,zero
 100d124:	003f4806 	br	100ce48 <__alt_data_end+0xff80ce48>
 100d128:	10e3c83a 	sub	r17,r2,r3
 100d12c:	9448983a 	sll	r4,r18,r17
 100d130:	003d3206 	br	100c5fc <__alt_data_end+0xff80c5fc>
 100d134:	d8000e15 	stw	zero,56(sp)
 100d138:	003d7506 	br	100c710 <__alt_data_end+0xff80c710>
 100d13c:	b005883a 	mov	r2,r22
 100d140:	003f4506 	br	100ce58 <__alt_data_end+0xff80ce58>
 100d144:	dc000915 	stw	r16,36(sp)
 100d148:	d9800a17 	ldw	r6,40(sp)
 100d14c:	d9400917 	ldw	r5,36(sp)
 100d150:	e009883a 	mov	r4,fp
 100d154:	100fecc0 	call	100fecc <__pow5mult>
 100d158:	1021883a 	mov	r16,r2
 100d15c:	003f5a06 	br	100cec8 <__alt_data_end+0xff80cec8>
 100d160:	01c00044 	movi	r7,1
 100d164:	d9c00b15 	stw	r7,44(sp)
 100d168:	d8802217 	ldw	r2,136(sp)
 100d16c:	0081280e 	bge	zero,r2,100d610 <_dtoa_r+0x11b0>
 100d170:	100d883a 	mov	r6,r2
 100d174:	1021883a 	mov	r16,r2
 100d178:	d8800c15 	stw	r2,48(sp)
 100d17c:	d8800615 	stw	r2,24(sp)
 100d180:	003d8806 	br	100c7a4 <__alt_data_end+0xff80c7a4>
 100d184:	d8800617 	ldw	r2,24(sp)
 100d188:	00be9b16 	blt	zero,r2,100cbf8 <__alt_data_end+0xff80cbf8>
 100d18c:	10010f1e 	bne	r2,zero,100d5cc <_dtoa_r+0x116c>
 100d190:	880b883a 	mov	r5,r17
 100d194:	000d883a 	mov	r6,zero
 100d198:	01d00534 	movhi	r7,16404
 100d19c:	8009883a 	mov	r4,r16
 100d1a0:	101504c0 	call	101504c <__muldf3>
 100d1a4:	900d883a 	mov	r6,r18
 100d1a8:	980f883a 	mov	r7,r19
 100d1ac:	1009883a 	mov	r4,r2
 100d1b0:	180b883a 	mov	r5,r3
 100d1b4:	1014e7c0 	call	1014e7c <__gedf2>
 100d1b8:	002b883a 	mov	r21,zero
 100d1bc:	0023883a 	mov	r17,zero
 100d1c0:	1000bf16 	blt	r2,zero,100d4c0 <_dtoa_r+0x1060>
 100d1c4:	d9802217 	ldw	r6,136(sp)
 100d1c8:	ddc00717 	ldw	r23,28(sp)
 100d1cc:	018c303a 	nor	r6,zero,r6
 100d1d0:	d9800515 	stw	r6,20(sp)
 100d1d4:	a80b883a 	mov	r5,r21
 100d1d8:	e009883a 	mov	r4,fp
 100d1dc:	100f9340 	call	100f934 <_Bfree>
 100d1e0:	883e4926 	beq	r17,zero,100cb08 <__alt_data_end+0xff80cb08>
 100d1e4:	003fad06 	br	100d09c <__alt_data_end+0xff80d09c>
 100d1e8:	d9c01117 	ldw	r7,68(sp)
 100d1ec:	3801bc26 	beq	r7,zero,100d8e0 <_dtoa_r+0x1480>
 100d1f0:	10810cc4 	addi	r2,r2,1075
 100d1f4:	dd400a17 	ldw	r21,40(sp)
 100d1f8:	dd000817 	ldw	r20,32(sp)
 100d1fc:	003f0a06 	br	100ce28 <__alt_data_end+0xff80ce28>
 100d200:	00800704 	movi	r2,28
 100d204:	d9000817 	ldw	r4,32(sp)
 100d208:	a0a9883a 	add	r20,r20,r2
 100d20c:	b0ad883a 	add	r22,r22,r2
 100d210:	2089883a 	add	r4,r4,r2
 100d214:	d9000815 	stw	r4,32(sp)
 100d218:	003f5106 	br	100cf60 <__alt_data_end+0xff80cf60>
 100d21c:	d8c00317 	ldw	r3,12(sp)
 100d220:	b8c1fc0e 	bge	r23,r3,100da14 <_dtoa_r+0x15b4>
 100d224:	0027883a 	mov	r19,zero
 100d228:	b805883a 	mov	r2,r23
 100d22c:	003f3e06 	br	100cf28 <__alt_data_end+0xff80cf28>
 100d230:	880b883a 	mov	r5,r17
 100d234:	e009883a 	mov	r4,fp
 100d238:	000f883a 	mov	r7,zero
 100d23c:	01800284 	movi	r6,10
 100d240:	100f95c0 	call	100f95c <__multadd>
 100d244:	d9000c17 	ldw	r4,48(sp)
 100d248:	1023883a 	mov	r17,r2
 100d24c:	0102040e 	bge	zero,r4,100da60 <_dtoa_r+0x1600>
 100d250:	d9000615 	stw	r4,24(sp)
 100d254:	0500050e 	bge	zero,r20,100d26c <_dtoa_r+0xe0c>
 100d258:	880b883a 	mov	r5,r17
 100d25c:	a00d883a 	mov	r6,r20
 100d260:	e009883a 	mov	r4,fp
 100d264:	101000c0 	call	101000c <__lshift>
 100d268:	1023883a 	mov	r17,r2
 100d26c:	9801241e 	bne	r19,zero,100d700 <_dtoa_r+0x12a0>
 100d270:	8829883a 	mov	r20,r17
 100d274:	d9000617 	ldw	r4,24(sp)
 100d278:	dcc00717 	ldw	r19,28(sp)
 100d27c:	9480004c 	andi	r18,r18,1
 100d280:	20bfffc4 	addi	r2,r4,-1
 100d284:	9885883a 	add	r2,r19,r2
 100d288:	d8800415 	stw	r2,16(sp)
 100d28c:	dc800615 	stw	r18,24(sp)
 100d290:	a80b883a 	mov	r5,r21
 100d294:	8009883a 	mov	r4,r16
 100d298:	100c2600 	call	100c260 <quorem>
 100d29c:	880b883a 	mov	r5,r17
 100d2a0:	8009883a 	mov	r4,r16
 100d2a4:	102f883a 	mov	r23,r2
 100d2a8:	10101540 	call	1010154 <__mcmp>
 100d2ac:	a80b883a 	mov	r5,r21
 100d2b0:	a00d883a 	mov	r6,r20
 100d2b4:	e009883a 	mov	r4,fp
 100d2b8:	102d883a 	mov	r22,r2
 100d2bc:	10101b40 	call	10101b4 <__mdiff>
 100d2c0:	1007883a 	mov	r3,r2
 100d2c4:	10800317 	ldw	r2,12(r2)
 100d2c8:	bc800c04 	addi	r18,r23,48
 100d2cc:	180b883a 	mov	r5,r3
 100d2d0:	10004e1e 	bne	r2,zero,100d40c <_dtoa_r+0xfac>
 100d2d4:	8009883a 	mov	r4,r16
 100d2d8:	d8c01615 	stw	r3,88(sp)
 100d2dc:	10101540 	call	1010154 <__mcmp>
 100d2e0:	d8c01617 	ldw	r3,88(sp)
 100d2e4:	e009883a 	mov	r4,fp
 100d2e8:	d8801615 	stw	r2,88(sp)
 100d2ec:	180b883a 	mov	r5,r3
 100d2f0:	100f9340 	call	100f934 <_Bfree>
 100d2f4:	d8801617 	ldw	r2,88(sp)
 100d2f8:	1000041e 	bne	r2,zero,100d30c <_dtoa_r+0xeac>
 100d2fc:	d9800317 	ldw	r6,12(sp)
 100d300:	3000021e 	bne	r6,zero,100d30c <_dtoa_r+0xeac>
 100d304:	d8c00617 	ldw	r3,24(sp)
 100d308:	18003726 	beq	r3,zero,100d3e8 <_dtoa_r+0xf88>
 100d30c:	b0002016 	blt	r22,zero,100d390 <_dtoa_r+0xf30>
 100d310:	b000041e 	bne	r22,zero,100d324 <_dtoa_r+0xec4>
 100d314:	d9000317 	ldw	r4,12(sp)
 100d318:	2000021e 	bne	r4,zero,100d324 <_dtoa_r+0xec4>
 100d31c:	d8c00617 	ldw	r3,24(sp)
 100d320:	18001b26 	beq	r3,zero,100d390 <_dtoa_r+0xf30>
 100d324:	00810716 	blt	zero,r2,100d744 <_dtoa_r+0x12e4>
 100d328:	d8c00417 	ldw	r3,16(sp)
 100d32c:	9d800044 	addi	r22,r19,1
 100d330:	9c800005 	stb	r18,0(r19)
 100d334:	b02f883a 	mov	r23,r22
 100d338:	98c10626 	beq	r19,r3,100d754 <_dtoa_r+0x12f4>
 100d33c:	800b883a 	mov	r5,r16
 100d340:	000f883a 	mov	r7,zero
 100d344:	01800284 	movi	r6,10
 100d348:	e009883a 	mov	r4,fp
 100d34c:	100f95c0 	call	100f95c <__multadd>
 100d350:	1021883a 	mov	r16,r2
 100d354:	000f883a 	mov	r7,zero
 100d358:	01800284 	movi	r6,10
 100d35c:	880b883a 	mov	r5,r17
 100d360:	e009883a 	mov	r4,fp
 100d364:	8d002526 	beq	r17,r20,100d3fc <_dtoa_r+0xf9c>
 100d368:	100f95c0 	call	100f95c <__multadd>
 100d36c:	a00b883a 	mov	r5,r20
 100d370:	000f883a 	mov	r7,zero
 100d374:	01800284 	movi	r6,10
 100d378:	e009883a 	mov	r4,fp
 100d37c:	1023883a 	mov	r17,r2
 100d380:	100f95c0 	call	100f95c <__multadd>
 100d384:	1029883a 	mov	r20,r2
 100d388:	b027883a 	mov	r19,r22
 100d38c:	003fc006 	br	100d290 <__alt_data_end+0xff80d290>
 100d390:	9011883a 	mov	r8,r18
 100d394:	00800e0e 	bge	zero,r2,100d3d0 <_dtoa_r+0xf70>
 100d398:	800b883a 	mov	r5,r16
 100d39c:	01800044 	movi	r6,1
 100d3a0:	e009883a 	mov	r4,fp
 100d3a4:	da001715 	stw	r8,92(sp)
 100d3a8:	101000c0 	call	101000c <__lshift>
 100d3ac:	a80b883a 	mov	r5,r21
 100d3b0:	1009883a 	mov	r4,r2
 100d3b4:	1021883a 	mov	r16,r2
 100d3b8:	10101540 	call	1010154 <__mcmp>
 100d3bc:	da001717 	ldw	r8,92(sp)
 100d3c0:	0081960e 	bge	zero,r2,100da1c <_dtoa_r+0x15bc>
 100d3c4:	00800e44 	movi	r2,57
 100d3c8:	40817026 	beq	r8,r2,100d98c <_dtoa_r+0x152c>
 100d3cc:	ba000c44 	addi	r8,r23,49
 100d3d0:	8825883a 	mov	r18,r17
 100d3d4:	9dc00044 	addi	r23,r19,1
 100d3d8:	9a000005 	stb	r8,0(r19)
 100d3dc:	a023883a 	mov	r17,r20
 100d3e0:	dc000915 	stw	r16,36(sp)
 100d3e4:	003f2406 	br	100d078 <__alt_data_end+0xff80d078>
 100d3e8:	00800e44 	movi	r2,57
 100d3ec:	9011883a 	mov	r8,r18
 100d3f0:	90816626 	beq	r18,r2,100d98c <_dtoa_r+0x152c>
 100d3f4:	05bff516 	blt	zero,r22,100d3cc <__alt_data_end+0xff80d3cc>
 100d3f8:	003ff506 	br	100d3d0 <__alt_data_end+0xff80d3d0>
 100d3fc:	100f95c0 	call	100f95c <__multadd>
 100d400:	1023883a 	mov	r17,r2
 100d404:	1029883a 	mov	r20,r2
 100d408:	003fdf06 	br	100d388 <__alt_data_end+0xff80d388>
 100d40c:	e009883a 	mov	r4,fp
 100d410:	100f9340 	call	100f934 <_Bfree>
 100d414:	00800044 	movi	r2,1
 100d418:	003fbc06 	br	100d30c <__alt_data_end+0xff80d30c>
 100d41c:	a80b883a 	mov	r5,r21
 100d420:	8009883a 	mov	r4,r16
 100d424:	10101540 	call	1010154 <__mcmp>
 100d428:	103edb0e 	bge	r2,zero,100cf98 <__alt_data_end+0xff80cf98>
 100d42c:	800b883a 	mov	r5,r16
 100d430:	000f883a 	mov	r7,zero
 100d434:	01800284 	movi	r6,10
 100d438:	e009883a 	mov	r4,fp
 100d43c:	100f95c0 	call	100f95c <__multadd>
 100d440:	1021883a 	mov	r16,r2
 100d444:	d8800517 	ldw	r2,20(sp)
 100d448:	d8c00b17 	ldw	r3,44(sp)
 100d44c:	10bfffc4 	addi	r2,r2,-1
 100d450:	d8800515 	stw	r2,20(sp)
 100d454:	183f761e 	bne	r3,zero,100d230 <__alt_data_end+0xff80d230>
 100d458:	d9000c17 	ldw	r4,48(sp)
 100d45c:	0101730e 	bge	zero,r4,100da2c <_dtoa_r+0x15cc>
 100d460:	d9000615 	stw	r4,24(sp)
 100d464:	003ed006 	br	100cfa8 <__alt_data_end+0xff80cfa8>
 100d468:	00800084 	movi	r2,2
 100d46c:	3081861e 	bne	r6,r2,100da88 <_dtoa_r+0x1628>
 100d470:	d8000b15 	stw	zero,44(sp)
 100d474:	003f3c06 	br	100d168 <__alt_data_end+0xff80d168>
 100d478:	dc000917 	ldw	r16,36(sp)
 100d47c:	003e9206 	br	100cec8 <__alt_data_end+0xff80cec8>
 100d480:	d9c00317 	ldw	r7,12(sp)
 100d484:	00800084 	movi	r2,2
 100d488:	11fec50e 	bge	r2,r7,100cfa0 <__alt_data_end+0xff80cfa0>
 100d48c:	d9000617 	ldw	r4,24(sp)
 100d490:	20013c1e 	bne	r4,zero,100d984 <_dtoa_r+0x1524>
 100d494:	a80b883a 	mov	r5,r21
 100d498:	000f883a 	mov	r7,zero
 100d49c:	01800144 	movi	r6,5
 100d4a0:	e009883a 	mov	r4,fp
 100d4a4:	100f95c0 	call	100f95c <__multadd>
 100d4a8:	100b883a 	mov	r5,r2
 100d4ac:	8009883a 	mov	r4,r16
 100d4b0:	102b883a 	mov	r21,r2
 100d4b4:	10101540 	call	1010154 <__mcmp>
 100d4b8:	dc000915 	stw	r16,36(sp)
 100d4bc:	00bf410e 	bge	zero,r2,100d1c4 <__alt_data_end+0xff80d1c4>
 100d4c0:	d9c00717 	ldw	r7,28(sp)
 100d4c4:	00800c44 	movi	r2,49
 100d4c8:	38800005 	stb	r2,0(r7)
 100d4cc:	d8800517 	ldw	r2,20(sp)
 100d4d0:	3dc00044 	addi	r23,r7,1
 100d4d4:	10800044 	addi	r2,r2,1
 100d4d8:	d8800515 	stw	r2,20(sp)
 100d4dc:	003f3d06 	br	100d1d4 <__alt_data_end+0xff80d1d4>
 100d4e0:	d9800517 	ldw	r6,20(sp)
 100d4e4:	d9c00717 	ldw	r7,28(sp)
 100d4e8:	00800c44 	movi	r2,49
 100d4ec:	31800044 	addi	r6,r6,1
 100d4f0:	d9800515 	stw	r6,20(sp)
 100d4f4:	38800005 	stb	r2,0(r7)
 100d4f8:	003edf06 	br	100d078 <__alt_data_end+0xff80d078>
 100d4fc:	d8000b15 	stw	zero,44(sp)
 100d500:	003c9f06 	br	100c780 <__alt_data_end+0xff80c780>
 100d504:	903e7e1e 	bne	r18,zero,100cf00 <__alt_data_end+0xff80cf00>
 100d508:	00800434 	movhi	r2,16
 100d50c:	10bfffc4 	addi	r2,r2,-1
 100d510:	9884703a 	and	r2,r19,r2
 100d514:	1000ea1e 	bne	r2,zero,100d8c0 <_dtoa_r+0x1460>
 100d518:	9cdffc2c 	andhi	r19,r19,32752
 100d51c:	9800e826 	beq	r19,zero,100d8c0 <_dtoa_r+0x1460>
 100d520:	d9c00817 	ldw	r7,32(sp)
 100d524:	b5800044 	addi	r22,r22,1
 100d528:	04c00044 	movi	r19,1
 100d52c:	39c00044 	addi	r7,r7,1
 100d530:	d9c00815 	stw	r7,32(sp)
 100d534:	d8800d17 	ldw	r2,52(sp)
 100d538:	103e721e 	bne	r2,zero,100cf04 <__alt_data_end+0xff80cf04>
 100d53c:	00800044 	movi	r2,1
 100d540:	003e7906 	br	100cf28 <__alt_data_end+0xff80cf28>
 100d544:	8009883a 	mov	r4,r16
 100d548:	10160e00 	call	10160e0 <__floatsidf>
 100d54c:	d9800f17 	ldw	r6,60(sp)
 100d550:	d9c01017 	ldw	r7,64(sp)
 100d554:	1009883a 	mov	r4,r2
 100d558:	180b883a 	mov	r5,r3
 100d55c:	101504c0 	call	101504c <__muldf3>
 100d560:	000d883a 	mov	r6,zero
 100d564:	01d00734 	movhi	r7,16412
 100d568:	1009883a 	mov	r4,r2
 100d56c:	180b883a 	mov	r5,r3
 100d570:	1013c600 	call	1013c60 <__adddf3>
 100d574:	047f3034 	movhi	r17,64704
 100d578:	1021883a 	mov	r16,r2
 100d57c:	1c63883a 	add	r17,r3,r17
 100d580:	d9000f17 	ldw	r4,60(sp)
 100d584:	d9401017 	ldw	r5,64(sp)
 100d588:	000d883a 	mov	r6,zero
 100d58c:	01d00534 	movhi	r7,16404
 100d590:	10157640 	call	1015764 <__subdf3>
 100d594:	800d883a 	mov	r6,r16
 100d598:	880f883a 	mov	r7,r17
 100d59c:	1009883a 	mov	r4,r2
 100d5a0:	180b883a 	mov	r5,r3
 100d5a4:	102b883a 	mov	r21,r2
 100d5a8:	1829883a 	mov	r20,r3
 100d5ac:	1014e7c0 	call	1014e7c <__gedf2>
 100d5b0:	00806c16 	blt	zero,r2,100d764 <_dtoa_r+0x1304>
 100d5b4:	89e0003c 	xorhi	r7,r17,32768
 100d5b8:	800d883a 	mov	r6,r16
 100d5bc:	a809883a 	mov	r4,r21
 100d5c0:	a00b883a 	mov	r5,r20
 100d5c4:	1014f580 	call	1014f58 <__ledf2>
 100d5c8:	103d7e0e 	bge	r2,zero,100cbc4 <__alt_data_end+0xff80cbc4>
 100d5cc:	002b883a 	mov	r21,zero
 100d5d0:	0023883a 	mov	r17,zero
 100d5d4:	003efb06 	br	100d1c4 <__alt_data_end+0xff80d1c4>
 100d5d8:	d8800717 	ldw	r2,28(sp)
 100d5dc:	003bd006 	br	100c520 <__alt_data_end+0xff80c520>
 100d5e0:	d9000a17 	ldw	r4,40(sp)
 100d5e4:	d9800d17 	ldw	r6,52(sp)
 100d5e8:	dd400a15 	stw	r21,40(sp)
 100d5ec:	a905c83a 	sub	r2,r21,r4
 100d5f0:	308d883a 	add	r6,r6,r2
 100d5f4:	d9800d15 	stw	r6,52(sp)
 100d5f8:	002b883a 	mov	r21,zero
 100d5fc:	003e0606 	br	100ce18 <__alt_data_end+0xff80ce18>
 100d600:	9023883a 	mov	r17,r18
 100d604:	9829883a 	mov	r20,r19
 100d608:	04000084 	movi	r16,2
 100d60c:	003c9206 	br	100c858 <__alt_data_end+0xff80c858>
 100d610:	04000044 	movi	r16,1
 100d614:	dc000c15 	stw	r16,48(sp)
 100d618:	dc000615 	stw	r16,24(sp)
 100d61c:	dc002215 	stw	r16,136(sp)
 100d620:	e0001115 	stw	zero,68(fp)
 100d624:	000b883a 	mov	r5,zero
 100d628:	003c6906 	br	100c7d0 <__alt_data_end+0xff80c7d0>
 100d62c:	3021883a 	mov	r16,r6
 100d630:	003ffb06 	br	100d620 <__alt_data_end+0xff80d620>
 100d634:	1000021e 	bne	r2,zero,100d640 <_dtoa_r+0x11e0>
 100d638:	4200004c 	andi	r8,r8,1
 100d63c:	403e7d1e 	bne	r8,zero,100d034 <__alt_data_end+0xff80d034>
 100d640:	01000c04 	movi	r4,48
 100d644:	00000106 	br	100d64c <_dtoa_r+0x11ec>
 100d648:	102f883a 	mov	r23,r2
 100d64c:	b8bfffc4 	addi	r2,r23,-1
 100d650:	10c00007 	ldb	r3,0(r2)
 100d654:	193ffc26 	beq	r3,r4,100d648 <__alt_data_end+0xff80d648>
 100d658:	003e8706 	br	100d078 <__alt_data_end+0xff80d078>
 100d65c:	d8800517 	ldw	r2,20(sp)
 100d660:	00a3c83a 	sub	r17,zero,r2
 100d664:	8800a426 	beq	r17,zero,100d8f8 <_dtoa_r+0x1498>
 100d668:	888003cc 	andi	r2,r17,15
 100d66c:	100490fa 	slli	r2,r2,3
 100d670:	00c040b4 	movhi	r3,258
 100d674:	18eb2d04 	addi	r3,r3,-21324
 100d678:	1885883a 	add	r2,r3,r2
 100d67c:	11800017 	ldw	r6,0(r2)
 100d680:	11c00117 	ldw	r7,4(r2)
 100d684:	9009883a 	mov	r4,r18
 100d688:	980b883a 	mov	r5,r19
 100d68c:	8823d13a 	srai	r17,r17,4
 100d690:	101504c0 	call	101504c <__muldf3>
 100d694:	d8800f15 	stw	r2,60(sp)
 100d698:	d8c01015 	stw	r3,64(sp)
 100d69c:	8800e826 	beq	r17,zero,100da40 <_dtoa_r+0x15e0>
 100d6a0:	050040b4 	movhi	r20,258
 100d6a4:	a52b2304 	addi	r20,r20,-21364
 100d6a8:	04000084 	movi	r16,2
 100d6ac:	8980004c 	andi	r6,r17,1
 100d6b0:	1009883a 	mov	r4,r2
 100d6b4:	8823d07a 	srai	r17,r17,1
 100d6b8:	180b883a 	mov	r5,r3
 100d6bc:	30000426 	beq	r6,zero,100d6d0 <_dtoa_r+0x1270>
 100d6c0:	a1800017 	ldw	r6,0(r20)
 100d6c4:	a1c00117 	ldw	r7,4(r20)
 100d6c8:	84000044 	addi	r16,r16,1
 100d6cc:	101504c0 	call	101504c <__muldf3>
 100d6d0:	a5000204 	addi	r20,r20,8
 100d6d4:	883ff51e 	bne	r17,zero,100d6ac <__alt_data_end+0xff80d6ac>
 100d6d8:	d8800f15 	stw	r2,60(sp)
 100d6dc:	d8c01015 	stw	r3,64(sp)
 100d6e0:	003c7606 	br	100c8bc <__alt_data_end+0xff80c8bc>
 100d6e4:	00c00c04 	movi	r3,48
 100d6e8:	10c00005 	stb	r3,0(r2)
 100d6ec:	d8c00517 	ldw	r3,20(sp)
 100d6f0:	bd3fffc3 	ldbu	r20,-1(r23)
 100d6f4:	18c00044 	addi	r3,r3,1
 100d6f8:	d8c00515 	stw	r3,20(sp)
 100d6fc:	003db906 	br	100cde4 <__alt_data_end+0xff80cde4>
 100d700:	89400117 	ldw	r5,4(r17)
 100d704:	e009883a 	mov	r4,fp
 100d708:	100f88c0 	call	100f88c <_Balloc>
 100d70c:	89800417 	ldw	r6,16(r17)
 100d710:	89400304 	addi	r5,r17,12
 100d714:	11000304 	addi	r4,r2,12
 100d718:	31800084 	addi	r6,r6,2
 100d71c:	318d883a 	add	r6,r6,r6
 100d720:	318d883a 	add	r6,r6,r6
 100d724:	1027883a 	mov	r19,r2
 100d728:	10099d40 	call	10099d4 <memcpy>
 100d72c:	01800044 	movi	r6,1
 100d730:	980b883a 	mov	r5,r19
 100d734:	e009883a 	mov	r4,fp
 100d738:	101000c0 	call	101000c <__lshift>
 100d73c:	1029883a 	mov	r20,r2
 100d740:	003ecc06 	br	100d274 <__alt_data_end+0xff80d274>
 100d744:	00800e44 	movi	r2,57
 100d748:	90809026 	beq	r18,r2,100d98c <_dtoa_r+0x152c>
 100d74c:	92000044 	addi	r8,r18,1
 100d750:	003f1f06 	br	100d3d0 <__alt_data_end+0xff80d3d0>
 100d754:	9011883a 	mov	r8,r18
 100d758:	8825883a 	mov	r18,r17
 100d75c:	a023883a 	mov	r17,r20
 100d760:	003e2906 	br	100d008 <__alt_data_end+0xff80d008>
 100d764:	002b883a 	mov	r21,zero
 100d768:	0023883a 	mov	r17,zero
 100d76c:	003f5406 	br	100d4c0 <__alt_data_end+0xff80d4c0>
 100d770:	61bfffc4 	addi	r6,r12,-1
 100d774:	300490fa 	slli	r2,r6,3
 100d778:	00c040b4 	movhi	r3,258
 100d77c:	18eb2d04 	addi	r3,r3,-21324
 100d780:	1885883a 	add	r2,r3,r2
 100d784:	11000017 	ldw	r4,0(r2)
 100d788:	11400117 	ldw	r5,4(r2)
 100d78c:	d8800717 	ldw	r2,28(sp)
 100d790:	880f883a 	mov	r7,r17
 100d794:	d9801215 	stw	r6,72(sp)
 100d798:	800d883a 	mov	r6,r16
 100d79c:	db001615 	stw	r12,88(sp)
 100d7a0:	15c00044 	addi	r23,r2,1
 100d7a4:	101504c0 	call	101504c <__muldf3>
 100d7a8:	d9401017 	ldw	r5,64(sp)
 100d7ac:	d9000f17 	ldw	r4,60(sp)
 100d7b0:	d8c01515 	stw	r3,84(sp)
 100d7b4:	d8801415 	stw	r2,80(sp)
 100d7b8:	10160600 	call	1016060 <__fixdfsi>
 100d7bc:	1009883a 	mov	r4,r2
 100d7c0:	1021883a 	mov	r16,r2
 100d7c4:	10160e00 	call	10160e0 <__floatsidf>
 100d7c8:	d9000f17 	ldw	r4,60(sp)
 100d7cc:	d9401017 	ldw	r5,64(sp)
 100d7d0:	100d883a 	mov	r6,r2
 100d7d4:	180f883a 	mov	r7,r3
 100d7d8:	10157640 	call	1015764 <__subdf3>
 100d7dc:	1829883a 	mov	r20,r3
 100d7e0:	d8c00717 	ldw	r3,28(sp)
 100d7e4:	84000c04 	addi	r16,r16,48
 100d7e8:	1023883a 	mov	r17,r2
 100d7ec:	1c000005 	stb	r16,0(r3)
 100d7f0:	db001617 	ldw	r12,88(sp)
 100d7f4:	00800044 	movi	r2,1
 100d7f8:	60802226 	beq	r12,r2,100d884 <_dtoa_r+0x1424>
 100d7fc:	d9c00717 	ldw	r7,28(sp)
 100d800:	8805883a 	mov	r2,r17
 100d804:	b82b883a 	mov	r21,r23
 100d808:	3b19883a 	add	r12,r7,r12
 100d80c:	6023883a 	mov	r17,r12
 100d810:	a007883a 	mov	r3,r20
 100d814:	dc800f15 	stw	r18,60(sp)
 100d818:	000d883a 	mov	r6,zero
 100d81c:	01d00934 	movhi	r7,16420
 100d820:	1009883a 	mov	r4,r2
 100d824:	180b883a 	mov	r5,r3
 100d828:	101504c0 	call	101504c <__muldf3>
 100d82c:	180b883a 	mov	r5,r3
 100d830:	1009883a 	mov	r4,r2
 100d834:	1829883a 	mov	r20,r3
 100d838:	1025883a 	mov	r18,r2
 100d83c:	10160600 	call	1016060 <__fixdfsi>
 100d840:	1009883a 	mov	r4,r2
 100d844:	1021883a 	mov	r16,r2
 100d848:	10160e00 	call	10160e0 <__floatsidf>
 100d84c:	100d883a 	mov	r6,r2
 100d850:	180f883a 	mov	r7,r3
 100d854:	9009883a 	mov	r4,r18
 100d858:	a00b883a 	mov	r5,r20
 100d85c:	84000c04 	addi	r16,r16,48
 100d860:	10157640 	call	1015764 <__subdf3>
 100d864:	ad400044 	addi	r21,r21,1
 100d868:	ac3fffc5 	stb	r16,-1(r21)
 100d86c:	ac7fea1e 	bne	r21,r17,100d818 <__alt_data_end+0xff80d818>
 100d870:	1023883a 	mov	r17,r2
 100d874:	d8801217 	ldw	r2,72(sp)
 100d878:	dc800f17 	ldw	r18,60(sp)
 100d87c:	1829883a 	mov	r20,r3
 100d880:	b8af883a 	add	r23,r23,r2
 100d884:	d9001417 	ldw	r4,80(sp)
 100d888:	d9401517 	ldw	r5,84(sp)
 100d88c:	000d883a 	mov	r6,zero
 100d890:	01cff834 	movhi	r7,16352
 100d894:	1013c600 	call	1013c60 <__adddf3>
 100d898:	880d883a 	mov	r6,r17
 100d89c:	a00f883a 	mov	r7,r20
 100d8a0:	1009883a 	mov	r4,r2
 100d8a4:	180b883a 	mov	r5,r3
 100d8a8:	1014f580 	call	1014f58 <__ledf2>
 100d8ac:	10003e0e 	bge	r2,zero,100d9a8 <_dtoa_r+0x1548>
 100d8b0:	d9001317 	ldw	r4,76(sp)
 100d8b4:	bd3fffc3 	ldbu	r20,-1(r23)
 100d8b8:	d9000515 	stw	r4,20(sp)
 100d8bc:	003d3b06 	br	100cdac <__alt_data_end+0xff80cdac>
 100d8c0:	0027883a 	mov	r19,zero
 100d8c4:	003f1b06 	br	100d534 <__alt_data_end+0xff80d534>
 100d8c8:	d8800817 	ldw	r2,32(sp)
 100d8cc:	11e9c83a 	sub	r20,r2,r7
 100d8d0:	0005883a 	mov	r2,zero
 100d8d4:	003d5406 	br	100ce28 <__alt_data_end+0xff80ce28>
 100d8d8:	00800044 	movi	r2,1
 100d8dc:	003dc706 	br	100cffc <__alt_data_end+0xff80cffc>
 100d8e0:	d8c00217 	ldw	r3,8(sp)
 100d8e4:	00800d84 	movi	r2,54
 100d8e8:	dd400a17 	ldw	r21,40(sp)
 100d8ec:	10c5c83a 	sub	r2,r2,r3
 100d8f0:	dd000817 	ldw	r20,32(sp)
 100d8f4:	003d4c06 	br	100ce28 <__alt_data_end+0xff80ce28>
 100d8f8:	dc800f15 	stw	r18,60(sp)
 100d8fc:	dcc01015 	stw	r19,64(sp)
 100d900:	04000084 	movi	r16,2
 100d904:	003bed06 	br	100c8bc <__alt_data_end+0xff80c8bc>
 100d908:	d9000617 	ldw	r4,24(sp)
 100d90c:	203f0d26 	beq	r4,zero,100d544 <__alt_data_end+0xff80d544>
 100d910:	d9800c17 	ldw	r6,48(sp)
 100d914:	01bcab0e 	bge	zero,r6,100cbc4 <__alt_data_end+0xff80cbc4>
 100d918:	d9401017 	ldw	r5,64(sp)
 100d91c:	d9000f17 	ldw	r4,60(sp)
 100d920:	000d883a 	mov	r6,zero
 100d924:	01d00934 	movhi	r7,16420
 100d928:	101504c0 	call	101504c <__muldf3>
 100d92c:	81000044 	addi	r4,r16,1
 100d930:	d8800f15 	stw	r2,60(sp)
 100d934:	d8c01015 	stw	r3,64(sp)
 100d938:	10160e00 	call	10160e0 <__floatsidf>
 100d93c:	d9800f17 	ldw	r6,60(sp)
 100d940:	d9c01017 	ldw	r7,64(sp)
 100d944:	1009883a 	mov	r4,r2
 100d948:	180b883a 	mov	r5,r3
 100d94c:	101504c0 	call	101504c <__muldf3>
 100d950:	01d00734 	movhi	r7,16412
 100d954:	000d883a 	mov	r6,zero
 100d958:	1009883a 	mov	r4,r2
 100d95c:	180b883a 	mov	r5,r3
 100d960:	1013c600 	call	1013c60 <__adddf3>
 100d964:	d9c00517 	ldw	r7,20(sp)
 100d968:	047f3034 	movhi	r17,64704
 100d96c:	1021883a 	mov	r16,r2
 100d970:	39ffffc4 	addi	r7,r7,-1
 100d974:	d9c01315 	stw	r7,76(sp)
 100d978:	1c63883a 	add	r17,r3,r17
 100d97c:	db000c17 	ldw	r12,48(sp)
 100d980:	003bea06 	br	100c92c <__alt_data_end+0xff80c92c>
 100d984:	dc000915 	stw	r16,36(sp)
 100d988:	003e0e06 	br	100d1c4 <__alt_data_end+0xff80d1c4>
 100d98c:	01000e44 	movi	r4,57
 100d990:	8825883a 	mov	r18,r17
 100d994:	9dc00044 	addi	r23,r19,1
 100d998:	99000005 	stb	r4,0(r19)
 100d99c:	a023883a 	mov	r17,r20
 100d9a0:	dc000915 	stw	r16,36(sp)
 100d9a4:	003da406 	br	100d038 <__alt_data_end+0xff80d038>
 100d9a8:	d9801417 	ldw	r6,80(sp)
 100d9ac:	d9c01517 	ldw	r7,84(sp)
 100d9b0:	0009883a 	mov	r4,zero
 100d9b4:	014ff834 	movhi	r5,16352
 100d9b8:	10157640 	call	1015764 <__subdf3>
 100d9bc:	880d883a 	mov	r6,r17
 100d9c0:	a00f883a 	mov	r7,r20
 100d9c4:	1009883a 	mov	r4,r2
 100d9c8:	180b883a 	mov	r5,r3
 100d9cc:	1014e7c0 	call	1014e7c <__gedf2>
 100d9d0:	00bc7c0e 	bge	zero,r2,100cbc4 <__alt_data_end+0xff80cbc4>
 100d9d4:	01000c04 	movi	r4,48
 100d9d8:	00000106 	br	100d9e0 <_dtoa_r+0x1580>
 100d9dc:	102f883a 	mov	r23,r2
 100d9e0:	b8bfffc4 	addi	r2,r23,-1
 100d9e4:	10c00007 	ldb	r3,0(r2)
 100d9e8:	193ffc26 	beq	r3,r4,100d9dc <__alt_data_end+0xff80d9dc>
 100d9ec:	d9801317 	ldw	r6,76(sp)
 100d9f0:	d9800515 	stw	r6,20(sp)
 100d9f4:	003c4406 	br	100cb08 <__alt_data_end+0xff80cb08>
 100d9f8:	d9801317 	ldw	r6,76(sp)
 100d9fc:	d9800515 	stw	r6,20(sp)
 100da00:	003cea06 	br	100cdac <__alt_data_end+0xff80cdac>
 100da04:	dd800f17 	ldw	r22,60(sp)
 100da08:	dcc01017 	ldw	r19,64(sp)
 100da0c:	dc801217 	ldw	r18,72(sp)
 100da10:	003c6c06 	br	100cbc4 <__alt_data_end+0xff80cbc4>
 100da14:	903e031e 	bne	r18,zero,100d224 <__alt_data_end+0xff80d224>
 100da18:	003ebb06 	br	100d508 <__alt_data_end+0xff80d508>
 100da1c:	103e6c1e 	bne	r2,zero,100d3d0 <__alt_data_end+0xff80d3d0>
 100da20:	4080004c 	andi	r2,r8,1
 100da24:	103e6a26 	beq	r2,zero,100d3d0 <__alt_data_end+0xff80d3d0>
 100da28:	003e6606 	br	100d3c4 <__alt_data_end+0xff80d3c4>
 100da2c:	d8c00317 	ldw	r3,12(sp)
 100da30:	00800084 	movi	r2,2
 100da34:	10c02916 	blt	r2,r3,100dadc <_dtoa_r+0x167c>
 100da38:	d9000c17 	ldw	r4,48(sp)
 100da3c:	003e8806 	br	100d460 <__alt_data_end+0xff80d460>
 100da40:	04000084 	movi	r16,2
 100da44:	003b9d06 	br	100c8bc <__alt_data_end+0xff80c8bc>
 100da48:	d9001317 	ldw	r4,76(sp)
 100da4c:	d9000515 	stw	r4,20(sp)
 100da50:	003cd606 	br	100cdac <__alt_data_end+0xff80cdac>
 100da54:	d8801317 	ldw	r2,76(sp)
 100da58:	d8800515 	stw	r2,20(sp)
 100da5c:	003c2a06 	br	100cb08 <__alt_data_end+0xff80cb08>
 100da60:	d9800317 	ldw	r6,12(sp)
 100da64:	00800084 	movi	r2,2
 100da68:	11801516 	blt	r2,r6,100dac0 <_dtoa_r+0x1660>
 100da6c:	d9c00c17 	ldw	r7,48(sp)
 100da70:	d9c00615 	stw	r7,24(sp)
 100da74:	003df706 	br	100d254 <__alt_data_end+0xff80d254>
 100da78:	193d3926 	beq	r3,r4,100cf60 <__alt_data_end+0xff80cf60>
 100da7c:	00c00f04 	movi	r3,60
 100da80:	1885c83a 	sub	r2,r3,r2
 100da84:	003ddf06 	br	100d204 <__alt_data_end+0xff80d204>
 100da88:	e009883a 	mov	r4,fp
 100da8c:	e0001115 	stw	zero,68(fp)
 100da90:	000b883a 	mov	r5,zero
 100da94:	100f88c0 	call	100f88c <_Balloc>
 100da98:	d8800715 	stw	r2,28(sp)
 100da9c:	d8c00717 	ldw	r3,28(sp)
 100daa0:	00bfffc4 	movi	r2,-1
 100daa4:	01000044 	movi	r4,1
 100daa8:	d8800c15 	stw	r2,48(sp)
 100daac:	e0c01015 	stw	r3,64(fp)
 100dab0:	d9000b15 	stw	r4,44(sp)
 100dab4:	d8800615 	stw	r2,24(sp)
 100dab8:	d8002215 	stw	zero,136(sp)
 100dabc:	003c4106 	br	100cbc4 <__alt_data_end+0xff80cbc4>
 100dac0:	d8c00c17 	ldw	r3,48(sp)
 100dac4:	d8c00615 	stw	r3,24(sp)
 100dac8:	003e7006 	br	100d48c <__alt_data_end+0xff80d48c>
 100dacc:	04400044 	movi	r17,1
 100dad0:	003b2006 	br	100c754 <__alt_data_end+0xff80c754>
 100dad4:	000b883a 	mov	r5,zero
 100dad8:	003b3d06 	br	100c7d0 <__alt_data_end+0xff80c7d0>
 100dadc:	d8800c17 	ldw	r2,48(sp)
 100dae0:	d8800615 	stw	r2,24(sp)
 100dae4:	003e6906 	br	100d48c <__alt_data_end+0xff80d48c>

0100dae8 <__sflush_r>:
 100dae8:	2880030b 	ldhu	r2,12(r5)
 100daec:	defffb04 	addi	sp,sp,-20
 100daf0:	dcc00315 	stw	r19,12(sp)
 100daf4:	dc400115 	stw	r17,4(sp)
 100daf8:	dfc00415 	stw	ra,16(sp)
 100dafc:	dc800215 	stw	r18,8(sp)
 100db00:	dc000015 	stw	r16,0(sp)
 100db04:	10c0020c 	andi	r3,r2,8
 100db08:	2823883a 	mov	r17,r5
 100db0c:	2027883a 	mov	r19,r4
 100db10:	1800311e 	bne	r3,zero,100dbd8 <__sflush_r+0xf0>
 100db14:	28c00117 	ldw	r3,4(r5)
 100db18:	10820014 	ori	r2,r2,2048
 100db1c:	2880030d 	sth	r2,12(r5)
 100db20:	00c04b0e 	bge	zero,r3,100dc50 <__sflush_r+0x168>
 100db24:	8a000a17 	ldw	r8,40(r17)
 100db28:	40002326 	beq	r8,zero,100dbb8 <__sflush_r+0xd0>
 100db2c:	9c000017 	ldw	r16,0(r19)
 100db30:	10c4000c 	andi	r3,r2,4096
 100db34:	98000015 	stw	zero,0(r19)
 100db38:	18004826 	beq	r3,zero,100dc5c <__sflush_r+0x174>
 100db3c:	89801417 	ldw	r6,80(r17)
 100db40:	10c0010c 	andi	r3,r2,4
 100db44:	18000626 	beq	r3,zero,100db60 <__sflush_r+0x78>
 100db48:	88c00117 	ldw	r3,4(r17)
 100db4c:	88800c17 	ldw	r2,48(r17)
 100db50:	30cdc83a 	sub	r6,r6,r3
 100db54:	10000226 	beq	r2,zero,100db60 <__sflush_r+0x78>
 100db58:	88800f17 	ldw	r2,60(r17)
 100db5c:	308dc83a 	sub	r6,r6,r2
 100db60:	89400717 	ldw	r5,28(r17)
 100db64:	000f883a 	mov	r7,zero
 100db68:	9809883a 	mov	r4,r19
 100db6c:	403ee83a 	callr	r8
 100db70:	00ffffc4 	movi	r3,-1
 100db74:	10c04426 	beq	r2,r3,100dc88 <__sflush_r+0x1a0>
 100db78:	88c0030b 	ldhu	r3,12(r17)
 100db7c:	89000417 	ldw	r4,16(r17)
 100db80:	88000115 	stw	zero,4(r17)
 100db84:	197dffcc 	andi	r5,r3,63487
 100db88:	8940030d 	sth	r5,12(r17)
 100db8c:	89000015 	stw	r4,0(r17)
 100db90:	18c4000c 	andi	r3,r3,4096
 100db94:	18002c1e 	bne	r3,zero,100dc48 <__sflush_r+0x160>
 100db98:	89400c17 	ldw	r5,48(r17)
 100db9c:	9c000015 	stw	r16,0(r19)
 100dba0:	28000526 	beq	r5,zero,100dbb8 <__sflush_r+0xd0>
 100dba4:	88801004 	addi	r2,r17,64
 100dba8:	28800226 	beq	r5,r2,100dbb4 <__sflush_r+0xcc>
 100dbac:	9809883a 	mov	r4,r19
 100dbb0:	100e2540 	call	100e254 <_free_r>
 100dbb4:	88000c15 	stw	zero,48(r17)
 100dbb8:	0005883a 	mov	r2,zero
 100dbbc:	dfc00417 	ldw	ra,16(sp)
 100dbc0:	dcc00317 	ldw	r19,12(sp)
 100dbc4:	dc800217 	ldw	r18,8(sp)
 100dbc8:	dc400117 	ldw	r17,4(sp)
 100dbcc:	dc000017 	ldw	r16,0(sp)
 100dbd0:	dec00504 	addi	sp,sp,20
 100dbd4:	f800283a 	ret
 100dbd8:	2c800417 	ldw	r18,16(r5)
 100dbdc:	903ff626 	beq	r18,zero,100dbb8 <__alt_data_end+0xff80dbb8>
 100dbe0:	2c000017 	ldw	r16,0(r5)
 100dbe4:	108000cc 	andi	r2,r2,3
 100dbe8:	2c800015 	stw	r18,0(r5)
 100dbec:	84a1c83a 	sub	r16,r16,r18
 100dbf0:	1000131e 	bne	r2,zero,100dc40 <__sflush_r+0x158>
 100dbf4:	28800517 	ldw	r2,20(r5)
 100dbf8:	88800215 	stw	r2,8(r17)
 100dbfc:	04000316 	blt	zero,r16,100dc0c <__sflush_r+0x124>
 100dc00:	003fed06 	br	100dbb8 <__alt_data_end+0xff80dbb8>
 100dc04:	90a5883a 	add	r18,r18,r2
 100dc08:	043feb0e 	bge	zero,r16,100dbb8 <__alt_data_end+0xff80dbb8>
 100dc0c:	88800917 	ldw	r2,36(r17)
 100dc10:	89400717 	ldw	r5,28(r17)
 100dc14:	800f883a 	mov	r7,r16
 100dc18:	900d883a 	mov	r6,r18
 100dc1c:	9809883a 	mov	r4,r19
 100dc20:	103ee83a 	callr	r2
 100dc24:	80a1c83a 	sub	r16,r16,r2
 100dc28:	00bff616 	blt	zero,r2,100dc04 <__alt_data_end+0xff80dc04>
 100dc2c:	88c0030b 	ldhu	r3,12(r17)
 100dc30:	00bfffc4 	movi	r2,-1
 100dc34:	18c01014 	ori	r3,r3,64
 100dc38:	88c0030d 	sth	r3,12(r17)
 100dc3c:	003fdf06 	br	100dbbc <__alt_data_end+0xff80dbbc>
 100dc40:	0005883a 	mov	r2,zero
 100dc44:	003fec06 	br	100dbf8 <__alt_data_end+0xff80dbf8>
 100dc48:	88801415 	stw	r2,80(r17)
 100dc4c:	003fd206 	br	100db98 <__alt_data_end+0xff80db98>
 100dc50:	28c00f17 	ldw	r3,60(r5)
 100dc54:	00ffb316 	blt	zero,r3,100db24 <__alt_data_end+0xff80db24>
 100dc58:	003fd706 	br	100dbb8 <__alt_data_end+0xff80dbb8>
 100dc5c:	89400717 	ldw	r5,28(r17)
 100dc60:	000d883a 	mov	r6,zero
 100dc64:	01c00044 	movi	r7,1
 100dc68:	9809883a 	mov	r4,r19
 100dc6c:	403ee83a 	callr	r8
 100dc70:	100d883a 	mov	r6,r2
 100dc74:	00bfffc4 	movi	r2,-1
 100dc78:	30801426 	beq	r6,r2,100dccc <__sflush_r+0x1e4>
 100dc7c:	8880030b 	ldhu	r2,12(r17)
 100dc80:	8a000a17 	ldw	r8,40(r17)
 100dc84:	003fae06 	br	100db40 <__alt_data_end+0xff80db40>
 100dc88:	98c00017 	ldw	r3,0(r19)
 100dc8c:	183fba26 	beq	r3,zero,100db78 <__alt_data_end+0xff80db78>
 100dc90:	01000744 	movi	r4,29
 100dc94:	19000626 	beq	r3,r4,100dcb0 <__sflush_r+0x1c8>
 100dc98:	01000584 	movi	r4,22
 100dc9c:	19000426 	beq	r3,r4,100dcb0 <__sflush_r+0x1c8>
 100dca0:	88c0030b 	ldhu	r3,12(r17)
 100dca4:	18c01014 	ori	r3,r3,64
 100dca8:	88c0030d 	sth	r3,12(r17)
 100dcac:	003fc306 	br	100dbbc <__alt_data_end+0xff80dbbc>
 100dcb0:	8880030b 	ldhu	r2,12(r17)
 100dcb4:	88c00417 	ldw	r3,16(r17)
 100dcb8:	88000115 	stw	zero,4(r17)
 100dcbc:	10bdffcc 	andi	r2,r2,63487
 100dcc0:	8880030d 	sth	r2,12(r17)
 100dcc4:	88c00015 	stw	r3,0(r17)
 100dcc8:	003fb306 	br	100db98 <__alt_data_end+0xff80db98>
 100dccc:	98800017 	ldw	r2,0(r19)
 100dcd0:	103fea26 	beq	r2,zero,100dc7c <__alt_data_end+0xff80dc7c>
 100dcd4:	00c00744 	movi	r3,29
 100dcd8:	10c00226 	beq	r2,r3,100dce4 <__sflush_r+0x1fc>
 100dcdc:	00c00584 	movi	r3,22
 100dce0:	10c0031e 	bne	r2,r3,100dcf0 <__sflush_r+0x208>
 100dce4:	9c000015 	stw	r16,0(r19)
 100dce8:	0005883a 	mov	r2,zero
 100dcec:	003fb306 	br	100dbbc <__alt_data_end+0xff80dbbc>
 100dcf0:	88c0030b 	ldhu	r3,12(r17)
 100dcf4:	3005883a 	mov	r2,r6
 100dcf8:	18c01014 	ori	r3,r3,64
 100dcfc:	88c0030d 	sth	r3,12(r17)
 100dd00:	003fae06 	br	100dbbc <__alt_data_end+0xff80dbbc>

0100dd04 <_fflush_r>:
 100dd04:	defffd04 	addi	sp,sp,-12
 100dd08:	dc000115 	stw	r16,4(sp)
 100dd0c:	dfc00215 	stw	ra,8(sp)
 100dd10:	2021883a 	mov	r16,r4
 100dd14:	20000226 	beq	r4,zero,100dd20 <_fflush_r+0x1c>
 100dd18:	20800e17 	ldw	r2,56(r4)
 100dd1c:	10000c26 	beq	r2,zero,100dd50 <_fflush_r+0x4c>
 100dd20:	2880030f 	ldh	r2,12(r5)
 100dd24:	1000051e 	bne	r2,zero,100dd3c <_fflush_r+0x38>
 100dd28:	0005883a 	mov	r2,zero
 100dd2c:	dfc00217 	ldw	ra,8(sp)
 100dd30:	dc000117 	ldw	r16,4(sp)
 100dd34:	dec00304 	addi	sp,sp,12
 100dd38:	f800283a 	ret
 100dd3c:	8009883a 	mov	r4,r16
 100dd40:	dfc00217 	ldw	ra,8(sp)
 100dd44:	dc000117 	ldw	r16,4(sp)
 100dd48:	dec00304 	addi	sp,sp,12
 100dd4c:	100dae81 	jmpi	100dae8 <__sflush_r>
 100dd50:	d9400015 	stw	r5,0(sp)
 100dd54:	100e0e00 	call	100e0e0 <__sinit>
 100dd58:	d9400017 	ldw	r5,0(sp)
 100dd5c:	003ff006 	br	100dd20 <__alt_data_end+0xff80dd20>

0100dd60 <fflush>:
 100dd60:	20000526 	beq	r4,zero,100dd78 <fflush+0x18>
 100dd64:	008040b4 	movhi	r2,258
 100dd68:	10b39b04 	addi	r2,r2,-12692
 100dd6c:	200b883a 	mov	r5,r4
 100dd70:	11000017 	ldw	r4,0(r2)
 100dd74:	100dd041 	jmpi	100dd04 <_fflush_r>
 100dd78:	008040b4 	movhi	r2,258
 100dd7c:	10b39a04 	addi	r2,r2,-12696
 100dd80:	11000017 	ldw	r4,0(r2)
 100dd84:	01404074 	movhi	r5,257
 100dd88:	29774104 	addi	r5,r5,-8956
 100dd8c:	100eae41 	jmpi	100eae4 <_fwalk_reent>

0100dd90 <__fp_unlock>:
 100dd90:	0005883a 	mov	r2,zero
 100dd94:	f800283a 	ret

0100dd98 <_cleanup_r>:
 100dd98:	01404074 	movhi	r5,257
 100dd9c:	294ad304 	addi	r5,r5,11084
 100dda0:	100eae41 	jmpi	100eae4 <_fwalk_reent>

0100dda4 <__sinit.part.1>:
 100dda4:	defff704 	addi	sp,sp,-36
 100dda8:	00c04074 	movhi	r3,257
 100ddac:	dfc00815 	stw	ra,32(sp)
 100ddb0:	ddc00715 	stw	r23,28(sp)
 100ddb4:	dd800615 	stw	r22,24(sp)
 100ddb8:	dd400515 	stw	r21,20(sp)
 100ddbc:	dd000415 	stw	r20,16(sp)
 100ddc0:	dcc00315 	stw	r19,12(sp)
 100ddc4:	dc800215 	stw	r18,8(sp)
 100ddc8:	dc400115 	stw	r17,4(sp)
 100ddcc:	dc000015 	stw	r16,0(sp)
 100ddd0:	18f76604 	addi	r3,r3,-8808
 100ddd4:	24000117 	ldw	r16,4(r4)
 100ddd8:	20c00f15 	stw	r3,60(r4)
 100dddc:	2080bb04 	addi	r2,r4,748
 100dde0:	00c000c4 	movi	r3,3
 100dde4:	20c0b915 	stw	r3,740(r4)
 100dde8:	2080ba15 	stw	r2,744(r4)
 100ddec:	2000b815 	stw	zero,736(r4)
 100ddf0:	05c00204 	movi	r23,8
 100ddf4:	00800104 	movi	r2,4
 100ddf8:	2025883a 	mov	r18,r4
 100ddfc:	b80d883a 	mov	r6,r23
 100de00:	81001704 	addi	r4,r16,92
 100de04:	000b883a 	mov	r5,zero
 100de08:	80000015 	stw	zero,0(r16)
 100de0c:	80000115 	stw	zero,4(r16)
 100de10:	80000215 	stw	zero,8(r16)
 100de14:	8080030d 	sth	r2,12(r16)
 100de18:	80001915 	stw	zero,100(r16)
 100de1c:	8000038d 	sth	zero,14(r16)
 100de20:	80000415 	stw	zero,16(r16)
 100de24:	80000515 	stw	zero,20(r16)
 100de28:	80000615 	stw	zero,24(r16)
 100de2c:	1009b1c0 	call	1009b1c <memset>
 100de30:	05804074 	movhi	r22,257
 100de34:	94400217 	ldw	r17,8(r18)
 100de38:	05404074 	movhi	r21,257
 100de3c:	05004074 	movhi	r20,257
 100de40:	04c04074 	movhi	r19,257
 100de44:	b5840704 	addi	r22,r22,4124
 100de48:	ad441e04 	addi	r21,r21,4216
 100de4c:	a5043d04 	addi	r20,r20,4340
 100de50:	9cc45404 	addi	r19,r19,4432
 100de54:	85800815 	stw	r22,32(r16)
 100de58:	85400915 	stw	r21,36(r16)
 100de5c:	85000a15 	stw	r20,40(r16)
 100de60:	84c00b15 	stw	r19,44(r16)
 100de64:	84000715 	stw	r16,28(r16)
 100de68:	00800284 	movi	r2,10
 100de6c:	8880030d 	sth	r2,12(r17)
 100de70:	00800044 	movi	r2,1
 100de74:	b80d883a 	mov	r6,r23
 100de78:	89001704 	addi	r4,r17,92
 100de7c:	000b883a 	mov	r5,zero
 100de80:	88000015 	stw	zero,0(r17)
 100de84:	88000115 	stw	zero,4(r17)
 100de88:	88000215 	stw	zero,8(r17)
 100de8c:	88001915 	stw	zero,100(r17)
 100de90:	8880038d 	sth	r2,14(r17)
 100de94:	88000415 	stw	zero,16(r17)
 100de98:	88000515 	stw	zero,20(r17)
 100de9c:	88000615 	stw	zero,24(r17)
 100dea0:	1009b1c0 	call	1009b1c <memset>
 100dea4:	94000317 	ldw	r16,12(r18)
 100dea8:	00800484 	movi	r2,18
 100deac:	8c400715 	stw	r17,28(r17)
 100deb0:	8d800815 	stw	r22,32(r17)
 100deb4:	8d400915 	stw	r21,36(r17)
 100deb8:	8d000a15 	stw	r20,40(r17)
 100debc:	8cc00b15 	stw	r19,44(r17)
 100dec0:	8080030d 	sth	r2,12(r16)
 100dec4:	00800084 	movi	r2,2
 100dec8:	80000015 	stw	zero,0(r16)
 100decc:	80000115 	stw	zero,4(r16)
 100ded0:	80000215 	stw	zero,8(r16)
 100ded4:	80001915 	stw	zero,100(r16)
 100ded8:	8080038d 	sth	r2,14(r16)
 100dedc:	80000415 	stw	zero,16(r16)
 100dee0:	80000515 	stw	zero,20(r16)
 100dee4:	80000615 	stw	zero,24(r16)
 100dee8:	b80d883a 	mov	r6,r23
 100deec:	000b883a 	mov	r5,zero
 100def0:	81001704 	addi	r4,r16,92
 100def4:	1009b1c0 	call	1009b1c <memset>
 100def8:	00800044 	movi	r2,1
 100defc:	84000715 	stw	r16,28(r16)
 100df00:	85800815 	stw	r22,32(r16)
 100df04:	85400915 	stw	r21,36(r16)
 100df08:	85000a15 	stw	r20,40(r16)
 100df0c:	84c00b15 	stw	r19,44(r16)
 100df10:	90800e15 	stw	r2,56(r18)
 100df14:	dfc00817 	ldw	ra,32(sp)
 100df18:	ddc00717 	ldw	r23,28(sp)
 100df1c:	dd800617 	ldw	r22,24(sp)
 100df20:	dd400517 	ldw	r21,20(sp)
 100df24:	dd000417 	ldw	r20,16(sp)
 100df28:	dcc00317 	ldw	r19,12(sp)
 100df2c:	dc800217 	ldw	r18,8(sp)
 100df30:	dc400117 	ldw	r17,4(sp)
 100df34:	dc000017 	ldw	r16,0(sp)
 100df38:	dec00904 	addi	sp,sp,36
 100df3c:	f800283a 	ret

0100df40 <__fp_lock>:
 100df40:	0005883a 	mov	r2,zero
 100df44:	f800283a 	ret

0100df48 <__sfmoreglue>:
 100df48:	defffc04 	addi	sp,sp,-16
 100df4c:	dc400115 	stw	r17,4(sp)
 100df50:	2c7fffc4 	addi	r17,r5,-1
 100df54:	8c401a24 	muli	r17,r17,104
 100df58:	dc800215 	stw	r18,8(sp)
 100df5c:	2825883a 	mov	r18,r5
 100df60:	89401d04 	addi	r5,r17,116
 100df64:	dc000015 	stw	r16,0(sp)
 100df68:	dfc00315 	stw	ra,12(sp)
 100df6c:	100ee400 	call	100ee40 <_malloc_r>
 100df70:	1021883a 	mov	r16,r2
 100df74:	10000726 	beq	r2,zero,100df94 <__sfmoreglue+0x4c>
 100df78:	11000304 	addi	r4,r2,12
 100df7c:	10000015 	stw	zero,0(r2)
 100df80:	14800115 	stw	r18,4(r2)
 100df84:	11000215 	stw	r4,8(r2)
 100df88:	89801a04 	addi	r6,r17,104
 100df8c:	000b883a 	mov	r5,zero
 100df90:	1009b1c0 	call	1009b1c <memset>
 100df94:	8005883a 	mov	r2,r16
 100df98:	dfc00317 	ldw	ra,12(sp)
 100df9c:	dc800217 	ldw	r18,8(sp)
 100dfa0:	dc400117 	ldw	r17,4(sp)
 100dfa4:	dc000017 	ldw	r16,0(sp)
 100dfa8:	dec00404 	addi	sp,sp,16
 100dfac:	f800283a 	ret

0100dfb0 <__sfp>:
 100dfb0:	defffb04 	addi	sp,sp,-20
 100dfb4:	dc000015 	stw	r16,0(sp)
 100dfb8:	040040b4 	movhi	r16,258
 100dfbc:	84339a04 	addi	r16,r16,-12696
 100dfc0:	dcc00315 	stw	r19,12(sp)
 100dfc4:	2027883a 	mov	r19,r4
 100dfc8:	81000017 	ldw	r4,0(r16)
 100dfcc:	dfc00415 	stw	ra,16(sp)
 100dfd0:	dc800215 	stw	r18,8(sp)
 100dfd4:	20800e17 	ldw	r2,56(r4)
 100dfd8:	dc400115 	stw	r17,4(sp)
 100dfdc:	1000021e 	bne	r2,zero,100dfe8 <__sfp+0x38>
 100dfe0:	100dda40 	call	100dda4 <__sinit.part.1>
 100dfe4:	81000017 	ldw	r4,0(r16)
 100dfe8:	2480b804 	addi	r18,r4,736
 100dfec:	047fffc4 	movi	r17,-1
 100dff0:	91000117 	ldw	r4,4(r18)
 100dff4:	94000217 	ldw	r16,8(r18)
 100dff8:	213fffc4 	addi	r4,r4,-1
 100dffc:	20000a16 	blt	r4,zero,100e028 <__sfp+0x78>
 100e000:	8080030f 	ldh	r2,12(r16)
 100e004:	10000c26 	beq	r2,zero,100e038 <__sfp+0x88>
 100e008:	80c01d04 	addi	r3,r16,116
 100e00c:	00000206 	br	100e018 <__sfp+0x68>
 100e010:	18bfe60f 	ldh	r2,-104(r3)
 100e014:	10000826 	beq	r2,zero,100e038 <__sfp+0x88>
 100e018:	213fffc4 	addi	r4,r4,-1
 100e01c:	1c3ffd04 	addi	r16,r3,-12
 100e020:	18c01a04 	addi	r3,r3,104
 100e024:	247ffa1e 	bne	r4,r17,100e010 <__alt_data_end+0xff80e010>
 100e028:	90800017 	ldw	r2,0(r18)
 100e02c:	10001d26 	beq	r2,zero,100e0a4 <__sfp+0xf4>
 100e030:	1025883a 	mov	r18,r2
 100e034:	003fee06 	br	100dff0 <__alt_data_end+0xff80dff0>
 100e038:	00bfffc4 	movi	r2,-1
 100e03c:	8080038d 	sth	r2,14(r16)
 100e040:	00800044 	movi	r2,1
 100e044:	8080030d 	sth	r2,12(r16)
 100e048:	80001915 	stw	zero,100(r16)
 100e04c:	80000015 	stw	zero,0(r16)
 100e050:	80000215 	stw	zero,8(r16)
 100e054:	80000115 	stw	zero,4(r16)
 100e058:	80000415 	stw	zero,16(r16)
 100e05c:	80000515 	stw	zero,20(r16)
 100e060:	80000615 	stw	zero,24(r16)
 100e064:	01800204 	movi	r6,8
 100e068:	000b883a 	mov	r5,zero
 100e06c:	81001704 	addi	r4,r16,92
 100e070:	1009b1c0 	call	1009b1c <memset>
 100e074:	8005883a 	mov	r2,r16
 100e078:	80000c15 	stw	zero,48(r16)
 100e07c:	80000d15 	stw	zero,52(r16)
 100e080:	80001115 	stw	zero,68(r16)
 100e084:	80001215 	stw	zero,72(r16)
 100e088:	dfc00417 	ldw	ra,16(sp)
 100e08c:	dcc00317 	ldw	r19,12(sp)
 100e090:	dc800217 	ldw	r18,8(sp)
 100e094:	dc400117 	ldw	r17,4(sp)
 100e098:	dc000017 	ldw	r16,0(sp)
 100e09c:	dec00504 	addi	sp,sp,20
 100e0a0:	f800283a 	ret
 100e0a4:	01400104 	movi	r5,4
 100e0a8:	9809883a 	mov	r4,r19
 100e0ac:	100df480 	call	100df48 <__sfmoreglue>
 100e0b0:	90800015 	stw	r2,0(r18)
 100e0b4:	103fde1e 	bne	r2,zero,100e030 <__alt_data_end+0xff80e030>
 100e0b8:	00800304 	movi	r2,12
 100e0bc:	98800015 	stw	r2,0(r19)
 100e0c0:	0005883a 	mov	r2,zero
 100e0c4:	003ff006 	br	100e088 <__alt_data_end+0xff80e088>

0100e0c8 <_cleanup>:
 100e0c8:	008040b4 	movhi	r2,258
 100e0cc:	10b39a04 	addi	r2,r2,-12696
 100e0d0:	11000017 	ldw	r4,0(r2)
 100e0d4:	01404074 	movhi	r5,257
 100e0d8:	294ad304 	addi	r5,r5,11084
 100e0dc:	100eae41 	jmpi	100eae4 <_fwalk_reent>

0100e0e0 <__sinit>:
 100e0e0:	20800e17 	ldw	r2,56(r4)
 100e0e4:	10000126 	beq	r2,zero,100e0ec <__sinit+0xc>
 100e0e8:	f800283a 	ret
 100e0ec:	100dda41 	jmpi	100dda4 <__sinit.part.1>

0100e0f0 <__sfp_lock_acquire>:
 100e0f0:	f800283a 	ret

0100e0f4 <__sfp_lock_release>:
 100e0f4:	f800283a 	ret

0100e0f8 <__sinit_lock_acquire>:
 100e0f8:	f800283a 	ret

0100e0fc <__sinit_lock_release>:
 100e0fc:	f800283a 	ret

0100e100 <__fp_lock_all>:
 100e100:	008040b4 	movhi	r2,258
 100e104:	10b39b04 	addi	r2,r2,-12692
 100e108:	11000017 	ldw	r4,0(r2)
 100e10c:	01404074 	movhi	r5,257
 100e110:	2977d004 	addi	r5,r5,-8384
 100e114:	100ea201 	jmpi	100ea20 <_fwalk>

0100e118 <__fp_unlock_all>:
 100e118:	008040b4 	movhi	r2,258
 100e11c:	10b39b04 	addi	r2,r2,-12692
 100e120:	11000017 	ldw	r4,0(r2)
 100e124:	01404074 	movhi	r5,257
 100e128:	29776404 	addi	r5,r5,-8816
 100e12c:	100ea201 	jmpi	100ea20 <_fwalk>

0100e130 <_malloc_trim_r>:
 100e130:	defffb04 	addi	sp,sp,-20
 100e134:	dcc00315 	stw	r19,12(sp)
 100e138:	04c040b4 	movhi	r19,258
 100e13c:	dc800215 	stw	r18,8(sp)
 100e140:	dc400115 	stw	r17,4(sp)
 100e144:	dc000015 	stw	r16,0(sp)
 100e148:	dfc00415 	stw	ra,16(sp)
 100e14c:	2821883a 	mov	r16,r5
 100e150:	9ced6e04 	addi	r19,r19,-19016
 100e154:	2025883a 	mov	r18,r4
 100e158:	10168a40 	call	10168a4 <__malloc_lock>
 100e15c:	98800217 	ldw	r2,8(r19)
 100e160:	14400117 	ldw	r17,4(r2)
 100e164:	00bfff04 	movi	r2,-4
 100e168:	88a2703a 	and	r17,r17,r2
 100e16c:	8c21c83a 	sub	r16,r17,r16
 100e170:	8403fbc4 	addi	r16,r16,4079
 100e174:	8020d33a 	srli	r16,r16,12
 100e178:	0083ffc4 	movi	r2,4095
 100e17c:	843fffc4 	addi	r16,r16,-1
 100e180:	8020933a 	slli	r16,r16,12
 100e184:	1400060e 	bge	r2,r16,100e1a0 <_malloc_trim_r+0x70>
 100e188:	000b883a 	mov	r5,zero
 100e18c:	9009883a 	mov	r4,r18
 100e190:	1010fc80 	call	1010fc8 <_sbrk_r>
 100e194:	98c00217 	ldw	r3,8(r19)
 100e198:	1c47883a 	add	r3,r3,r17
 100e19c:	10c00a26 	beq	r2,r3,100e1c8 <_malloc_trim_r+0x98>
 100e1a0:	9009883a 	mov	r4,r18
 100e1a4:	10168c80 	call	10168c8 <__malloc_unlock>
 100e1a8:	0005883a 	mov	r2,zero
 100e1ac:	dfc00417 	ldw	ra,16(sp)
 100e1b0:	dcc00317 	ldw	r19,12(sp)
 100e1b4:	dc800217 	ldw	r18,8(sp)
 100e1b8:	dc400117 	ldw	r17,4(sp)
 100e1bc:	dc000017 	ldw	r16,0(sp)
 100e1c0:	dec00504 	addi	sp,sp,20
 100e1c4:	f800283a 	ret
 100e1c8:	040bc83a 	sub	r5,zero,r16
 100e1cc:	9009883a 	mov	r4,r18
 100e1d0:	1010fc80 	call	1010fc8 <_sbrk_r>
 100e1d4:	00ffffc4 	movi	r3,-1
 100e1d8:	10c00d26 	beq	r2,r3,100e210 <_malloc_trim_r+0xe0>
 100e1dc:	00c05cf4 	movhi	r3,371
 100e1e0:	18e9d704 	addi	r3,r3,-22692
 100e1e4:	18800017 	ldw	r2,0(r3)
 100e1e8:	99000217 	ldw	r4,8(r19)
 100e1ec:	8c23c83a 	sub	r17,r17,r16
 100e1f0:	8c400054 	ori	r17,r17,1
 100e1f4:	1421c83a 	sub	r16,r2,r16
 100e1f8:	24400115 	stw	r17,4(r4)
 100e1fc:	9009883a 	mov	r4,r18
 100e200:	1c000015 	stw	r16,0(r3)
 100e204:	10168c80 	call	10168c8 <__malloc_unlock>
 100e208:	00800044 	movi	r2,1
 100e20c:	003fe706 	br	100e1ac <__alt_data_end+0xff80e1ac>
 100e210:	000b883a 	mov	r5,zero
 100e214:	9009883a 	mov	r4,r18
 100e218:	1010fc80 	call	1010fc8 <_sbrk_r>
 100e21c:	99000217 	ldw	r4,8(r19)
 100e220:	014003c4 	movi	r5,15
 100e224:	1107c83a 	sub	r3,r2,r4
 100e228:	28ffdd0e 	bge	r5,r3,100e1a0 <__alt_data_end+0xff80e1a0>
 100e22c:	014040b4 	movhi	r5,258
 100e230:	29739d04 	addi	r5,r5,-12684
 100e234:	29400017 	ldw	r5,0(r5)
 100e238:	18c00054 	ori	r3,r3,1
 100e23c:	20c00115 	stw	r3,4(r4)
 100e240:	00c05cf4 	movhi	r3,371
 100e244:	1145c83a 	sub	r2,r2,r5
 100e248:	18e9d704 	addi	r3,r3,-22692
 100e24c:	18800015 	stw	r2,0(r3)
 100e250:	003fd306 	br	100e1a0 <__alt_data_end+0xff80e1a0>

0100e254 <_free_r>:
 100e254:	28004126 	beq	r5,zero,100e35c <_free_r+0x108>
 100e258:	defffd04 	addi	sp,sp,-12
 100e25c:	dc400115 	stw	r17,4(sp)
 100e260:	dc000015 	stw	r16,0(sp)
 100e264:	2023883a 	mov	r17,r4
 100e268:	2821883a 	mov	r16,r5
 100e26c:	dfc00215 	stw	ra,8(sp)
 100e270:	10168a40 	call	10168a4 <__malloc_lock>
 100e274:	81ffff17 	ldw	r7,-4(r16)
 100e278:	00bfff84 	movi	r2,-2
 100e27c:	010040b4 	movhi	r4,258
 100e280:	81bffe04 	addi	r6,r16,-8
 100e284:	3884703a 	and	r2,r7,r2
 100e288:	212d6e04 	addi	r4,r4,-19016
 100e28c:	308b883a 	add	r5,r6,r2
 100e290:	2a400117 	ldw	r9,4(r5)
 100e294:	22000217 	ldw	r8,8(r4)
 100e298:	00ffff04 	movi	r3,-4
 100e29c:	48c6703a 	and	r3,r9,r3
 100e2a0:	2a005726 	beq	r5,r8,100e400 <_free_r+0x1ac>
 100e2a4:	28c00115 	stw	r3,4(r5)
 100e2a8:	39c0004c 	andi	r7,r7,1
 100e2ac:	3800091e 	bne	r7,zero,100e2d4 <_free_r+0x80>
 100e2b0:	823ffe17 	ldw	r8,-8(r16)
 100e2b4:	22400204 	addi	r9,r4,8
 100e2b8:	320dc83a 	sub	r6,r6,r8
 100e2bc:	31c00217 	ldw	r7,8(r6)
 100e2c0:	1205883a 	add	r2,r2,r8
 100e2c4:	3a406526 	beq	r7,r9,100e45c <_free_r+0x208>
 100e2c8:	32000317 	ldw	r8,12(r6)
 100e2cc:	3a000315 	stw	r8,12(r7)
 100e2d0:	41c00215 	stw	r7,8(r8)
 100e2d4:	28cf883a 	add	r7,r5,r3
 100e2d8:	39c00117 	ldw	r7,4(r7)
 100e2dc:	39c0004c 	andi	r7,r7,1
 100e2e0:	38003a26 	beq	r7,zero,100e3cc <_free_r+0x178>
 100e2e4:	10c00054 	ori	r3,r2,1
 100e2e8:	30c00115 	stw	r3,4(r6)
 100e2ec:	3087883a 	add	r3,r6,r2
 100e2f0:	18800015 	stw	r2,0(r3)
 100e2f4:	00c07fc4 	movi	r3,511
 100e2f8:	18801936 	bltu	r3,r2,100e360 <_free_r+0x10c>
 100e2fc:	1004d0fa 	srli	r2,r2,3
 100e300:	01c00044 	movi	r7,1
 100e304:	21400117 	ldw	r5,4(r4)
 100e308:	10c00044 	addi	r3,r2,1
 100e30c:	18c7883a 	add	r3,r3,r3
 100e310:	1005d0ba 	srai	r2,r2,2
 100e314:	18c7883a 	add	r3,r3,r3
 100e318:	18c7883a 	add	r3,r3,r3
 100e31c:	1907883a 	add	r3,r3,r4
 100e320:	3884983a 	sll	r2,r7,r2
 100e324:	19c00017 	ldw	r7,0(r3)
 100e328:	1a3ffe04 	addi	r8,r3,-8
 100e32c:	1144b03a 	or	r2,r2,r5
 100e330:	32000315 	stw	r8,12(r6)
 100e334:	31c00215 	stw	r7,8(r6)
 100e338:	20800115 	stw	r2,4(r4)
 100e33c:	19800015 	stw	r6,0(r3)
 100e340:	39800315 	stw	r6,12(r7)
 100e344:	8809883a 	mov	r4,r17
 100e348:	dfc00217 	ldw	ra,8(sp)
 100e34c:	dc400117 	ldw	r17,4(sp)
 100e350:	dc000017 	ldw	r16,0(sp)
 100e354:	dec00304 	addi	sp,sp,12
 100e358:	10168c81 	jmpi	10168c8 <__malloc_unlock>
 100e35c:	f800283a 	ret
 100e360:	100ad27a 	srli	r5,r2,9
 100e364:	00c00104 	movi	r3,4
 100e368:	19404a36 	bltu	r3,r5,100e494 <_free_r+0x240>
 100e36c:	100ad1ba 	srli	r5,r2,6
 100e370:	28c00e44 	addi	r3,r5,57
 100e374:	18c7883a 	add	r3,r3,r3
 100e378:	29400e04 	addi	r5,r5,56
 100e37c:	18c7883a 	add	r3,r3,r3
 100e380:	18c7883a 	add	r3,r3,r3
 100e384:	1909883a 	add	r4,r3,r4
 100e388:	20c00017 	ldw	r3,0(r4)
 100e38c:	01c040b4 	movhi	r7,258
 100e390:	213ffe04 	addi	r4,r4,-8
 100e394:	39ed6e04 	addi	r7,r7,-19016
 100e398:	20c04426 	beq	r4,r3,100e4ac <_free_r+0x258>
 100e39c:	01ffff04 	movi	r7,-4
 100e3a0:	19400117 	ldw	r5,4(r3)
 100e3a4:	29ca703a 	and	r5,r5,r7
 100e3a8:	1140022e 	bgeu	r2,r5,100e3b4 <_free_r+0x160>
 100e3ac:	18c00217 	ldw	r3,8(r3)
 100e3b0:	20fffb1e 	bne	r4,r3,100e3a0 <__alt_data_end+0xff80e3a0>
 100e3b4:	19000317 	ldw	r4,12(r3)
 100e3b8:	31000315 	stw	r4,12(r6)
 100e3bc:	30c00215 	stw	r3,8(r6)
 100e3c0:	21800215 	stw	r6,8(r4)
 100e3c4:	19800315 	stw	r6,12(r3)
 100e3c8:	003fde06 	br	100e344 <__alt_data_end+0xff80e344>
 100e3cc:	29c00217 	ldw	r7,8(r5)
 100e3d0:	10c5883a 	add	r2,r2,r3
 100e3d4:	00c040b4 	movhi	r3,258
 100e3d8:	18ed7004 	addi	r3,r3,-19008
 100e3dc:	38c03b26 	beq	r7,r3,100e4cc <_free_r+0x278>
 100e3e0:	2a000317 	ldw	r8,12(r5)
 100e3e4:	11400054 	ori	r5,r2,1
 100e3e8:	3087883a 	add	r3,r6,r2
 100e3ec:	3a000315 	stw	r8,12(r7)
 100e3f0:	41c00215 	stw	r7,8(r8)
 100e3f4:	31400115 	stw	r5,4(r6)
 100e3f8:	18800015 	stw	r2,0(r3)
 100e3fc:	003fbd06 	br	100e2f4 <__alt_data_end+0xff80e2f4>
 100e400:	39c0004c 	andi	r7,r7,1
 100e404:	10c5883a 	add	r2,r2,r3
 100e408:	3800071e 	bne	r7,zero,100e428 <_free_r+0x1d4>
 100e40c:	81fffe17 	ldw	r7,-8(r16)
 100e410:	31cdc83a 	sub	r6,r6,r7
 100e414:	30c00317 	ldw	r3,12(r6)
 100e418:	31400217 	ldw	r5,8(r6)
 100e41c:	11c5883a 	add	r2,r2,r7
 100e420:	28c00315 	stw	r3,12(r5)
 100e424:	19400215 	stw	r5,8(r3)
 100e428:	10c00054 	ori	r3,r2,1
 100e42c:	30c00115 	stw	r3,4(r6)
 100e430:	00c040b4 	movhi	r3,258
 100e434:	18f39e04 	addi	r3,r3,-12680
 100e438:	18c00017 	ldw	r3,0(r3)
 100e43c:	21800215 	stw	r6,8(r4)
 100e440:	10ffc036 	bltu	r2,r3,100e344 <__alt_data_end+0xff80e344>
 100e444:	008040b4 	movhi	r2,258
 100e448:	10b42604 	addi	r2,r2,-12136
 100e44c:	11400017 	ldw	r5,0(r2)
 100e450:	8809883a 	mov	r4,r17
 100e454:	100e1300 	call	100e130 <_malloc_trim_r>
 100e458:	003fba06 	br	100e344 <__alt_data_end+0xff80e344>
 100e45c:	28c9883a 	add	r4,r5,r3
 100e460:	21000117 	ldw	r4,4(r4)
 100e464:	2100004c 	andi	r4,r4,1
 100e468:	2000391e 	bne	r4,zero,100e550 <_free_r+0x2fc>
 100e46c:	29c00217 	ldw	r7,8(r5)
 100e470:	29000317 	ldw	r4,12(r5)
 100e474:	1885883a 	add	r2,r3,r2
 100e478:	10c00054 	ori	r3,r2,1
 100e47c:	39000315 	stw	r4,12(r7)
 100e480:	21c00215 	stw	r7,8(r4)
 100e484:	30c00115 	stw	r3,4(r6)
 100e488:	308d883a 	add	r6,r6,r2
 100e48c:	30800015 	stw	r2,0(r6)
 100e490:	003fac06 	br	100e344 <__alt_data_end+0xff80e344>
 100e494:	00c00504 	movi	r3,20
 100e498:	19401536 	bltu	r3,r5,100e4f0 <_free_r+0x29c>
 100e49c:	28c01704 	addi	r3,r5,92
 100e4a0:	18c7883a 	add	r3,r3,r3
 100e4a4:	294016c4 	addi	r5,r5,91
 100e4a8:	003fb406 	br	100e37c <__alt_data_end+0xff80e37c>
 100e4ac:	280bd0ba 	srai	r5,r5,2
 100e4b0:	00c00044 	movi	r3,1
 100e4b4:	38800117 	ldw	r2,4(r7)
 100e4b8:	194a983a 	sll	r5,r3,r5
 100e4bc:	2007883a 	mov	r3,r4
 100e4c0:	2884b03a 	or	r2,r5,r2
 100e4c4:	38800115 	stw	r2,4(r7)
 100e4c8:	003fbb06 	br	100e3b8 <__alt_data_end+0xff80e3b8>
 100e4cc:	21800515 	stw	r6,20(r4)
 100e4d0:	21800415 	stw	r6,16(r4)
 100e4d4:	10c00054 	ori	r3,r2,1
 100e4d8:	31c00315 	stw	r7,12(r6)
 100e4dc:	31c00215 	stw	r7,8(r6)
 100e4e0:	30c00115 	stw	r3,4(r6)
 100e4e4:	308d883a 	add	r6,r6,r2
 100e4e8:	30800015 	stw	r2,0(r6)
 100e4ec:	003f9506 	br	100e344 <__alt_data_end+0xff80e344>
 100e4f0:	00c01504 	movi	r3,84
 100e4f4:	19400536 	bltu	r3,r5,100e50c <_free_r+0x2b8>
 100e4f8:	100ad33a 	srli	r5,r2,12
 100e4fc:	28c01bc4 	addi	r3,r5,111
 100e500:	18c7883a 	add	r3,r3,r3
 100e504:	29401b84 	addi	r5,r5,110
 100e508:	003f9c06 	br	100e37c <__alt_data_end+0xff80e37c>
 100e50c:	00c05504 	movi	r3,340
 100e510:	19400536 	bltu	r3,r5,100e528 <_free_r+0x2d4>
 100e514:	100ad3fa 	srli	r5,r2,15
 100e518:	28c01e04 	addi	r3,r5,120
 100e51c:	18c7883a 	add	r3,r3,r3
 100e520:	29401dc4 	addi	r5,r5,119
 100e524:	003f9506 	br	100e37c <__alt_data_end+0xff80e37c>
 100e528:	00c15504 	movi	r3,1364
 100e52c:	19400536 	bltu	r3,r5,100e544 <_free_r+0x2f0>
 100e530:	100ad4ba 	srli	r5,r2,18
 100e534:	28c01f44 	addi	r3,r5,125
 100e538:	18c7883a 	add	r3,r3,r3
 100e53c:	29401f04 	addi	r5,r5,124
 100e540:	003f8e06 	br	100e37c <__alt_data_end+0xff80e37c>
 100e544:	00c03f84 	movi	r3,254
 100e548:	01401f84 	movi	r5,126
 100e54c:	003f8b06 	br	100e37c <__alt_data_end+0xff80e37c>
 100e550:	10c00054 	ori	r3,r2,1
 100e554:	30c00115 	stw	r3,4(r6)
 100e558:	308d883a 	add	r6,r6,r2
 100e55c:	30800015 	stw	r2,0(r6)
 100e560:	003f7806 	br	100e344 <__alt_data_end+0xff80e344>

0100e564 <__sfvwrite_r>:
 100e564:	30800217 	ldw	r2,8(r6)
 100e568:	10006726 	beq	r2,zero,100e708 <__sfvwrite_r+0x1a4>
 100e56c:	28c0030b 	ldhu	r3,12(r5)
 100e570:	defff404 	addi	sp,sp,-48
 100e574:	dd400715 	stw	r21,28(sp)
 100e578:	dd000615 	stw	r20,24(sp)
 100e57c:	dc000215 	stw	r16,8(sp)
 100e580:	dfc00b15 	stw	ra,44(sp)
 100e584:	df000a15 	stw	fp,40(sp)
 100e588:	ddc00915 	stw	r23,36(sp)
 100e58c:	dd800815 	stw	r22,32(sp)
 100e590:	dcc00515 	stw	r19,20(sp)
 100e594:	dc800415 	stw	r18,16(sp)
 100e598:	dc400315 	stw	r17,12(sp)
 100e59c:	1880020c 	andi	r2,r3,8
 100e5a0:	2821883a 	mov	r16,r5
 100e5a4:	202b883a 	mov	r21,r4
 100e5a8:	3029883a 	mov	r20,r6
 100e5ac:	10002726 	beq	r2,zero,100e64c <__sfvwrite_r+0xe8>
 100e5b0:	28800417 	ldw	r2,16(r5)
 100e5b4:	10002526 	beq	r2,zero,100e64c <__sfvwrite_r+0xe8>
 100e5b8:	1880008c 	andi	r2,r3,2
 100e5bc:	a4400017 	ldw	r17,0(r20)
 100e5c0:	10002a26 	beq	r2,zero,100e66c <__sfvwrite_r+0x108>
 100e5c4:	05a00034 	movhi	r22,32768
 100e5c8:	0027883a 	mov	r19,zero
 100e5cc:	0025883a 	mov	r18,zero
 100e5d0:	b5bf0004 	addi	r22,r22,-1024
 100e5d4:	980d883a 	mov	r6,r19
 100e5d8:	a809883a 	mov	r4,r21
 100e5dc:	90004626 	beq	r18,zero,100e6f8 <__sfvwrite_r+0x194>
 100e5e0:	900f883a 	mov	r7,r18
 100e5e4:	b480022e 	bgeu	r22,r18,100e5f0 <__sfvwrite_r+0x8c>
 100e5e8:	01e00034 	movhi	r7,32768
 100e5ec:	39ff0004 	addi	r7,r7,-1024
 100e5f0:	80800917 	ldw	r2,36(r16)
 100e5f4:	81400717 	ldw	r5,28(r16)
 100e5f8:	103ee83a 	callr	r2
 100e5fc:	0080570e 	bge	zero,r2,100e75c <__sfvwrite_r+0x1f8>
 100e600:	a0c00217 	ldw	r3,8(r20)
 100e604:	98a7883a 	add	r19,r19,r2
 100e608:	90a5c83a 	sub	r18,r18,r2
 100e60c:	1885c83a 	sub	r2,r3,r2
 100e610:	a0800215 	stw	r2,8(r20)
 100e614:	103fef1e 	bne	r2,zero,100e5d4 <__alt_data_end+0xff80e5d4>
 100e618:	0005883a 	mov	r2,zero
 100e61c:	dfc00b17 	ldw	ra,44(sp)
 100e620:	df000a17 	ldw	fp,40(sp)
 100e624:	ddc00917 	ldw	r23,36(sp)
 100e628:	dd800817 	ldw	r22,32(sp)
 100e62c:	dd400717 	ldw	r21,28(sp)
 100e630:	dd000617 	ldw	r20,24(sp)
 100e634:	dcc00517 	ldw	r19,20(sp)
 100e638:	dc800417 	ldw	r18,16(sp)
 100e63c:	dc400317 	ldw	r17,12(sp)
 100e640:	dc000217 	ldw	r16,8(sp)
 100e644:	dec00c04 	addi	sp,sp,48
 100e648:	f800283a 	ret
 100e64c:	800b883a 	mov	r5,r16
 100e650:	a809883a 	mov	r4,r21
 100e654:	100c10c0 	call	100c10c <__swsetup_r>
 100e658:	1000eb1e 	bne	r2,zero,100ea08 <__sfvwrite_r+0x4a4>
 100e65c:	80c0030b 	ldhu	r3,12(r16)
 100e660:	a4400017 	ldw	r17,0(r20)
 100e664:	1880008c 	andi	r2,r3,2
 100e668:	103fd61e 	bne	r2,zero,100e5c4 <__alt_data_end+0xff80e5c4>
 100e66c:	1880004c 	andi	r2,r3,1
 100e670:	10003f1e 	bne	r2,zero,100e770 <__sfvwrite_r+0x20c>
 100e674:	0039883a 	mov	fp,zero
 100e678:	0025883a 	mov	r18,zero
 100e67c:	90001a26 	beq	r18,zero,100e6e8 <__sfvwrite_r+0x184>
 100e680:	1880800c 	andi	r2,r3,512
 100e684:	84c00217 	ldw	r19,8(r16)
 100e688:	10002126 	beq	r2,zero,100e710 <__sfvwrite_r+0x1ac>
 100e68c:	982f883a 	mov	r23,r19
 100e690:	94c09336 	bltu	r18,r19,100e8e0 <__sfvwrite_r+0x37c>
 100e694:	1881200c 	andi	r2,r3,1152
 100e698:	10009e1e 	bne	r2,zero,100e914 <__sfvwrite_r+0x3b0>
 100e69c:	81000017 	ldw	r4,0(r16)
 100e6a0:	b80d883a 	mov	r6,r23
 100e6a4:	e00b883a 	mov	r5,fp
 100e6a8:	100f7300 	call	100f730 <memmove>
 100e6ac:	80c00217 	ldw	r3,8(r16)
 100e6b0:	81000017 	ldw	r4,0(r16)
 100e6b4:	9005883a 	mov	r2,r18
 100e6b8:	1ce7c83a 	sub	r19,r3,r19
 100e6bc:	25cf883a 	add	r7,r4,r23
 100e6c0:	84c00215 	stw	r19,8(r16)
 100e6c4:	81c00015 	stw	r7,0(r16)
 100e6c8:	a0c00217 	ldw	r3,8(r20)
 100e6cc:	e0b9883a 	add	fp,fp,r2
 100e6d0:	90a5c83a 	sub	r18,r18,r2
 100e6d4:	18a7c83a 	sub	r19,r3,r2
 100e6d8:	a4c00215 	stw	r19,8(r20)
 100e6dc:	983fce26 	beq	r19,zero,100e618 <__alt_data_end+0xff80e618>
 100e6e0:	80c0030b 	ldhu	r3,12(r16)
 100e6e4:	903fe61e 	bne	r18,zero,100e680 <__alt_data_end+0xff80e680>
 100e6e8:	8f000017 	ldw	fp,0(r17)
 100e6ec:	8c800117 	ldw	r18,4(r17)
 100e6f0:	8c400204 	addi	r17,r17,8
 100e6f4:	003fe106 	br	100e67c <__alt_data_end+0xff80e67c>
 100e6f8:	8cc00017 	ldw	r19,0(r17)
 100e6fc:	8c800117 	ldw	r18,4(r17)
 100e700:	8c400204 	addi	r17,r17,8
 100e704:	003fb306 	br	100e5d4 <__alt_data_end+0xff80e5d4>
 100e708:	0005883a 	mov	r2,zero
 100e70c:	f800283a 	ret
 100e710:	81000017 	ldw	r4,0(r16)
 100e714:	80800417 	ldw	r2,16(r16)
 100e718:	11005736 	bltu	r2,r4,100e878 <__sfvwrite_r+0x314>
 100e71c:	85c00517 	ldw	r23,20(r16)
 100e720:	95c05536 	bltu	r18,r23,100e878 <__sfvwrite_r+0x314>
 100e724:	00a00034 	movhi	r2,32768
 100e728:	10bfffc4 	addi	r2,r2,-1
 100e72c:	9009883a 	mov	r4,r18
 100e730:	1480012e 	bgeu	r2,r18,100e738 <__sfvwrite_r+0x1d4>
 100e734:	1009883a 	mov	r4,r2
 100e738:	b80b883a 	mov	r5,r23
 100e73c:	10096ac0 	call	10096ac <__divsi3>
 100e740:	15cf383a 	mul	r7,r2,r23
 100e744:	81400717 	ldw	r5,28(r16)
 100e748:	80800917 	ldw	r2,36(r16)
 100e74c:	e00d883a 	mov	r6,fp
 100e750:	a809883a 	mov	r4,r21
 100e754:	103ee83a 	callr	r2
 100e758:	00bfdb16 	blt	zero,r2,100e6c8 <__alt_data_end+0xff80e6c8>
 100e75c:	8080030b 	ldhu	r2,12(r16)
 100e760:	10801014 	ori	r2,r2,64
 100e764:	8080030d 	sth	r2,12(r16)
 100e768:	00bfffc4 	movi	r2,-1
 100e76c:	003fab06 	br	100e61c <__alt_data_end+0xff80e61c>
 100e770:	0027883a 	mov	r19,zero
 100e774:	0011883a 	mov	r8,zero
 100e778:	0039883a 	mov	fp,zero
 100e77c:	0025883a 	mov	r18,zero
 100e780:	90001f26 	beq	r18,zero,100e800 <__sfvwrite_r+0x29c>
 100e784:	40005a26 	beq	r8,zero,100e8f0 <__sfvwrite_r+0x38c>
 100e788:	982d883a 	mov	r22,r19
 100e78c:	94c0012e 	bgeu	r18,r19,100e794 <__sfvwrite_r+0x230>
 100e790:	902d883a 	mov	r22,r18
 100e794:	81000017 	ldw	r4,0(r16)
 100e798:	80800417 	ldw	r2,16(r16)
 100e79c:	b02f883a 	mov	r23,r22
 100e7a0:	81c00517 	ldw	r7,20(r16)
 100e7a4:	1100032e 	bgeu	r2,r4,100e7b4 <__sfvwrite_r+0x250>
 100e7a8:	80c00217 	ldw	r3,8(r16)
 100e7ac:	38c7883a 	add	r3,r7,r3
 100e7b0:	1d801816 	blt	r3,r22,100e814 <__sfvwrite_r+0x2b0>
 100e7b4:	b1c03e16 	blt	r22,r7,100e8b0 <__sfvwrite_r+0x34c>
 100e7b8:	80800917 	ldw	r2,36(r16)
 100e7bc:	81400717 	ldw	r5,28(r16)
 100e7c0:	e00d883a 	mov	r6,fp
 100e7c4:	da000115 	stw	r8,4(sp)
 100e7c8:	a809883a 	mov	r4,r21
 100e7cc:	103ee83a 	callr	r2
 100e7d0:	102f883a 	mov	r23,r2
 100e7d4:	da000117 	ldw	r8,4(sp)
 100e7d8:	00bfe00e 	bge	zero,r2,100e75c <__alt_data_end+0xff80e75c>
 100e7dc:	9de7c83a 	sub	r19,r19,r23
 100e7e0:	98001f26 	beq	r19,zero,100e860 <__sfvwrite_r+0x2fc>
 100e7e4:	a0800217 	ldw	r2,8(r20)
 100e7e8:	e5f9883a 	add	fp,fp,r23
 100e7ec:	95e5c83a 	sub	r18,r18,r23
 100e7f0:	15efc83a 	sub	r23,r2,r23
 100e7f4:	a5c00215 	stw	r23,8(r20)
 100e7f8:	b83f8726 	beq	r23,zero,100e618 <__alt_data_end+0xff80e618>
 100e7fc:	903fe11e 	bne	r18,zero,100e784 <__alt_data_end+0xff80e784>
 100e800:	8f000017 	ldw	fp,0(r17)
 100e804:	8c800117 	ldw	r18,4(r17)
 100e808:	0011883a 	mov	r8,zero
 100e80c:	8c400204 	addi	r17,r17,8
 100e810:	003fdb06 	br	100e780 <__alt_data_end+0xff80e780>
 100e814:	180d883a 	mov	r6,r3
 100e818:	e00b883a 	mov	r5,fp
 100e81c:	da000115 	stw	r8,4(sp)
 100e820:	d8c00015 	stw	r3,0(sp)
 100e824:	100f7300 	call	100f730 <memmove>
 100e828:	d8c00017 	ldw	r3,0(sp)
 100e82c:	80800017 	ldw	r2,0(r16)
 100e830:	800b883a 	mov	r5,r16
 100e834:	a809883a 	mov	r4,r21
 100e838:	10c5883a 	add	r2,r2,r3
 100e83c:	80800015 	stw	r2,0(r16)
 100e840:	d8c00015 	stw	r3,0(sp)
 100e844:	100dd040 	call	100dd04 <_fflush_r>
 100e848:	d8c00017 	ldw	r3,0(sp)
 100e84c:	da000117 	ldw	r8,4(sp)
 100e850:	103fc21e 	bne	r2,zero,100e75c <__alt_data_end+0xff80e75c>
 100e854:	182f883a 	mov	r23,r3
 100e858:	9de7c83a 	sub	r19,r19,r23
 100e85c:	983fe11e 	bne	r19,zero,100e7e4 <__alt_data_end+0xff80e7e4>
 100e860:	800b883a 	mov	r5,r16
 100e864:	a809883a 	mov	r4,r21
 100e868:	100dd040 	call	100dd04 <_fflush_r>
 100e86c:	103fbb1e 	bne	r2,zero,100e75c <__alt_data_end+0xff80e75c>
 100e870:	0011883a 	mov	r8,zero
 100e874:	003fdb06 	br	100e7e4 <__alt_data_end+0xff80e7e4>
 100e878:	94c0012e 	bgeu	r18,r19,100e880 <__sfvwrite_r+0x31c>
 100e87c:	9027883a 	mov	r19,r18
 100e880:	980d883a 	mov	r6,r19
 100e884:	e00b883a 	mov	r5,fp
 100e888:	100f7300 	call	100f730 <memmove>
 100e88c:	80800217 	ldw	r2,8(r16)
 100e890:	80c00017 	ldw	r3,0(r16)
 100e894:	14c5c83a 	sub	r2,r2,r19
 100e898:	1cc7883a 	add	r3,r3,r19
 100e89c:	80800215 	stw	r2,8(r16)
 100e8a0:	80c00015 	stw	r3,0(r16)
 100e8a4:	10004326 	beq	r2,zero,100e9b4 <__sfvwrite_r+0x450>
 100e8a8:	9805883a 	mov	r2,r19
 100e8ac:	003f8606 	br	100e6c8 <__alt_data_end+0xff80e6c8>
 100e8b0:	b00d883a 	mov	r6,r22
 100e8b4:	e00b883a 	mov	r5,fp
 100e8b8:	da000115 	stw	r8,4(sp)
 100e8bc:	100f7300 	call	100f730 <memmove>
 100e8c0:	80800217 	ldw	r2,8(r16)
 100e8c4:	80c00017 	ldw	r3,0(r16)
 100e8c8:	da000117 	ldw	r8,4(sp)
 100e8cc:	1585c83a 	sub	r2,r2,r22
 100e8d0:	1dad883a 	add	r22,r3,r22
 100e8d4:	80800215 	stw	r2,8(r16)
 100e8d8:	85800015 	stw	r22,0(r16)
 100e8dc:	003fbf06 	br	100e7dc <__alt_data_end+0xff80e7dc>
 100e8e0:	81000017 	ldw	r4,0(r16)
 100e8e4:	9027883a 	mov	r19,r18
 100e8e8:	902f883a 	mov	r23,r18
 100e8ec:	003f6c06 	br	100e6a0 <__alt_data_end+0xff80e6a0>
 100e8f0:	900d883a 	mov	r6,r18
 100e8f4:	01400284 	movi	r5,10
 100e8f8:	e009883a 	mov	r4,fp
 100e8fc:	100f64c0 	call	100f64c <memchr>
 100e900:	10003e26 	beq	r2,zero,100e9fc <__sfvwrite_r+0x498>
 100e904:	10800044 	addi	r2,r2,1
 100e908:	1727c83a 	sub	r19,r2,fp
 100e90c:	02000044 	movi	r8,1
 100e910:	003f9d06 	br	100e788 <__alt_data_end+0xff80e788>
 100e914:	80800517 	ldw	r2,20(r16)
 100e918:	81400417 	ldw	r5,16(r16)
 100e91c:	81c00017 	ldw	r7,0(r16)
 100e920:	10a7883a 	add	r19,r2,r2
 100e924:	9885883a 	add	r2,r19,r2
 100e928:	1026d7fa 	srli	r19,r2,31
 100e92c:	396dc83a 	sub	r22,r7,r5
 100e930:	b1000044 	addi	r4,r22,1
 100e934:	9885883a 	add	r2,r19,r2
 100e938:	1027d07a 	srai	r19,r2,1
 100e93c:	2485883a 	add	r2,r4,r18
 100e940:	980d883a 	mov	r6,r19
 100e944:	9880022e 	bgeu	r19,r2,100e950 <__sfvwrite_r+0x3ec>
 100e948:	1027883a 	mov	r19,r2
 100e94c:	100d883a 	mov	r6,r2
 100e950:	18c1000c 	andi	r3,r3,1024
 100e954:	18001c26 	beq	r3,zero,100e9c8 <__sfvwrite_r+0x464>
 100e958:	300b883a 	mov	r5,r6
 100e95c:	a809883a 	mov	r4,r21
 100e960:	100ee400 	call	100ee40 <_malloc_r>
 100e964:	102f883a 	mov	r23,r2
 100e968:	10002926 	beq	r2,zero,100ea10 <__sfvwrite_r+0x4ac>
 100e96c:	81400417 	ldw	r5,16(r16)
 100e970:	b00d883a 	mov	r6,r22
 100e974:	1009883a 	mov	r4,r2
 100e978:	10099d40 	call	10099d4 <memcpy>
 100e97c:	8080030b 	ldhu	r2,12(r16)
 100e980:	00fedfc4 	movi	r3,-1153
 100e984:	10c4703a 	and	r2,r2,r3
 100e988:	10802014 	ori	r2,r2,128
 100e98c:	8080030d 	sth	r2,12(r16)
 100e990:	bd89883a 	add	r4,r23,r22
 100e994:	9d8fc83a 	sub	r7,r19,r22
 100e998:	85c00415 	stw	r23,16(r16)
 100e99c:	84c00515 	stw	r19,20(r16)
 100e9a0:	81000015 	stw	r4,0(r16)
 100e9a4:	9027883a 	mov	r19,r18
 100e9a8:	81c00215 	stw	r7,8(r16)
 100e9ac:	902f883a 	mov	r23,r18
 100e9b0:	003f3b06 	br	100e6a0 <__alt_data_end+0xff80e6a0>
 100e9b4:	800b883a 	mov	r5,r16
 100e9b8:	a809883a 	mov	r4,r21
 100e9bc:	100dd040 	call	100dd04 <_fflush_r>
 100e9c0:	103fb926 	beq	r2,zero,100e8a8 <__alt_data_end+0xff80e8a8>
 100e9c4:	003f6506 	br	100e75c <__alt_data_end+0xff80e75c>
 100e9c8:	a809883a 	mov	r4,r21
 100e9cc:	10109f00 	call	10109f0 <_realloc_r>
 100e9d0:	102f883a 	mov	r23,r2
 100e9d4:	103fee1e 	bne	r2,zero,100e990 <__alt_data_end+0xff80e990>
 100e9d8:	81400417 	ldw	r5,16(r16)
 100e9dc:	a809883a 	mov	r4,r21
 100e9e0:	100e2540 	call	100e254 <_free_r>
 100e9e4:	8080030b 	ldhu	r2,12(r16)
 100e9e8:	00ffdfc4 	movi	r3,-129
 100e9ec:	1884703a 	and	r2,r3,r2
 100e9f0:	00c00304 	movi	r3,12
 100e9f4:	a8c00015 	stw	r3,0(r21)
 100e9f8:	003f5906 	br	100e760 <__alt_data_end+0xff80e760>
 100e9fc:	94c00044 	addi	r19,r18,1
 100ea00:	02000044 	movi	r8,1
 100ea04:	003f6006 	br	100e788 <__alt_data_end+0xff80e788>
 100ea08:	00bfffc4 	movi	r2,-1
 100ea0c:	003f0306 	br	100e61c <__alt_data_end+0xff80e61c>
 100ea10:	00800304 	movi	r2,12
 100ea14:	a8800015 	stw	r2,0(r21)
 100ea18:	8080030b 	ldhu	r2,12(r16)
 100ea1c:	003f5006 	br	100e760 <__alt_data_end+0xff80e760>

0100ea20 <_fwalk>:
 100ea20:	defff704 	addi	sp,sp,-36
 100ea24:	dd000415 	stw	r20,16(sp)
 100ea28:	dfc00815 	stw	ra,32(sp)
 100ea2c:	ddc00715 	stw	r23,28(sp)
 100ea30:	dd800615 	stw	r22,24(sp)
 100ea34:	dd400515 	stw	r21,20(sp)
 100ea38:	dcc00315 	stw	r19,12(sp)
 100ea3c:	dc800215 	stw	r18,8(sp)
 100ea40:	dc400115 	stw	r17,4(sp)
 100ea44:	dc000015 	stw	r16,0(sp)
 100ea48:	2500b804 	addi	r20,r4,736
 100ea4c:	a0002326 	beq	r20,zero,100eadc <_fwalk+0xbc>
 100ea50:	282b883a 	mov	r21,r5
 100ea54:	002f883a 	mov	r23,zero
 100ea58:	05800044 	movi	r22,1
 100ea5c:	04ffffc4 	movi	r19,-1
 100ea60:	a4400117 	ldw	r17,4(r20)
 100ea64:	a4800217 	ldw	r18,8(r20)
 100ea68:	8c7fffc4 	addi	r17,r17,-1
 100ea6c:	88000d16 	blt	r17,zero,100eaa4 <_fwalk+0x84>
 100ea70:	94000304 	addi	r16,r18,12
 100ea74:	94800384 	addi	r18,r18,14
 100ea78:	8080000b 	ldhu	r2,0(r16)
 100ea7c:	8c7fffc4 	addi	r17,r17,-1
 100ea80:	813ffd04 	addi	r4,r16,-12
 100ea84:	b080042e 	bgeu	r22,r2,100ea98 <_fwalk+0x78>
 100ea88:	9080000f 	ldh	r2,0(r18)
 100ea8c:	14c00226 	beq	r2,r19,100ea98 <_fwalk+0x78>
 100ea90:	a83ee83a 	callr	r21
 100ea94:	b8aeb03a 	or	r23,r23,r2
 100ea98:	84001a04 	addi	r16,r16,104
 100ea9c:	94801a04 	addi	r18,r18,104
 100eaa0:	8cfff51e 	bne	r17,r19,100ea78 <__alt_data_end+0xff80ea78>
 100eaa4:	a5000017 	ldw	r20,0(r20)
 100eaa8:	a03fed1e 	bne	r20,zero,100ea60 <__alt_data_end+0xff80ea60>
 100eaac:	b805883a 	mov	r2,r23
 100eab0:	dfc00817 	ldw	ra,32(sp)
 100eab4:	ddc00717 	ldw	r23,28(sp)
 100eab8:	dd800617 	ldw	r22,24(sp)
 100eabc:	dd400517 	ldw	r21,20(sp)
 100eac0:	dd000417 	ldw	r20,16(sp)
 100eac4:	dcc00317 	ldw	r19,12(sp)
 100eac8:	dc800217 	ldw	r18,8(sp)
 100eacc:	dc400117 	ldw	r17,4(sp)
 100ead0:	dc000017 	ldw	r16,0(sp)
 100ead4:	dec00904 	addi	sp,sp,36
 100ead8:	f800283a 	ret
 100eadc:	002f883a 	mov	r23,zero
 100eae0:	003ff206 	br	100eaac <__alt_data_end+0xff80eaac>

0100eae4 <_fwalk_reent>:
 100eae4:	defff704 	addi	sp,sp,-36
 100eae8:	dd000415 	stw	r20,16(sp)
 100eaec:	dfc00815 	stw	ra,32(sp)
 100eaf0:	ddc00715 	stw	r23,28(sp)
 100eaf4:	dd800615 	stw	r22,24(sp)
 100eaf8:	dd400515 	stw	r21,20(sp)
 100eafc:	dcc00315 	stw	r19,12(sp)
 100eb00:	dc800215 	stw	r18,8(sp)
 100eb04:	dc400115 	stw	r17,4(sp)
 100eb08:	dc000015 	stw	r16,0(sp)
 100eb0c:	2500b804 	addi	r20,r4,736
 100eb10:	a0002326 	beq	r20,zero,100eba0 <_fwalk_reent+0xbc>
 100eb14:	282b883a 	mov	r21,r5
 100eb18:	2027883a 	mov	r19,r4
 100eb1c:	002f883a 	mov	r23,zero
 100eb20:	05800044 	movi	r22,1
 100eb24:	04bfffc4 	movi	r18,-1
 100eb28:	a4400117 	ldw	r17,4(r20)
 100eb2c:	a4000217 	ldw	r16,8(r20)
 100eb30:	8c7fffc4 	addi	r17,r17,-1
 100eb34:	88000c16 	blt	r17,zero,100eb68 <_fwalk_reent+0x84>
 100eb38:	84000304 	addi	r16,r16,12
 100eb3c:	8080000b 	ldhu	r2,0(r16)
 100eb40:	8c7fffc4 	addi	r17,r17,-1
 100eb44:	817ffd04 	addi	r5,r16,-12
 100eb48:	b080052e 	bgeu	r22,r2,100eb60 <_fwalk_reent+0x7c>
 100eb4c:	8080008f 	ldh	r2,2(r16)
 100eb50:	9809883a 	mov	r4,r19
 100eb54:	14800226 	beq	r2,r18,100eb60 <_fwalk_reent+0x7c>
 100eb58:	a83ee83a 	callr	r21
 100eb5c:	b8aeb03a 	or	r23,r23,r2
 100eb60:	84001a04 	addi	r16,r16,104
 100eb64:	8cbff51e 	bne	r17,r18,100eb3c <__alt_data_end+0xff80eb3c>
 100eb68:	a5000017 	ldw	r20,0(r20)
 100eb6c:	a03fee1e 	bne	r20,zero,100eb28 <__alt_data_end+0xff80eb28>
 100eb70:	b805883a 	mov	r2,r23
 100eb74:	dfc00817 	ldw	ra,32(sp)
 100eb78:	ddc00717 	ldw	r23,28(sp)
 100eb7c:	dd800617 	ldw	r22,24(sp)
 100eb80:	dd400517 	ldw	r21,20(sp)
 100eb84:	dd000417 	ldw	r20,16(sp)
 100eb88:	dcc00317 	ldw	r19,12(sp)
 100eb8c:	dc800217 	ldw	r18,8(sp)
 100eb90:	dc400117 	ldw	r17,4(sp)
 100eb94:	dc000017 	ldw	r16,0(sp)
 100eb98:	dec00904 	addi	sp,sp,36
 100eb9c:	f800283a 	ret
 100eba0:	002f883a 	mov	r23,zero
 100eba4:	003ff206 	br	100eb70 <__alt_data_end+0xff80eb70>

0100eba8 <_setlocale_r>:
 100eba8:	30001b26 	beq	r6,zero,100ec18 <_setlocale_r+0x70>
 100ebac:	014040b4 	movhi	r5,258
 100ebb0:	defffe04 	addi	sp,sp,-8
 100ebb4:	296b1304 	addi	r5,r5,-21428
 100ebb8:	3009883a 	mov	r4,r6
 100ebbc:	dc000015 	stw	r16,0(sp)
 100ebc0:	dfc00115 	stw	ra,4(sp)
 100ebc4:	3021883a 	mov	r16,r6
 100ebc8:	10111580 	call	1011158 <strcmp>
 100ebcc:	1000061e 	bne	r2,zero,100ebe8 <_setlocale_r+0x40>
 100ebd0:	008040b4 	movhi	r2,258
 100ebd4:	10ab1204 	addi	r2,r2,-21432
 100ebd8:	dfc00117 	ldw	ra,4(sp)
 100ebdc:	dc000017 	ldw	r16,0(sp)
 100ebe0:	dec00204 	addi	sp,sp,8
 100ebe4:	f800283a 	ret
 100ebe8:	014040b4 	movhi	r5,258
 100ebec:	296b1204 	addi	r5,r5,-21432
 100ebf0:	8009883a 	mov	r4,r16
 100ebf4:	10111580 	call	1011158 <strcmp>
 100ebf8:	103ff526 	beq	r2,zero,100ebd0 <__alt_data_end+0xff80ebd0>
 100ebfc:	014040b4 	movhi	r5,258
 100ec00:	296afd04 	addi	r5,r5,-21516
 100ec04:	8009883a 	mov	r4,r16
 100ec08:	10111580 	call	1011158 <strcmp>
 100ec0c:	103ff026 	beq	r2,zero,100ebd0 <__alt_data_end+0xff80ebd0>
 100ec10:	0005883a 	mov	r2,zero
 100ec14:	003ff006 	br	100ebd8 <__alt_data_end+0xff80ebd8>
 100ec18:	008040b4 	movhi	r2,258
 100ec1c:	10ab1204 	addi	r2,r2,-21432
 100ec20:	f800283a 	ret

0100ec24 <__locale_charset>:
 100ec24:	008040b4 	movhi	r2,258
 100ec28:	10ad5804 	addi	r2,r2,-19104
 100ec2c:	f800283a 	ret

0100ec30 <__locale_mb_cur_max>:
 100ec30:	008040b4 	movhi	r2,258
 100ec34:	10b39c04 	addi	r2,r2,-12688
 100ec38:	10800017 	ldw	r2,0(r2)
 100ec3c:	f800283a 	ret

0100ec40 <__locale_msgcharset>:
 100ec40:	008040b4 	movhi	r2,258
 100ec44:	10ad5004 	addi	r2,r2,-19136
 100ec48:	f800283a 	ret

0100ec4c <__locale_cjk_lang>:
 100ec4c:	0005883a 	mov	r2,zero
 100ec50:	f800283a 	ret

0100ec54 <_localeconv_r>:
 100ec54:	008040b4 	movhi	r2,258
 100ec58:	10ad6004 	addi	r2,r2,-19072
 100ec5c:	f800283a 	ret

0100ec60 <setlocale>:
 100ec60:	008040b4 	movhi	r2,258
 100ec64:	10b39b04 	addi	r2,r2,-12692
 100ec68:	280d883a 	mov	r6,r5
 100ec6c:	200b883a 	mov	r5,r4
 100ec70:	11000017 	ldw	r4,0(r2)
 100ec74:	100eba81 	jmpi	100eba8 <_setlocale_r>

0100ec78 <localeconv>:
 100ec78:	008040b4 	movhi	r2,258
 100ec7c:	10ad6004 	addi	r2,r2,-19072
 100ec80:	f800283a 	ret

0100ec84 <__smakebuf_r>:
 100ec84:	2880030b 	ldhu	r2,12(r5)
 100ec88:	10c0008c 	andi	r3,r2,2
 100ec8c:	1800411e 	bne	r3,zero,100ed94 <__smakebuf_r+0x110>
 100ec90:	deffec04 	addi	sp,sp,-80
 100ec94:	dc000f15 	stw	r16,60(sp)
 100ec98:	2821883a 	mov	r16,r5
 100ec9c:	2940038f 	ldh	r5,14(r5)
 100eca0:	dc401015 	stw	r17,64(sp)
 100eca4:	dfc01315 	stw	ra,76(sp)
 100eca8:	dcc01215 	stw	r19,72(sp)
 100ecac:	dc801115 	stw	r18,68(sp)
 100ecb0:	2023883a 	mov	r17,r4
 100ecb4:	28001c16 	blt	r5,zero,100ed28 <__smakebuf_r+0xa4>
 100ecb8:	d80d883a 	mov	r6,sp
 100ecbc:	1012e580 	call	1012e58 <_fstat_r>
 100ecc0:	10001816 	blt	r2,zero,100ed24 <__smakebuf_r+0xa0>
 100ecc4:	d8800117 	ldw	r2,4(sp)
 100ecc8:	00e00014 	movui	r3,32768
 100eccc:	10bc000c 	andi	r2,r2,61440
 100ecd0:	14c80020 	cmpeqi	r19,r2,8192
 100ecd4:	10c03726 	beq	r2,r3,100edb4 <__smakebuf_r+0x130>
 100ecd8:	80c0030b 	ldhu	r3,12(r16)
 100ecdc:	18c20014 	ori	r3,r3,2048
 100ece0:	80c0030d 	sth	r3,12(r16)
 100ece4:	00c80004 	movi	r3,8192
 100ece8:	10c0521e 	bne	r2,r3,100ee34 <__smakebuf_r+0x1b0>
 100ecec:	8140038f 	ldh	r5,14(r16)
 100ecf0:	8809883a 	mov	r4,r17
 100ecf4:	1012eb40 	call	1012eb4 <_isatty_r>
 100ecf8:	10004c26 	beq	r2,zero,100ee2c <__smakebuf_r+0x1a8>
 100ecfc:	8080030b 	ldhu	r2,12(r16)
 100ed00:	80c010c4 	addi	r3,r16,67
 100ed04:	80c00015 	stw	r3,0(r16)
 100ed08:	10800054 	ori	r2,r2,1
 100ed0c:	8080030d 	sth	r2,12(r16)
 100ed10:	00800044 	movi	r2,1
 100ed14:	80c00415 	stw	r3,16(r16)
 100ed18:	80800515 	stw	r2,20(r16)
 100ed1c:	04810004 	movi	r18,1024
 100ed20:	00000706 	br	100ed40 <__smakebuf_r+0xbc>
 100ed24:	8080030b 	ldhu	r2,12(r16)
 100ed28:	10c0200c 	andi	r3,r2,128
 100ed2c:	18001f1e 	bne	r3,zero,100edac <__smakebuf_r+0x128>
 100ed30:	04810004 	movi	r18,1024
 100ed34:	10820014 	ori	r2,r2,2048
 100ed38:	8080030d 	sth	r2,12(r16)
 100ed3c:	0027883a 	mov	r19,zero
 100ed40:	900b883a 	mov	r5,r18
 100ed44:	8809883a 	mov	r4,r17
 100ed48:	100ee400 	call	100ee40 <_malloc_r>
 100ed4c:	10002c26 	beq	r2,zero,100ee00 <__smakebuf_r+0x17c>
 100ed50:	80c0030b 	ldhu	r3,12(r16)
 100ed54:	01004074 	movhi	r4,257
 100ed58:	21376604 	addi	r4,r4,-8808
 100ed5c:	89000f15 	stw	r4,60(r17)
 100ed60:	18c02014 	ori	r3,r3,128
 100ed64:	80c0030d 	sth	r3,12(r16)
 100ed68:	80800015 	stw	r2,0(r16)
 100ed6c:	80800415 	stw	r2,16(r16)
 100ed70:	84800515 	stw	r18,20(r16)
 100ed74:	98001a1e 	bne	r19,zero,100ede0 <__smakebuf_r+0x15c>
 100ed78:	dfc01317 	ldw	ra,76(sp)
 100ed7c:	dcc01217 	ldw	r19,72(sp)
 100ed80:	dc801117 	ldw	r18,68(sp)
 100ed84:	dc401017 	ldw	r17,64(sp)
 100ed88:	dc000f17 	ldw	r16,60(sp)
 100ed8c:	dec01404 	addi	sp,sp,80
 100ed90:	f800283a 	ret
 100ed94:	288010c4 	addi	r2,r5,67
 100ed98:	28800015 	stw	r2,0(r5)
 100ed9c:	28800415 	stw	r2,16(r5)
 100eda0:	00800044 	movi	r2,1
 100eda4:	28800515 	stw	r2,20(r5)
 100eda8:	f800283a 	ret
 100edac:	04801004 	movi	r18,64
 100edb0:	003fe006 	br	100ed34 <__alt_data_end+0xff80ed34>
 100edb4:	81000a17 	ldw	r4,40(r16)
 100edb8:	00c04074 	movhi	r3,257
 100edbc:	18c43d04 	addi	r3,r3,4340
 100edc0:	20ffc51e 	bne	r4,r3,100ecd8 <__alt_data_end+0xff80ecd8>
 100edc4:	8080030b 	ldhu	r2,12(r16)
 100edc8:	04810004 	movi	r18,1024
 100edcc:	84801315 	stw	r18,76(r16)
 100edd0:	1484b03a 	or	r2,r2,r18
 100edd4:	8080030d 	sth	r2,12(r16)
 100edd8:	0027883a 	mov	r19,zero
 100eddc:	003fd806 	br	100ed40 <__alt_data_end+0xff80ed40>
 100ede0:	8140038f 	ldh	r5,14(r16)
 100ede4:	8809883a 	mov	r4,r17
 100ede8:	1012eb40 	call	1012eb4 <_isatty_r>
 100edec:	103fe226 	beq	r2,zero,100ed78 <__alt_data_end+0xff80ed78>
 100edf0:	8080030b 	ldhu	r2,12(r16)
 100edf4:	10800054 	ori	r2,r2,1
 100edf8:	8080030d 	sth	r2,12(r16)
 100edfc:	003fde06 	br	100ed78 <__alt_data_end+0xff80ed78>
 100ee00:	8080030b 	ldhu	r2,12(r16)
 100ee04:	10c0800c 	andi	r3,r2,512
 100ee08:	183fdb1e 	bne	r3,zero,100ed78 <__alt_data_end+0xff80ed78>
 100ee0c:	10800094 	ori	r2,r2,2
 100ee10:	80c010c4 	addi	r3,r16,67
 100ee14:	8080030d 	sth	r2,12(r16)
 100ee18:	00800044 	movi	r2,1
 100ee1c:	80c00015 	stw	r3,0(r16)
 100ee20:	80c00415 	stw	r3,16(r16)
 100ee24:	80800515 	stw	r2,20(r16)
 100ee28:	003fd306 	br	100ed78 <__alt_data_end+0xff80ed78>
 100ee2c:	04810004 	movi	r18,1024
 100ee30:	003fc306 	br	100ed40 <__alt_data_end+0xff80ed40>
 100ee34:	0027883a 	mov	r19,zero
 100ee38:	04810004 	movi	r18,1024
 100ee3c:	003fc006 	br	100ed40 <__alt_data_end+0xff80ed40>

0100ee40 <_malloc_r>:
 100ee40:	defff504 	addi	sp,sp,-44
 100ee44:	dc800315 	stw	r18,12(sp)
 100ee48:	dfc00a15 	stw	ra,40(sp)
 100ee4c:	df000915 	stw	fp,36(sp)
 100ee50:	ddc00815 	stw	r23,32(sp)
 100ee54:	dd800715 	stw	r22,28(sp)
 100ee58:	dd400615 	stw	r21,24(sp)
 100ee5c:	dd000515 	stw	r20,20(sp)
 100ee60:	dcc00415 	stw	r19,16(sp)
 100ee64:	dc400215 	stw	r17,8(sp)
 100ee68:	dc000115 	stw	r16,4(sp)
 100ee6c:	288002c4 	addi	r2,r5,11
 100ee70:	00c00584 	movi	r3,22
 100ee74:	2025883a 	mov	r18,r4
 100ee78:	18807f2e 	bgeu	r3,r2,100f078 <_malloc_r+0x238>
 100ee7c:	047ffe04 	movi	r17,-8
 100ee80:	1462703a 	and	r17,r2,r17
 100ee84:	8800a316 	blt	r17,zero,100f114 <_malloc_r+0x2d4>
 100ee88:	8940a236 	bltu	r17,r5,100f114 <_malloc_r+0x2d4>
 100ee8c:	10168a40 	call	10168a4 <__malloc_lock>
 100ee90:	00807dc4 	movi	r2,503
 100ee94:	1441e92e 	bgeu	r2,r17,100f63c <_malloc_r+0x7fc>
 100ee98:	8804d27a 	srli	r2,r17,9
 100ee9c:	1000a126 	beq	r2,zero,100f124 <_malloc_r+0x2e4>
 100eea0:	00c00104 	movi	r3,4
 100eea4:	18811e36 	bltu	r3,r2,100f320 <_malloc_r+0x4e0>
 100eea8:	8804d1ba 	srli	r2,r17,6
 100eeac:	12000e44 	addi	r8,r2,57
 100eeb0:	11c00e04 	addi	r7,r2,56
 100eeb4:	4209883a 	add	r4,r8,r8
 100eeb8:	04c040b4 	movhi	r19,258
 100eebc:	2109883a 	add	r4,r4,r4
 100eec0:	9ced6e04 	addi	r19,r19,-19016
 100eec4:	2109883a 	add	r4,r4,r4
 100eec8:	9909883a 	add	r4,r19,r4
 100eecc:	24000117 	ldw	r16,4(r4)
 100eed0:	213ffe04 	addi	r4,r4,-8
 100eed4:	24009726 	beq	r4,r16,100f134 <_malloc_r+0x2f4>
 100eed8:	80800117 	ldw	r2,4(r16)
 100eedc:	01bfff04 	movi	r6,-4
 100eee0:	014003c4 	movi	r5,15
 100eee4:	1184703a 	and	r2,r2,r6
 100eee8:	1447c83a 	sub	r3,r2,r17
 100eeec:	28c00716 	blt	r5,r3,100ef0c <_malloc_r+0xcc>
 100eef0:	1800920e 	bge	r3,zero,100f13c <_malloc_r+0x2fc>
 100eef4:	84000317 	ldw	r16,12(r16)
 100eef8:	24008e26 	beq	r4,r16,100f134 <_malloc_r+0x2f4>
 100eefc:	80800117 	ldw	r2,4(r16)
 100ef00:	1184703a 	and	r2,r2,r6
 100ef04:	1447c83a 	sub	r3,r2,r17
 100ef08:	28fff90e 	bge	r5,r3,100eef0 <__alt_data_end+0xff80eef0>
 100ef0c:	3809883a 	mov	r4,r7
 100ef10:	018040b4 	movhi	r6,258
 100ef14:	9c000417 	ldw	r16,16(r19)
 100ef18:	31ad6e04 	addi	r6,r6,-19016
 100ef1c:	32000204 	addi	r8,r6,8
 100ef20:	82013426 	beq	r16,r8,100f3f4 <_malloc_r+0x5b4>
 100ef24:	80c00117 	ldw	r3,4(r16)
 100ef28:	00bfff04 	movi	r2,-4
 100ef2c:	188e703a 	and	r7,r3,r2
 100ef30:	3c45c83a 	sub	r2,r7,r17
 100ef34:	00c003c4 	movi	r3,15
 100ef38:	18811f16 	blt	r3,r2,100f3b8 <_malloc_r+0x578>
 100ef3c:	32000515 	stw	r8,20(r6)
 100ef40:	32000415 	stw	r8,16(r6)
 100ef44:	10007f0e 	bge	r2,zero,100f144 <_malloc_r+0x304>
 100ef48:	00807fc4 	movi	r2,511
 100ef4c:	11c0fd36 	bltu	r2,r7,100f344 <_malloc_r+0x504>
 100ef50:	3806d0fa 	srli	r3,r7,3
 100ef54:	01c00044 	movi	r7,1
 100ef58:	30800117 	ldw	r2,4(r6)
 100ef5c:	19400044 	addi	r5,r3,1
 100ef60:	294b883a 	add	r5,r5,r5
 100ef64:	1807d0ba 	srai	r3,r3,2
 100ef68:	294b883a 	add	r5,r5,r5
 100ef6c:	294b883a 	add	r5,r5,r5
 100ef70:	298b883a 	add	r5,r5,r6
 100ef74:	38c6983a 	sll	r3,r7,r3
 100ef78:	29c00017 	ldw	r7,0(r5)
 100ef7c:	2a7ffe04 	addi	r9,r5,-8
 100ef80:	1886b03a 	or	r3,r3,r2
 100ef84:	82400315 	stw	r9,12(r16)
 100ef88:	81c00215 	stw	r7,8(r16)
 100ef8c:	30c00115 	stw	r3,4(r6)
 100ef90:	2c000015 	stw	r16,0(r5)
 100ef94:	3c000315 	stw	r16,12(r7)
 100ef98:	2005d0ba 	srai	r2,r4,2
 100ef9c:	01400044 	movi	r5,1
 100efa0:	288a983a 	sll	r5,r5,r2
 100efa4:	19406f36 	bltu	r3,r5,100f164 <_malloc_r+0x324>
 100efa8:	28c4703a 	and	r2,r5,r3
 100efac:	10000a1e 	bne	r2,zero,100efd8 <_malloc_r+0x198>
 100efb0:	00bfff04 	movi	r2,-4
 100efb4:	294b883a 	add	r5,r5,r5
 100efb8:	2088703a 	and	r4,r4,r2
 100efbc:	28c4703a 	and	r2,r5,r3
 100efc0:	21000104 	addi	r4,r4,4
 100efc4:	1000041e 	bne	r2,zero,100efd8 <_malloc_r+0x198>
 100efc8:	294b883a 	add	r5,r5,r5
 100efcc:	28c4703a 	and	r2,r5,r3
 100efd0:	21000104 	addi	r4,r4,4
 100efd4:	103ffc26 	beq	r2,zero,100efc8 <__alt_data_end+0xff80efc8>
 100efd8:	02bfff04 	movi	r10,-4
 100efdc:	024003c4 	movi	r9,15
 100efe0:	21800044 	addi	r6,r4,1
 100efe4:	318d883a 	add	r6,r6,r6
 100efe8:	318d883a 	add	r6,r6,r6
 100efec:	318d883a 	add	r6,r6,r6
 100eff0:	998d883a 	add	r6,r19,r6
 100eff4:	333ffe04 	addi	r12,r6,-8
 100eff8:	2017883a 	mov	r11,r4
 100effc:	31800104 	addi	r6,r6,4
 100f000:	34000017 	ldw	r16,0(r6)
 100f004:	31fffd04 	addi	r7,r6,-12
 100f008:	81c0041e 	bne	r16,r7,100f01c <_malloc_r+0x1dc>
 100f00c:	0000fb06 	br	100f3fc <_malloc_r+0x5bc>
 100f010:	1801030e 	bge	r3,zero,100f420 <_malloc_r+0x5e0>
 100f014:	84000317 	ldw	r16,12(r16)
 100f018:	81c0f826 	beq	r16,r7,100f3fc <_malloc_r+0x5bc>
 100f01c:	80800117 	ldw	r2,4(r16)
 100f020:	1284703a 	and	r2,r2,r10
 100f024:	1447c83a 	sub	r3,r2,r17
 100f028:	48fff90e 	bge	r9,r3,100f010 <__alt_data_end+0xff80f010>
 100f02c:	80800317 	ldw	r2,12(r16)
 100f030:	81000217 	ldw	r4,8(r16)
 100f034:	89400054 	ori	r5,r17,1
 100f038:	81400115 	stw	r5,4(r16)
 100f03c:	20800315 	stw	r2,12(r4)
 100f040:	11000215 	stw	r4,8(r2)
 100f044:	8463883a 	add	r17,r16,r17
 100f048:	9c400515 	stw	r17,20(r19)
 100f04c:	9c400415 	stw	r17,16(r19)
 100f050:	18800054 	ori	r2,r3,1
 100f054:	88800115 	stw	r2,4(r17)
 100f058:	8a000315 	stw	r8,12(r17)
 100f05c:	8a000215 	stw	r8,8(r17)
 100f060:	88e3883a 	add	r17,r17,r3
 100f064:	88c00015 	stw	r3,0(r17)
 100f068:	9009883a 	mov	r4,r18
 100f06c:	10168c80 	call	10168c8 <__malloc_unlock>
 100f070:	80800204 	addi	r2,r16,8
 100f074:	00001b06 	br	100f0e4 <_malloc_r+0x2a4>
 100f078:	04400404 	movi	r17,16
 100f07c:	89402536 	bltu	r17,r5,100f114 <_malloc_r+0x2d4>
 100f080:	10168a40 	call	10168a4 <__malloc_lock>
 100f084:	00800184 	movi	r2,6
 100f088:	01000084 	movi	r4,2
 100f08c:	04c040b4 	movhi	r19,258
 100f090:	1085883a 	add	r2,r2,r2
 100f094:	9ced6e04 	addi	r19,r19,-19016
 100f098:	1085883a 	add	r2,r2,r2
 100f09c:	9885883a 	add	r2,r19,r2
 100f0a0:	14000117 	ldw	r16,4(r2)
 100f0a4:	10fffe04 	addi	r3,r2,-8
 100f0a8:	80c0d926 	beq	r16,r3,100f410 <_malloc_r+0x5d0>
 100f0ac:	80c00117 	ldw	r3,4(r16)
 100f0b0:	81000317 	ldw	r4,12(r16)
 100f0b4:	00bfff04 	movi	r2,-4
 100f0b8:	1884703a 	and	r2,r3,r2
 100f0bc:	81400217 	ldw	r5,8(r16)
 100f0c0:	8085883a 	add	r2,r16,r2
 100f0c4:	10c00117 	ldw	r3,4(r2)
 100f0c8:	29000315 	stw	r4,12(r5)
 100f0cc:	21400215 	stw	r5,8(r4)
 100f0d0:	18c00054 	ori	r3,r3,1
 100f0d4:	10c00115 	stw	r3,4(r2)
 100f0d8:	9009883a 	mov	r4,r18
 100f0dc:	10168c80 	call	10168c8 <__malloc_unlock>
 100f0e0:	80800204 	addi	r2,r16,8
 100f0e4:	dfc00a17 	ldw	ra,40(sp)
 100f0e8:	df000917 	ldw	fp,36(sp)
 100f0ec:	ddc00817 	ldw	r23,32(sp)
 100f0f0:	dd800717 	ldw	r22,28(sp)
 100f0f4:	dd400617 	ldw	r21,24(sp)
 100f0f8:	dd000517 	ldw	r20,20(sp)
 100f0fc:	dcc00417 	ldw	r19,16(sp)
 100f100:	dc800317 	ldw	r18,12(sp)
 100f104:	dc400217 	ldw	r17,8(sp)
 100f108:	dc000117 	ldw	r16,4(sp)
 100f10c:	dec00b04 	addi	sp,sp,44
 100f110:	f800283a 	ret
 100f114:	00800304 	movi	r2,12
 100f118:	90800015 	stw	r2,0(r18)
 100f11c:	0005883a 	mov	r2,zero
 100f120:	003ff006 	br	100f0e4 <__alt_data_end+0xff80f0e4>
 100f124:	01002004 	movi	r4,128
 100f128:	02001004 	movi	r8,64
 100f12c:	01c00fc4 	movi	r7,63
 100f130:	003f6106 	br	100eeb8 <__alt_data_end+0xff80eeb8>
 100f134:	4009883a 	mov	r4,r8
 100f138:	003f7506 	br	100ef10 <__alt_data_end+0xff80ef10>
 100f13c:	81000317 	ldw	r4,12(r16)
 100f140:	003fde06 	br	100f0bc <__alt_data_end+0xff80f0bc>
 100f144:	81c5883a 	add	r2,r16,r7
 100f148:	11400117 	ldw	r5,4(r2)
 100f14c:	9009883a 	mov	r4,r18
 100f150:	29400054 	ori	r5,r5,1
 100f154:	11400115 	stw	r5,4(r2)
 100f158:	10168c80 	call	10168c8 <__malloc_unlock>
 100f15c:	80800204 	addi	r2,r16,8
 100f160:	003fe006 	br	100f0e4 <__alt_data_end+0xff80f0e4>
 100f164:	9c000217 	ldw	r16,8(r19)
 100f168:	00bfff04 	movi	r2,-4
 100f16c:	85800117 	ldw	r22,4(r16)
 100f170:	b0ac703a 	and	r22,r22,r2
 100f174:	b4400336 	bltu	r22,r17,100f184 <_malloc_r+0x344>
 100f178:	b445c83a 	sub	r2,r22,r17
 100f17c:	00c003c4 	movi	r3,15
 100f180:	18805d16 	blt	r3,r2,100f2f8 <_malloc_r+0x4b8>
 100f184:	05c040b4 	movhi	r23,258
 100f188:	008040b4 	movhi	r2,258
 100f18c:	10b42604 	addi	r2,r2,-12136
 100f190:	bdf39d04 	addi	r23,r23,-12684
 100f194:	15400017 	ldw	r21,0(r2)
 100f198:	b8c00017 	ldw	r3,0(r23)
 100f19c:	00bfffc4 	movi	r2,-1
 100f1a0:	858d883a 	add	r6,r16,r22
 100f1a4:	8d6b883a 	add	r21,r17,r21
 100f1a8:	1880ea26 	beq	r3,r2,100f554 <_malloc_r+0x714>
 100f1ac:	ad4403c4 	addi	r21,r21,4111
 100f1b0:	00bc0004 	movi	r2,-4096
 100f1b4:	a8aa703a 	and	r21,r21,r2
 100f1b8:	a80b883a 	mov	r5,r21
 100f1bc:	9009883a 	mov	r4,r18
 100f1c0:	d9800015 	stw	r6,0(sp)
 100f1c4:	1010fc80 	call	1010fc8 <_sbrk_r>
 100f1c8:	1029883a 	mov	r20,r2
 100f1cc:	00bfffc4 	movi	r2,-1
 100f1d0:	d9800017 	ldw	r6,0(sp)
 100f1d4:	a080e826 	beq	r20,r2,100f578 <_malloc_r+0x738>
 100f1d8:	a180a636 	bltu	r20,r6,100f474 <_malloc_r+0x634>
 100f1dc:	07005cf4 	movhi	fp,371
 100f1e0:	e729d704 	addi	fp,fp,-22692
 100f1e4:	e0800017 	ldw	r2,0(fp)
 100f1e8:	a887883a 	add	r3,r21,r2
 100f1ec:	e0c00015 	stw	r3,0(fp)
 100f1f0:	3500e626 	beq	r6,r20,100f58c <_malloc_r+0x74c>
 100f1f4:	b9000017 	ldw	r4,0(r23)
 100f1f8:	00bfffc4 	movi	r2,-1
 100f1fc:	2080ee26 	beq	r4,r2,100f5b8 <_malloc_r+0x778>
 100f200:	a185c83a 	sub	r2,r20,r6
 100f204:	10c5883a 	add	r2,r2,r3
 100f208:	e0800015 	stw	r2,0(fp)
 100f20c:	a0c001cc 	andi	r3,r20,7
 100f210:	1800bc26 	beq	r3,zero,100f504 <_malloc_r+0x6c4>
 100f214:	a0e9c83a 	sub	r20,r20,r3
 100f218:	00840204 	movi	r2,4104
 100f21c:	a5000204 	addi	r20,r20,8
 100f220:	10c7c83a 	sub	r3,r2,r3
 100f224:	a545883a 	add	r2,r20,r21
 100f228:	1083ffcc 	andi	r2,r2,4095
 100f22c:	18abc83a 	sub	r21,r3,r2
 100f230:	a80b883a 	mov	r5,r21
 100f234:	9009883a 	mov	r4,r18
 100f238:	1010fc80 	call	1010fc8 <_sbrk_r>
 100f23c:	00ffffc4 	movi	r3,-1
 100f240:	10c0e126 	beq	r2,r3,100f5c8 <_malloc_r+0x788>
 100f244:	1505c83a 	sub	r2,r2,r20
 100f248:	1545883a 	add	r2,r2,r21
 100f24c:	10800054 	ori	r2,r2,1
 100f250:	e0c00017 	ldw	r3,0(fp)
 100f254:	9d000215 	stw	r20,8(r19)
 100f258:	a0800115 	stw	r2,4(r20)
 100f25c:	a8c7883a 	add	r3,r21,r3
 100f260:	e0c00015 	stw	r3,0(fp)
 100f264:	84c00e26 	beq	r16,r19,100f2a0 <_malloc_r+0x460>
 100f268:	018003c4 	movi	r6,15
 100f26c:	3580a72e 	bgeu	r6,r22,100f50c <_malloc_r+0x6cc>
 100f270:	81400117 	ldw	r5,4(r16)
 100f274:	013ffe04 	movi	r4,-8
 100f278:	b0bffd04 	addi	r2,r22,-12
 100f27c:	1104703a 	and	r2,r2,r4
 100f280:	2900004c 	andi	r4,r5,1
 100f284:	2088b03a 	or	r4,r4,r2
 100f288:	81000115 	stw	r4,4(r16)
 100f28c:	01400144 	movi	r5,5
 100f290:	8089883a 	add	r4,r16,r2
 100f294:	21400115 	stw	r5,4(r4)
 100f298:	21400215 	stw	r5,8(r4)
 100f29c:	3080cd36 	bltu	r6,r2,100f5d4 <_malloc_r+0x794>
 100f2a0:	008040b4 	movhi	r2,258
 100f2a4:	10b42504 	addi	r2,r2,-12140
 100f2a8:	11000017 	ldw	r4,0(r2)
 100f2ac:	20c0012e 	bgeu	r4,r3,100f2b4 <_malloc_r+0x474>
 100f2b0:	10c00015 	stw	r3,0(r2)
 100f2b4:	008040b4 	movhi	r2,258
 100f2b8:	10b42404 	addi	r2,r2,-12144
 100f2bc:	11000017 	ldw	r4,0(r2)
 100f2c0:	9c000217 	ldw	r16,8(r19)
 100f2c4:	20c0012e 	bgeu	r4,r3,100f2cc <_malloc_r+0x48c>
 100f2c8:	10c00015 	stw	r3,0(r2)
 100f2cc:	80c00117 	ldw	r3,4(r16)
 100f2d0:	00bfff04 	movi	r2,-4
 100f2d4:	1886703a 	and	r3,r3,r2
 100f2d8:	1c45c83a 	sub	r2,r3,r17
 100f2dc:	1c400236 	bltu	r3,r17,100f2e8 <_malloc_r+0x4a8>
 100f2e0:	00c003c4 	movi	r3,15
 100f2e4:	18800416 	blt	r3,r2,100f2f8 <_malloc_r+0x4b8>
 100f2e8:	9009883a 	mov	r4,r18
 100f2ec:	10168c80 	call	10168c8 <__malloc_unlock>
 100f2f0:	0005883a 	mov	r2,zero
 100f2f4:	003f7b06 	br	100f0e4 <__alt_data_end+0xff80f0e4>
 100f2f8:	88c00054 	ori	r3,r17,1
 100f2fc:	80c00115 	stw	r3,4(r16)
 100f300:	8463883a 	add	r17,r16,r17
 100f304:	10800054 	ori	r2,r2,1
 100f308:	9c400215 	stw	r17,8(r19)
 100f30c:	88800115 	stw	r2,4(r17)
 100f310:	9009883a 	mov	r4,r18
 100f314:	10168c80 	call	10168c8 <__malloc_unlock>
 100f318:	80800204 	addi	r2,r16,8
 100f31c:	003f7106 	br	100f0e4 <__alt_data_end+0xff80f0e4>
 100f320:	00c00504 	movi	r3,20
 100f324:	18804a2e 	bgeu	r3,r2,100f450 <_malloc_r+0x610>
 100f328:	00c01504 	movi	r3,84
 100f32c:	18806e36 	bltu	r3,r2,100f4e8 <_malloc_r+0x6a8>
 100f330:	8804d33a 	srli	r2,r17,12
 100f334:	12001bc4 	addi	r8,r2,111
 100f338:	11c01b84 	addi	r7,r2,110
 100f33c:	4209883a 	add	r4,r8,r8
 100f340:	003edd06 	br	100eeb8 <__alt_data_end+0xff80eeb8>
 100f344:	3804d27a 	srli	r2,r7,9
 100f348:	00c00104 	movi	r3,4
 100f34c:	1880442e 	bgeu	r3,r2,100f460 <_malloc_r+0x620>
 100f350:	00c00504 	movi	r3,20
 100f354:	18808136 	bltu	r3,r2,100f55c <_malloc_r+0x71c>
 100f358:	11401704 	addi	r5,r2,92
 100f35c:	10c016c4 	addi	r3,r2,91
 100f360:	294b883a 	add	r5,r5,r5
 100f364:	294b883a 	add	r5,r5,r5
 100f368:	294b883a 	add	r5,r5,r5
 100f36c:	994b883a 	add	r5,r19,r5
 100f370:	28800017 	ldw	r2,0(r5)
 100f374:	018040b4 	movhi	r6,258
 100f378:	297ffe04 	addi	r5,r5,-8
 100f37c:	31ad6e04 	addi	r6,r6,-19016
 100f380:	28806526 	beq	r5,r2,100f518 <_malloc_r+0x6d8>
 100f384:	01bfff04 	movi	r6,-4
 100f388:	10c00117 	ldw	r3,4(r2)
 100f38c:	1986703a 	and	r3,r3,r6
 100f390:	38c0022e 	bgeu	r7,r3,100f39c <_malloc_r+0x55c>
 100f394:	10800217 	ldw	r2,8(r2)
 100f398:	28bffb1e 	bne	r5,r2,100f388 <__alt_data_end+0xff80f388>
 100f39c:	11400317 	ldw	r5,12(r2)
 100f3a0:	98c00117 	ldw	r3,4(r19)
 100f3a4:	81400315 	stw	r5,12(r16)
 100f3a8:	80800215 	stw	r2,8(r16)
 100f3ac:	2c000215 	stw	r16,8(r5)
 100f3b0:	14000315 	stw	r16,12(r2)
 100f3b4:	003ef806 	br	100ef98 <__alt_data_end+0xff80ef98>
 100f3b8:	88c00054 	ori	r3,r17,1
 100f3bc:	80c00115 	stw	r3,4(r16)
 100f3c0:	8463883a 	add	r17,r16,r17
 100f3c4:	34400515 	stw	r17,20(r6)
 100f3c8:	34400415 	stw	r17,16(r6)
 100f3cc:	10c00054 	ori	r3,r2,1
 100f3d0:	8a000315 	stw	r8,12(r17)
 100f3d4:	8a000215 	stw	r8,8(r17)
 100f3d8:	88c00115 	stw	r3,4(r17)
 100f3dc:	88a3883a 	add	r17,r17,r2
 100f3e0:	88800015 	stw	r2,0(r17)
 100f3e4:	9009883a 	mov	r4,r18
 100f3e8:	10168c80 	call	10168c8 <__malloc_unlock>
 100f3ec:	80800204 	addi	r2,r16,8
 100f3f0:	003f3c06 	br	100f0e4 <__alt_data_end+0xff80f0e4>
 100f3f4:	30c00117 	ldw	r3,4(r6)
 100f3f8:	003ee706 	br	100ef98 <__alt_data_end+0xff80ef98>
 100f3fc:	5ac00044 	addi	r11,r11,1
 100f400:	588000cc 	andi	r2,r11,3
 100f404:	31800204 	addi	r6,r6,8
 100f408:	103efd1e 	bne	r2,zero,100f000 <__alt_data_end+0xff80f000>
 100f40c:	00002406 	br	100f4a0 <_malloc_r+0x660>
 100f410:	14000317 	ldw	r16,12(r2)
 100f414:	143f251e 	bne	r2,r16,100f0ac <__alt_data_end+0xff80f0ac>
 100f418:	21000084 	addi	r4,r4,2
 100f41c:	003ebc06 	br	100ef10 <__alt_data_end+0xff80ef10>
 100f420:	8085883a 	add	r2,r16,r2
 100f424:	10c00117 	ldw	r3,4(r2)
 100f428:	81000317 	ldw	r4,12(r16)
 100f42c:	81400217 	ldw	r5,8(r16)
 100f430:	18c00054 	ori	r3,r3,1
 100f434:	10c00115 	stw	r3,4(r2)
 100f438:	29000315 	stw	r4,12(r5)
 100f43c:	21400215 	stw	r5,8(r4)
 100f440:	9009883a 	mov	r4,r18
 100f444:	10168c80 	call	10168c8 <__malloc_unlock>
 100f448:	80800204 	addi	r2,r16,8
 100f44c:	003f2506 	br	100f0e4 <__alt_data_end+0xff80f0e4>
 100f450:	12001704 	addi	r8,r2,92
 100f454:	11c016c4 	addi	r7,r2,91
 100f458:	4209883a 	add	r4,r8,r8
 100f45c:	003e9606 	br	100eeb8 <__alt_data_end+0xff80eeb8>
 100f460:	3804d1ba 	srli	r2,r7,6
 100f464:	11400e44 	addi	r5,r2,57
 100f468:	10c00e04 	addi	r3,r2,56
 100f46c:	294b883a 	add	r5,r5,r5
 100f470:	003fbc06 	br	100f364 <__alt_data_end+0xff80f364>
 100f474:	84ff5926 	beq	r16,r19,100f1dc <__alt_data_end+0xff80f1dc>
 100f478:	008040b4 	movhi	r2,258
 100f47c:	10ad6e04 	addi	r2,r2,-19016
 100f480:	14000217 	ldw	r16,8(r2)
 100f484:	00bfff04 	movi	r2,-4
 100f488:	80c00117 	ldw	r3,4(r16)
 100f48c:	1886703a 	and	r3,r3,r2
 100f490:	003f9106 	br	100f2d8 <__alt_data_end+0xff80f2d8>
 100f494:	60800217 	ldw	r2,8(r12)
 100f498:	213fffc4 	addi	r4,r4,-1
 100f49c:	1300651e 	bne	r2,r12,100f634 <_malloc_r+0x7f4>
 100f4a0:	208000cc 	andi	r2,r4,3
 100f4a4:	633ffe04 	addi	r12,r12,-8
 100f4a8:	103ffa1e 	bne	r2,zero,100f494 <__alt_data_end+0xff80f494>
 100f4ac:	98800117 	ldw	r2,4(r19)
 100f4b0:	0146303a 	nor	r3,zero,r5
 100f4b4:	1884703a 	and	r2,r3,r2
 100f4b8:	98800115 	stw	r2,4(r19)
 100f4bc:	294b883a 	add	r5,r5,r5
 100f4c0:	117f2836 	bltu	r2,r5,100f164 <__alt_data_end+0xff80f164>
 100f4c4:	283f2726 	beq	r5,zero,100f164 <__alt_data_end+0xff80f164>
 100f4c8:	2886703a 	and	r3,r5,r2
 100f4cc:	5809883a 	mov	r4,r11
 100f4d0:	183ec31e 	bne	r3,zero,100efe0 <__alt_data_end+0xff80efe0>
 100f4d4:	294b883a 	add	r5,r5,r5
 100f4d8:	2886703a 	and	r3,r5,r2
 100f4dc:	21000104 	addi	r4,r4,4
 100f4e0:	183ffc26 	beq	r3,zero,100f4d4 <__alt_data_end+0xff80f4d4>
 100f4e4:	003ebe06 	br	100efe0 <__alt_data_end+0xff80efe0>
 100f4e8:	00c05504 	movi	r3,340
 100f4ec:	18801236 	bltu	r3,r2,100f538 <_malloc_r+0x6f8>
 100f4f0:	8804d3fa 	srli	r2,r17,15
 100f4f4:	12001e04 	addi	r8,r2,120
 100f4f8:	11c01dc4 	addi	r7,r2,119
 100f4fc:	4209883a 	add	r4,r8,r8
 100f500:	003e6d06 	br	100eeb8 <__alt_data_end+0xff80eeb8>
 100f504:	00c40004 	movi	r3,4096
 100f508:	003f4606 	br	100f224 <__alt_data_end+0xff80f224>
 100f50c:	00800044 	movi	r2,1
 100f510:	a0800115 	stw	r2,4(r20)
 100f514:	003f7406 	br	100f2e8 <__alt_data_end+0xff80f2e8>
 100f518:	1805d0ba 	srai	r2,r3,2
 100f51c:	01c00044 	movi	r7,1
 100f520:	30c00117 	ldw	r3,4(r6)
 100f524:	388e983a 	sll	r7,r7,r2
 100f528:	2805883a 	mov	r2,r5
 100f52c:	38c6b03a 	or	r3,r7,r3
 100f530:	30c00115 	stw	r3,4(r6)
 100f534:	003f9b06 	br	100f3a4 <__alt_data_end+0xff80f3a4>
 100f538:	00c15504 	movi	r3,1364
 100f53c:	18801a36 	bltu	r3,r2,100f5a8 <_malloc_r+0x768>
 100f540:	8804d4ba 	srli	r2,r17,18
 100f544:	12001f44 	addi	r8,r2,125
 100f548:	11c01f04 	addi	r7,r2,124
 100f54c:	4209883a 	add	r4,r8,r8
 100f550:	003e5906 	br	100eeb8 <__alt_data_end+0xff80eeb8>
 100f554:	ad400404 	addi	r21,r21,16
 100f558:	003f1706 	br	100f1b8 <__alt_data_end+0xff80f1b8>
 100f55c:	00c01504 	movi	r3,84
 100f560:	18802336 	bltu	r3,r2,100f5f0 <_malloc_r+0x7b0>
 100f564:	3804d33a 	srli	r2,r7,12
 100f568:	11401bc4 	addi	r5,r2,111
 100f56c:	10c01b84 	addi	r3,r2,110
 100f570:	294b883a 	add	r5,r5,r5
 100f574:	003f7b06 	br	100f364 <__alt_data_end+0xff80f364>
 100f578:	9c000217 	ldw	r16,8(r19)
 100f57c:	00bfff04 	movi	r2,-4
 100f580:	80c00117 	ldw	r3,4(r16)
 100f584:	1886703a 	and	r3,r3,r2
 100f588:	003f5306 	br	100f2d8 <__alt_data_end+0xff80f2d8>
 100f58c:	3083ffcc 	andi	r2,r6,4095
 100f590:	103f181e 	bne	r2,zero,100f1f4 <__alt_data_end+0xff80f1f4>
 100f594:	99000217 	ldw	r4,8(r19)
 100f598:	b545883a 	add	r2,r22,r21
 100f59c:	10800054 	ori	r2,r2,1
 100f5a0:	20800115 	stw	r2,4(r4)
 100f5a4:	003f3e06 	br	100f2a0 <__alt_data_end+0xff80f2a0>
 100f5a8:	01003f84 	movi	r4,254
 100f5ac:	02001fc4 	movi	r8,127
 100f5b0:	01c01f84 	movi	r7,126
 100f5b4:	003e4006 	br	100eeb8 <__alt_data_end+0xff80eeb8>
 100f5b8:	008040b4 	movhi	r2,258
 100f5bc:	10b39d04 	addi	r2,r2,-12684
 100f5c0:	15000015 	stw	r20,0(r2)
 100f5c4:	003f1106 	br	100f20c <__alt_data_end+0xff80f20c>
 100f5c8:	00800044 	movi	r2,1
 100f5cc:	002b883a 	mov	r21,zero
 100f5d0:	003f1f06 	br	100f250 <__alt_data_end+0xff80f250>
 100f5d4:	81400204 	addi	r5,r16,8
 100f5d8:	9009883a 	mov	r4,r18
 100f5dc:	100e2540 	call	100e254 <_free_r>
 100f5e0:	00805cf4 	movhi	r2,371
 100f5e4:	10a9d704 	addi	r2,r2,-22692
 100f5e8:	10c00017 	ldw	r3,0(r2)
 100f5ec:	003f2c06 	br	100f2a0 <__alt_data_end+0xff80f2a0>
 100f5f0:	00c05504 	movi	r3,340
 100f5f4:	18800536 	bltu	r3,r2,100f60c <_malloc_r+0x7cc>
 100f5f8:	3804d3fa 	srli	r2,r7,15
 100f5fc:	11401e04 	addi	r5,r2,120
 100f600:	10c01dc4 	addi	r3,r2,119
 100f604:	294b883a 	add	r5,r5,r5
 100f608:	003f5606 	br	100f364 <__alt_data_end+0xff80f364>
 100f60c:	00c15504 	movi	r3,1364
 100f610:	18800536 	bltu	r3,r2,100f628 <_malloc_r+0x7e8>
 100f614:	3804d4ba 	srli	r2,r7,18
 100f618:	11401f44 	addi	r5,r2,125
 100f61c:	10c01f04 	addi	r3,r2,124
 100f620:	294b883a 	add	r5,r5,r5
 100f624:	003f4f06 	br	100f364 <__alt_data_end+0xff80f364>
 100f628:	01403f84 	movi	r5,254
 100f62c:	00c01f84 	movi	r3,126
 100f630:	003f4c06 	br	100f364 <__alt_data_end+0xff80f364>
 100f634:	98800117 	ldw	r2,4(r19)
 100f638:	003fa006 	br	100f4bc <__alt_data_end+0xff80f4bc>
 100f63c:	8808d0fa 	srli	r4,r17,3
 100f640:	20800044 	addi	r2,r4,1
 100f644:	1085883a 	add	r2,r2,r2
 100f648:	003e9006 	br	100f08c <__alt_data_end+0xff80f08c>

0100f64c <memchr>:
 100f64c:	208000cc 	andi	r2,r4,3
 100f650:	280f883a 	mov	r7,r5
 100f654:	10003426 	beq	r2,zero,100f728 <memchr+0xdc>
 100f658:	30bfffc4 	addi	r2,r6,-1
 100f65c:	30001a26 	beq	r6,zero,100f6c8 <memchr+0x7c>
 100f660:	20c00003 	ldbu	r3,0(r4)
 100f664:	29803fcc 	andi	r6,r5,255
 100f668:	30c0051e 	bne	r6,r3,100f680 <memchr+0x34>
 100f66c:	00001806 	br	100f6d0 <memchr+0x84>
 100f670:	10001526 	beq	r2,zero,100f6c8 <memchr+0x7c>
 100f674:	20c00003 	ldbu	r3,0(r4)
 100f678:	10bfffc4 	addi	r2,r2,-1
 100f67c:	30c01426 	beq	r6,r3,100f6d0 <memchr+0x84>
 100f680:	21000044 	addi	r4,r4,1
 100f684:	20c000cc 	andi	r3,r4,3
 100f688:	183ff91e 	bne	r3,zero,100f670 <__alt_data_end+0xff80f670>
 100f68c:	020000c4 	movi	r8,3
 100f690:	40801136 	bltu	r8,r2,100f6d8 <memchr+0x8c>
 100f694:	10000c26 	beq	r2,zero,100f6c8 <memchr+0x7c>
 100f698:	20c00003 	ldbu	r3,0(r4)
 100f69c:	29403fcc 	andi	r5,r5,255
 100f6a0:	28c00b26 	beq	r5,r3,100f6d0 <memchr+0x84>
 100f6a4:	20c00044 	addi	r3,r4,1
 100f6a8:	39803fcc 	andi	r6,r7,255
 100f6ac:	2089883a 	add	r4,r4,r2
 100f6b0:	00000306 	br	100f6c0 <memchr+0x74>
 100f6b4:	18c00044 	addi	r3,r3,1
 100f6b8:	197fffc3 	ldbu	r5,-1(r3)
 100f6bc:	31400526 	beq	r6,r5,100f6d4 <memchr+0x88>
 100f6c0:	1805883a 	mov	r2,r3
 100f6c4:	20fffb1e 	bne	r4,r3,100f6b4 <__alt_data_end+0xff80f6b4>
 100f6c8:	0005883a 	mov	r2,zero
 100f6cc:	f800283a 	ret
 100f6d0:	2005883a 	mov	r2,r4
 100f6d4:	f800283a 	ret
 100f6d8:	28c03fcc 	andi	r3,r5,255
 100f6dc:	1812923a 	slli	r9,r3,8
 100f6e0:	02ffbff4 	movhi	r11,65279
 100f6e4:	02a02074 	movhi	r10,32897
 100f6e8:	48d2b03a 	or	r9,r9,r3
 100f6ec:	4806943a 	slli	r3,r9,16
 100f6f0:	5affbfc4 	addi	r11,r11,-257
 100f6f4:	52a02004 	addi	r10,r10,-32640
 100f6f8:	48d2b03a 	or	r9,r9,r3
 100f6fc:	20c00017 	ldw	r3,0(r4)
 100f700:	48c6f03a 	xor	r3,r9,r3
 100f704:	1acd883a 	add	r6,r3,r11
 100f708:	00c6303a 	nor	r3,zero,r3
 100f70c:	30c6703a 	and	r3,r6,r3
 100f710:	1a86703a 	and	r3,r3,r10
 100f714:	183fe01e 	bne	r3,zero,100f698 <__alt_data_end+0xff80f698>
 100f718:	10bfff04 	addi	r2,r2,-4
 100f71c:	21000104 	addi	r4,r4,4
 100f720:	40bff636 	bltu	r8,r2,100f6fc <__alt_data_end+0xff80f6fc>
 100f724:	003fdb06 	br	100f694 <__alt_data_end+0xff80f694>
 100f728:	3005883a 	mov	r2,r6
 100f72c:	003fd706 	br	100f68c <__alt_data_end+0xff80f68c>

0100f730 <memmove>:
 100f730:	2005883a 	mov	r2,r4
 100f734:	29000b2e 	bgeu	r5,r4,100f764 <memmove+0x34>
 100f738:	298f883a 	add	r7,r5,r6
 100f73c:	21c0092e 	bgeu	r4,r7,100f764 <memmove+0x34>
 100f740:	2187883a 	add	r3,r4,r6
 100f744:	198bc83a 	sub	r5,r3,r6
 100f748:	30004826 	beq	r6,zero,100f86c <memmove+0x13c>
 100f74c:	39ffffc4 	addi	r7,r7,-1
 100f750:	39000003 	ldbu	r4,0(r7)
 100f754:	18ffffc4 	addi	r3,r3,-1
 100f758:	19000005 	stb	r4,0(r3)
 100f75c:	28fffb1e 	bne	r5,r3,100f74c <__alt_data_end+0xff80f74c>
 100f760:	f800283a 	ret
 100f764:	00c003c4 	movi	r3,15
 100f768:	1980412e 	bgeu	r3,r6,100f870 <memmove+0x140>
 100f76c:	2886b03a 	or	r3,r5,r2
 100f770:	18c000cc 	andi	r3,r3,3
 100f774:	1800401e 	bne	r3,zero,100f878 <memmove+0x148>
 100f778:	33fffc04 	addi	r15,r6,-16
 100f77c:	781ed13a 	srli	r15,r15,4
 100f780:	28c00104 	addi	r3,r5,4
 100f784:	13400104 	addi	r13,r2,4
 100f788:	781c913a 	slli	r14,r15,4
 100f78c:	2b000204 	addi	r12,r5,8
 100f790:	12c00204 	addi	r11,r2,8
 100f794:	73800504 	addi	r14,r14,20
 100f798:	2a800304 	addi	r10,r5,12
 100f79c:	12400304 	addi	r9,r2,12
 100f7a0:	2b9d883a 	add	r14,r5,r14
 100f7a4:	2811883a 	mov	r8,r5
 100f7a8:	100f883a 	mov	r7,r2
 100f7ac:	41000017 	ldw	r4,0(r8)
 100f7b0:	39c00404 	addi	r7,r7,16
 100f7b4:	18c00404 	addi	r3,r3,16
 100f7b8:	393ffc15 	stw	r4,-16(r7)
 100f7bc:	193ffc17 	ldw	r4,-16(r3)
 100f7c0:	6b400404 	addi	r13,r13,16
 100f7c4:	5ac00404 	addi	r11,r11,16
 100f7c8:	693ffc15 	stw	r4,-16(r13)
 100f7cc:	61000017 	ldw	r4,0(r12)
 100f7d0:	4a400404 	addi	r9,r9,16
 100f7d4:	42000404 	addi	r8,r8,16
 100f7d8:	593ffc15 	stw	r4,-16(r11)
 100f7dc:	51000017 	ldw	r4,0(r10)
 100f7e0:	63000404 	addi	r12,r12,16
 100f7e4:	52800404 	addi	r10,r10,16
 100f7e8:	493ffc15 	stw	r4,-16(r9)
 100f7ec:	1bbfef1e 	bne	r3,r14,100f7ac <__alt_data_end+0xff80f7ac>
 100f7f0:	79000044 	addi	r4,r15,1
 100f7f4:	2008913a 	slli	r4,r4,4
 100f7f8:	328003cc 	andi	r10,r6,15
 100f7fc:	02c000c4 	movi	r11,3
 100f800:	1107883a 	add	r3,r2,r4
 100f804:	290b883a 	add	r5,r5,r4
 100f808:	5a801e2e 	bgeu	r11,r10,100f884 <memmove+0x154>
 100f80c:	1813883a 	mov	r9,r3
 100f810:	2811883a 	mov	r8,r5
 100f814:	500f883a 	mov	r7,r10
 100f818:	41000017 	ldw	r4,0(r8)
 100f81c:	4a400104 	addi	r9,r9,4
 100f820:	39ffff04 	addi	r7,r7,-4
 100f824:	493fff15 	stw	r4,-4(r9)
 100f828:	42000104 	addi	r8,r8,4
 100f82c:	59fffa36 	bltu	r11,r7,100f818 <__alt_data_end+0xff80f818>
 100f830:	513fff04 	addi	r4,r10,-4
 100f834:	2008d0ba 	srli	r4,r4,2
 100f838:	318000cc 	andi	r6,r6,3
 100f83c:	21000044 	addi	r4,r4,1
 100f840:	2109883a 	add	r4,r4,r4
 100f844:	2109883a 	add	r4,r4,r4
 100f848:	1907883a 	add	r3,r3,r4
 100f84c:	290b883a 	add	r5,r5,r4
 100f850:	30000b26 	beq	r6,zero,100f880 <memmove+0x150>
 100f854:	198d883a 	add	r6,r3,r6
 100f858:	29c00003 	ldbu	r7,0(r5)
 100f85c:	18c00044 	addi	r3,r3,1
 100f860:	29400044 	addi	r5,r5,1
 100f864:	19ffffc5 	stb	r7,-1(r3)
 100f868:	19bffb1e 	bne	r3,r6,100f858 <__alt_data_end+0xff80f858>
 100f86c:	f800283a 	ret
 100f870:	1007883a 	mov	r3,r2
 100f874:	003ff606 	br	100f850 <__alt_data_end+0xff80f850>
 100f878:	1007883a 	mov	r3,r2
 100f87c:	003ff506 	br	100f854 <__alt_data_end+0xff80f854>
 100f880:	f800283a 	ret
 100f884:	500d883a 	mov	r6,r10
 100f888:	003ff106 	br	100f850 <__alt_data_end+0xff80f850>

0100f88c <_Balloc>:
 100f88c:	20801317 	ldw	r2,76(r4)
 100f890:	defffc04 	addi	sp,sp,-16
 100f894:	dc400115 	stw	r17,4(sp)
 100f898:	dc000015 	stw	r16,0(sp)
 100f89c:	dfc00315 	stw	ra,12(sp)
 100f8a0:	dc800215 	stw	r18,8(sp)
 100f8a4:	2023883a 	mov	r17,r4
 100f8a8:	2821883a 	mov	r16,r5
 100f8ac:	10000f26 	beq	r2,zero,100f8ec <_Balloc+0x60>
 100f8b0:	8407883a 	add	r3,r16,r16
 100f8b4:	18c7883a 	add	r3,r3,r3
 100f8b8:	10c7883a 	add	r3,r2,r3
 100f8bc:	18800017 	ldw	r2,0(r3)
 100f8c0:	10001126 	beq	r2,zero,100f908 <_Balloc+0x7c>
 100f8c4:	11000017 	ldw	r4,0(r2)
 100f8c8:	19000015 	stw	r4,0(r3)
 100f8cc:	10000415 	stw	zero,16(r2)
 100f8d0:	10000315 	stw	zero,12(r2)
 100f8d4:	dfc00317 	ldw	ra,12(sp)
 100f8d8:	dc800217 	ldw	r18,8(sp)
 100f8dc:	dc400117 	ldw	r17,4(sp)
 100f8e0:	dc000017 	ldw	r16,0(sp)
 100f8e4:	dec00404 	addi	sp,sp,16
 100f8e8:	f800283a 	ret
 100f8ec:	01800844 	movi	r6,33
 100f8f0:	01400104 	movi	r5,4
 100f8f4:	1012a880 	call	1012a88 <_calloc_r>
 100f8f8:	88801315 	stw	r2,76(r17)
 100f8fc:	103fec1e 	bne	r2,zero,100f8b0 <__alt_data_end+0xff80f8b0>
 100f900:	0005883a 	mov	r2,zero
 100f904:	003ff306 	br	100f8d4 <__alt_data_end+0xff80f8d4>
 100f908:	01400044 	movi	r5,1
 100f90c:	2c24983a 	sll	r18,r5,r16
 100f910:	8809883a 	mov	r4,r17
 100f914:	91800144 	addi	r6,r18,5
 100f918:	318d883a 	add	r6,r6,r6
 100f91c:	318d883a 	add	r6,r6,r6
 100f920:	1012a880 	call	1012a88 <_calloc_r>
 100f924:	103ff626 	beq	r2,zero,100f900 <__alt_data_end+0xff80f900>
 100f928:	14000115 	stw	r16,4(r2)
 100f92c:	14800215 	stw	r18,8(r2)
 100f930:	003fe606 	br	100f8cc <__alt_data_end+0xff80f8cc>

0100f934 <_Bfree>:
 100f934:	28000826 	beq	r5,zero,100f958 <_Bfree+0x24>
 100f938:	28c00117 	ldw	r3,4(r5)
 100f93c:	20801317 	ldw	r2,76(r4)
 100f940:	18c7883a 	add	r3,r3,r3
 100f944:	18c7883a 	add	r3,r3,r3
 100f948:	10c5883a 	add	r2,r2,r3
 100f94c:	10c00017 	ldw	r3,0(r2)
 100f950:	28c00015 	stw	r3,0(r5)
 100f954:	11400015 	stw	r5,0(r2)
 100f958:	f800283a 	ret

0100f95c <__multadd>:
 100f95c:	defffa04 	addi	sp,sp,-24
 100f960:	dc800315 	stw	r18,12(sp)
 100f964:	dc400215 	stw	r17,8(sp)
 100f968:	dc000115 	stw	r16,4(sp)
 100f96c:	2823883a 	mov	r17,r5
 100f970:	2c000417 	ldw	r16,16(r5)
 100f974:	dfc00515 	stw	ra,20(sp)
 100f978:	dcc00415 	stw	r19,16(sp)
 100f97c:	2025883a 	mov	r18,r4
 100f980:	29400504 	addi	r5,r5,20
 100f984:	0011883a 	mov	r8,zero
 100f988:	28c00017 	ldw	r3,0(r5)
 100f98c:	29400104 	addi	r5,r5,4
 100f990:	42000044 	addi	r8,r8,1
 100f994:	18bfffcc 	andi	r2,r3,65535
 100f998:	1185383a 	mul	r2,r2,r6
 100f99c:	1806d43a 	srli	r3,r3,16
 100f9a0:	11cf883a 	add	r7,r2,r7
 100f9a4:	3808d43a 	srli	r4,r7,16
 100f9a8:	1987383a 	mul	r3,r3,r6
 100f9ac:	38bfffcc 	andi	r2,r7,65535
 100f9b0:	1907883a 	add	r3,r3,r4
 100f9b4:	1808943a 	slli	r4,r3,16
 100f9b8:	180ed43a 	srli	r7,r3,16
 100f9bc:	2085883a 	add	r2,r4,r2
 100f9c0:	28bfff15 	stw	r2,-4(r5)
 100f9c4:	443ff016 	blt	r8,r16,100f988 <__alt_data_end+0xff80f988>
 100f9c8:	38000926 	beq	r7,zero,100f9f0 <__multadd+0x94>
 100f9cc:	88800217 	ldw	r2,8(r17)
 100f9d0:	80800f0e 	bge	r16,r2,100fa10 <__multadd+0xb4>
 100f9d4:	80800144 	addi	r2,r16,5
 100f9d8:	1085883a 	add	r2,r2,r2
 100f9dc:	1085883a 	add	r2,r2,r2
 100f9e0:	8885883a 	add	r2,r17,r2
 100f9e4:	11c00015 	stw	r7,0(r2)
 100f9e8:	84000044 	addi	r16,r16,1
 100f9ec:	8c000415 	stw	r16,16(r17)
 100f9f0:	8805883a 	mov	r2,r17
 100f9f4:	dfc00517 	ldw	ra,20(sp)
 100f9f8:	dcc00417 	ldw	r19,16(sp)
 100f9fc:	dc800317 	ldw	r18,12(sp)
 100fa00:	dc400217 	ldw	r17,8(sp)
 100fa04:	dc000117 	ldw	r16,4(sp)
 100fa08:	dec00604 	addi	sp,sp,24
 100fa0c:	f800283a 	ret
 100fa10:	89400117 	ldw	r5,4(r17)
 100fa14:	9009883a 	mov	r4,r18
 100fa18:	d9c00015 	stw	r7,0(sp)
 100fa1c:	29400044 	addi	r5,r5,1
 100fa20:	100f88c0 	call	100f88c <_Balloc>
 100fa24:	89800417 	ldw	r6,16(r17)
 100fa28:	89400304 	addi	r5,r17,12
 100fa2c:	11000304 	addi	r4,r2,12
 100fa30:	31800084 	addi	r6,r6,2
 100fa34:	318d883a 	add	r6,r6,r6
 100fa38:	318d883a 	add	r6,r6,r6
 100fa3c:	1027883a 	mov	r19,r2
 100fa40:	10099d40 	call	10099d4 <memcpy>
 100fa44:	d9c00017 	ldw	r7,0(sp)
 100fa48:	88000a26 	beq	r17,zero,100fa74 <__multadd+0x118>
 100fa4c:	88c00117 	ldw	r3,4(r17)
 100fa50:	90801317 	ldw	r2,76(r18)
 100fa54:	18c7883a 	add	r3,r3,r3
 100fa58:	18c7883a 	add	r3,r3,r3
 100fa5c:	10c5883a 	add	r2,r2,r3
 100fa60:	10c00017 	ldw	r3,0(r2)
 100fa64:	88c00015 	stw	r3,0(r17)
 100fa68:	14400015 	stw	r17,0(r2)
 100fa6c:	9823883a 	mov	r17,r19
 100fa70:	003fd806 	br	100f9d4 <__alt_data_end+0xff80f9d4>
 100fa74:	9823883a 	mov	r17,r19
 100fa78:	003fd606 	br	100f9d4 <__alt_data_end+0xff80f9d4>

0100fa7c <__s2b>:
 100fa7c:	defff904 	addi	sp,sp,-28
 100fa80:	dc400115 	stw	r17,4(sp)
 100fa84:	dc000015 	stw	r16,0(sp)
 100fa88:	2023883a 	mov	r17,r4
 100fa8c:	2821883a 	mov	r16,r5
 100fa90:	39000204 	addi	r4,r7,8
 100fa94:	01400244 	movi	r5,9
 100fa98:	dcc00315 	stw	r19,12(sp)
 100fa9c:	dc800215 	stw	r18,8(sp)
 100faa0:	dfc00615 	stw	ra,24(sp)
 100faa4:	dd400515 	stw	r21,20(sp)
 100faa8:	dd000415 	stw	r20,16(sp)
 100faac:	3825883a 	mov	r18,r7
 100fab0:	3027883a 	mov	r19,r6
 100fab4:	10096ac0 	call	10096ac <__divsi3>
 100fab8:	00c00044 	movi	r3,1
 100fabc:	000b883a 	mov	r5,zero
 100fac0:	1880030e 	bge	r3,r2,100fad0 <__s2b+0x54>
 100fac4:	18c7883a 	add	r3,r3,r3
 100fac8:	29400044 	addi	r5,r5,1
 100facc:	18bffd16 	blt	r3,r2,100fac4 <__alt_data_end+0xff80fac4>
 100fad0:	8809883a 	mov	r4,r17
 100fad4:	100f88c0 	call	100f88c <_Balloc>
 100fad8:	d8c00717 	ldw	r3,28(sp)
 100fadc:	10c00515 	stw	r3,20(r2)
 100fae0:	00c00044 	movi	r3,1
 100fae4:	10c00415 	stw	r3,16(r2)
 100fae8:	00c00244 	movi	r3,9
 100faec:	1cc0210e 	bge	r3,r19,100fb74 <__s2b+0xf8>
 100faf0:	80eb883a 	add	r21,r16,r3
 100faf4:	a829883a 	mov	r20,r21
 100faf8:	84e1883a 	add	r16,r16,r19
 100fafc:	a1c00007 	ldb	r7,0(r20)
 100fb00:	01800284 	movi	r6,10
 100fb04:	a5000044 	addi	r20,r20,1
 100fb08:	100b883a 	mov	r5,r2
 100fb0c:	39fff404 	addi	r7,r7,-48
 100fb10:	8809883a 	mov	r4,r17
 100fb14:	100f95c0 	call	100f95c <__multadd>
 100fb18:	a43ff81e 	bne	r20,r16,100fafc <__alt_data_end+0xff80fafc>
 100fb1c:	ace1883a 	add	r16,r21,r19
 100fb20:	843ffe04 	addi	r16,r16,-8
 100fb24:	9c800a0e 	bge	r19,r18,100fb50 <__s2b+0xd4>
 100fb28:	94e5c83a 	sub	r18,r18,r19
 100fb2c:	84a5883a 	add	r18,r16,r18
 100fb30:	81c00007 	ldb	r7,0(r16)
 100fb34:	01800284 	movi	r6,10
 100fb38:	84000044 	addi	r16,r16,1
 100fb3c:	100b883a 	mov	r5,r2
 100fb40:	39fff404 	addi	r7,r7,-48
 100fb44:	8809883a 	mov	r4,r17
 100fb48:	100f95c0 	call	100f95c <__multadd>
 100fb4c:	84bff81e 	bne	r16,r18,100fb30 <__alt_data_end+0xff80fb30>
 100fb50:	dfc00617 	ldw	ra,24(sp)
 100fb54:	dd400517 	ldw	r21,20(sp)
 100fb58:	dd000417 	ldw	r20,16(sp)
 100fb5c:	dcc00317 	ldw	r19,12(sp)
 100fb60:	dc800217 	ldw	r18,8(sp)
 100fb64:	dc400117 	ldw	r17,4(sp)
 100fb68:	dc000017 	ldw	r16,0(sp)
 100fb6c:	dec00704 	addi	sp,sp,28
 100fb70:	f800283a 	ret
 100fb74:	84000284 	addi	r16,r16,10
 100fb78:	1827883a 	mov	r19,r3
 100fb7c:	003fe906 	br	100fb24 <__alt_data_end+0xff80fb24>

0100fb80 <__hi0bits>:
 100fb80:	20bfffec 	andhi	r2,r4,65535
 100fb84:	1000141e 	bne	r2,zero,100fbd8 <__hi0bits+0x58>
 100fb88:	2008943a 	slli	r4,r4,16
 100fb8c:	00800404 	movi	r2,16
 100fb90:	20ffc02c 	andhi	r3,r4,65280
 100fb94:	1800021e 	bne	r3,zero,100fba0 <__hi0bits+0x20>
 100fb98:	2008923a 	slli	r4,r4,8
 100fb9c:	10800204 	addi	r2,r2,8
 100fba0:	20fc002c 	andhi	r3,r4,61440
 100fba4:	1800021e 	bne	r3,zero,100fbb0 <__hi0bits+0x30>
 100fba8:	2008913a 	slli	r4,r4,4
 100fbac:	10800104 	addi	r2,r2,4
 100fbb0:	20f0002c 	andhi	r3,r4,49152
 100fbb4:	1800031e 	bne	r3,zero,100fbc4 <__hi0bits+0x44>
 100fbb8:	2109883a 	add	r4,r4,r4
 100fbbc:	10800084 	addi	r2,r2,2
 100fbc0:	2109883a 	add	r4,r4,r4
 100fbc4:	20000316 	blt	r4,zero,100fbd4 <__hi0bits+0x54>
 100fbc8:	2110002c 	andhi	r4,r4,16384
 100fbcc:	2000041e 	bne	r4,zero,100fbe0 <__hi0bits+0x60>
 100fbd0:	00800804 	movi	r2,32
 100fbd4:	f800283a 	ret
 100fbd8:	0005883a 	mov	r2,zero
 100fbdc:	003fec06 	br	100fb90 <__alt_data_end+0xff80fb90>
 100fbe0:	10800044 	addi	r2,r2,1
 100fbe4:	f800283a 	ret

0100fbe8 <__lo0bits>:
 100fbe8:	20c00017 	ldw	r3,0(r4)
 100fbec:	188001cc 	andi	r2,r3,7
 100fbf0:	10000826 	beq	r2,zero,100fc14 <__lo0bits+0x2c>
 100fbf4:	1880004c 	andi	r2,r3,1
 100fbf8:	1000211e 	bne	r2,zero,100fc80 <__lo0bits+0x98>
 100fbfc:	1880008c 	andi	r2,r3,2
 100fc00:	1000211e 	bne	r2,zero,100fc88 <__lo0bits+0xa0>
 100fc04:	1806d0ba 	srli	r3,r3,2
 100fc08:	00800084 	movi	r2,2
 100fc0c:	20c00015 	stw	r3,0(r4)
 100fc10:	f800283a 	ret
 100fc14:	18bfffcc 	andi	r2,r3,65535
 100fc18:	10001326 	beq	r2,zero,100fc68 <__lo0bits+0x80>
 100fc1c:	0005883a 	mov	r2,zero
 100fc20:	19403fcc 	andi	r5,r3,255
 100fc24:	2800021e 	bne	r5,zero,100fc30 <__lo0bits+0x48>
 100fc28:	1806d23a 	srli	r3,r3,8
 100fc2c:	10800204 	addi	r2,r2,8
 100fc30:	194003cc 	andi	r5,r3,15
 100fc34:	2800021e 	bne	r5,zero,100fc40 <__lo0bits+0x58>
 100fc38:	1806d13a 	srli	r3,r3,4
 100fc3c:	10800104 	addi	r2,r2,4
 100fc40:	194000cc 	andi	r5,r3,3
 100fc44:	2800021e 	bne	r5,zero,100fc50 <__lo0bits+0x68>
 100fc48:	1806d0ba 	srli	r3,r3,2
 100fc4c:	10800084 	addi	r2,r2,2
 100fc50:	1940004c 	andi	r5,r3,1
 100fc54:	2800081e 	bne	r5,zero,100fc78 <__lo0bits+0x90>
 100fc58:	1806d07a 	srli	r3,r3,1
 100fc5c:	1800051e 	bne	r3,zero,100fc74 <__lo0bits+0x8c>
 100fc60:	00800804 	movi	r2,32
 100fc64:	f800283a 	ret
 100fc68:	1806d43a 	srli	r3,r3,16
 100fc6c:	00800404 	movi	r2,16
 100fc70:	003feb06 	br	100fc20 <__alt_data_end+0xff80fc20>
 100fc74:	10800044 	addi	r2,r2,1
 100fc78:	20c00015 	stw	r3,0(r4)
 100fc7c:	f800283a 	ret
 100fc80:	0005883a 	mov	r2,zero
 100fc84:	f800283a 	ret
 100fc88:	1806d07a 	srli	r3,r3,1
 100fc8c:	00800044 	movi	r2,1
 100fc90:	20c00015 	stw	r3,0(r4)
 100fc94:	f800283a 	ret

0100fc98 <__i2b>:
 100fc98:	defffd04 	addi	sp,sp,-12
 100fc9c:	dc000015 	stw	r16,0(sp)
 100fca0:	04000044 	movi	r16,1
 100fca4:	dc400115 	stw	r17,4(sp)
 100fca8:	2823883a 	mov	r17,r5
 100fcac:	800b883a 	mov	r5,r16
 100fcb0:	dfc00215 	stw	ra,8(sp)
 100fcb4:	100f88c0 	call	100f88c <_Balloc>
 100fcb8:	14400515 	stw	r17,20(r2)
 100fcbc:	14000415 	stw	r16,16(r2)
 100fcc0:	dfc00217 	ldw	ra,8(sp)
 100fcc4:	dc400117 	ldw	r17,4(sp)
 100fcc8:	dc000017 	ldw	r16,0(sp)
 100fccc:	dec00304 	addi	sp,sp,12
 100fcd0:	f800283a 	ret

0100fcd4 <__multiply>:
 100fcd4:	defffa04 	addi	sp,sp,-24
 100fcd8:	dcc00315 	stw	r19,12(sp)
 100fcdc:	dc800215 	stw	r18,8(sp)
 100fce0:	34c00417 	ldw	r19,16(r6)
 100fce4:	2c800417 	ldw	r18,16(r5)
 100fce8:	dd000415 	stw	r20,16(sp)
 100fcec:	dc400115 	stw	r17,4(sp)
 100fcf0:	dfc00515 	stw	ra,20(sp)
 100fcf4:	dc000015 	stw	r16,0(sp)
 100fcf8:	2829883a 	mov	r20,r5
 100fcfc:	3023883a 	mov	r17,r6
 100fd00:	94c0050e 	bge	r18,r19,100fd18 <__multiply+0x44>
 100fd04:	9007883a 	mov	r3,r18
 100fd08:	3029883a 	mov	r20,r6
 100fd0c:	9825883a 	mov	r18,r19
 100fd10:	2823883a 	mov	r17,r5
 100fd14:	1827883a 	mov	r19,r3
 100fd18:	a0800217 	ldw	r2,8(r20)
 100fd1c:	94e1883a 	add	r16,r18,r19
 100fd20:	a1400117 	ldw	r5,4(r20)
 100fd24:	1400010e 	bge	r2,r16,100fd2c <__multiply+0x58>
 100fd28:	29400044 	addi	r5,r5,1
 100fd2c:	100f88c0 	call	100f88c <_Balloc>
 100fd30:	8415883a 	add	r10,r16,r16
 100fd34:	12c00504 	addi	r11,r2,20
 100fd38:	5295883a 	add	r10,r10,r10
 100fd3c:	5a95883a 	add	r10,r11,r10
 100fd40:	5807883a 	mov	r3,r11
 100fd44:	5a80032e 	bgeu	r11,r10,100fd54 <__multiply+0x80>
 100fd48:	18000015 	stw	zero,0(r3)
 100fd4c:	18c00104 	addi	r3,r3,4
 100fd50:	1abffd36 	bltu	r3,r10,100fd48 <__alt_data_end+0xff80fd48>
 100fd54:	9ce7883a 	add	r19,r19,r19
 100fd58:	94a5883a 	add	r18,r18,r18
 100fd5c:	89800504 	addi	r6,r17,20
 100fd60:	9ce7883a 	add	r19,r19,r19
 100fd64:	a3400504 	addi	r13,r20,20
 100fd68:	94a5883a 	add	r18,r18,r18
 100fd6c:	34d9883a 	add	r12,r6,r19
 100fd70:	6c93883a 	add	r9,r13,r18
 100fd74:	3300422e 	bgeu	r6,r12,100fe80 <__multiply+0x1ac>
 100fd78:	37c00017 	ldw	ra,0(r6)
 100fd7c:	fbffffcc 	andi	r15,ra,65535
 100fd80:	78001b26 	beq	r15,zero,100fdf0 <__multiply+0x11c>
 100fd84:	5811883a 	mov	r8,r11
 100fd88:	681d883a 	mov	r14,r13
 100fd8c:	000f883a 	mov	r7,zero
 100fd90:	71000017 	ldw	r4,0(r14)
 100fd94:	40c00017 	ldw	r3,0(r8)
 100fd98:	73800104 	addi	r14,r14,4
 100fd9c:	217fffcc 	andi	r5,r4,65535
 100fda0:	2bcb383a 	mul	r5,r5,r15
 100fda4:	2008d43a 	srli	r4,r4,16
 100fda8:	1c7fffcc 	andi	r17,r3,65535
 100fdac:	2c4b883a 	add	r5,r5,r17
 100fdb0:	29cb883a 	add	r5,r5,r7
 100fdb4:	23c9383a 	mul	r4,r4,r15
 100fdb8:	1806d43a 	srli	r3,r3,16
 100fdbc:	280ed43a 	srli	r7,r5,16
 100fdc0:	297fffcc 	andi	r5,r5,65535
 100fdc4:	20c7883a 	add	r3,r4,r3
 100fdc8:	19c7883a 	add	r3,r3,r7
 100fdcc:	1808943a 	slli	r4,r3,16
 100fdd0:	4023883a 	mov	r17,r8
 100fdd4:	180ed43a 	srli	r7,r3,16
 100fdd8:	214ab03a 	or	r5,r4,r5
 100fddc:	41400015 	stw	r5,0(r8)
 100fde0:	42000104 	addi	r8,r8,4
 100fde4:	727fea36 	bltu	r14,r9,100fd90 <__alt_data_end+0xff80fd90>
 100fde8:	89c00115 	stw	r7,4(r17)
 100fdec:	37c00017 	ldw	ra,0(r6)
 100fdf0:	f83ed43a 	srli	ra,ra,16
 100fdf4:	f8001f26 	beq	ra,zero,100fe74 <__multiply+0x1a0>
 100fdf8:	58c00017 	ldw	r3,0(r11)
 100fdfc:	681d883a 	mov	r14,r13
 100fe00:	581f883a 	mov	r15,r11
 100fe04:	1811883a 	mov	r8,r3
 100fe08:	5825883a 	mov	r18,r11
 100fe0c:	000f883a 	mov	r7,zero
 100fe10:	00000106 	br	100fe18 <__multiply+0x144>
 100fe14:	8825883a 	mov	r18,r17
 100fe18:	7140000b 	ldhu	r5,0(r14)
 100fe1c:	4010d43a 	srli	r8,r8,16
 100fe20:	193fffcc 	andi	r4,r3,65535
 100fe24:	2fcb383a 	mul	r5,r5,ra
 100fe28:	7bc00104 	addi	r15,r15,4
 100fe2c:	73800104 	addi	r14,r14,4
 100fe30:	2a0b883a 	add	r5,r5,r8
 100fe34:	29cb883a 	add	r5,r5,r7
 100fe38:	2806943a 	slli	r3,r5,16
 100fe3c:	94400104 	addi	r17,r18,4
 100fe40:	280ad43a 	srli	r5,r5,16
 100fe44:	1908b03a 	or	r4,r3,r4
 100fe48:	793fff15 	stw	r4,-4(r15)
 100fe4c:	70ffff17 	ldw	r3,-4(r14)
 100fe50:	8a000017 	ldw	r8,0(r17)
 100fe54:	1806d43a 	srli	r3,r3,16
 100fe58:	413fffcc 	andi	r4,r8,65535
 100fe5c:	1fc7383a 	mul	r3,r3,ra
 100fe60:	1907883a 	add	r3,r3,r4
 100fe64:	1947883a 	add	r3,r3,r5
 100fe68:	180ed43a 	srli	r7,r3,16
 100fe6c:	727fe936 	bltu	r14,r9,100fe14 <__alt_data_end+0xff80fe14>
 100fe70:	90c00115 	stw	r3,4(r18)
 100fe74:	31800104 	addi	r6,r6,4
 100fe78:	5ac00104 	addi	r11,r11,4
 100fe7c:	333fbe36 	bltu	r6,r12,100fd78 <__alt_data_end+0xff80fd78>
 100fe80:	0400090e 	bge	zero,r16,100fea8 <__multiply+0x1d4>
 100fe84:	50ffff17 	ldw	r3,-4(r10)
 100fe88:	52bfff04 	addi	r10,r10,-4
 100fe8c:	18000326 	beq	r3,zero,100fe9c <__multiply+0x1c8>
 100fe90:	00000506 	br	100fea8 <__multiply+0x1d4>
 100fe94:	50c00017 	ldw	r3,0(r10)
 100fe98:	1800031e 	bne	r3,zero,100fea8 <__multiply+0x1d4>
 100fe9c:	843fffc4 	addi	r16,r16,-1
 100fea0:	52bfff04 	addi	r10,r10,-4
 100fea4:	803ffb1e 	bne	r16,zero,100fe94 <__alt_data_end+0xff80fe94>
 100fea8:	14000415 	stw	r16,16(r2)
 100feac:	dfc00517 	ldw	ra,20(sp)
 100feb0:	dd000417 	ldw	r20,16(sp)
 100feb4:	dcc00317 	ldw	r19,12(sp)
 100feb8:	dc800217 	ldw	r18,8(sp)
 100febc:	dc400117 	ldw	r17,4(sp)
 100fec0:	dc000017 	ldw	r16,0(sp)
 100fec4:	dec00604 	addi	sp,sp,24
 100fec8:	f800283a 	ret

0100fecc <__pow5mult>:
 100fecc:	defffa04 	addi	sp,sp,-24
 100fed0:	dcc00315 	stw	r19,12(sp)
 100fed4:	dc000015 	stw	r16,0(sp)
 100fed8:	dfc00515 	stw	ra,20(sp)
 100fedc:	dd000415 	stw	r20,16(sp)
 100fee0:	dc800215 	stw	r18,8(sp)
 100fee4:	dc400115 	stw	r17,4(sp)
 100fee8:	308000cc 	andi	r2,r6,3
 100feec:	3021883a 	mov	r16,r6
 100fef0:	2027883a 	mov	r19,r4
 100fef4:	10002f1e 	bne	r2,zero,100ffb4 <__pow5mult+0xe8>
 100fef8:	2825883a 	mov	r18,r5
 100fefc:	8021d0ba 	srai	r16,r16,2
 100ff00:	80001a26 	beq	r16,zero,100ff6c <__pow5mult+0xa0>
 100ff04:	9c401217 	ldw	r17,72(r19)
 100ff08:	8800061e 	bne	r17,zero,100ff24 <__pow5mult+0x58>
 100ff0c:	00003406 	br	100ffe0 <__pow5mult+0x114>
 100ff10:	8021d07a 	srai	r16,r16,1
 100ff14:	80001526 	beq	r16,zero,100ff6c <__pow5mult+0xa0>
 100ff18:	88800017 	ldw	r2,0(r17)
 100ff1c:	10001c26 	beq	r2,zero,100ff90 <__pow5mult+0xc4>
 100ff20:	1023883a 	mov	r17,r2
 100ff24:	8080004c 	andi	r2,r16,1
 100ff28:	103ff926 	beq	r2,zero,100ff10 <__alt_data_end+0xff80ff10>
 100ff2c:	880d883a 	mov	r6,r17
 100ff30:	900b883a 	mov	r5,r18
 100ff34:	9809883a 	mov	r4,r19
 100ff38:	100fcd40 	call	100fcd4 <__multiply>
 100ff3c:	90001b26 	beq	r18,zero,100ffac <__pow5mult+0xe0>
 100ff40:	91000117 	ldw	r4,4(r18)
 100ff44:	98c01317 	ldw	r3,76(r19)
 100ff48:	8021d07a 	srai	r16,r16,1
 100ff4c:	2109883a 	add	r4,r4,r4
 100ff50:	2109883a 	add	r4,r4,r4
 100ff54:	1907883a 	add	r3,r3,r4
 100ff58:	19000017 	ldw	r4,0(r3)
 100ff5c:	91000015 	stw	r4,0(r18)
 100ff60:	1c800015 	stw	r18,0(r3)
 100ff64:	1025883a 	mov	r18,r2
 100ff68:	803feb1e 	bne	r16,zero,100ff18 <__alt_data_end+0xff80ff18>
 100ff6c:	9005883a 	mov	r2,r18
 100ff70:	dfc00517 	ldw	ra,20(sp)
 100ff74:	dd000417 	ldw	r20,16(sp)
 100ff78:	dcc00317 	ldw	r19,12(sp)
 100ff7c:	dc800217 	ldw	r18,8(sp)
 100ff80:	dc400117 	ldw	r17,4(sp)
 100ff84:	dc000017 	ldw	r16,0(sp)
 100ff88:	dec00604 	addi	sp,sp,24
 100ff8c:	f800283a 	ret
 100ff90:	880d883a 	mov	r6,r17
 100ff94:	880b883a 	mov	r5,r17
 100ff98:	9809883a 	mov	r4,r19
 100ff9c:	100fcd40 	call	100fcd4 <__multiply>
 100ffa0:	88800015 	stw	r2,0(r17)
 100ffa4:	10000015 	stw	zero,0(r2)
 100ffa8:	003fdd06 	br	100ff20 <__alt_data_end+0xff80ff20>
 100ffac:	1025883a 	mov	r18,r2
 100ffb0:	003fd706 	br	100ff10 <__alt_data_end+0xff80ff10>
 100ffb4:	10bfffc4 	addi	r2,r2,-1
 100ffb8:	1085883a 	add	r2,r2,r2
 100ffbc:	00c040b4 	movhi	r3,258
 100ffc0:	18eb1604 	addi	r3,r3,-21416
 100ffc4:	1085883a 	add	r2,r2,r2
 100ffc8:	1885883a 	add	r2,r3,r2
 100ffcc:	11800017 	ldw	r6,0(r2)
 100ffd0:	000f883a 	mov	r7,zero
 100ffd4:	100f95c0 	call	100f95c <__multadd>
 100ffd8:	1025883a 	mov	r18,r2
 100ffdc:	003fc706 	br	100fefc <__alt_data_end+0xff80fefc>
 100ffe0:	05000044 	movi	r20,1
 100ffe4:	a00b883a 	mov	r5,r20
 100ffe8:	9809883a 	mov	r4,r19
 100ffec:	100f88c0 	call	100f88c <_Balloc>
 100fff0:	1023883a 	mov	r17,r2
 100fff4:	00809c44 	movi	r2,625
 100fff8:	88800515 	stw	r2,20(r17)
 100fffc:	8d000415 	stw	r20,16(r17)
 1010000:	9c401215 	stw	r17,72(r19)
 1010004:	88000015 	stw	zero,0(r17)
 1010008:	003fc606 	br	100ff24 <__alt_data_end+0xff80ff24>

0101000c <__lshift>:
 101000c:	defff904 	addi	sp,sp,-28
 1010010:	dd400515 	stw	r21,20(sp)
 1010014:	dcc00315 	stw	r19,12(sp)
 1010018:	302bd17a 	srai	r21,r6,5
 101001c:	2cc00417 	ldw	r19,16(r5)
 1010020:	28800217 	ldw	r2,8(r5)
 1010024:	dd000415 	stw	r20,16(sp)
 1010028:	ace7883a 	add	r19,r21,r19
 101002c:	dc800215 	stw	r18,8(sp)
 1010030:	dc400115 	stw	r17,4(sp)
 1010034:	dc000015 	stw	r16,0(sp)
 1010038:	dfc00615 	stw	ra,24(sp)
 101003c:	9c000044 	addi	r16,r19,1
 1010040:	2823883a 	mov	r17,r5
 1010044:	3029883a 	mov	r20,r6
 1010048:	2025883a 	mov	r18,r4
 101004c:	29400117 	ldw	r5,4(r5)
 1010050:	1400030e 	bge	r2,r16,1010060 <__lshift+0x54>
 1010054:	1085883a 	add	r2,r2,r2
 1010058:	29400044 	addi	r5,r5,1
 101005c:	143ffd16 	blt	r2,r16,1010054 <__alt_data_end+0xff810054>
 1010060:	9009883a 	mov	r4,r18
 1010064:	100f88c0 	call	100f88c <_Balloc>
 1010068:	10c00504 	addi	r3,r2,20
 101006c:	0540070e 	bge	zero,r21,101008c <__lshift+0x80>
 1010070:	ad6b883a 	add	r21,r21,r21
 1010074:	ad6b883a 	add	r21,r21,r21
 1010078:	1809883a 	mov	r4,r3
 101007c:	1d47883a 	add	r3,r3,r21
 1010080:	20000015 	stw	zero,0(r4)
 1010084:	21000104 	addi	r4,r4,4
 1010088:	193ffd1e 	bne	r3,r4,1010080 <__alt_data_end+0xff810080>
 101008c:	8a000417 	ldw	r8,16(r17)
 1010090:	89000504 	addi	r4,r17,20
 1010094:	a18007cc 	andi	r6,r20,31
 1010098:	4211883a 	add	r8,r8,r8
 101009c:	4211883a 	add	r8,r8,r8
 10100a0:	2211883a 	add	r8,r4,r8
 10100a4:	30002326 	beq	r6,zero,1010134 <__lshift+0x128>
 10100a8:	02400804 	movi	r9,32
 10100ac:	4993c83a 	sub	r9,r9,r6
 10100b0:	000b883a 	mov	r5,zero
 10100b4:	21c00017 	ldw	r7,0(r4)
 10100b8:	1815883a 	mov	r10,r3
 10100bc:	18c00104 	addi	r3,r3,4
 10100c0:	398e983a 	sll	r7,r7,r6
 10100c4:	21000104 	addi	r4,r4,4
 10100c8:	394ab03a 	or	r5,r7,r5
 10100cc:	197fff15 	stw	r5,-4(r3)
 10100d0:	217fff17 	ldw	r5,-4(r4)
 10100d4:	2a4ad83a 	srl	r5,r5,r9
 10100d8:	223ff636 	bltu	r4,r8,10100b4 <__alt_data_end+0xff8100b4>
 10100dc:	51400115 	stw	r5,4(r10)
 10100e0:	28001a1e 	bne	r5,zero,101014c <__lshift+0x140>
 10100e4:	843fffc4 	addi	r16,r16,-1
 10100e8:	14000415 	stw	r16,16(r2)
 10100ec:	88000826 	beq	r17,zero,1010110 <__lshift+0x104>
 10100f0:	89000117 	ldw	r4,4(r17)
 10100f4:	90c01317 	ldw	r3,76(r18)
 10100f8:	2109883a 	add	r4,r4,r4
 10100fc:	2109883a 	add	r4,r4,r4
 1010100:	1907883a 	add	r3,r3,r4
 1010104:	19000017 	ldw	r4,0(r3)
 1010108:	89000015 	stw	r4,0(r17)
 101010c:	1c400015 	stw	r17,0(r3)
 1010110:	dfc00617 	ldw	ra,24(sp)
 1010114:	dd400517 	ldw	r21,20(sp)
 1010118:	dd000417 	ldw	r20,16(sp)
 101011c:	dcc00317 	ldw	r19,12(sp)
 1010120:	dc800217 	ldw	r18,8(sp)
 1010124:	dc400117 	ldw	r17,4(sp)
 1010128:	dc000017 	ldw	r16,0(sp)
 101012c:	dec00704 	addi	sp,sp,28
 1010130:	f800283a 	ret
 1010134:	21400017 	ldw	r5,0(r4)
 1010138:	18c00104 	addi	r3,r3,4
 101013c:	21000104 	addi	r4,r4,4
 1010140:	197fff15 	stw	r5,-4(r3)
 1010144:	223ffb36 	bltu	r4,r8,1010134 <__alt_data_end+0xff810134>
 1010148:	003fe606 	br	10100e4 <__alt_data_end+0xff8100e4>
 101014c:	9c000084 	addi	r16,r19,2
 1010150:	003fe406 	br	10100e4 <__alt_data_end+0xff8100e4>

01010154 <__mcmp>:
 1010154:	20800417 	ldw	r2,16(r4)
 1010158:	28c00417 	ldw	r3,16(r5)
 101015c:	10c5c83a 	sub	r2,r2,r3
 1010160:	1000111e 	bne	r2,zero,10101a8 <__mcmp+0x54>
 1010164:	18c7883a 	add	r3,r3,r3
 1010168:	18c7883a 	add	r3,r3,r3
 101016c:	21000504 	addi	r4,r4,20
 1010170:	29400504 	addi	r5,r5,20
 1010174:	20c5883a 	add	r2,r4,r3
 1010178:	28cb883a 	add	r5,r5,r3
 101017c:	00000106 	br	1010184 <__mcmp+0x30>
 1010180:	20800a2e 	bgeu	r4,r2,10101ac <__mcmp+0x58>
 1010184:	10bfff04 	addi	r2,r2,-4
 1010188:	297fff04 	addi	r5,r5,-4
 101018c:	11800017 	ldw	r6,0(r2)
 1010190:	28c00017 	ldw	r3,0(r5)
 1010194:	30fffa26 	beq	r6,r3,1010180 <__alt_data_end+0xff810180>
 1010198:	30c00236 	bltu	r6,r3,10101a4 <__mcmp+0x50>
 101019c:	00800044 	movi	r2,1
 10101a0:	f800283a 	ret
 10101a4:	00bfffc4 	movi	r2,-1
 10101a8:	f800283a 	ret
 10101ac:	0005883a 	mov	r2,zero
 10101b0:	f800283a 	ret

010101b4 <__mdiff>:
 10101b4:	28c00417 	ldw	r3,16(r5)
 10101b8:	30800417 	ldw	r2,16(r6)
 10101bc:	defffa04 	addi	sp,sp,-24
 10101c0:	dcc00315 	stw	r19,12(sp)
 10101c4:	dc800215 	stw	r18,8(sp)
 10101c8:	dfc00515 	stw	ra,20(sp)
 10101cc:	dd000415 	stw	r20,16(sp)
 10101d0:	dc400115 	stw	r17,4(sp)
 10101d4:	dc000015 	stw	r16,0(sp)
 10101d8:	1887c83a 	sub	r3,r3,r2
 10101dc:	2825883a 	mov	r18,r5
 10101e0:	3027883a 	mov	r19,r6
 10101e4:	1800141e 	bne	r3,zero,1010238 <__mdiff+0x84>
 10101e8:	1085883a 	add	r2,r2,r2
 10101ec:	1085883a 	add	r2,r2,r2
 10101f0:	2a000504 	addi	r8,r5,20
 10101f4:	34000504 	addi	r16,r6,20
 10101f8:	4087883a 	add	r3,r8,r2
 10101fc:	8085883a 	add	r2,r16,r2
 1010200:	00000106 	br	1010208 <__mdiff+0x54>
 1010204:	40c0592e 	bgeu	r8,r3,101036c <__mdiff+0x1b8>
 1010208:	18ffff04 	addi	r3,r3,-4
 101020c:	10bfff04 	addi	r2,r2,-4
 1010210:	19c00017 	ldw	r7,0(r3)
 1010214:	11400017 	ldw	r5,0(r2)
 1010218:	397ffa26 	beq	r7,r5,1010204 <__alt_data_end+0xff810204>
 101021c:	3940592e 	bgeu	r7,r5,1010384 <__mdiff+0x1d0>
 1010220:	9005883a 	mov	r2,r18
 1010224:	4023883a 	mov	r17,r8
 1010228:	9825883a 	mov	r18,r19
 101022c:	05000044 	movi	r20,1
 1010230:	1027883a 	mov	r19,r2
 1010234:	00000406 	br	1010248 <__mdiff+0x94>
 1010238:	18005616 	blt	r3,zero,1010394 <__mdiff+0x1e0>
 101023c:	34400504 	addi	r17,r6,20
 1010240:	2c000504 	addi	r16,r5,20
 1010244:	0029883a 	mov	r20,zero
 1010248:	91400117 	ldw	r5,4(r18)
 101024c:	100f88c0 	call	100f88c <_Balloc>
 1010250:	92400417 	ldw	r9,16(r18)
 1010254:	9b000417 	ldw	r12,16(r19)
 1010258:	12c00504 	addi	r11,r2,20
 101025c:	4a51883a 	add	r8,r9,r9
 1010260:	6319883a 	add	r12,r12,r12
 1010264:	4211883a 	add	r8,r8,r8
 1010268:	6319883a 	add	r12,r12,r12
 101026c:	15000315 	stw	r20,12(r2)
 1010270:	8211883a 	add	r8,r16,r8
 1010274:	8b19883a 	add	r12,r17,r12
 1010278:	0007883a 	mov	r3,zero
 101027c:	81400017 	ldw	r5,0(r16)
 1010280:	89c00017 	ldw	r7,0(r17)
 1010284:	59800104 	addi	r6,r11,4
 1010288:	293fffcc 	andi	r4,r5,65535
 101028c:	20c7883a 	add	r3,r4,r3
 1010290:	393fffcc 	andi	r4,r7,65535
 1010294:	1909c83a 	sub	r4,r3,r4
 1010298:	280ad43a 	srli	r5,r5,16
 101029c:	380ed43a 	srli	r7,r7,16
 10102a0:	2007d43a 	srai	r3,r4,16
 10102a4:	213fffcc 	andi	r4,r4,65535
 10102a8:	29cbc83a 	sub	r5,r5,r7
 10102ac:	28c7883a 	add	r3,r5,r3
 10102b0:	180a943a 	slli	r5,r3,16
 10102b4:	8c400104 	addi	r17,r17,4
 10102b8:	84000104 	addi	r16,r16,4
 10102bc:	2908b03a 	or	r4,r5,r4
 10102c0:	59000015 	stw	r4,0(r11)
 10102c4:	1807d43a 	srai	r3,r3,16
 10102c8:	3015883a 	mov	r10,r6
 10102cc:	3017883a 	mov	r11,r6
 10102d0:	8b3fea36 	bltu	r17,r12,101027c <__alt_data_end+0xff81027c>
 10102d4:	8200162e 	bgeu	r16,r8,1010330 <__mdiff+0x17c>
 10102d8:	8017883a 	mov	r11,r16
 10102dc:	59400017 	ldw	r5,0(r11)
 10102e0:	31800104 	addi	r6,r6,4
 10102e4:	5ac00104 	addi	r11,r11,4
 10102e8:	293fffcc 	andi	r4,r5,65535
 10102ec:	20c7883a 	add	r3,r4,r3
 10102f0:	280ed43a 	srli	r7,r5,16
 10102f4:	180bd43a 	srai	r5,r3,16
 10102f8:	193fffcc 	andi	r4,r3,65535
 10102fc:	3947883a 	add	r3,r7,r5
 1010300:	180a943a 	slli	r5,r3,16
 1010304:	1807d43a 	srai	r3,r3,16
 1010308:	2908b03a 	or	r4,r5,r4
 101030c:	313fff15 	stw	r4,-4(r6)
 1010310:	5a3ff236 	bltu	r11,r8,10102dc <__alt_data_end+0xff8102dc>
 1010314:	0406303a 	nor	r3,zero,r16
 1010318:	1a07883a 	add	r3,r3,r8
 101031c:	1806d0ba 	srli	r3,r3,2
 1010320:	18c00044 	addi	r3,r3,1
 1010324:	18c7883a 	add	r3,r3,r3
 1010328:	18c7883a 	add	r3,r3,r3
 101032c:	50d5883a 	add	r10,r10,r3
 1010330:	50ffff04 	addi	r3,r10,-4
 1010334:	2000041e 	bne	r4,zero,1010348 <__mdiff+0x194>
 1010338:	18ffff04 	addi	r3,r3,-4
 101033c:	19000017 	ldw	r4,0(r3)
 1010340:	4a7fffc4 	addi	r9,r9,-1
 1010344:	203ffc26 	beq	r4,zero,1010338 <__alt_data_end+0xff810338>
 1010348:	12400415 	stw	r9,16(r2)
 101034c:	dfc00517 	ldw	ra,20(sp)
 1010350:	dd000417 	ldw	r20,16(sp)
 1010354:	dcc00317 	ldw	r19,12(sp)
 1010358:	dc800217 	ldw	r18,8(sp)
 101035c:	dc400117 	ldw	r17,4(sp)
 1010360:	dc000017 	ldw	r16,0(sp)
 1010364:	dec00604 	addi	sp,sp,24
 1010368:	f800283a 	ret
 101036c:	000b883a 	mov	r5,zero
 1010370:	100f88c0 	call	100f88c <_Balloc>
 1010374:	00c00044 	movi	r3,1
 1010378:	10c00415 	stw	r3,16(r2)
 101037c:	10000515 	stw	zero,20(r2)
 1010380:	003ff206 	br	101034c <__alt_data_end+0xff81034c>
 1010384:	8023883a 	mov	r17,r16
 1010388:	0029883a 	mov	r20,zero
 101038c:	4021883a 	mov	r16,r8
 1010390:	003fad06 	br	1010248 <__alt_data_end+0xff810248>
 1010394:	9005883a 	mov	r2,r18
 1010398:	94400504 	addi	r17,r18,20
 101039c:	9c000504 	addi	r16,r19,20
 10103a0:	9825883a 	mov	r18,r19
 10103a4:	05000044 	movi	r20,1
 10103a8:	1027883a 	mov	r19,r2
 10103ac:	003fa606 	br	1010248 <__alt_data_end+0xff810248>

010103b0 <__ulp>:
 10103b0:	295ffc2c 	andhi	r5,r5,32752
 10103b4:	00bf3034 	movhi	r2,64704
 10103b8:	2887883a 	add	r3,r5,r2
 10103bc:	00c0020e 	bge	zero,r3,10103c8 <__ulp+0x18>
 10103c0:	0005883a 	mov	r2,zero
 10103c4:	f800283a 	ret
 10103c8:	00c7c83a 	sub	r3,zero,r3
 10103cc:	1807d53a 	srai	r3,r3,20
 10103d0:	008004c4 	movi	r2,19
 10103d4:	10c00b0e 	bge	r2,r3,1010404 <__ulp+0x54>
 10103d8:	18bffb04 	addi	r2,r3,-20
 10103dc:	01000784 	movi	r4,30
 10103e0:	0007883a 	mov	r3,zero
 10103e4:	20800516 	blt	r4,r2,10103fc <__ulp+0x4c>
 10103e8:	010007c4 	movi	r4,31
 10103ec:	2089c83a 	sub	r4,r4,r2
 10103f0:	00800044 	movi	r2,1
 10103f4:	1104983a 	sll	r2,r2,r4
 10103f8:	f800283a 	ret
 10103fc:	00800044 	movi	r2,1
 1010400:	f800283a 	ret
 1010404:	01400234 	movhi	r5,8
 1010408:	28c7d83a 	sra	r3,r5,r3
 101040c:	0005883a 	mov	r2,zero
 1010410:	f800283a 	ret

01010414 <__b2d>:
 1010414:	defffa04 	addi	sp,sp,-24
 1010418:	dc000015 	stw	r16,0(sp)
 101041c:	24000417 	ldw	r16,16(r4)
 1010420:	dc400115 	stw	r17,4(sp)
 1010424:	24400504 	addi	r17,r4,20
 1010428:	8421883a 	add	r16,r16,r16
 101042c:	8421883a 	add	r16,r16,r16
 1010430:	8c21883a 	add	r16,r17,r16
 1010434:	dc800215 	stw	r18,8(sp)
 1010438:	84bfff17 	ldw	r18,-4(r16)
 101043c:	dd000415 	stw	r20,16(sp)
 1010440:	dcc00315 	stw	r19,12(sp)
 1010444:	9009883a 	mov	r4,r18
 1010448:	2829883a 	mov	r20,r5
 101044c:	dfc00515 	stw	ra,20(sp)
 1010450:	100fb800 	call	100fb80 <__hi0bits>
 1010454:	00c00804 	movi	r3,32
 1010458:	1889c83a 	sub	r4,r3,r2
 101045c:	a1000015 	stw	r4,0(r20)
 1010460:	01000284 	movi	r4,10
 1010464:	84ffff04 	addi	r19,r16,-4
 1010468:	20801216 	blt	r4,r2,10104b4 <__b2d+0xa0>
 101046c:	018002c4 	movi	r6,11
 1010470:	308dc83a 	sub	r6,r6,r2
 1010474:	9186d83a 	srl	r3,r18,r6
 1010478:	18cffc34 	orhi	r3,r3,16368
 101047c:	8cc0212e 	bgeu	r17,r19,1010504 <__b2d+0xf0>
 1010480:	813ffe17 	ldw	r4,-8(r16)
 1010484:	218cd83a 	srl	r6,r4,r6
 1010488:	10800544 	addi	r2,r2,21
 101048c:	9084983a 	sll	r2,r18,r2
 1010490:	1184b03a 	or	r2,r2,r6
 1010494:	dfc00517 	ldw	ra,20(sp)
 1010498:	dd000417 	ldw	r20,16(sp)
 101049c:	dcc00317 	ldw	r19,12(sp)
 10104a0:	dc800217 	ldw	r18,8(sp)
 10104a4:	dc400117 	ldw	r17,4(sp)
 10104a8:	dc000017 	ldw	r16,0(sp)
 10104ac:	dec00604 	addi	sp,sp,24
 10104b0:	f800283a 	ret
 10104b4:	8cc00f2e 	bgeu	r17,r19,10104f4 <__b2d+0xe0>
 10104b8:	117ffd44 	addi	r5,r2,-11
 10104bc:	80bffe17 	ldw	r2,-8(r16)
 10104c0:	28000e26 	beq	r5,zero,10104fc <__b2d+0xe8>
 10104c4:	1949c83a 	sub	r4,r3,r5
 10104c8:	9164983a 	sll	r18,r18,r5
 10104cc:	1106d83a 	srl	r3,r2,r4
 10104d0:	81bffe04 	addi	r6,r16,-8
 10104d4:	948ffc34 	orhi	r18,r18,16368
 10104d8:	90c6b03a 	or	r3,r18,r3
 10104dc:	89800e2e 	bgeu	r17,r6,1010518 <__b2d+0x104>
 10104e0:	81bffd17 	ldw	r6,-12(r16)
 10104e4:	1144983a 	sll	r2,r2,r5
 10104e8:	310ad83a 	srl	r5,r6,r4
 10104ec:	2884b03a 	or	r2,r5,r2
 10104f0:	003fe806 	br	1010494 <__alt_data_end+0xff810494>
 10104f4:	10bffd44 	addi	r2,r2,-11
 10104f8:	1000041e 	bne	r2,zero,101050c <__b2d+0xf8>
 10104fc:	90cffc34 	orhi	r3,r18,16368
 1010500:	003fe406 	br	1010494 <__alt_data_end+0xff810494>
 1010504:	000d883a 	mov	r6,zero
 1010508:	003fdf06 	br	1010488 <__alt_data_end+0xff810488>
 101050c:	90a4983a 	sll	r18,r18,r2
 1010510:	0005883a 	mov	r2,zero
 1010514:	003ff906 	br	10104fc <__alt_data_end+0xff8104fc>
 1010518:	1144983a 	sll	r2,r2,r5
 101051c:	003fdd06 	br	1010494 <__alt_data_end+0xff810494>

01010520 <__d2b>:
 1010520:	defff804 	addi	sp,sp,-32
 1010524:	dc000215 	stw	r16,8(sp)
 1010528:	3021883a 	mov	r16,r6
 101052c:	dc400315 	stw	r17,12(sp)
 1010530:	8022907a 	slli	r17,r16,1
 1010534:	dd000615 	stw	r20,24(sp)
 1010538:	2829883a 	mov	r20,r5
 101053c:	01400044 	movi	r5,1
 1010540:	dcc00515 	stw	r19,20(sp)
 1010544:	dc800415 	stw	r18,16(sp)
 1010548:	dfc00715 	stw	ra,28(sp)
 101054c:	3825883a 	mov	r18,r7
 1010550:	8822d57a 	srli	r17,r17,21
 1010554:	100f88c0 	call	100f88c <_Balloc>
 1010558:	1027883a 	mov	r19,r2
 101055c:	00800434 	movhi	r2,16
 1010560:	10bfffc4 	addi	r2,r2,-1
 1010564:	808c703a 	and	r6,r16,r2
 1010568:	88000126 	beq	r17,zero,1010570 <__d2b+0x50>
 101056c:	31800434 	orhi	r6,r6,16
 1010570:	d9800015 	stw	r6,0(sp)
 1010574:	a0002426 	beq	r20,zero,1010608 <__d2b+0xe8>
 1010578:	d9000104 	addi	r4,sp,4
 101057c:	dd000115 	stw	r20,4(sp)
 1010580:	100fbe80 	call	100fbe8 <__lo0bits>
 1010584:	d8c00017 	ldw	r3,0(sp)
 1010588:	10002f1e 	bne	r2,zero,1010648 <__d2b+0x128>
 101058c:	d9000117 	ldw	r4,4(sp)
 1010590:	99000515 	stw	r4,20(r19)
 1010594:	1821003a 	cmpeq	r16,r3,zero
 1010598:	01000084 	movi	r4,2
 101059c:	2421c83a 	sub	r16,r4,r16
 10105a0:	98c00615 	stw	r3,24(r19)
 10105a4:	9c000415 	stw	r16,16(r19)
 10105a8:	88001f1e 	bne	r17,zero,1010628 <__d2b+0x108>
 10105ac:	10bef384 	addi	r2,r2,-1074
 10105b0:	90800015 	stw	r2,0(r18)
 10105b4:	00900034 	movhi	r2,16384
 10105b8:	10bfffc4 	addi	r2,r2,-1
 10105bc:	8085883a 	add	r2,r16,r2
 10105c0:	1085883a 	add	r2,r2,r2
 10105c4:	1085883a 	add	r2,r2,r2
 10105c8:	9885883a 	add	r2,r19,r2
 10105cc:	11000517 	ldw	r4,20(r2)
 10105d0:	8020917a 	slli	r16,r16,5
 10105d4:	100fb800 	call	100fb80 <__hi0bits>
 10105d8:	d8c00817 	ldw	r3,32(sp)
 10105dc:	8085c83a 	sub	r2,r16,r2
 10105e0:	18800015 	stw	r2,0(r3)
 10105e4:	9805883a 	mov	r2,r19
 10105e8:	dfc00717 	ldw	ra,28(sp)
 10105ec:	dd000617 	ldw	r20,24(sp)
 10105f0:	dcc00517 	ldw	r19,20(sp)
 10105f4:	dc800417 	ldw	r18,16(sp)
 10105f8:	dc400317 	ldw	r17,12(sp)
 10105fc:	dc000217 	ldw	r16,8(sp)
 1010600:	dec00804 	addi	sp,sp,32
 1010604:	f800283a 	ret
 1010608:	d809883a 	mov	r4,sp
 101060c:	100fbe80 	call	100fbe8 <__lo0bits>
 1010610:	d8c00017 	ldw	r3,0(sp)
 1010614:	04000044 	movi	r16,1
 1010618:	9c000415 	stw	r16,16(r19)
 101061c:	98c00515 	stw	r3,20(r19)
 1010620:	10800804 	addi	r2,r2,32
 1010624:	883fe126 	beq	r17,zero,10105ac <__alt_data_end+0xff8105ac>
 1010628:	00c00d44 	movi	r3,53
 101062c:	8c7ef344 	addi	r17,r17,-1075
 1010630:	88a3883a 	add	r17,r17,r2
 1010634:	1885c83a 	sub	r2,r3,r2
 1010638:	d8c00817 	ldw	r3,32(sp)
 101063c:	94400015 	stw	r17,0(r18)
 1010640:	18800015 	stw	r2,0(r3)
 1010644:	003fe706 	br	10105e4 <__alt_data_end+0xff8105e4>
 1010648:	01000804 	movi	r4,32
 101064c:	2089c83a 	sub	r4,r4,r2
 1010650:	1908983a 	sll	r4,r3,r4
 1010654:	d9400117 	ldw	r5,4(sp)
 1010658:	1886d83a 	srl	r3,r3,r2
 101065c:	2148b03a 	or	r4,r4,r5
 1010660:	99000515 	stw	r4,20(r19)
 1010664:	d8c00015 	stw	r3,0(sp)
 1010668:	003fca06 	br	1010594 <__alt_data_end+0xff810594>

0101066c <__ratio>:
 101066c:	defff904 	addi	sp,sp,-28
 1010670:	dc400315 	stw	r17,12(sp)
 1010674:	2823883a 	mov	r17,r5
 1010678:	d9400104 	addi	r5,sp,4
 101067c:	dfc00615 	stw	ra,24(sp)
 1010680:	dcc00515 	stw	r19,20(sp)
 1010684:	dc800415 	stw	r18,16(sp)
 1010688:	2027883a 	mov	r19,r4
 101068c:	dc000215 	stw	r16,8(sp)
 1010690:	10104140 	call	1010414 <__b2d>
 1010694:	d80b883a 	mov	r5,sp
 1010698:	8809883a 	mov	r4,r17
 101069c:	1025883a 	mov	r18,r2
 10106a0:	1821883a 	mov	r16,r3
 10106a4:	10104140 	call	1010414 <__b2d>
 10106a8:	8a000417 	ldw	r8,16(r17)
 10106ac:	99000417 	ldw	r4,16(r19)
 10106b0:	d9400117 	ldw	r5,4(sp)
 10106b4:	2209c83a 	sub	r4,r4,r8
 10106b8:	2010917a 	slli	r8,r4,5
 10106bc:	d9000017 	ldw	r4,0(sp)
 10106c0:	2909c83a 	sub	r4,r5,r4
 10106c4:	4109883a 	add	r4,r8,r4
 10106c8:	01000e0e 	bge	zero,r4,1010704 <__ratio+0x98>
 10106cc:	2008953a 	slli	r4,r4,20
 10106d0:	2421883a 	add	r16,r4,r16
 10106d4:	100d883a 	mov	r6,r2
 10106d8:	180f883a 	mov	r7,r3
 10106dc:	9009883a 	mov	r4,r18
 10106e0:	800b883a 	mov	r5,r16
 10106e4:	101450c0 	call	101450c <__divdf3>
 10106e8:	dfc00617 	ldw	ra,24(sp)
 10106ec:	dcc00517 	ldw	r19,20(sp)
 10106f0:	dc800417 	ldw	r18,16(sp)
 10106f4:	dc400317 	ldw	r17,12(sp)
 10106f8:	dc000217 	ldw	r16,8(sp)
 10106fc:	dec00704 	addi	sp,sp,28
 1010700:	f800283a 	ret
 1010704:	2008953a 	slli	r4,r4,20
 1010708:	1907c83a 	sub	r3,r3,r4
 101070c:	003ff106 	br	10106d4 <__alt_data_end+0xff8106d4>

01010710 <_mprec_log10>:
 1010710:	defffe04 	addi	sp,sp,-8
 1010714:	dc000015 	stw	r16,0(sp)
 1010718:	dfc00115 	stw	ra,4(sp)
 101071c:	008005c4 	movi	r2,23
 1010720:	2021883a 	mov	r16,r4
 1010724:	11000d0e 	bge	r2,r4,101075c <_mprec_log10+0x4c>
 1010728:	0005883a 	mov	r2,zero
 101072c:	00cffc34 	movhi	r3,16368
 1010730:	843fffc4 	addi	r16,r16,-1
 1010734:	000d883a 	mov	r6,zero
 1010738:	01d00934 	movhi	r7,16420
 101073c:	1009883a 	mov	r4,r2
 1010740:	180b883a 	mov	r5,r3
 1010744:	101504c0 	call	101504c <__muldf3>
 1010748:	803ff91e 	bne	r16,zero,1010730 <__alt_data_end+0xff810730>
 101074c:	dfc00117 	ldw	ra,4(sp)
 1010750:	dc000017 	ldw	r16,0(sp)
 1010754:	dec00204 	addi	sp,sp,8
 1010758:	f800283a 	ret
 101075c:	202090fa 	slli	r16,r4,3
 1010760:	008040b4 	movhi	r2,258
 1010764:	10ab2d04 	addi	r2,r2,-21324
 1010768:	1421883a 	add	r16,r2,r16
 101076c:	80800017 	ldw	r2,0(r16)
 1010770:	80c00117 	ldw	r3,4(r16)
 1010774:	dfc00117 	ldw	ra,4(sp)
 1010778:	dc000017 	ldw	r16,0(sp)
 101077c:	dec00204 	addi	sp,sp,8
 1010780:	f800283a 	ret

01010784 <__copybits>:
 1010784:	297fffc4 	addi	r5,r5,-1
 1010788:	280fd17a 	srai	r7,r5,5
 101078c:	30c00417 	ldw	r3,16(r6)
 1010790:	30800504 	addi	r2,r6,20
 1010794:	39c00044 	addi	r7,r7,1
 1010798:	18c7883a 	add	r3,r3,r3
 101079c:	39cf883a 	add	r7,r7,r7
 10107a0:	18c7883a 	add	r3,r3,r3
 10107a4:	39cf883a 	add	r7,r7,r7
 10107a8:	10c7883a 	add	r3,r2,r3
 10107ac:	21cf883a 	add	r7,r4,r7
 10107b0:	10c00d2e 	bgeu	r2,r3,10107e8 <__copybits+0x64>
 10107b4:	200b883a 	mov	r5,r4
 10107b8:	12000017 	ldw	r8,0(r2)
 10107bc:	29400104 	addi	r5,r5,4
 10107c0:	10800104 	addi	r2,r2,4
 10107c4:	2a3fff15 	stw	r8,-4(r5)
 10107c8:	10fffb36 	bltu	r2,r3,10107b8 <__alt_data_end+0xff8107b8>
 10107cc:	1985c83a 	sub	r2,r3,r6
 10107d0:	10bffac4 	addi	r2,r2,-21
 10107d4:	1004d0ba 	srli	r2,r2,2
 10107d8:	10800044 	addi	r2,r2,1
 10107dc:	1085883a 	add	r2,r2,r2
 10107e0:	1085883a 	add	r2,r2,r2
 10107e4:	2089883a 	add	r4,r4,r2
 10107e8:	21c0032e 	bgeu	r4,r7,10107f8 <__copybits+0x74>
 10107ec:	20000015 	stw	zero,0(r4)
 10107f0:	21000104 	addi	r4,r4,4
 10107f4:	21fffd36 	bltu	r4,r7,10107ec <__alt_data_end+0xff8107ec>
 10107f8:	f800283a 	ret

010107fc <__any_on>:
 10107fc:	20c00417 	ldw	r3,16(r4)
 1010800:	2805d17a 	srai	r2,r5,5
 1010804:	21000504 	addi	r4,r4,20
 1010808:	18800d0e 	bge	r3,r2,1010840 <__any_on+0x44>
 101080c:	18c7883a 	add	r3,r3,r3
 1010810:	18c7883a 	add	r3,r3,r3
 1010814:	20c7883a 	add	r3,r4,r3
 1010818:	20c0192e 	bgeu	r4,r3,1010880 <__any_on+0x84>
 101081c:	18bfff17 	ldw	r2,-4(r3)
 1010820:	18ffff04 	addi	r3,r3,-4
 1010824:	1000041e 	bne	r2,zero,1010838 <__any_on+0x3c>
 1010828:	20c0142e 	bgeu	r4,r3,101087c <__any_on+0x80>
 101082c:	18ffff04 	addi	r3,r3,-4
 1010830:	19400017 	ldw	r5,0(r3)
 1010834:	283ffc26 	beq	r5,zero,1010828 <__alt_data_end+0xff810828>
 1010838:	00800044 	movi	r2,1
 101083c:	f800283a 	ret
 1010840:	10c00a0e 	bge	r2,r3,101086c <__any_on+0x70>
 1010844:	1085883a 	add	r2,r2,r2
 1010848:	1085883a 	add	r2,r2,r2
 101084c:	294007cc 	andi	r5,r5,31
 1010850:	2087883a 	add	r3,r4,r2
 1010854:	283ff026 	beq	r5,zero,1010818 <__alt_data_end+0xff810818>
 1010858:	19800017 	ldw	r6,0(r3)
 101085c:	3144d83a 	srl	r2,r6,r5
 1010860:	114a983a 	sll	r5,r2,r5
 1010864:	317ff41e 	bne	r6,r5,1010838 <__alt_data_end+0xff810838>
 1010868:	003feb06 	br	1010818 <__alt_data_end+0xff810818>
 101086c:	1085883a 	add	r2,r2,r2
 1010870:	1085883a 	add	r2,r2,r2
 1010874:	2087883a 	add	r3,r4,r2
 1010878:	003fe706 	br	1010818 <__alt_data_end+0xff810818>
 101087c:	f800283a 	ret
 1010880:	0005883a 	mov	r2,zero
 1010884:	f800283a 	ret

01010888 <_putc_r>:
 1010888:	defffc04 	addi	sp,sp,-16
 101088c:	dc000215 	stw	r16,8(sp)
 1010890:	dfc00315 	stw	ra,12(sp)
 1010894:	2021883a 	mov	r16,r4
 1010898:	20000226 	beq	r4,zero,10108a4 <_putc_r+0x1c>
 101089c:	20800e17 	ldw	r2,56(r4)
 10108a0:	10001b26 	beq	r2,zero,1010910 <_putc_r+0x88>
 10108a4:	30800217 	ldw	r2,8(r6)
 10108a8:	10bfffc4 	addi	r2,r2,-1
 10108ac:	30800215 	stw	r2,8(r6)
 10108b0:	10000a16 	blt	r2,zero,10108dc <_putc_r+0x54>
 10108b4:	30800017 	ldw	r2,0(r6)
 10108b8:	11400005 	stb	r5,0(r2)
 10108bc:	30800017 	ldw	r2,0(r6)
 10108c0:	10c00044 	addi	r3,r2,1
 10108c4:	30c00015 	stw	r3,0(r6)
 10108c8:	10800003 	ldbu	r2,0(r2)
 10108cc:	dfc00317 	ldw	ra,12(sp)
 10108d0:	dc000217 	ldw	r16,8(sp)
 10108d4:	dec00404 	addi	sp,sp,16
 10108d8:	f800283a 	ret
 10108dc:	30c00617 	ldw	r3,24(r6)
 10108e0:	10c00616 	blt	r2,r3,10108fc <_putc_r+0x74>
 10108e4:	30800017 	ldw	r2,0(r6)
 10108e8:	00c00284 	movi	r3,10
 10108ec:	11400005 	stb	r5,0(r2)
 10108f0:	30800017 	ldw	r2,0(r6)
 10108f4:	11400003 	ldbu	r5,0(r2)
 10108f8:	28fff11e 	bne	r5,r3,10108c0 <__alt_data_end+0xff8108c0>
 10108fc:	8009883a 	mov	r4,r16
 1010900:	dfc00317 	ldw	ra,12(sp)
 1010904:	dc000217 	ldw	r16,8(sp)
 1010908:	dec00404 	addi	sp,sp,16
 101090c:	101287c1 	jmpi	101287c <__swbuf_r>
 1010910:	d9400015 	stw	r5,0(sp)
 1010914:	d9800115 	stw	r6,4(sp)
 1010918:	100e0e00 	call	100e0e0 <__sinit>
 101091c:	d9800117 	ldw	r6,4(sp)
 1010920:	d9400017 	ldw	r5,0(sp)
 1010924:	003fdf06 	br	10108a4 <__alt_data_end+0xff8108a4>

01010928 <putc>:
 1010928:	008040b4 	movhi	r2,258
 101092c:	defffc04 	addi	sp,sp,-16
 1010930:	10b39b04 	addi	r2,r2,-12692
 1010934:	dc000115 	stw	r16,4(sp)
 1010938:	14000017 	ldw	r16,0(r2)
 101093c:	dc400215 	stw	r17,8(sp)
 1010940:	dfc00315 	stw	ra,12(sp)
 1010944:	2023883a 	mov	r17,r4
 1010948:	80000226 	beq	r16,zero,1010954 <putc+0x2c>
 101094c:	80800e17 	ldw	r2,56(r16)
 1010950:	10001a26 	beq	r2,zero,10109bc <putc+0x94>
 1010954:	28800217 	ldw	r2,8(r5)
 1010958:	10bfffc4 	addi	r2,r2,-1
 101095c:	28800215 	stw	r2,8(r5)
 1010960:	10000b16 	blt	r2,zero,1010990 <putc+0x68>
 1010964:	28800017 	ldw	r2,0(r5)
 1010968:	14400005 	stb	r17,0(r2)
 101096c:	28800017 	ldw	r2,0(r5)
 1010970:	10c00044 	addi	r3,r2,1
 1010974:	28c00015 	stw	r3,0(r5)
 1010978:	10800003 	ldbu	r2,0(r2)
 101097c:	dfc00317 	ldw	ra,12(sp)
 1010980:	dc400217 	ldw	r17,8(sp)
 1010984:	dc000117 	ldw	r16,4(sp)
 1010988:	dec00404 	addi	sp,sp,16
 101098c:	f800283a 	ret
 1010990:	28c00617 	ldw	r3,24(r5)
 1010994:	10c00e16 	blt	r2,r3,10109d0 <putc+0xa8>
 1010998:	28800017 	ldw	r2,0(r5)
 101099c:	01000284 	movi	r4,10
 10109a0:	14400005 	stb	r17,0(r2)
 10109a4:	28800017 	ldw	r2,0(r5)
 10109a8:	10c00003 	ldbu	r3,0(r2)
 10109ac:	193ff01e 	bne	r3,r4,1010970 <__alt_data_end+0xff810970>
 10109b0:	280d883a 	mov	r6,r5
 10109b4:	180b883a 	mov	r5,r3
 10109b8:	00000706 	br	10109d8 <putc+0xb0>
 10109bc:	8009883a 	mov	r4,r16
 10109c0:	d9400015 	stw	r5,0(sp)
 10109c4:	100e0e00 	call	100e0e0 <__sinit>
 10109c8:	d9400017 	ldw	r5,0(sp)
 10109cc:	003fe106 	br	1010954 <__alt_data_end+0xff810954>
 10109d0:	280d883a 	mov	r6,r5
 10109d4:	880b883a 	mov	r5,r17
 10109d8:	8009883a 	mov	r4,r16
 10109dc:	dfc00317 	ldw	ra,12(sp)
 10109e0:	dc400217 	ldw	r17,8(sp)
 10109e4:	dc000117 	ldw	r16,4(sp)
 10109e8:	dec00404 	addi	sp,sp,16
 10109ec:	101287c1 	jmpi	101287c <__swbuf_r>

010109f0 <_realloc_r>:
 10109f0:	defff604 	addi	sp,sp,-40
 10109f4:	dc800215 	stw	r18,8(sp)
 10109f8:	dfc00915 	stw	ra,36(sp)
 10109fc:	df000815 	stw	fp,32(sp)
 1010a00:	ddc00715 	stw	r23,28(sp)
 1010a04:	dd800615 	stw	r22,24(sp)
 1010a08:	dd400515 	stw	r21,20(sp)
 1010a0c:	dd000415 	stw	r20,16(sp)
 1010a10:	dcc00315 	stw	r19,12(sp)
 1010a14:	dc400115 	stw	r17,4(sp)
 1010a18:	dc000015 	stw	r16,0(sp)
 1010a1c:	3025883a 	mov	r18,r6
 1010a20:	2800b726 	beq	r5,zero,1010d00 <_realloc_r+0x310>
 1010a24:	282b883a 	mov	r21,r5
 1010a28:	2029883a 	mov	r20,r4
 1010a2c:	10168a40 	call	10168a4 <__malloc_lock>
 1010a30:	a8bfff17 	ldw	r2,-4(r21)
 1010a34:	043fff04 	movi	r16,-4
 1010a38:	90c002c4 	addi	r3,r18,11
 1010a3c:	01000584 	movi	r4,22
 1010a40:	acfffe04 	addi	r19,r21,-8
 1010a44:	1420703a 	and	r16,r2,r16
 1010a48:	20c0332e 	bgeu	r4,r3,1010b18 <_realloc_r+0x128>
 1010a4c:	047ffe04 	movi	r17,-8
 1010a50:	1c62703a 	and	r17,r3,r17
 1010a54:	8807883a 	mov	r3,r17
 1010a58:	88005816 	blt	r17,zero,1010bbc <_realloc_r+0x1cc>
 1010a5c:	8c805736 	bltu	r17,r18,1010bbc <_realloc_r+0x1cc>
 1010a60:	80c0300e 	bge	r16,r3,1010b24 <_realloc_r+0x134>
 1010a64:	070040b4 	movhi	fp,258
 1010a68:	e72d6e04 	addi	fp,fp,-19016
 1010a6c:	e1c00217 	ldw	r7,8(fp)
 1010a70:	9c09883a 	add	r4,r19,r16
 1010a74:	22000117 	ldw	r8,4(r4)
 1010a78:	21c06326 	beq	r4,r7,1010c08 <_realloc_r+0x218>
 1010a7c:	017fff84 	movi	r5,-2
 1010a80:	414a703a 	and	r5,r8,r5
 1010a84:	214b883a 	add	r5,r4,r5
 1010a88:	29800117 	ldw	r6,4(r5)
 1010a8c:	3180004c 	andi	r6,r6,1
 1010a90:	30003f26 	beq	r6,zero,1010b90 <_realloc_r+0x1a0>
 1010a94:	1080004c 	andi	r2,r2,1
 1010a98:	10008326 	beq	r2,zero,1010ca8 <_realloc_r+0x2b8>
 1010a9c:	900b883a 	mov	r5,r18
 1010aa0:	a009883a 	mov	r4,r20
 1010aa4:	100ee400 	call	100ee40 <_malloc_r>
 1010aa8:	1025883a 	mov	r18,r2
 1010aac:	10011e26 	beq	r2,zero,1010f28 <_realloc_r+0x538>
 1010ab0:	a93fff17 	ldw	r4,-4(r21)
 1010ab4:	10fffe04 	addi	r3,r2,-8
 1010ab8:	00bfff84 	movi	r2,-2
 1010abc:	2084703a 	and	r2,r4,r2
 1010ac0:	9885883a 	add	r2,r19,r2
 1010ac4:	1880ee26 	beq	r3,r2,1010e80 <_realloc_r+0x490>
 1010ac8:	81bfff04 	addi	r6,r16,-4
 1010acc:	00800904 	movi	r2,36
 1010ad0:	1180b836 	bltu	r2,r6,1010db4 <_realloc_r+0x3c4>
 1010ad4:	00c004c4 	movi	r3,19
 1010ad8:	19809636 	bltu	r3,r6,1010d34 <_realloc_r+0x344>
 1010adc:	9005883a 	mov	r2,r18
 1010ae0:	a807883a 	mov	r3,r21
 1010ae4:	19000017 	ldw	r4,0(r3)
 1010ae8:	11000015 	stw	r4,0(r2)
 1010aec:	19000117 	ldw	r4,4(r3)
 1010af0:	11000115 	stw	r4,4(r2)
 1010af4:	18c00217 	ldw	r3,8(r3)
 1010af8:	10c00215 	stw	r3,8(r2)
 1010afc:	a80b883a 	mov	r5,r21
 1010b00:	a009883a 	mov	r4,r20
 1010b04:	100e2540 	call	100e254 <_free_r>
 1010b08:	a009883a 	mov	r4,r20
 1010b0c:	10168c80 	call	10168c8 <__malloc_unlock>
 1010b10:	9005883a 	mov	r2,r18
 1010b14:	00001206 	br	1010b60 <_realloc_r+0x170>
 1010b18:	00c00404 	movi	r3,16
 1010b1c:	1823883a 	mov	r17,r3
 1010b20:	003fce06 	br	1010a5c <__alt_data_end+0xff810a5c>
 1010b24:	a825883a 	mov	r18,r21
 1010b28:	8445c83a 	sub	r2,r16,r17
 1010b2c:	00c003c4 	movi	r3,15
 1010b30:	18802636 	bltu	r3,r2,1010bcc <_realloc_r+0x1dc>
 1010b34:	99800117 	ldw	r6,4(r19)
 1010b38:	9c07883a 	add	r3,r19,r16
 1010b3c:	3180004c 	andi	r6,r6,1
 1010b40:	3420b03a 	or	r16,r6,r16
 1010b44:	9c000115 	stw	r16,4(r19)
 1010b48:	18800117 	ldw	r2,4(r3)
 1010b4c:	10800054 	ori	r2,r2,1
 1010b50:	18800115 	stw	r2,4(r3)
 1010b54:	a009883a 	mov	r4,r20
 1010b58:	10168c80 	call	10168c8 <__malloc_unlock>
 1010b5c:	9005883a 	mov	r2,r18
 1010b60:	dfc00917 	ldw	ra,36(sp)
 1010b64:	df000817 	ldw	fp,32(sp)
 1010b68:	ddc00717 	ldw	r23,28(sp)
 1010b6c:	dd800617 	ldw	r22,24(sp)
 1010b70:	dd400517 	ldw	r21,20(sp)
 1010b74:	dd000417 	ldw	r20,16(sp)
 1010b78:	dcc00317 	ldw	r19,12(sp)
 1010b7c:	dc800217 	ldw	r18,8(sp)
 1010b80:	dc400117 	ldw	r17,4(sp)
 1010b84:	dc000017 	ldw	r16,0(sp)
 1010b88:	dec00a04 	addi	sp,sp,40
 1010b8c:	f800283a 	ret
 1010b90:	017fff04 	movi	r5,-4
 1010b94:	414a703a 	and	r5,r8,r5
 1010b98:	814d883a 	add	r6,r16,r5
 1010b9c:	30c01f16 	blt	r6,r3,1010c1c <_realloc_r+0x22c>
 1010ba0:	20800317 	ldw	r2,12(r4)
 1010ba4:	20c00217 	ldw	r3,8(r4)
 1010ba8:	a825883a 	mov	r18,r21
 1010bac:	3021883a 	mov	r16,r6
 1010bb0:	18800315 	stw	r2,12(r3)
 1010bb4:	10c00215 	stw	r3,8(r2)
 1010bb8:	003fdb06 	br	1010b28 <__alt_data_end+0xff810b28>
 1010bbc:	00800304 	movi	r2,12
 1010bc0:	a0800015 	stw	r2,0(r20)
 1010bc4:	0005883a 	mov	r2,zero
 1010bc8:	003fe506 	br	1010b60 <__alt_data_end+0xff810b60>
 1010bcc:	98c00117 	ldw	r3,4(r19)
 1010bd0:	9c4b883a 	add	r5,r19,r17
 1010bd4:	11000054 	ori	r4,r2,1
 1010bd8:	18c0004c 	andi	r3,r3,1
 1010bdc:	1c62b03a 	or	r17,r3,r17
 1010be0:	9c400115 	stw	r17,4(r19)
 1010be4:	29000115 	stw	r4,4(r5)
 1010be8:	2885883a 	add	r2,r5,r2
 1010bec:	10c00117 	ldw	r3,4(r2)
 1010bf0:	29400204 	addi	r5,r5,8
 1010bf4:	a009883a 	mov	r4,r20
 1010bf8:	18c00054 	ori	r3,r3,1
 1010bfc:	10c00115 	stw	r3,4(r2)
 1010c00:	100e2540 	call	100e254 <_free_r>
 1010c04:	003fd306 	br	1010b54 <__alt_data_end+0xff810b54>
 1010c08:	017fff04 	movi	r5,-4
 1010c0c:	414a703a 	and	r5,r8,r5
 1010c10:	89800404 	addi	r6,r17,16
 1010c14:	8151883a 	add	r8,r16,r5
 1010c18:	4180590e 	bge	r8,r6,1010d80 <_realloc_r+0x390>
 1010c1c:	1080004c 	andi	r2,r2,1
 1010c20:	103f9e1e 	bne	r2,zero,1010a9c <__alt_data_end+0xff810a9c>
 1010c24:	adbffe17 	ldw	r22,-8(r21)
 1010c28:	00bfff04 	movi	r2,-4
 1010c2c:	9dadc83a 	sub	r22,r19,r22
 1010c30:	b1800117 	ldw	r6,4(r22)
 1010c34:	3084703a 	and	r2,r6,r2
 1010c38:	20002026 	beq	r4,zero,1010cbc <_realloc_r+0x2cc>
 1010c3c:	80af883a 	add	r23,r16,r2
 1010c40:	b96f883a 	add	r23,r23,r5
 1010c44:	21c05f26 	beq	r4,r7,1010dc4 <_realloc_r+0x3d4>
 1010c48:	b8c01c16 	blt	r23,r3,1010cbc <_realloc_r+0x2cc>
 1010c4c:	20800317 	ldw	r2,12(r4)
 1010c50:	20c00217 	ldw	r3,8(r4)
 1010c54:	81bfff04 	addi	r6,r16,-4
 1010c58:	01000904 	movi	r4,36
 1010c5c:	18800315 	stw	r2,12(r3)
 1010c60:	10c00215 	stw	r3,8(r2)
 1010c64:	b0c00217 	ldw	r3,8(r22)
 1010c68:	b0800317 	ldw	r2,12(r22)
 1010c6c:	b4800204 	addi	r18,r22,8
 1010c70:	18800315 	stw	r2,12(r3)
 1010c74:	10c00215 	stw	r3,8(r2)
 1010c78:	21801b36 	bltu	r4,r6,1010ce8 <_realloc_r+0x2f8>
 1010c7c:	008004c4 	movi	r2,19
 1010c80:	1180352e 	bgeu	r2,r6,1010d58 <_realloc_r+0x368>
 1010c84:	a8800017 	ldw	r2,0(r21)
 1010c88:	b0800215 	stw	r2,8(r22)
 1010c8c:	a8800117 	ldw	r2,4(r21)
 1010c90:	b0800315 	stw	r2,12(r22)
 1010c94:	008006c4 	movi	r2,27
 1010c98:	11807f36 	bltu	r2,r6,1010e98 <_realloc_r+0x4a8>
 1010c9c:	b0800404 	addi	r2,r22,16
 1010ca0:	ad400204 	addi	r21,r21,8
 1010ca4:	00002d06 	br	1010d5c <_realloc_r+0x36c>
 1010ca8:	adbffe17 	ldw	r22,-8(r21)
 1010cac:	00bfff04 	movi	r2,-4
 1010cb0:	9dadc83a 	sub	r22,r19,r22
 1010cb4:	b1000117 	ldw	r4,4(r22)
 1010cb8:	2084703a 	and	r2,r4,r2
 1010cbc:	b03f7726 	beq	r22,zero,1010a9c <__alt_data_end+0xff810a9c>
 1010cc0:	80af883a 	add	r23,r16,r2
 1010cc4:	b8ff7516 	blt	r23,r3,1010a9c <__alt_data_end+0xff810a9c>
 1010cc8:	b0800317 	ldw	r2,12(r22)
 1010ccc:	b0c00217 	ldw	r3,8(r22)
 1010cd0:	81bfff04 	addi	r6,r16,-4
 1010cd4:	01000904 	movi	r4,36
 1010cd8:	18800315 	stw	r2,12(r3)
 1010cdc:	10c00215 	stw	r3,8(r2)
 1010ce0:	b4800204 	addi	r18,r22,8
 1010ce4:	21bfe52e 	bgeu	r4,r6,1010c7c <__alt_data_end+0xff810c7c>
 1010ce8:	a80b883a 	mov	r5,r21
 1010cec:	9009883a 	mov	r4,r18
 1010cf0:	100f7300 	call	100f730 <memmove>
 1010cf4:	b821883a 	mov	r16,r23
 1010cf8:	b027883a 	mov	r19,r22
 1010cfc:	003f8a06 	br	1010b28 <__alt_data_end+0xff810b28>
 1010d00:	300b883a 	mov	r5,r6
 1010d04:	dfc00917 	ldw	ra,36(sp)
 1010d08:	df000817 	ldw	fp,32(sp)
 1010d0c:	ddc00717 	ldw	r23,28(sp)
 1010d10:	dd800617 	ldw	r22,24(sp)
 1010d14:	dd400517 	ldw	r21,20(sp)
 1010d18:	dd000417 	ldw	r20,16(sp)
 1010d1c:	dcc00317 	ldw	r19,12(sp)
 1010d20:	dc800217 	ldw	r18,8(sp)
 1010d24:	dc400117 	ldw	r17,4(sp)
 1010d28:	dc000017 	ldw	r16,0(sp)
 1010d2c:	dec00a04 	addi	sp,sp,40
 1010d30:	100ee401 	jmpi	100ee40 <_malloc_r>
 1010d34:	a8c00017 	ldw	r3,0(r21)
 1010d38:	90c00015 	stw	r3,0(r18)
 1010d3c:	a8c00117 	ldw	r3,4(r21)
 1010d40:	90c00115 	stw	r3,4(r18)
 1010d44:	00c006c4 	movi	r3,27
 1010d48:	19804536 	bltu	r3,r6,1010e60 <_realloc_r+0x470>
 1010d4c:	90800204 	addi	r2,r18,8
 1010d50:	a8c00204 	addi	r3,r21,8
 1010d54:	003f6306 	br	1010ae4 <__alt_data_end+0xff810ae4>
 1010d58:	9005883a 	mov	r2,r18
 1010d5c:	a8c00017 	ldw	r3,0(r21)
 1010d60:	b821883a 	mov	r16,r23
 1010d64:	b027883a 	mov	r19,r22
 1010d68:	10c00015 	stw	r3,0(r2)
 1010d6c:	a8c00117 	ldw	r3,4(r21)
 1010d70:	10c00115 	stw	r3,4(r2)
 1010d74:	a8c00217 	ldw	r3,8(r21)
 1010d78:	10c00215 	stw	r3,8(r2)
 1010d7c:	003f6a06 	br	1010b28 <__alt_data_end+0xff810b28>
 1010d80:	9c67883a 	add	r19,r19,r17
 1010d84:	4445c83a 	sub	r2,r8,r17
 1010d88:	e4c00215 	stw	r19,8(fp)
 1010d8c:	10800054 	ori	r2,r2,1
 1010d90:	98800115 	stw	r2,4(r19)
 1010d94:	a8bfff17 	ldw	r2,-4(r21)
 1010d98:	a009883a 	mov	r4,r20
 1010d9c:	1080004c 	andi	r2,r2,1
 1010da0:	1462b03a 	or	r17,r2,r17
 1010da4:	ac7fff15 	stw	r17,-4(r21)
 1010da8:	10168c80 	call	10168c8 <__malloc_unlock>
 1010dac:	a805883a 	mov	r2,r21
 1010db0:	003f6b06 	br	1010b60 <__alt_data_end+0xff810b60>
 1010db4:	a80b883a 	mov	r5,r21
 1010db8:	9009883a 	mov	r4,r18
 1010dbc:	100f7300 	call	100f730 <memmove>
 1010dc0:	003f4e06 	br	1010afc <__alt_data_end+0xff810afc>
 1010dc4:	89000404 	addi	r4,r17,16
 1010dc8:	b93fbc16 	blt	r23,r4,1010cbc <__alt_data_end+0xff810cbc>
 1010dcc:	b0800317 	ldw	r2,12(r22)
 1010dd0:	b0c00217 	ldw	r3,8(r22)
 1010dd4:	81bfff04 	addi	r6,r16,-4
 1010dd8:	01000904 	movi	r4,36
 1010ddc:	18800315 	stw	r2,12(r3)
 1010de0:	10c00215 	stw	r3,8(r2)
 1010de4:	b4800204 	addi	r18,r22,8
 1010de8:	21804336 	bltu	r4,r6,1010ef8 <_realloc_r+0x508>
 1010dec:	008004c4 	movi	r2,19
 1010df0:	11803f2e 	bgeu	r2,r6,1010ef0 <_realloc_r+0x500>
 1010df4:	a8800017 	ldw	r2,0(r21)
 1010df8:	b0800215 	stw	r2,8(r22)
 1010dfc:	a8800117 	ldw	r2,4(r21)
 1010e00:	b0800315 	stw	r2,12(r22)
 1010e04:	008006c4 	movi	r2,27
 1010e08:	11803f36 	bltu	r2,r6,1010f08 <_realloc_r+0x518>
 1010e0c:	b0800404 	addi	r2,r22,16
 1010e10:	ad400204 	addi	r21,r21,8
 1010e14:	a8c00017 	ldw	r3,0(r21)
 1010e18:	10c00015 	stw	r3,0(r2)
 1010e1c:	a8c00117 	ldw	r3,4(r21)
 1010e20:	10c00115 	stw	r3,4(r2)
 1010e24:	a8c00217 	ldw	r3,8(r21)
 1010e28:	10c00215 	stw	r3,8(r2)
 1010e2c:	b447883a 	add	r3,r22,r17
 1010e30:	bc45c83a 	sub	r2,r23,r17
 1010e34:	e0c00215 	stw	r3,8(fp)
 1010e38:	10800054 	ori	r2,r2,1
 1010e3c:	18800115 	stw	r2,4(r3)
 1010e40:	b0800117 	ldw	r2,4(r22)
 1010e44:	a009883a 	mov	r4,r20
 1010e48:	1080004c 	andi	r2,r2,1
 1010e4c:	1462b03a 	or	r17,r2,r17
 1010e50:	b4400115 	stw	r17,4(r22)
 1010e54:	10168c80 	call	10168c8 <__malloc_unlock>
 1010e58:	9005883a 	mov	r2,r18
 1010e5c:	003f4006 	br	1010b60 <__alt_data_end+0xff810b60>
 1010e60:	a8c00217 	ldw	r3,8(r21)
 1010e64:	90c00215 	stw	r3,8(r18)
 1010e68:	a8c00317 	ldw	r3,12(r21)
 1010e6c:	90c00315 	stw	r3,12(r18)
 1010e70:	30801126 	beq	r6,r2,1010eb8 <_realloc_r+0x4c8>
 1010e74:	90800404 	addi	r2,r18,16
 1010e78:	a8c00404 	addi	r3,r21,16
 1010e7c:	003f1906 	br	1010ae4 <__alt_data_end+0xff810ae4>
 1010e80:	90ffff17 	ldw	r3,-4(r18)
 1010e84:	00bfff04 	movi	r2,-4
 1010e88:	a825883a 	mov	r18,r21
 1010e8c:	1884703a 	and	r2,r3,r2
 1010e90:	80a1883a 	add	r16,r16,r2
 1010e94:	003f2406 	br	1010b28 <__alt_data_end+0xff810b28>
 1010e98:	a8800217 	ldw	r2,8(r21)
 1010e9c:	b0800415 	stw	r2,16(r22)
 1010ea0:	a8800317 	ldw	r2,12(r21)
 1010ea4:	b0800515 	stw	r2,20(r22)
 1010ea8:	31000a26 	beq	r6,r4,1010ed4 <_realloc_r+0x4e4>
 1010eac:	b0800604 	addi	r2,r22,24
 1010eb0:	ad400404 	addi	r21,r21,16
 1010eb4:	003fa906 	br	1010d5c <__alt_data_end+0xff810d5c>
 1010eb8:	a9000417 	ldw	r4,16(r21)
 1010ebc:	90800604 	addi	r2,r18,24
 1010ec0:	a8c00604 	addi	r3,r21,24
 1010ec4:	91000415 	stw	r4,16(r18)
 1010ec8:	a9000517 	ldw	r4,20(r21)
 1010ecc:	91000515 	stw	r4,20(r18)
 1010ed0:	003f0406 	br	1010ae4 <__alt_data_end+0xff810ae4>
 1010ed4:	a8c00417 	ldw	r3,16(r21)
 1010ed8:	ad400604 	addi	r21,r21,24
 1010edc:	b0800804 	addi	r2,r22,32
 1010ee0:	b0c00615 	stw	r3,24(r22)
 1010ee4:	a8ffff17 	ldw	r3,-4(r21)
 1010ee8:	b0c00715 	stw	r3,28(r22)
 1010eec:	003f9b06 	br	1010d5c <__alt_data_end+0xff810d5c>
 1010ef0:	9005883a 	mov	r2,r18
 1010ef4:	003fc706 	br	1010e14 <__alt_data_end+0xff810e14>
 1010ef8:	a80b883a 	mov	r5,r21
 1010efc:	9009883a 	mov	r4,r18
 1010f00:	100f7300 	call	100f730 <memmove>
 1010f04:	003fc906 	br	1010e2c <__alt_data_end+0xff810e2c>
 1010f08:	a8800217 	ldw	r2,8(r21)
 1010f0c:	b0800415 	stw	r2,16(r22)
 1010f10:	a8800317 	ldw	r2,12(r21)
 1010f14:	b0800515 	stw	r2,20(r22)
 1010f18:	31000726 	beq	r6,r4,1010f38 <_realloc_r+0x548>
 1010f1c:	b0800604 	addi	r2,r22,24
 1010f20:	ad400404 	addi	r21,r21,16
 1010f24:	003fbb06 	br	1010e14 <__alt_data_end+0xff810e14>
 1010f28:	a009883a 	mov	r4,r20
 1010f2c:	10168c80 	call	10168c8 <__malloc_unlock>
 1010f30:	0005883a 	mov	r2,zero
 1010f34:	003f0a06 	br	1010b60 <__alt_data_end+0xff810b60>
 1010f38:	a8c00417 	ldw	r3,16(r21)
 1010f3c:	ad400604 	addi	r21,r21,24
 1010f40:	b0800804 	addi	r2,r22,32
 1010f44:	b0c00615 	stw	r3,24(r22)
 1010f48:	a8ffff17 	ldw	r3,-4(r21)
 1010f4c:	b0c00715 	stw	r3,28(r22)
 1010f50:	003fb006 	br	1010e14 <__alt_data_end+0xff810e14>

01010f54 <__fpclassifyd>:
 1010f54:	00a00034 	movhi	r2,32768
 1010f58:	10bfffc4 	addi	r2,r2,-1
 1010f5c:	2884703a 	and	r2,r5,r2
 1010f60:	10000726 	beq	r2,zero,1010f80 <__fpclassifyd+0x2c>
 1010f64:	00fffc34 	movhi	r3,65520
 1010f68:	019ff834 	movhi	r6,32736
 1010f6c:	28c7883a 	add	r3,r5,r3
 1010f70:	31bfffc4 	addi	r6,r6,-1
 1010f74:	30c00536 	bltu	r6,r3,1010f8c <__fpclassifyd+0x38>
 1010f78:	00800104 	movi	r2,4
 1010f7c:	f800283a 	ret
 1010f80:	2000021e 	bne	r4,zero,1010f8c <__fpclassifyd+0x38>
 1010f84:	00800084 	movi	r2,2
 1010f88:	f800283a 	ret
 1010f8c:	00dffc34 	movhi	r3,32752
 1010f90:	019ff834 	movhi	r6,32736
 1010f94:	28cb883a 	add	r5,r5,r3
 1010f98:	31bfffc4 	addi	r6,r6,-1
 1010f9c:	317ff62e 	bgeu	r6,r5,1010f78 <__alt_data_end+0xff810f78>
 1010fa0:	01400434 	movhi	r5,16
 1010fa4:	297fffc4 	addi	r5,r5,-1
 1010fa8:	28800236 	bltu	r5,r2,1010fb4 <__fpclassifyd+0x60>
 1010fac:	008000c4 	movi	r2,3
 1010fb0:	f800283a 	ret
 1010fb4:	10c00226 	beq	r2,r3,1010fc0 <__fpclassifyd+0x6c>
 1010fb8:	0005883a 	mov	r2,zero
 1010fbc:	f800283a 	ret
 1010fc0:	2005003a 	cmpeq	r2,r4,zero
 1010fc4:	f800283a 	ret

01010fc8 <_sbrk_r>:
 1010fc8:	defffd04 	addi	sp,sp,-12
 1010fcc:	dc000015 	stw	r16,0(sp)
 1010fd0:	040040b4 	movhi	r16,258
 1010fd4:	dc400115 	stw	r17,4(sp)
 1010fd8:	84342704 	addi	r16,r16,-12132
 1010fdc:	2023883a 	mov	r17,r4
 1010fe0:	2809883a 	mov	r4,r5
 1010fe4:	dfc00215 	stw	ra,8(sp)
 1010fe8:	80000015 	stw	zero,0(r16)
 1010fec:	1016abc0 	call	1016abc <sbrk>
 1010ff0:	00ffffc4 	movi	r3,-1
 1010ff4:	10c00526 	beq	r2,r3,101100c <_sbrk_r+0x44>
 1010ff8:	dfc00217 	ldw	ra,8(sp)
 1010ffc:	dc400117 	ldw	r17,4(sp)
 1011000:	dc000017 	ldw	r16,0(sp)
 1011004:	dec00304 	addi	sp,sp,12
 1011008:	f800283a 	ret
 101100c:	80c00017 	ldw	r3,0(r16)
 1011010:	183ff926 	beq	r3,zero,1010ff8 <__alt_data_end+0xff810ff8>
 1011014:	88c00015 	stw	r3,0(r17)
 1011018:	003ff706 	br	1010ff8 <__alt_data_end+0xff810ff8>

0101101c <__sread>:
 101101c:	defffe04 	addi	sp,sp,-8
 1011020:	dc000015 	stw	r16,0(sp)
 1011024:	2821883a 	mov	r16,r5
 1011028:	2940038f 	ldh	r5,14(r5)
 101102c:	dfc00115 	stw	ra,4(sp)
 1011030:	1012f680 	call	1012f68 <_read_r>
 1011034:	10000716 	blt	r2,zero,1011054 <__sread+0x38>
 1011038:	80c01417 	ldw	r3,80(r16)
 101103c:	1887883a 	add	r3,r3,r2
 1011040:	80c01415 	stw	r3,80(r16)
 1011044:	dfc00117 	ldw	ra,4(sp)
 1011048:	dc000017 	ldw	r16,0(sp)
 101104c:	dec00204 	addi	sp,sp,8
 1011050:	f800283a 	ret
 1011054:	80c0030b 	ldhu	r3,12(r16)
 1011058:	18fbffcc 	andi	r3,r3,61439
 101105c:	80c0030d 	sth	r3,12(r16)
 1011060:	dfc00117 	ldw	ra,4(sp)
 1011064:	dc000017 	ldw	r16,0(sp)
 1011068:	dec00204 	addi	sp,sp,8
 101106c:	f800283a 	ret

01011070 <__seofread>:
 1011070:	0005883a 	mov	r2,zero
 1011074:	f800283a 	ret

01011078 <__swrite>:
 1011078:	2880030b 	ldhu	r2,12(r5)
 101107c:	defffb04 	addi	sp,sp,-20
 1011080:	dcc00315 	stw	r19,12(sp)
 1011084:	dc800215 	stw	r18,8(sp)
 1011088:	dc400115 	stw	r17,4(sp)
 101108c:	dc000015 	stw	r16,0(sp)
 1011090:	dfc00415 	stw	ra,16(sp)
 1011094:	10c0400c 	andi	r3,r2,256
 1011098:	2821883a 	mov	r16,r5
 101109c:	2023883a 	mov	r17,r4
 10110a0:	3025883a 	mov	r18,r6
 10110a4:	3827883a 	mov	r19,r7
 10110a8:	18000526 	beq	r3,zero,10110c0 <__swrite+0x48>
 10110ac:	2940038f 	ldh	r5,14(r5)
 10110b0:	01c00084 	movi	r7,2
 10110b4:	000d883a 	mov	r6,zero
 10110b8:	1012f080 	call	1012f08 <_lseek_r>
 10110bc:	8080030b 	ldhu	r2,12(r16)
 10110c0:	8140038f 	ldh	r5,14(r16)
 10110c4:	10bbffcc 	andi	r2,r2,61439
 10110c8:	980f883a 	mov	r7,r19
 10110cc:	900d883a 	mov	r6,r18
 10110d0:	8809883a 	mov	r4,r17
 10110d4:	8080030d 	sth	r2,12(r16)
 10110d8:	dfc00417 	ldw	ra,16(sp)
 10110dc:	dcc00317 	ldw	r19,12(sp)
 10110e0:	dc800217 	ldw	r18,8(sp)
 10110e4:	dc400117 	ldw	r17,4(sp)
 10110e8:	dc000017 	ldw	r16,0(sp)
 10110ec:	dec00504 	addi	sp,sp,20
 10110f0:	10129d41 	jmpi	10129d4 <_write_r>

010110f4 <__sseek>:
 10110f4:	defffe04 	addi	sp,sp,-8
 10110f8:	dc000015 	stw	r16,0(sp)
 10110fc:	2821883a 	mov	r16,r5
 1011100:	2940038f 	ldh	r5,14(r5)
 1011104:	dfc00115 	stw	ra,4(sp)
 1011108:	1012f080 	call	1012f08 <_lseek_r>
 101110c:	00ffffc4 	movi	r3,-1
 1011110:	10c00826 	beq	r2,r3,1011134 <__sseek+0x40>
 1011114:	80c0030b 	ldhu	r3,12(r16)
 1011118:	80801415 	stw	r2,80(r16)
 101111c:	18c40014 	ori	r3,r3,4096
 1011120:	80c0030d 	sth	r3,12(r16)
 1011124:	dfc00117 	ldw	ra,4(sp)
 1011128:	dc000017 	ldw	r16,0(sp)
 101112c:	dec00204 	addi	sp,sp,8
 1011130:	f800283a 	ret
 1011134:	80c0030b 	ldhu	r3,12(r16)
 1011138:	18fbffcc 	andi	r3,r3,61439
 101113c:	80c0030d 	sth	r3,12(r16)
 1011140:	dfc00117 	ldw	ra,4(sp)
 1011144:	dc000017 	ldw	r16,0(sp)
 1011148:	dec00204 	addi	sp,sp,8
 101114c:	f800283a 	ret

01011150 <__sclose>:
 1011150:	2940038f 	ldh	r5,14(r5)
 1011154:	1012a341 	jmpi	1012a34 <_close_r>

01011158 <strcmp>:
 1011158:	2144b03a 	or	r2,r4,r5
 101115c:	108000cc 	andi	r2,r2,3
 1011160:	1000171e 	bne	r2,zero,10111c0 <strcmp+0x68>
 1011164:	20800017 	ldw	r2,0(r4)
 1011168:	28c00017 	ldw	r3,0(r5)
 101116c:	10c0141e 	bne	r2,r3,10111c0 <strcmp+0x68>
 1011170:	027fbff4 	movhi	r9,65279
 1011174:	4a7fbfc4 	addi	r9,r9,-257
 1011178:	0086303a 	nor	r3,zero,r2
 101117c:	02202074 	movhi	r8,32897
 1011180:	1245883a 	add	r2,r2,r9
 1011184:	42202004 	addi	r8,r8,-32640
 1011188:	10c4703a 	and	r2,r2,r3
 101118c:	1204703a 	and	r2,r2,r8
 1011190:	10000226 	beq	r2,zero,101119c <strcmp+0x44>
 1011194:	00002306 	br	1011224 <strcmp+0xcc>
 1011198:	1000221e 	bne	r2,zero,1011224 <strcmp+0xcc>
 101119c:	21000104 	addi	r4,r4,4
 10111a0:	20c00017 	ldw	r3,0(r4)
 10111a4:	29400104 	addi	r5,r5,4
 10111a8:	29800017 	ldw	r6,0(r5)
 10111ac:	1a4f883a 	add	r7,r3,r9
 10111b0:	00c4303a 	nor	r2,zero,r3
 10111b4:	3884703a 	and	r2,r7,r2
 10111b8:	1204703a 	and	r2,r2,r8
 10111bc:	19bff626 	beq	r3,r6,1011198 <__alt_data_end+0xff811198>
 10111c0:	20800003 	ldbu	r2,0(r4)
 10111c4:	10c03fcc 	andi	r3,r2,255
 10111c8:	18c0201c 	xori	r3,r3,128
 10111cc:	18ffe004 	addi	r3,r3,-128
 10111d0:	18000c26 	beq	r3,zero,1011204 <strcmp+0xac>
 10111d4:	29800007 	ldb	r6,0(r5)
 10111d8:	19800326 	beq	r3,r6,10111e8 <strcmp+0x90>
 10111dc:	00001306 	br	101122c <strcmp+0xd4>
 10111e0:	29800007 	ldb	r6,0(r5)
 10111e4:	11800b1e 	bne	r2,r6,1011214 <strcmp+0xbc>
 10111e8:	21000044 	addi	r4,r4,1
 10111ec:	20c00003 	ldbu	r3,0(r4)
 10111f0:	29400044 	addi	r5,r5,1
 10111f4:	18803fcc 	andi	r2,r3,255
 10111f8:	1080201c 	xori	r2,r2,128
 10111fc:	10bfe004 	addi	r2,r2,-128
 1011200:	103ff71e 	bne	r2,zero,10111e0 <__alt_data_end+0xff8111e0>
 1011204:	0007883a 	mov	r3,zero
 1011208:	28800003 	ldbu	r2,0(r5)
 101120c:	1885c83a 	sub	r2,r3,r2
 1011210:	f800283a 	ret
 1011214:	28800003 	ldbu	r2,0(r5)
 1011218:	18c03fcc 	andi	r3,r3,255
 101121c:	1885c83a 	sub	r2,r3,r2
 1011220:	f800283a 	ret
 1011224:	0005883a 	mov	r2,zero
 1011228:	f800283a 	ret
 101122c:	10c03fcc 	andi	r3,r2,255
 1011230:	003ff506 	br	1011208 <__alt_data_end+0xff811208>

01011234 <__sprint_r.part.0>:
 1011234:	28801917 	ldw	r2,100(r5)
 1011238:	defff604 	addi	sp,sp,-40
 101123c:	dd400515 	stw	r21,20(sp)
 1011240:	dfc00915 	stw	ra,36(sp)
 1011244:	df000815 	stw	fp,32(sp)
 1011248:	ddc00715 	stw	r23,28(sp)
 101124c:	dd800615 	stw	r22,24(sp)
 1011250:	dd000415 	stw	r20,16(sp)
 1011254:	dcc00315 	stw	r19,12(sp)
 1011258:	dc800215 	stw	r18,8(sp)
 101125c:	dc400115 	stw	r17,4(sp)
 1011260:	dc000015 	stw	r16,0(sp)
 1011264:	1088000c 	andi	r2,r2,8192
 1011268:	302b883a 	mov	r21,r6
 101126c:	10002e26 	beq	r2,zero,1011328 <__sprint_r.part.0+0xf4>
 1011270:	30800217 	ldw	r2,8(r6)
 1011274:	35800017 	ldw	r22,0(r6)
 1011278:	10002926 	beq	r2,zero,1011320 <__sprint_r.part.0+0xec>
 101127c:	2827883a 	mov	r19,r5
 1011280:	2029883a 	mov	r20,r4
 1011284:	b5c00104 	addi	r23,r22,4
 1011288:	04bfffc4 	movi	r18,-1
 101128c:	bc400017 	ldw	r17,0(r23)
 1011290:	b4000017 	ldw	r16,0(r22)
 1011294:	0039883a 	mov	fp,zero
 1011298:	8822d0ba 	srli	r17,r17,2
 101129c:	8800031e 	bne	r17,zero,10112ac <__sprint_r.part.0+0x78>
 10112a0:	00001806 	br	1011304 <__sprint_r.part.0+0xd0>
 10112a4:	84000104 	addi	r16,r16,4
 10112a8:	8f001526 	beq	r17,fp,1011300 <__sprint_r.part.0+0xcc>
 10112ac:	81400017 	ldw	r5,0(r16)
 10112b0:	980d883a 	mov	r6,r19
 10112b4:	a009883a 	mov	r4,r20
 10112b8:	1012db40 	call	1012db4 <_fputwc_r>
 10112bc:	e7000044 	addi	fp,fp,1
 10112c0:	14bff81e 	bne	r2,r18,10112a4 <__alt_data_end+0xff8112a4>
 10112c4:	9005883a 	mov	r2,r18
 10112c8:	a8000215 	stw	zero,8(r21)
 10112cc:	a8000115 	stw	zero,4(r21)
 10112d0:	dfc00917 	ldw	ra,36(sp)
 10112d4:	df000817 	ldw	fp,32(sp)
 10112d8:	ddc00717 	ldw	r23,28(sp)
 10112dc:	dd800617 	ldw	r22,24(sp)
 10112e0:	dd400517 	ldw	r21,20(sp)
 10112e4:	dd000417 	ldw	r20,16(sp)
 10112e8:	dcc00317 	ldw	r19,12(sp)
 10112ec:	dc800217 	ldw	r18,8(sp)
 10112f0:	dc400117 	ldw	r17,4(sp)
 10112f4:	dc000017 	ldw	r16,0(sp)
 10112f8:	dec00a04 	addi	sp,sp,40
 10112fc:	f800283a 	ret
 1011300:	a8800217 	ldw	r2,8(r21)
 1011304:	8c63883a 	add	r17,r17,r17
 1011308:	8c63883a 	add	r17,r17,r17
 101130c:	1445c83a 	sub	r2,r2,r17
 1011310:	a8800215 	stw	r2,8(r21)
 1011314:	b5800204 	addi	r22,r22,8
 1011318:	bdc00204 	addi	r23,r23,8
 101131c:	103fdb1e 	bne	r2,zero,101128c <__alt_data_end+0xff81128c>
 1011320:	0005883a 	mov	r2,zero
 1011324:	003fe806 	br	10112c8 <__alt_data_end+0xff8112c8>
 1011328:	100e5640 	call	100e564 <__sfvwrite_r>
 101132c:	003fe606 	br	10112c8 <__alt_data_end+0xff8112c8>

01011330 <__sprint_r>:
 1011330:	30c00217 	ldw	r3,8(r6)
 1011334:	18000126 	beq	r3,zero,101133c <__sprint_r+0xc>
 1011338:	10112341 	jmpi	1011234 <__sprint_r.part.0>
 101133c:	30000115 	stw	zero,4(r6)
 1011340:	0005883a 	mov	r2,zero
 1011344:	f800283a 	ret

01011348 <___vfiprintf_internal_r>:
 1011348:	deffc904 	addi	sp,sp,-220
 101134c:	df003515 	stw	fp,212(sp)
 1011350:	dd003115 	stw	r20,196(sp)
 1011354:	dfc03615 	stw	ra,216(sp)
 1011358:	ddc03415 	stw	r23,208(sp)
 101135c:	dd803315 	stw	r22,204(sp)
 1011360:	dd403215 	stw	r21,200(sp)
 1011364:	dcc03015 	stw	r19,192(sp)
 1011368:	dc802f15 	stw	r18,188(sp)
 101136c:	dc402e15 	stw	r17,184(sp)
 1011370:	dc002d15 	stw	r16,180(sp)
 1011374:	d9002015 	stw	r4,128(sp)
 1011378:	d9c02215 	stw	r7,136(sp)
 101137c:	2829883a 	mov	r20,r5
 1011380:	3039883a 	mov	fp,r6
 1011384:	20000226 	beq	r4,zero,1011390 <___vfiprintf_internal_r+0x48>
 1011388:	20800e17 	ldw	r2,56(r4)
 101138c:	1000cf26 	beq	r2,zero,10116cc <___vfiprintf_internal_r+0x384>
 1011390:	a080030b 	ldhu	r2,12(r20)
 1011394:	10c8000c 	andi	r3,r2,8192
 1011398:	1800061e 	bne	r3,zero,10113b4 <___vfiprintf_internal_r+0x6c>
 101139c:	a1001917 	ldw	r4,100(r20)
 10113a0:	00f7ffc4 	movi	r3,-8193
 10113a4:	10880014 	ori	r2,r2,8192
 10113a8:	20c6703a 	and	r3,r4,r3
 10113ac:	a080030d 	sth	r2,12(r20)
 10113b0:	a0c01915 	stw	r3,100(r20)
 10113b4:	10c0020c 	andi	r3,r2,8
 10113b8:	1800a926 	beq	r3,zero,1011660 <___vfiprintf_internal_r+0x318>
 10113bc:	a0c00417 	ldw	r3,16(r20)
 10113c0:	1800a726 	beq	r3,zero,1011660 <___vfiprintf_internal_r+0x318>
 10113c4:	1080068c 	andi	r2,r2,26
 10113c8:	00c00284 	movi	r3,10
 10113cc:	10c0ac26 	beq	r2,r3,1011680 <___vfiprintf_internal_r+0x338>
 10113d0:	da801a04 	addi	r10,sp,104
 10113d4:	da801e15 	stw	r10,120(sp)
 10113d8:	d8801e17 	ldw	r2,120(sp)
 10113dc:	da8019c4 	addi	r10,sp,103
 10113e0:	058040b4 	movhi	r22,258
 10113e4:	05c040b4 	movhi	r23,258
 10113e8:	da801f15 	stw	r10,124(sp)
 10113ec:	1295c83a 	sub	r10,r2,r10
 10113f0:	b5ab6304 	addi	r22,r22,-21108
 10113f4:	bdeb5f04 	addi	r23,r23,-21124
 10113f8:	dec01a15 	stw	sp,104(sp)
 10113fc:	d8001c15 	stw	zero,112(sp)
 1011400:	d8001b15 	stw	zero,108(sp)
 1011404:	d8002615 	stw	zero,152(sp)
 1011408:	d8002315 	stw	zero,140(sp)
 101140c:	da802715 	stw	r10,156(sp)
 1011410:	d811883a 	mov	r8,sp
 1011414:	dd002115 	stw	r20,132(sp)
 1011418:	e021883a 	mov	r16,fp
 101141c:	80800007 	ldb	r2,0(r16)
 1011420:	1003ea26 	beq	r2,zero,10123cc <___vfiprintf_internal_r+0x1084>
 1011424:	00c00944 	movi	r3,37
 1011428:	8025883a 	mov	r18,r16
 101142c:	10c0021e 	bne	r2,r3,1011438 <___vfiprintf_internal_r+0xf0>
 1011430:	00001606 	br	101148c <___vfiprintf_internal_r+0x144>
 1011434:	10c00326 	beq	r2,r3,1011444 <___vfiprintf_internal_r+0xfc>
 1011438:	94800044 	addi	r18,r18,1
 101143c:	90800007 	ldb	r2,0(r18)
 1011440:	103ffc1e 	bne	r2,zero,1011434 <__alt_data_end+0xff811434>
 1011444:	9423c83a 	sub	r17,r18,r16
 1011448:	88001026 	beq	r17,zero,101148c <___vfiprintf_internal_r+0x144>
 101144c:	d8c01c17 	ldw	r3,112(sp)
 1011450:	d8801b17 	ldw	r2,108(sp)
 1011454:	44000015 	stw	r16,0(r8)
 1011458:	88c7883a 	add	r3,r17,r3
 101145c:	10800044 	addi	r2,r2,1
 1011460:	44400115 	stw	r17,4(r8)
 1011464:	d8c01c15 	stw	r3,112(sp)
 1011468:	d8801b15 	stw	r2,108(sp)
 101146c:	010001c4 	movi	r4,7
 1011470:	2080760e 	bge	r4,r2,101164c <___vfiprintf_internal_r+0x304>
 1011474:	1803821e 	bne	r3,zero,1012280 <___vfiprintf_internal_r+0xf38>
 1011478:	da802317 	ldw	r10,140(sp)
 101147c:	d8001b15 	stw	zero,108(sp)
 1011480:	d811883a 	mov	r8,sp
 1011484:	5455883a 	add	r10,r10,r17
 1011488:	da802315 	stw	r10,140(sp)
 101148c:	90800007 	ldb	r2,0(r18)
 1011490:	10044626 	beq	r2,zero,10125ac <___vfiprintf_internal_r+0x1264>
 1011494:	90c00047 	ldb	r3,1(r18)
 1011498:	94000044 	addi	r16,r18,1
 101149c:	d8001d85 	stb	zero,118(sp)
 10114a0:	0009883a 	mov	r4,zero
 10114a4:	000f883a 	mov	r7,zero
 10114a8:	027fffc4 	movi	r9,-1
 10114ac:	0023883a 	mov	r17,zero
 10114b0:	0029883a 	mov	r20,zero
 10114b4:	01401604 	movi	r5,88
 10114b8:	01800244 	movi	r6,9
 10114bc:	03400a84 	movi	r13,42
 10114c0:	03001b04 	movi	r12,108
 10114c4:	84000044 	addi	r16,r16,1
 10114c8:	18bff804 	addi	r2,r3,-32
 10114cc:	28827336 	bltu	r5,r2,1011e9c <___vfiprintf_internal_r+0xb54>
 10114d0:	100490ba 	slli	r2,r2,2
 10114d4:	02804074 	movhi	r10,257
 10114d8:	52853a04 	addi	r10,r10,5352
 10114dc:	1285883a 	add	r2,r2,r10
 10114e0:	10800017 	ldw	r2,0(r2)
 10114e4:	1000683a 	jmp	r2
 10114e8:	01011bd0 	cmplti	r4,zero,1135
 10114ec:	01011e9c 	xori	r4,zero,1146
 10114f0:	01011e9c 	xori	r4,zero,1146
 10114f4:	01011bf0 	cmpltui	r4,zero,1135
 10114f8:	01011e9c 	xori	r4,zero,1146
 10114fc:	01011e9c 	xori	r4,zero,1146
 1011500:	01011e9c 	xori	r4,zero,1146
 1011504:	01011e9c 	xori	r4,zero,1146
 1011508:	01011e9c 	xori	r4,zero,1146
 101150c:	01011e9c 	xori	r4,zero,1146
 1011510:	01011dd8 	cmpnei	r4,zero,1143
 1011514:	01011df4 	movhi	r4,1143
 1011518:	01011e9c 	xori	r4,zero,1146
 101151c:	010116dc 	xori	r4,zero,1115
 1011520:	01011e04 	movi	r4,1144
 1011524:	01011e9c 	xori	r4,zero,1146
 1011528:	01011bfc 	xorhi	r4,zero,1135
 101152c:	01011c08 	cmpgei	r4,zero,1136
 1011530:	01011c08 	cmpgei	r4,zero,1136
 1011534:	01011c08 	cmpgei	r4,zero,1136
 1011538:	01011c08 	cmpgei	r4,zero,1136
 101153c:	01011c08 	cmpgei	r4,zero,1136
 1011540:	01011c08 	cmpgei	r4,zero,1136
 1011544:	01011c08 	cmpgei	r4,zero,1136
 1011548:	01011c08 	cmpgei	r4,zero,1136
 101154c:	01011c08 	cmpgei	r4,zero,1136
 1011550:	01011e9c 	xori	r4,zero,1146
 1011554:	01011e9c 	xori	r4,zero,1146
 1011558:	01011e9c 	xori	r4,zero,1146
 101155c:	01011e9c 	xori	r4,zero,1146
 1011560:	01011e9c 	xori	r4,zero,1146
 1011564:	01011e9c 	xori	r4,zero,1146
 1011568:	01011e9c 	xori	r4,zero,1146
 101156c:	01011e9c 	xori	r4,zero,1146
 1011570:	01011e9c 	xori	r4,zero,1146
 1011574:	01011e9c 	xori	r4,zero,1146
 1011578:	01011c34 	movhi	r4,1136
 101157c:	01011e9c 	xori	r4,zero,1146
 1011580:	01011e9c 	xori	r4,zero,1146
 1011584:	01011e9c 	xori	r4,zero,1146
 1011588:	01011e9c 	xori	r4,zero,1146
 101158c:	01011e9c 	xori	r4,zero,1146
 1011590:	01011e9c 	xori	r4,zero,1146
 1011594:	01011e9c 	xori	r4,zero,1146
 1011598:	01011e9c 	xori	r4,zero,1146
 101159c:	01011e9c 	xori	r4,zero,1146
 10115a0:	01011e9c 	xori	r4,zero,1146
 10115a4:	01011c6c 	andhi	r4,zero,1137
 10115a8:	01011e9c 	xori	r4,zero,1146
 10115ac:	01011e9c 	xori	r4,zero,1146
 10115b0:	01011e9c 	xori	r4,zero,1146
 10115b4:	01011e9c 	xori	r4,zero,1146
 10115b8:	01011e9c 	xori	r4,zero,1146
 10115bc:	01011cc4 	movi	r4,1139
 10115c0:	01011e9c 	xori	r4,zero,1146
 10115c4:	01011e9c 	xori	r4,zero,1146
 10115c8:	01011d34 	movhi	r4,1140
 10115cc:	01011e9c 	xori	r4,zero,1146
 10115d0:	01011e9c 	xori	r4,zero,1146
 10115d4:	01011e9c 	xori	r4,zero,1146
 10115d8:	01011e9c 	xori	r4,zero,1146
 10115dc:	01011e9c 	xori	r4,zero,1146
 10115e0:	01011e9c 	xori	r4,zero,1146
 10115e4:	01011e9c 	xori	r4,zero,1146
 10115e8:	01011e9c 	xori	r4,zero,1146
 10115ec:	01011e9c 	xori	r4,zero,1146
 10115f0:	01011e9c 	xori	r4,zero,1146
 10115f4:	01011ae0 	cmpeqi	r4,zero,1131
 10115f8:	01011b0c 	andi	r4,zero,1132
 10115fc:	01011e9c 	xori	r4,zero,1146
 1011600:	01011e9c 	xori	r4,zero,1146
 1011604:	01011e9c 	xori	r4,zero,1146
 1011608:	01011e44 	movi	r4,1145
 101160c:	01011b0c 	andi	r4,zero,1132
 1011610:	01011e9c 	xori	r4,zero,1146
 1011614:	01011e9c 	xori	r4,zero,1146
 1011618:	010119a0 	cmpeqi	r4,zero,1126
 101161c:	01011e9c 	xori	r4,zero,1146
 1011620:	010119b0 	cmpltui	r4,zero,1126
 1011624:	010119ec 	andhi	r4,zero,1127
 1011628:	010116e8 	cmpgeui	r4,zero,1115
 101162c:	01011994 	movui	r4,1126
 1011630:	01011e9c 	xori	r4,zero,1146
 1011634:	01011d70 	cmpltui	r4,zero,1141
 1011638:	01011e9c 	xori	r4,zero,1146
 101163c:	01011dc8 	cmpgei	r4,zero,1143
 1011640:	01011e9c 	xori	r4,zero,1146
 1011644:	01011e9c 	xori	r4,zero,1146
 1011648:	01011a8c 	andi	r4,zero,1130
 101164c:	42000204 	addi	r8,r8,8
 1011650:	da802317 	ldw	r10,140(sp)
 1011654:	5455883a 	add	r10,r10,r17
 1011658:	da802315 	stw	r10,140(sp)
 101165c:	003f8b06 	br	101148c <__alt_data_end+0xff81148c>
 1011660:	d9002017 	ldw	r4,128(sp)
 1011664:	a00b883a 	mov	r5,r20
 1011668:	100c10c0 	call	100c10c <__swsetup_r>
 101166c:	1003b11e 	bne	r2,zero,1012534 <___vfiprintf_internal_r+0x11ec>
 1011670:	a080030b 	ldhu	r2,12(r20)
 1011674:	00c00284 	movi	r3,10
 1011678:	1080068c 	andi	r2,r2,26
 101167c:	10ff541e 	bne	r2,r3,10113d0 <__alt_data_end+0xff8113d0>
 1011680:	a080038f 	ldh	r2,14(r20)
 1011684:	103f5216 	blt	r2,zero,10113d0 <__alt_data_end+0xff8113d0>
 1011688:	d9c02217 	ldw	r7,136(sp)
 101168c:	d9002017 	ldw	r4,128(sp)
 1011690:	e00d883a 	mov	r6,fp
 1011694:	a00b883a 	mov	r5,r20
 1011698:	10127c00 	call	10127c0 <__sbprintf>
 101169c:	dfc03617 	ldw	ra,216(sp)
 10116a0:	df003517 	ldw	fp,212(sp)
 10116a4:	ddc03417 	ldw	r23,208(sp)
 10116a8:	dd803317 	ldw	r22,204(sp)
 10116ac:	dd403217 	ldw	r21,200(sp)
 10116b0:	dd003117 	ldw	r20,196(sp)
 10116b4:	dcc03017 	ldw	r19,192(sp)
 10116b8:	dc802f17 	ldw	r18,188(sp)
 10116bc:	dc402e17 	ldw	r17,184(sp)
 10116c0:	dc002d17 	ldw	r16,180(sp)
 10116c4:	dec03704 	addi	sp,sp,220
 10116c8:	f800283a 	ret
 10116cc:	100e0e00 	call	100e0e0 <__sinit>
 10116d0:	003f2f06 	br	1011390 <__alt_data_end+0xff811390>
 10116d4:	0463c83a 	sub	r17,zero,r17
 10116d8:	d8802215 	stw	r2,136(sp)
 10116dc:	a5000114 	ori	r20,r20,4
 10116e0:	80c00007 	ldb	r3,0(r16)
 10116e4:	003f7706 	br	10114c4 <__alt_data_end+0xff8114c4>
 10116e8:	00800c04 	movi	r2,48
 10116ec:	da802217 	ldw	r10,136(sp)
 10116f0:	d8801d05 	stb	r2,116(sp)
 10116f4:	00801e04 	movi	r2,120
 10116f8:	d8801d45 	stb	r2,117(sp)
 10116fc:	d8001d85 	stb	zero,118(sp)
 1011700:	50c00104 	addi	r3,r10,4
 1011704:	54800017 	ldw	r18,0(r10)
 1011708:	0027883a 	mov	r19,zero
 101170c:	a0800094 	ori	r2,r20,2
 1011710:	48030b16 	blt	r9,zero,1012340 <___vfiprintf_internal_r+0xff8>
 1011714:	00bfdfc4 	movi	r2,-129
 1011718:	a096703a 	and	r11,r20,r2
 101171c:	d8c02215 	stw	r3,136(sp)
 1011720:	5d000094 	ori	r20,r11,2
 1011724:	90032b1e 	bne	r18,zero,10123d4 <___vfiprintf_internal_r+0x108c>
 1011728:	008040b4 	movhi	r2,258
 101172c:	10aafe04 	addi	r2,r2,-21512
 1011730:	d8802615 	stw	r2,152(sp)
 1011734:	0039883a 	mov	fp,zero
 1011738:	48017b1e 	bne	r9,zero,1011d28 <___vfiprintf_internal_r+0x9e0>
 101173c:	0013883a 	mov	r9,zero
 1011740:	0027883a 	mov	r19,zero
 1011744:	dd401a04 	addi	r21,sp,104
 1011748:	4825883a 	mov	r18,r9
 101174c:	4cc0010e 	bge	r9,r19,1011754 <___vfiprintf_internal_r+0x40c>
 1011750:	9825883a 	mov	r18,r19
 1011754:	e7003fcc 	andi	fp,fp,255
 1011758:	e700201c 	xori	fp,fp,128
 101175c:	e73fe004 	addi	fp,fp,-128
 1011760:	e0000126 	beq	fp,zero,1011768 <___vfiprintf_internal_r+0x420>
 1011764:	94800044 	addi	r18,r18,1
 1011768:	a380008c 	andi	r14,r20,2
 101176c:	70000126 	beq	r14,zero,1011774 <___vfiprintf_internal_r+0x42c>
 1011770:	94800084 	addi	r18,r18,2
 1011774:	a700210c 	andi	fp,r20,132
 1011778:	e001df1e 	bne	fp,zero,1011ef8 <___vfiprintf_internal_r+0xbb0>
 101177c:	8c87c83a 	sub	r3,r17,r18
 1011780:	00c1dd0e 	bge	zero,r3,1011ef8 <___vfiprintf_internal_r+0xbb0>
 1011784:	01c00404 	movi	r7,16
 1011788:	d8801c17 	ldw	r2,112(sp)
 101178c:	38c3ad0e 	bge	r7,r3,1012644 <___vfiprintf_internal_r+0x12fc>
 1011790:	028040b4 	movhi	r10,258
 1011794:	52ab6304 	addi	r10,r10,-21108
 1011798:	dc002915 	stw	r16,164(sp)
 101179c:	d9801b17 	ldw	r6,108(sp)
 10117a0:	da802415 	stw	r10,144(sp)
 10117a4:	03c001c4 	movi	r15,7
 10117a8:	da402515 	stw	r9,148(sp)
 10117ac:	db802815 	stw	r14,160(sp)
 10117b0:	1821883a 	mov	r16,r3
 10117b4:	00000506 	br	10117cc <___vfiprintf_internal_r+0x484>
 10117b8:	31400084 	addi	r5,r6,2
 10117bc:	42000204 	addi	r8,r8,8
 10117c0:	200d883a 	mov	r6,r4
 10117c4:	843ffc04 	addi	r16,r16,-16
 10117c8:	3c000d0e 	bge	r7,r16,1011800 <___vfiprintf_internal_r+0x4b8>
 10117cc:	10800404 	addi	r2,r2,16
 10117d0:	31000044 	addi	r4,r6,1
 10117d4:	45800015 	stw	r22,0(r8)
 10117d8:	41c00115 	stw	r7,4(r8)
 10117dc:	d8801c15 	stw	r2,112(sp)
 10117e0:	d9001b15 	stw	r4,108(sp)
 10117e4:	793ff40e 	bge	r15,r4,10117b8 <__alt_data_end+0xff8117b8>
 10117e8:	1001b51e 	bne	r2,zero,1011ec0 <___vfiprintf_internal_r+0xb78>
 10117ec:	843ffc04 	addi	r16,r16,-16
 10117f0:	000d883a 	mov	r6,zero
 10117f4:	01400044 	movi	r5,1
 10117f8:	d811883a 	mov	r8,sp
 10117fc:	3c3ff316 	blt	r7,r16,10117cc <__alt_data_end+0xff8117cc>
 1011800:	8007883a 	mov	r3,r16
 1011804:	da402517 	ldw	r9,148(sp)
 1011808:	db802817 	ldw	r14,160(sp)
 101180c:	dc002917 	ldw	r16,164(sp)
 1011810:	da802417 	ldw	r10,144(sp)
 1011814:	1885883a 	add	r2,r3,r2
 1011818:	40c00115 	stw	r3,4(r8)
 101181c:	42800015 	stw	r10,0(r8)
 1011820:	d8801c15 	stw	r2,112(sp)
 1011824:	d9401b15 	stw	r5,108(sp)
 1011828:	00c001c4 	movi	r3,7
 101182c:	19426016 	blt	r3,r5,10121b0 <___vfiprintf_internal_r+0xe68>
 1011830:	d8c01d87 	ldb	r3,118(sp)
 1011834:	42000204 	addi	r8,r8,8
 1011838:	29000044 	addi	r4,r5,1
 101183c:	1801b31e 	bne	r3,zero,1011f0c <___vfiprintf_internal_r+0xbc4>
 1011840:	7001c026 	beq	r14,zero,1011f44 <___vfiprintf_internal_r+0xbfc>
 1011844:	d8c01d04 	addi	r3,sp,116
 1011848:	10800084 	addi	r2,r2,2
 101184c:	40c00015 	stw	r3,0(r8)
 1011850:	00c00084 	movi	r3,2
 1011854:	40c00115 	stw	r3,4(r8)
 1011858:	d8801c15 	stw	r2,112(sp)
 101185c:	d9001b15 	stw	r4,108(sp)
 1011860:	00c001c4 	movi	r3,7
 1011864:	1902650e 	bge	r3,r4,10121fc <___vfiprintf_internal_r+0xeb4>
 1011868:	10029a1e 	bne	r2,zero,10122d4 <___vfiprintf_internal_r+0xf8c>
 101186c:	00c02004 	movi	r3,128
 1011870:	01000044 	movi	r4,1
 1011874:	000b883a 	mov	r5,zero
 1011878:	d811883a 	mov	r8,sp
 101187c:	e0c1b31e 	bne	fp,r3,1011f4c <___vfiprintf_internal_r+0xc04>
 1011880:	8cb9c83a 	sub	fp,r17,r18
 1011884:	0701b10e 	bge	zero,fp,1011f4c <___vfiprintf_internal_r+0xc04>
 1011888:	01c00404 	movi	r7,16
 101188c:	3f03890e 	bge	r7,fp,10126b4 <___vfiprintf_internal_r+0x136c>
 1011890:	00c040b4 	movhi	r3,258
 1011894:	18eb5f04 	addi	r3,r3,-21124
 1011898:	d8c02415 	stw	r3,144(sp)
 101189c:	8007883a 	mov	r3,r16
 10118a0:	034001c4 	movi	r13,7
 10118a4:	e021883a 	mov	r16,fp
 10118a8:	da402515 	stw	r9,148(sp)
 10118ac:	1839883a 	mov	fp,r3
 10118b0:	00000506 	br	10118c8 <___vfiprintf_internal_r+0x580>
 10118b4:	29800084 	addi	r6,r5,2
 10118b8:	42000204 	addi	r8,r8,8
 10118bc:	180b883a 	mov	r5,r3
 10118c0:	843ffc04 	addi	r16,r16,-16
 10118c4:	3c000d0e 	bge	r7,r16,10118fc <___vfiprintf_internal_r+0x5b4>
 10118c8:	10800404 	addi	r2,r2,16
 10118cc:	28c00044 	addi	r3,r5,1
 10118d0:	45c00015 	stw	r23,0(r8)
 10118d4:	41c00115 	stw	r7,4(r8)
 10118d8:	d8801c15 	stw	r2,112(sp)
 10118dc:	d8c01b15 	stw	r3,108(sp)
 10118e0:	68fff40e 	bge	r13,r3,10118b4 <__alt_data_end+0xff8118b4>
 10118e4:	1002241e 	bne	r2,zero,1012178 <___vfiprintf_internal_r+0xe30>
 10118e8:	843ffc04 	addi	r16,r16,-16
 10118ec:	01800044 	movi	r6,1
 10118f0:	000b883a 	mov	r5,zero
 10118f4:	d811883a 	mov	r8,sp
 10118f8:	3c3ff316 	blt	r7,r16,10118c8 <__alt_data_end+0xff8118c8>
 10118fc:	da402517 	ldw	r9,148(sp)
 1011900:	e007883a 	mov	r3,fp
 1011904:	8039883a 	mov	fp,r16
 1011908:	1821883a 	mov	r16,r3
 101190c:	d8c02417 	ldw	r3,144(sp)
 1011910:	1705883a 	add	r2,r2,fp
 1011914:	47000115 	stw	fp,4(r8)
 1011918:	40c00015 	stw	r3,0(r8)
 101191c:	d8801c15 	stw	r2,112(sp)
 1011920:	d9801b15 	stw	r6,108(sp)
 1011924:	00c001c4 	movi	r3,7
 1011928:	19827616 	blt	r3,r6,1012304 <___vfiprintf_internal_r+0xfbc>
 101192c:	4cf9c83a 	sub	fp,r9,r19
 1011930:	42000204 	addi	r8,r8,8
 1011934:	31000044 	addi	r4,r6,1
 1011938:	300b883a 	mov	r5,r6
 101193c:	07018516 	blt	zero,fp,1011f54 <___vfiprintf_internal_r+0xc0c>
 1011940:	9885883a 	add	r2,r19,r2
 1011944:	45400015 	stw	r21,0(r8)
 1011948:	44c00115 	stw	r19,4(r8)
 101194c:	d8801c15 	stw	r2,112(sp)
 1011950:	d9001b15 	stw	r4,108(sp)
 1011954:	00c001c4 	movi	r3,7
 1011958:	1901dd0e 	bge	r3,r4,10120d0 <___vfiprintf_internal_r+0xd88>
 101195c:	1002401e 	bne	r2,zero,1012260 <___vfiprintf_internal_r+0xf18>
 1011960:	d8001b15 	stw	zero,108(sp)
 1011964:	a2c0010c 	andi	r11,r20,4
 1011968:	58000226 	beq	r11,zero,1011974 <___vfiprintf_internal_r+0x62c>
 101196c:	8ca7c83a 	sub	r19,r17,r18
 1011970:	04c2f216 	blt	zero,r19,101253c <___vfiprintf_internal_r+0x11f4>
 1011974:	8c80010e 	bge	r17,r18,101197c <___vfiprintf_internal_r+0x634>
 1011978:	9023883a 	mov	r17,r18
 101197c:	da802317 	ldw	r10,140(sp)
 1011980:	5455883a 	add	r10,r10,r17
 1011984:	da802315 	stw	r10,140(sp)
 1011988:	d8001b15 	stw	zero,108(sp)
 101198c:	d811883a 	mov	r8,sp
 1011990:	003ea206 	br	101141c <__alt_data_end+0xff81141c>
 1011994:	a5000814 	ori	r20,r20,32
 1011998:	80c00007 	ldb	r3,0(r16)
 101199c:	003ec906 	br	10114c4 <__alt_data_end+0xff8114c4>
 10119a0:	80c00007 	ldb	r3,0(r16)
 10119a4:	1b030926 	beq	r3,r12,10125cc <___vfiprintf_internal_r+0x1284>
 10119a8:	a5000414 	ori	r20,r20,16
 10119ac:	003ec506 	br	10114c4 <__alt_data_end+0xff8114c4>
 10119b0:	21003fcc 	andi	r4,r4,255
 10119b4:	20035e1e 	bne	r4,zero,1012730 <___vfiprintf_internal_r+0x13e8>
 10119b8:	a080080c 	andi	r2,r20,32
 10119bc:	1002a526 	beq	r2,zero,1012454 <___vfiprintf_internal_r+0x110c>
 10119c0:	da802217 	ldw	r10,136(sp)
 10119c4:	50800017 	ldw	r2,0(r10)
 10119c8:	da802317 	ldw	r10,140(sp)
 10119cc:	5007d7fa 	srai	r3,r10,31
 10119d0:	da802217 	ldw	r10,136(sp)
 10119d4:	10c00115 	stw	r3,4(r2)
 10119d8:	52800104 	addi	r10,r10,4
 10119dc:	da802215 	stw	r10,136(sp)
 10119e0:	da802317 	ldw	r10,140(sp)
 10119e4:	12800015 	stw	r10,0(r2)
 10119e8:	003e8c06 	br	101141c <__alt_data_end+0xff81141c>
 10119ec:	21003fcc 	andi	r4,r4,255
 10119f0:	2003511e 	bne	r4,zero,1012738 <___vfiprintf_internal_r+0x13f0>
 10119f4:	a080080c 	andi	r2,r20,32
 10119f8:	1000a126 	beq	r2,zero,1011c80 <___vfiprintf_internal_r+0x938>
 10119fc:	da802217 	ldw	r10,136(sp)
 1011a00:	d8001d85 	stb	zero,118(sp)
 1011a04:	50800204 	addi	r2,r10,8
 1011a08:	54800017 	ldw	r18,0(r10)
 1011a0c:	54c00117 	ldw	r19,4(r10)
 1011a10:	4802b416 	blt	r9,zero,10124e4 <___vfiprintf_internal_r+0x119c>
 1011a14:	013fdfc4 	movi	r4,-129
 1011a18:	94c6b03a 	or	r3,r18,r19
 1011a1c:	d8802215 	stw	r2,136(sp)
 1011a20:	a128703a 	and	r20,r20,r4
 1011a24:	1800a226 	beq	r3,zero,1011cb0 <___vfiprintf_internal_r+0x968>
 1011a28:	0039883a 	mov	fp,zero
 1011a2c:	dd401a04 	addi	r21,sp,104
 1011a30:	9006d0fa 	srli	r3,r18,3
 1011a34:	9808977a 	slli	r4,r19,29
 1011a38:	9826d0fa 	srli	r19,r19,3
 1011a3c:	948001cc 	andi	r18,r18,7
 1011a40:	90800c04 	addi	r2,r18,48
 1011a44:	ad7fffc4 	addi	r21,r21,-1
 1011a48:	20e4b03a 	or	r18,r4,r3
 1011a4c:	a8800005 	stb	r2,0(r21)
 1011a50:	94c6b03a 	or	r3,r18,r19
 1011a54:	183ff61e 	bne	r3,zero,1011a30 <__alt_data_end+0xff811a30>
 1011a58:	a0c0004c 	andi	r3,r20,1
 1011a5c:	18005926 	beq	r3,zero,1011bc4 <___vfiprintf_internal_r+0x87c>
 1011a60:	10803fcc 	andi	r2,r2,255
 1011a64:	1080201c 	xori	r2,r2,128
 1011a68:	10bfe004 	addi	r2,r2,-128
 1011a6c:	00c00c04 	movi	r3,48
 1011a70:	10c05426 	beq	r2,r3,1011bc4 <___vfiprintf_internal_r+0x87c>
 1011a74:	da801e17 	ldw	r10,120(sp)
 1011a78:	a8bfffc4 	addi	r2,r21,-1
 1011a7c:	a8ffffc5 	stb	r3,-1(r21)
 1011a80:	50a7c83a 	sub	r19,r10,r2
 1011a84:	102b883a 	mov	r21,r2
 1011a88:	003f2f06 	br	1011748 <__alt_data_end+0xff811748>
 1011a8c:	21003fcc 	andi	r4,r4,255
 1011a90:	2003421e 	bne	r4,zero,101279c <___vfiprintf_internal_r+0x1454>
 1011a94:	008040b4 	movhi	r2,258
 1011a98:	10aafe04 	addi	r2,r2,-21512
 1011a9c:	d8802615 	stw	r2,152(sp)
 1011aa0:	a080080c 	andi	r2,r20,32
 1011aa4:	1000aa26 	beq	r2,zero,1011d50 <___vfiprintf_internal_r+0xa08>
 1011aa8:	da802217 	ldw	r10,136(sp)
 1011aac:	54800017 	ldw	r18,0(r10)
 1011ab0:	54c00117 	ldw	r19,4(r10)
 1011ab4:	52800204 	addi	r10,r10,8
 1011ab8:	da802215 	stw	r10,136(sp)
 1011abc:	a080004c 	andi	r2,r20,1
 1011ac0:	1001d226 	beq	r2,zero,101220c <___vfiprintf_internal_r+0xec4>
 1011ac4:	94c4b03a 	or	r2,r18,r19
 1011ac8:	1002351e 	bne	r2,zero,10123a0 <___vfiprintf_internal_r+0x1058>
 1011acc:	d8001d85 	stb	zero,118(sp)
 1011ad0:	48022216 	blt	r9,zero,101235c <___vfiprintf_internal_r+0x1014>
 1011ad4:	00bfdfc4 	movi	r2,-129
 1011ad8:	a0a8703a 	and	r20,r20,r2
 1011adc:	003f1506 	br	1011734 <__alt_data_end+0xff811734>
 1011ae0:	da802217 	ldw	r10,136(sp)
 1011ae4:	04800044 	movi	r18,1
 1011ae8:	d8001d85 	stb	zero,118(sp)
 1011aec:	50800017 	ldw	r2,0(r10)
 1011af0:	52800104 	addi	r10,r10,4
 1011af4:	da802215 	stw	r10,136(sp)
 1011af8:	d8801005 	stb	r2,64(sp)
 1011afc:	9027883a 	mov	r19,r18
 1011b00:	dd401004 	addi	r21,sp,64
 1011b04:	0013883a 	mov	r9,zero
 1011b08:	003f1706 	br	1011768 <__alt_data_end+0xff811768>
 1011b0c:	21003fcc 	andi	r4,r4,255
 1011b10:	2003201e 	bne	r4,zero,1012794 <___vfiprintf_internal_r+0x144c>
 1011b14:	a080080c 	andi	r2,r20,32
 1011b18:	10004b26 	beq	r2,zero,1011c48 <___vfiprintf_internal_r+0x900>
 1011b1c:	da802217 	ldw	r10,136(sp)
 1011b20:	50800117 	ldw	r2,4(r10)
 1011b24:	54800017 	ldw	r18,0(r10)
 1011b28:	52800204 	addi	r10,r10,8
 1011b2c:	da802215 	stw	r10,136(sp)
 1011b30:	1027883a 	mov	r19,r2
 1011b34:	10022c16 	blt	r2,zero,10123e8 <___vfiprintf_internal_r+0x10a0>
 1011b38:	df001d83 	ldbu	fp,118(sp)
 1011b3c:	48007216 	blt	r9,zero,1011d08 <___vfiprintf_internal_r+0x9c0>
 1011b40:	00ffdfc4 	movi	r3,-129
 1011b44:	94c4b03a 	or	r2,r18,r19
 1011b48:	a0e8703a 	and	r20,r20,r3
 1011b4c:	1000cc26 	beq	r2,zero,1011e80 <___vfiprintf_internal_r+0xb38>
 1011b50:	98021026 	beq	r19,zero,1012394 <___vfiprintf_internal_r+0x104c>
 1011b54:	dc402415 	stw	r17,144(sp)
 1011b58:	dc002515 	stw	r16,148(sp)
 1011b5c:	9823883a 	mov	r17,r19
 1011b60:	9021883a 	mov	r16,r18
 1011b64:	dd401a04 	addi	r21,sp,104
 1011b68:	4825883a 	mov	r18,r9
 1011b6c:	4027883a 	mov	r19,r8
 1011b70:	8009883a 	mov	r4,r16
 1011b74:	880b883a 	mov	r5,r17
 1011b78:	01800284 	movi	r6,10
 1011b7c:	000f883a 	mov	r7,zero
 1011b80:	10137280 	call	1013728 <__umoddi3>
 1011b84:	10800c04 	addi	r2,r2,48
 1011b88:	ad7fffc4 	addi	r21,r21,-1
 1011b8c:	8009883a 	mov	r4,r16
 1011b90:	880b883a 	mov	r5,r17
 1011b94:	a8800005 	stb	r2,0(r21)
 1011b98:	01800284 	movi	r6,10
 1011b9c:	000f883a 	mov	r7,zero
 1011ba0:	10131b00 	call	10131b0 <__udivdi3>
 1011ba4:	1021883a 	mov	r16,r2
 1011ba8:	10c4b03a 	or	r2,r2,r3
 1011bac:	1823883a 	mov	r17,r3
 1011bb0:	103fef1e 	bne	r2,zero,1011b70 <__alt_data_end+0xff811b70>
 1011bb4:	dc402417 	ldw	r17,144(sp)
 1011bb8:	dc002517 	ldw	r16,148(sp)
 1011bbc:	9013883a 	mov	r9,r18
 1011bc0:	9811883a 	mov	r8,r19
 1011bc4:	da801e17 	ldw	r10,120(sp)
 1011bc8:	5567c83a 	sub	r19,r10,r21
 1011bcc:	003ede06 	br	1011748 <__alt_data_end+0xff811748>
 1011bd0:	38803fcc 	andi	r2,r7,255
 1011bd4:	1080201c 	xori	r2,r2,128
 1011bd8:	10bfe004 	addi	r2,r2,-128
 1011bdc:	1002371e 	bne	r2,zero,10124bc <___vfiprintf_internal_r+0x1174>
 1011be0:	01000044 	movi	r4,1
 1011be4:	01c00804 	movi	r7,32
 1011be8:	80c00007 	ldb	r3,0(r16)
 1011bec:	003e3506 	br	10114c4 <__alt_data_end+0xff8114c4>
 1011bf0:	a5000054 	ori	r20,r20,1
 1011bf4:	80c00007 	ldb	r3,0(r16)
 1011bf8:	003e3206 	br	10114c4 <__alt_data_end+0xff8114c4>
 1011bfc:	a5002014 	ori	r20,r20,128
 1011c00:	80c00007 	ldb	r3,0(r16)
 1011c04:	003e2f06 	br	10114c4 <__alt_data_end+0xff8114c4>
 1011c08:	8015883a 	mov	r10,r16
 1011c0c:	0023883a 	mov	r17,zero
 1011c10:	18bff404 	addi	r2,r3,-48
 1011c14:	50c00007 	ldb	r3,0(r10)
 1011c18:	8c4002a4 	muli	r17,r17,10
 1011c1c:	84000044 	addi	r16,r16,1
 1011c20:	8015883a 	mov	r10,r16
 1011c24:	1463883a 	add	r17,r2,r17
 1011c28:	18bff404 	addi	r2,r3,-48
 1011c2c:	30bff92e 	bgeu	r6,r2,1011c14 <__alt_data_end+0xff811c14>
 1011c30:	003e2506 	br	10114c8 <__alt_data_end+0xff8114c8>
 1011c34:	21003fcc 	andi	r4,r4,255
 1011c38:	2002d41e 	bne	r4,zero,101278c <___vfiprintf_internal_r+0x1444>
 1011c3c:	a5000414 	ori	r20,r20,16
 1011c40:	a080080c 	andi	r2,r20,32
 1011c44:	103fb51e 	bne	r2,zero,1011b1c <__alt_data_end+0xff811b1c>
 1011c48:	a080040c 	andi	r2,r20,16
 1011c4c:	1001f826 	beq	r2,zero,1012430 <___vfiprintf_internal_r+0x10e8>
 1011c50:	da802217 	ldw	r10,136(sp)
 1011c54:	54800017 	ldw	r18,0(r10)
 1011c58:	52800104 	addi	r10,r10,4
 1011c5c:	da802215 	stw	r10,136(sp)
 1011c60:	9027d7fa 	srai	r19,r18,31
 1011c64:	9805883a 	mov	r2,r19
 1011c68:	003fb206 	br	1011b34 <__alt_data_end+0xff811b34>
 1011c6c:	21003fcc 	andi	r4,r4,255
 1011c70:	2002c41e 	bne	r4,zero,1012784 <___vfiprintf_internal_r+0x143c>
 1011c74:	a5000414 	ori	r20,r20,16
 1011c78:	a080080c 	andi	r2,r20,32
 1011c7c:	103f5f1e 	bne	r2,zero,10119fc <__alt_data_end+0xff8119fc>
 1011c80:	a080040c 	andi	r2,r20,16
 1011c84:	10020f26 	beq	r2,zero,10124c4 <___vfiprintf_internal_r+0x117c>
 1011c88:	da802217 	ldw	r10,136(sp)
 1011c8c:	d8001d85 	stb	zero,118(sp)
 1011c90:	0027883a 	mov	r19,zero
 1011c94:	50800104 	addi	r2,r10,4
 1011c98:	54800017 	ldw	r18,0(r10)
 1011c9c:	48021116 	blt	r9,zero,10124e4 <___vfiprintf_internal_r+0x119c>
 1011ca0:	00ffdfc4 	movi	r3,-129
 1011ca4:	d8802215 	stw	r2,136(sp)
 1011ca8:	a0e8703a 	and	r20,r20,r3
 1011cac:	903f5e1e 	bne	r18,zero,1011a28 <__alt_data_end+0xff811a28>
 1011cb0:	0039883a 	mov	fp,zero
 1011cb4:	4802a626 	beq	r9,zero,1012750 <___vfiprintf_internal_r+0x1408>
 1011cb8:	0025883a 	mov	r18,zero
 1011cbc:	0027883a 	mov	r19,zero
 1011cc0:	003f5a06 	br	1011a2c <__alt_data_end+0xff811a2c>
 1011cc4:	21003fcc 	andi	r4,r4,255
 1011cc8:	20029f1e 	bne	r4,zero,1012748 <___vfiprintf_internal_r+0x1400>
 1011ccc:	a5000414 	ori	r20,r20,16
 1011cd0:	a080080c 	andi	r2,r20,32
 1011cd4:	10005e1e 	bne	r2,zero,1011e50 <___vfiprintf_internal_r+0xb08>
 1011cd8:	a080040c 	andi	r2,r20,16
 1011cdc:	1001a21e 	bne	r2,zero,1012368 <___vfiprintf_internal_r+0x1020>
 1011ce0:	a080100c 	andi	r2,r20,64
 1011ce4:	d8001d85 	stb	zero,118(sp)
 1011ce8:	da802217 	ldw	r10,136(sp)
 1011cec:	1002231e 	bne	r2,zero,101257c <___vfiprintf_internal_r+0x1234>
 1011cf0:	50800104 	addi	r2,r10,4
 1011cf4:	54800017 	ldw	r18,0(r10)
 1011cf8:	0027883a 	mov	r19,zero
 1011cfc:	4801a00e 	bge	r9,zero,1012380 <___vfiprintf_internal_r+0x1038>
 1011d00:	d8802215 	stw	r2,136(sp)
 1011d04:	0039883a 	mov	fp,zero
 1011d08:	94c4b03a 	or	r2,r18,r19
 1011d0c:	103f901e 	bne	r2,zero,1011b50 <__alt_data_end+0xff811b50>
 1011d10:	00800044 	movi	r2,1
 1011d14:	10803fcc 	andi	r2,r2,255
 1011d18:	00c00044 	movi	r3,1
 1011d1c:	10c05926 	beq	r2,r3,1011e84 <___vfiprintf_internal_r+0xb3c>
 1011d20:	00c00084 	movi	r3,2
 1011d24:	10ffe41e 	bne	r2,r3,1011cb8 <__alt_data_end+0xff811cb8>
 1011d28:	0025883a 	mov	r18,zero
 1011d2c:	0027883a 	mov	r19,zero
 1011d30:	00013d06 	br	1012228 <___vfiprintf_internal_r+0xee0>
 1011d34:	21003fcc 	andi	r4,r4,255
 1011d38:	2002811e 	bne	r4,zero,1012740 <___vfiprintf_internal_r+0x13f8>
 1011d3c:	008040b4 	movhi	r2,258
 1011d40:	10aaf904 	addi	r2,r2,-21532
 1011d44:	d8802615 	stw	r2,152(sp)
 1011d48:	a080080c 	andi	r2,r20,32
 1011d4c:	103f561e 	bne	r2,zero,1011aa8 <__alt_data_end+0xff811aa8>
 1011d50:	a080040c 	andi	r2,r20,16
 1011d54:	1001d126 	beq	r2,zero,101249c <___vfiprintf_internal_r+0x1154>
 1011d58:	da802217 	ldw	r10,136(sp)
 1011d5c:	0027883a 	mov	r19,zero
 1011d60:	54800017 	ldw	r18,0(r10)
 1011d64:	52800104 	addi	r10,r10,4
 1011d68:	da802215 	stw	r10,136(sp)
 1011d6c:	003f5306 	br	1011abc <__alt_data_end+0xff811abc>
 1011d70:	da802217 	ldw	r10,136(sp)
 1011d74:	d8001d85 	stb	zero,118(sp)
 1011d78:	55400017 	ldw	r21,0(r10)
 1011d7c:	50c00104 	addi	r3,r10,4
 1011d80:	a8024226 	beq	r21,zero,101268c <___vfiprintf_internal_r+0x1344>
 1011d84:	48021816 	blt	r9,zero,10125e8 <___vfiprintf_internal_r+0x12a0>
 1011d88:	480d883a 	mov	r6,r9
 1011d8c:	000b883a 	mov	r5,zero
 1011d90:	a809883a 	mov	r4,r21
 1011d94:	d8c02a15 	stw	r3,168(sp)
 1011d98:	da002b15 	stw	r8,172(sp)
 1011d9c:	da402c15 	stw	r9,176(sp)
 1011da0:	100f64c0 	call	100f64c <memchr>
 1011da4:	d8c02a17 	ldw	r3,168(sp)
 1011da8:	da002b17 	ldw	r8,172(sp)
 1011dac:	da402c17 	ldw	r9,176(sp)
 1011db0:	10024826 	beq	r2,zero,10126d4 <___vfiprintf_internal_r+0x138c>
 1011db4:	1567c83a 	sub	r19,r2,r21
 1011db8:	df001d83 	ldbu	fp,118(sp)
 1011dbc:	d8c02215 	stw	r3,136(sp)
 1011dc0:	0013883a 	mov	r9,zero
 1011dc4:	003e6006 	br	1011748 <__alt_data_end+0xff811748>
 1011dc8:	21003fcc 	andi	r4,r4,255
 1011dcc:	203fc026 	beq	r4,zero,1011cd0 <__alt_data_end+0xff811cd0>
 1011dd0:	d9c01d85 	stb	r7,118(sp)
 1011dd4:	003fbe06 	br	1011cd0 <__alt_data_end+0xff811cd0>
 1011dd8:	da802217 	ldw	r10,136(sp)
 1011ddc:	54400017 	ldw	r17,0(r10)
 1011de0:	50800104 	addi	r2,r10,4
 1011de4:	883e3b16 	blt	r17,zero,10116d4 <__alt_data_end+0xff8116d4>
 1011de8:	d8802215 	stw	r2,136(sp)
 1011dec:	80c00007 	ldb	r3,0(r16)
 1011df0:	003db406 	br	10114c4 <__alt_data_end+0xff8114c4>
 1011df4:	01000044 	movi	r4,1
 1011df8:	01c00ac4 	movi	r7,43
 1011dfc:	80c00007 	ldb	r3,0(r16)
 1011e00:	003db006 	br	10114c4 <__alt_data_end+0xff8114c4>
 1011e04:	80c00007 	ldb	r3,0(r16)
 1011e08:	82800044 	addi	r10,r16,1
 1011e0c:	1b423c26 	beq	r3,r13,1012700 <___vfiprintf_internal_r+0x13b8>
 1011e10:	18bff404 	addi	r2,r3,-48
 1011e14:	0013883a 	mov	r9,zero
 1011e18:	30822b36 	bltu	r6,r2,10126c8 <___vfiprintf_internal_r+0x1380>
 1011e1c:	50c00007 	ldb	r3,0(r10)
 1011e20:	4a4002a4 	muli	r9,r9,10
 1011e24:	54000044 	addi	r16,r10,1
 1011e28:	8015883a 	mov	r10,r16
 1011e2c:	4893883a 	add	r9,r9,r2
 1011e30:	18bff404 	addi	r2,r3,-48
 1011e34:	30bff92e 	bgeu	r6,r2,1011e1c <__alt_data_end+0xff811e1c>
 1011e38:	483da30e 	bge	r9,zero,10114c8 <__alt_data_end+0xff8114c8>
 1011e3c:	027fffc4 	movi	r9,-1
 1011e40:	003da106 	br	10114c8 <__alt_data_end+0xff8114c8>
 1011e44:	a5001014 	ori	r20,r20,64
 1011e48:	80c00007 	ldb	r3,0(r16)
 1011e4c:	003d9d06 	br	10114c4 <__alt_data_end+0xff8114c4>
 1011e50:	da802217 	ldw	r10,136(sp)
 1011e54:	d8001d85 	stb	zero,118(sp)
 1011e58:	50c00204 	addi	r3,r10,8
 1011e5c:	54800017 	ldw	r18,0(r10)
 1011e60:	54c00117 	ldw	r19,4(r10)
 1011e64:	4801ca16 	blt	r9,zero,1012590 <___vfiprintf_internal_r+0x1248>
 1011e68:	013fdfc4 	movi	r4,-129
 1011e6c:	94c4b03a 	or	r2,r18,r19
 1011e70:	d8c02215 	stw	r3,136(sp)
 1011e74:	a128703a 	and	r20,r20,r4
 1011e78:	0039883a 	mov	fp,zero
 1011e7c:	103f341e 	bne	r2,zero,1011b50 <__alt_data_end+0xff811b50>
 1011e80:	483e2e26 	beq	r9,zero,101173c <__alt_data_end+0xff81173c>
 1011e84:	0025883a 	mov	r18,zero
 1011e88:	94800c04 	addi	r18,r18,48
 1011e8c:	dc8019c5 	stb	r18,103(sp)
 1011e90:	dcc02717 	ldw	r19,156(sp)
 1011e94:	dd4019c4 	addi	r21,sp,103
 1011e98:	003e2b06 	br	1011748 <__alt_data_end+0xff811748>
 1011e9c:	21003fcc 	andi	r4,r4,255
 1011ea0:	2002361e 	bne	r4,zero,101277c <___vfiprintf_internal_r+0x1434>
 1011ea4:	1801c126 	beq	r3,zero,10125ac <___vfiprintf_internal_r+0x1264>
 1011ea8:	04800044 	movi	r18,1
 1011eac:	d8c01005 	stb	r3,64(sp)
 1011eb0:	d8001d85 	stb	zero,118(sp)
 1011eb4:	9027883a 	mov	r19,r18
 1011eb8:	dd401004 	addi	r21,sp,64
 1011ebc:	003f1106 	br	1011b04 <__alt_data_end+0xff811b04>
 1011ec0:	d9402117 	ldw	r5,132(sp)
 1011ec4:	d9002017 	ldw	r4,128(sp)
 1011ec8:	d9801a04 	addi	r6,sp,104
 1011ecc:	d9c02b15 	stw	r7,172(sp)
 1011ed0:	dbc02a15 	stw	r15,168(sp)
 1011ed4:	10112340 	call	1011234 <__sprint_r.part.0>
 1011ed8:	d9c02b17 	ldw	r7,172(sp)
 1011edc:	dbc02a17 	ldw	r15,168(sp)
 1011ee0:	10006d1e 	bne	r2,zero,1012098 <___vfiprintf_internal_r+0xd50>
 1011ee4:	d9801b17 	ldw	r6,108(sp)
 1011ee8:	d8801c17 	ldw	r2,112(sp)
 1011eec:	d811883a 	mov	r8,sp
 1011ef0:	31400044 	addi	r5,r6,1
 1011ef4:	003e3306 	br	10117c4 <__alt_data_end+0xff8117c4>
 1011ef8:	d9401b17 	ldw	r5,108(sp)
 1011efc:	d8801c17 	ldw	r2,112(sp)
 1011f00:	29000044 	addi	r4,r5,1
 1011f04:	d8c01d87 	ldb	r3,118(sp)
 1011f08:	183e4d26 	beq	r3,zero,1011840 <__alt_data_end+0xff811840>
 1011f0c:	00c00044 	movi	r3,1
 1011f10:	d9401d84 	addi	r5,sp,118
 1011f14:	10c5883a 	add	r2,r2,r3
 1011f18:	41400015 	stw	r5,0(r8)
 1011f1c:	40c00115 	stw	r3,4(r8)
 1011f20:	d8801c15 	stw	r2,112(sp)
 1011f24:	d9001b15 	stw	r4,108(sp)
 1011f28:	014001c4 	movi	r5,7
 1011f2c:	2900a90e 	bge	r5,r4,10121d4 <___vfiprintf_internal_r+0xe8c>
 1011f30:	1000da1e 	bne	r2,zero,101229c <___vfiprintf_internal_r+0xf54>
 1011f34:	7000ab1e 	bne	r14,zero,10121e4 <___vfiprintf_internal_r+0xe9c>
 1011f38:	000b883a 	mov	r5,zero
 1011f3c:	1809883a 	mov	r4,r3
 1011f40:	d811883a 	mov	r8,sp
 1011f44:	00c02004 	movi	r3,128
 1011f48:	e0fe4d26 	beq	fp,r3,1011880 <__alt_data_end+0xff811880>
 1011f4c:	4cf9c83a 	sub	fp,r9,r19
 1011f50:	073e7b0e 	bge	zero,fp,1011940 <__alt_data_end+0xff811940>
 1011f54:	01c00404 	movi	r7,16
 1011f58:	3f01900e 	bge	r7,fp,101259c <___vfiprintf_internal_r+0x1254>
 1011f5c:	00c040b4 	movhi	r3,258
 1011f60:	18eb5f04 	addi	r3,r3,-21124
 1011f64:	d8c02415 	stw	r3,144(sp)
 1011f68:	034001c4 	movi	r13,7
 1011f6c:	00000506 	br	1011f84 <___vfiprintf_internal_r+0xc3c>
 1011f70:	29000084 	addi	r4,r5,2
 1011f74:	42000204 	addi	r8,r8,8
 1011f78:	180b883a 	mov	r5,r3
 1011f7c:	e73ffc04 	addi	fp,fp,-16
 1011f80:	3f000d0e 	bge	r7,fp,1011fb8 <___vfiprintf_internal_r+0xc70>
 1011f84:	10800404 	addi	r2,r2,16
 1011f88:	28c00044 	addi	r3,r5,1
 1011f8c:	45c00015 	stw	r23,0(r8)
 1011f90:	41c00115 	stw	r7,4(r8)
 1011f94:	d8801c15 	stw	r2,112(sp)
 1011f98:	d8c01b15 	stw	r3,108(sp)
 1011f9c:	68fff40e 	bge	r13,r3,1011f70 <__alt_data_end+0xff811f70>
 1011fa0:	1000101e 	bne	r2,zero,1011fe4 <___vfiprintf_internal_r+0xc9c>
 1011fa4:	e73ffc04 	addi	fp,fp,-16
 1011fa8:	01000044 	movi	r4,1
 1011fac:	000b883a 	mov	r5,zero
 1011fb0:	d811883a 	mov	r8,sp
 1011fb4:	3f3ff316 	blt	r7,fp,1011f84 <__alt_data_end+0xff811f84>
 1011fb8:	da802417 	ldw	r10,144(sp)
 1011fbc:	1705883a 	add	r2,r2,fp
 1011fc0:	47000115 	stw	fp,4(r8)
 1011fc4:	42800015 	stw	r10,0(r8)
 1011fc8:	d8801c15 	stw	r2,112(sp)
 1011fcc:	d9001b15 	stw	r4,108(sp)
 1011fd0:	00c001c4 	movi	r3,7
 1011fd4:	19003616 	blt	r3,r4,10120b0 <___vfiprintf_internal_r+0xd68>
 1011fd8:	42000204 	addi	r8,r8,8
 1011fdc:	21000044 	addi	r4,r4,1
 1011fe0:	003e5706 	br	1011940 <__alt_data_end+0xff811940>
 1011fe4:	d9402117 	ldw	r5,132(sp)
 1011fe8:	d9002017 	ldw	r4,128(sp)
 1011fec:	d9801a04 	addi	r6,sp,104
 1011ff0:	d9c02b15 	stw	r7,172(sp)
 1011ff4:	db402a15 	stw	r13,168(sp)
 1011ff8:	10112340 	call	1011234 <__sprint_r.part.0>
 1011ffc:	d9c02b17 	ldw	r7,172(sp)
 1012000:	db402a17 	ldw	r13,168(sp)
 1012004:	1000241e 	bne	r2,zero,1012098 <___vfiprintf_internal_r+0xd50>
 1012008:	d9401b17 	ldw	r5,108(sp)
 101200c:	d8801c17 	ldw	r2,112(sp)
 1012010:	d811883a 	mov	r8,sp
 1012014:	29000044 	addi	r4,r5,1
 1012018:	003fd806 	br	1011f7c <__alt_data_end+0xff811f7c>
 101201c:	d9401b17 	ldw	r5,108(sp)
 1012020:	00c040b4 	movhi	r3,258
 1012024:	18eb6304 	addi	r3,r3,-21108
 1012028:	d8c02415 	stw	r3,144(sp)
 101202c:	29400044 	addi	r5,r5,1
 1012030:	d8c02417 	ldw	r3,144(sp)
 1012034:	14c5883a 	add	r2,r2,r19
 1012038:	44c00115 	stw	r19,4(r8)
 101203c:	40c00015 	stw	r3,0(r8)
 1012040:	d8801c15 	stw	r2,112(sp)
 1012044:	d9401b15 	stw	r5,108(sp)
 1012048:	00c001c4 	movi	r3,7
 101204c:	1940070e 	bge	r3,r5,101206c <___vfiprintf_internal_r+0xd24>
 1012050:	103e4826 	beq	r2,zero,1011974 <__alt_data_end+0xff811974>
 1012054:	d9402117 	ldw	r5,132(sp)
 1012058:	d9002017 	ldw	r4,128(sp)
 101205c:	d9801a04 	addi	r6,sp,104
 1012060:	10112340 	call	1011234 <__sprint_r.part.0>
 1012064:	10000c1e 	bne	r2,zero,1012098 <___vfiprintf_internal_r+0xd50>
 1012068:	d8801c17 	ldw	r2,112(sp)
 101206c:	8c80010e 	bge	r17,r18,1012074 <___vfiprintf_internal_r+0xd2c>
 1012070:	9023883a 	mov	r17,r18
 1012074:	da802317 	ldw	r10,140(sp)
 1012078:	5455883a 	add	r10,r10,r17
 101207c:	da802315 	stw	r10,140(sp)
 1012080:	103e4126 	beq	r2,zero,1011988 <__alt_data_end+0xff811988>
 1012084:	d9402117 	ldw	r5,132(sp)
 1012088:	d9002017 	ldw	r4,128(sp)
 101208c:	d9801a04 	addi	r6,sp,104
 1012090:	10112340 	call	1011234 <__sprint_r.part.0>
 1012094:	103e3c26 	beq	r2,zero,1011988 <__alt_data_end+0xff811988>
 1012098:	dd002117 	ldw	r20,132(sp)
 101209c:	a080030b 	ldhu	r2,12(r20)
 10120a0:	1080100c 	andi	r2,r2,64
 10120a4:	1001231e 	bne	r2,zero,1012534 <___vfiprintf_internal_r+0x11ec>
 10120a8:	d8802317 	ldw	r2,140(sp)
 10120ac:	003d7b06 	br	101169c <__alt_data_end+0xff81169c>
 10120b0:	1000991e 	bne	r2,zero,1012318 <___vfiprintf_internal_r+0xfd0>
 10120b4:	00c00044 	movi	r3,1
 10120b8:	9805883a 	mov	r2,r19
 10120bc:	dd400015 	stw	r21,0(sp)
 10120c0:	dcc00115 	stw	r19,4(sp)
 10120c4:	dcc01c15 	stw	r19,112(sp)
 10120c8:	d8c01b15 	stw	r3,108(sp)
 10120cc:	d811883a 	mov	r8,sp
 10120d0:	42000204 	addi	r8,r8,8
 10120d4:	a2c0010c 	andi	r11,r20,4
 10120d8:	583fe426 	beq	r11,zero,101206c <__alt_data_end+0xff81206c>
 10120dc:	8ca7c83a 	sub	r19,r17,r18
 10120e0:	04ffe20e 	bge	zero,r19,101206c <__alt_data_end+0xff81206c>
 10120e4:	01c00404 	movi	r7,16
 10120e8:	3cffcc0e 	bge	r7,r19,101201c <__alt_data_end+0xff81201c>
 10120ec:	028040b4 	movhi	r10,258
 10120f0:	52ab6304 	addi	r10,r10,-21108
 10120f4:	d9001b17 	ldw	r4,108(sp)
 10120f8:	da802415 	stw	r10,144(sp)
 10120fc:	382b883a 	mov	r21,r7
 1012100:	050001c4 	movi	r20,7
 1012104:	df002017 	ldw	fp,128(sp)
 1012108:	00000506 	br	1012120 <___vfiprintf_internal_r+0xdd8>
 101210c:	21400084 	addi	r5,r4,2
 1012110:	42000204 	addi	r8,r8,8
 1012114:	1809883a 	mov	r4,r3
 1012118:	9cfffc04 	addi	r19,r19,-16
 101211c:	acffc40e 	bge	r21,r19,1012030 <__alt_data_end+0xff812030>
 1012120:	10800404 	addi	r2,r2,16
 1012124:	20c00044 	addi	r3,r4,1
 1012128:	45800015 	stw	r22,0(r8)
 101212c:	45400115 	stw	r21,4(r8)
 1012130:	d8801c15 	stw	r2,112(sp)
 1012134:	d8c01b15 	stw	r3,108(sp)
 1012138:	a0fff40e 	bge	r20,r3,101210c <__alt_data_end+0xff81210c>
 101213c:	1000041e 	bne	r2,zero,1012150 <___vfiprintf_internal_r+0xe08>
 1012140:	01400044 	movi	r5,1
 1012144:	0009883a 	mov	r4,zero
 1012148:	d811883a 	mov	r8,sp
 101214c:	003ff206 	br	1012118 <__alt_data_end+0xff812118>
 1012150:	d9402117 	ldw	r5,132(sp)
 1012154:	d9801a04 	addi	r6,sp,104
 1012158:	e009883a 	mov	r4,fp
 101215c:	10112340 	call	1011234 <__sprint_r.part.0>
 1012160:	103fcd1e 	bne	r2,zero,1012098 <__alt_data_end+0xff812098>
 1012164:	d9001b17 	ldw	r4,108(sp)
 1012168:	d8801c17 	ldw	r2,112(sp)
 101216c:	d811883a 	mov	r8,sp
 1012170:	21400044 	addi	r5,r4,1
 1012174:	003fe806 	br	1012118 <__alt_data_end+0xff812118>
 1012178:	d9402117 	ldw	r5,132(sp)
 101217c:	d9002017 	ldw	r4,128(sp)
 1012180:	d9801a04 	addi	r6,sp,104
 1012184:	d9c02b15 	stw	r7,172(sp)
 1012188:	db402a15 	stw	r13,168(sp)
 101218c:	10112340 	call	1011234 <__sprint_r.part.0>
 1012190:	d9c02b17 	ldw	r7,172(sp)
 1012194:	db402a17 	ldw	r13,168(sp)
 1012198:	103fbf1e 	bne	r2,zero,1012098 <__alt_data_end+0xff812098>
 101219c:	d9401b17 	ldw	r5,108(sp)
 10121a0:	d8801c17 	ldw	r2,112(sp)
 10121a4:	d811883a 	mov	r8,sp
 10121a8:	29800044 	addi	r6,r5,1
 10121ac:	003dc406 	br	10118c0 <__alt_data_end+0xff8118c0>
 10121b0:	1000d21e 	bne	r2,zero,10124fc <___vfiprintf_internal_r+0x11b4>
 10121b4:	d8c01d87 	ldb	r3,118(sp)
 10121b8:	18009526 	beq	r3,zero,1012410 <___vfiprintf_internal_r+0x10c8>
 10121bc:	00800044 	movi	r2,1
 10121c0:	d8c01d84 	addi	r3,sp,118
 10121c4:	1009883a 	mov	r4,r2
 10121c8:	d8c00015 	stw	r3,0(sp)
 10121cc:	d8800115 	stw	r2,4(sp)
 10121d0:	d811883a 	mov	r8,sp
 10121d4:	200b883a 	mov	r5,r4
 10121d8:	42000204 	addi	r8,r8,8
 10121dc:	21000044 	addi	r4,r4,1
 10121e0:	003d9706 	br	1011840 <__alt_data_end+0xff811840>
 10121e4:	d9001d04 	addi	r4,sp,116
 10121e8:	00800084 	movi	r2,2
 10121ec:	d9000015 	stw	r4,0(sp)
 10121f0:	d8800115 	stw	r2,4(sp)
 10121f4:	1809883a 	mov	r4,r3
 10121f8:	d811883a 	mov	r8,sp
 10121fc:	200b883a 	mov	r5,r4
 1012200:	42000204 	addi	r8,r8,8
 1012204:	21000044 	addi	r4,r4,1
 1012208:	003f4e06 	br	1011f44 <__alt_data_end+0xff811f44>
 101220c:	d8001d85 	stb	zero,118(sp)
 1012210:	48005016 	blt	r9,zero,1012354 <___vfiprintf_internal_r+0x100c>
 1012214:	00ffdfc4 	movi	r3,-129
 1012218:	94c4b03a 	or	r2,r18,r19
 101221c:	a0e8703a 	and	r20,r20,r3
 1012220:	103d4426 	beq	r2,zero,1011734 <__alt_data_end+0xff811734>
 1012224:	0039883a 	mov	fp,zero
 1012228:	d9002617 	ldw	r4,152(sp)
 101222c:	dd401a04 	addi	r21,sp,104
 1012230:	908003cc 	andi	r2,r18,15
 1012234:	9806973a 	slli	r3,r19,28
 1012238:	2085883a 	add	r2,r4,r2
 101223c:	9024d13a 	srli	r18,r18,4
 1012240:	10800003 	ldbu	r2,0(r2)
 1012244:	9826d13a 	srli	r19,r19,4
 1012248:	ad7fffc4 	addi	r21,r21,-1
 101224c:	1ca4b03a 	or	r18,r3,r18
 1012250:	a8800005 	stb	r2,0(r21)
 1012254:	94c4b03a 	or	r2,r18,r19
 1012258:	103ff51e 	bne	r2,zero,1012230 <__alt_data_end+0xff812230>
 101225c:	003e5906 	br	1011bc4 <__alt_data_end+0xff811bc4>
 1012260:	d9402117 	ldw	r5,132(sp)
 1012264:	d9002017 	ldw	r4,128(sp)
 1012268:	d9801a04 	addi	r6,sp,104
 101226c:	10112340 	call	1011234 <__sprint_r.part.0>
 1012270:	103f891e 	bne	r2,zero,1012098 <__alt_data_end+0xff812098>
 1012274:	d8801c17 	ldw	r2,112(sp)
 1012278:	d811883a 	mov	r8,sp
 101227c:	003f9506 	br	10120d4 <__alt_data_end+0xff8120d4>
 1012280:	d9402117 	ldw	r5,132(sp)
 1012284:	d9002017 	ldw	r4,128(sp)
 1012288:	d9801a04 	addi	r6,sp,104
 101228c:	10112340 	call	1011234 <__sprint_r.part.0>
 1012290:	103f811e 	bne	r2,zero,1012098 <__alt_data_end+0xff812098>
 1012294:	d811883a 	mov	r8,sp
 1012298:	003ced06 	br	1011650 <__alt_data_end+0xff811650>
 101229c:	d9402117 	ldw	r5,132(sp)
 10122a0:	d9002017 	ldw	r4,128(sp)
 10122a4:	d9801a04 	addi	r6,sp,104
 10122a8:	da402c15 	stw	r9,176(sp)
 10122ac:	db802a15 	stw	r14,168(sp)
 10122b0:	10112340 	call	1011234 <__sprint_r.part.0>
 10122b4:	da402c17 	ldw	r9,176(sp)
 10122b8:	db802a17 	ldw	r14,168(sp)
 10122bc:	103f761e 	bne	r2,zero,1012098 <__alt_data_end+0xff812098>
 10122c0:	d9401b17 	ldw	r5,108(sp)
 10122c4:	d8801c17 	ldw	r2,112(sp)
 10122c8:	d811883a 	mov	r8,sp
 10122cc:	29000044 	addi	r4,r5,1
 10122d0:	003d5b06 	br	1011840 <__alt_data_end+0xff811840>
 10122d4:	d9402117 	ldw	r5,132(sp)
 10122d8:	d9002017 	ldw	r4,128(sp)
 10122dc:	d9801a04 	addi	r6,sp,104
 10122e0:	da402c15 	stw	r9,176(sp)
 10122e4:	10112340 	call	1011234 <__sprint_r.part.0>
 10122e8:	da402c17 	ldw	r9,176(sp)
 10122ec:	103f6a1e 	bne	r2,zero,1012098 <__alt_data_end+0xff812098>
 10122f0:	d9401b17 	ldw	r5,108(sp)
 10122f4:	d8801c17 	ldw	r2,112(sp)
 10122f8:	d811883a 	mov	r8,sp
 10122fc:	29000044 	addi	r4,r5,1
 1012300:	003f1006 	br	1011f44 <__alt_data_end+0xff811f44>
 1012304:	1000c31e 	bne	r2,zero,1012614 <___vfiprintf_internal_r+0x12cc>
 1012308:	01000044 	movi	r4,1
 101230c:	000b883a 	mov	r5,zero
 1012310:	d811883a 	mov	r8,sp
 1012314:	003f0d06 	br	1011f4c <__alt_data_end+0xff811f4c>
 1012318:	d9402117 	ldw	r5,132(sp)
 101231c:	d9002017 	ldw	r4,128(sp)
 1012320:	d9801a04 	addi	r6,sp,104
 1012324:	10112340 	call	1011234 <__sprint_r.part.0>
 1012328:	103f5b1e 	bne	r2,zero,1012098 <__alt_data_end+0xff812098>
 101232c:	d9001b17 	ldw	r4,108(sp)
 1012330:	d8801c17 	ldw	r2,112(sp)
 1012334:	d811883a 	mov	r8,sp
 1012338:	21000044 	addi	r4,r4,1
 101233c:	003d8006 	br	1011940 <__alt_data_end+0xff811940>
 1012340:	010040b4 	movhi	r4,258
 1012344:	212afe04 	addi	r4,r4,-21512
 1012348:	d9002615 	stw	r4,152(sp)
 101234c:	d8c02215 	stw	r3,136(sp)
 1012350:	1029883a 	mov	r20,r2
 1012354:	94c4b03a 	or	r2,r18,r19
 1012358:	103fb21e 	bne	r2,zero,1012224 <__alt_data_end+0xff812224>
 101235c:	0039883a 	mov	fp,zero
 1012360:	00800084 	movi	r2,2
 1012364:	003e6b06 	br	1011d14 <__alt_data_end+0xff811d14>
 1012368:	da802217 	ldw	r10,136(sp)
 101236c:	d8001d85 	stb	zero,118(sp)
 1012370:	0027883a 	mov	r19,zero
 1012374:	50800104 	addi	r2,r10,4
 1012378:	54800017 	ldw	r18,0(r10)
 101237c:	483e6016 	blt	r9,zero,1011d00 <__alt_data_end+0xff811d00>
 1012380:	00ffdfc4 	movi	r3,-129
 1012384:	d8802215 	stw	r2,136(sp)
 1012388:	a0e8703a 	and	r20,r20,r3
 101238c:	0039883a 	mov	fp,zero
 1012390:	903ebb26 	beq	r18,zero,1011e80 <__alt_data_end+0xff811e80>
 1012394:	00800244 	movi	r2,9
 1012398:	14bdee36 	bltu	r2,r18,1011b54 <__alt_data_end+0xff811b54>
 101239c:	003eba06 	br	1011e88 <__alt_data_end+0xff811e88>
 10123a0:	00800c04 	movi	r2,48
 10123a4:	d8c01d45 	stb	r3,117(sp)
 10123a8:	d8801d05 	stb	r2,116(sp)
 10123ac:	d8001d85 	stb	zero,118(sp)
 10123b0:	a0c00094 	ori	r3,r20,2
 10123b4:	4800a916 	blt	r9,zero,101265c <___vfiprintf_internal_r+0x1314>
 10123b8:	00bfdfc4 	movi	r2,-129
 10123bc:	a096703a 	and	r11,r20,r2
 10123c0:	5d000094 	ori	r20,r11,2
 10123c4:	0039883a 	mov	fp,zero
 10123c8:	003f9706 	br	1012228 <__alt_data_end+0xff812228>
 10123cc:	8025883a 	mov	r18,r16
 10123d0:	003c2e06 	br	101148c <__alt_data_end+0xff81148c>
 10123d4:	008040b4 	movhi	r2,258
 10123d8:	10aafe04 	addi	r2,r2,-21512
 10123dc:	0039883a 	mov	fp,zero
 10123e0:	d8802615 	stw	r2,152(sp)
 10123e4:	003f9006 	br	1012228 <__alt_data_end+0xff812228>
 10123e8:	04a5c83a 	sub	r18,zero,r18
 10123ec:	07000b44 	movi	fp,45
 10123f0:	9004c03a 	cmpne	r2,r18,zero
 10123f4:	04e7c83a 	sub	r19,zero,r19
 10123f8:	df001d85 	stb	fp,118(sp)
 10123fc:	98a7c83a 	sub	r19,r19,r2
 1012400:	48009f16 	blt	r9,zero,1012680 <___vfiprintf_internal_r+0x1338>
 1012404:	00bfdfc4 	movi	r2,-129
 1012408:	a0a8703a 	and	r20,r20,r2
 101240c:	003dd006 	br	1011b50 <__alt_data_end+0xff811b50>
 1012410:	70004c26 	beq	r14,zero,1012544 <___vfiprintf_internal_r+0x11fc>
 1012414:	00800084 	movi	r2,2
 1012418:	d8c01d04 	addi	r3,sp,116
 101241c:	d8c00015 	stw	r3,0(sp)
 1012420:	d8800115 	stw	r2,4(sp)
 1012424:	01000044 	movi	r4,1
 1012428:	d811883a 	mov	r8,sp
 101242c:	003f7306 	br	10121fc <__alt_data_end+0xff8121fc>
 1012430:	a080100c 	andi	r2,r20,64
 1012434:	da802217 	ldw	r10,136(sp)
 1012438:	103e0626 	beq	r2,zero,1011c54 <__alt_data_end+0xff811c54>
 101243c:	5480000f 	ldh	r18,0(r10)
 1012440:	52800104 	addi	r10,r10,4
 1012444:	da802215 	stw	r10,136(sp)
 1012448:	9027d7fa 	srai	r19,r18,31
 101244c:	9805883a 	mov	r2,r19
 1012450:	003db806 	br	1011b34 <__alt_data_end+0xff811b34>
 1012454:	a080040c 	andi	r2,r20,16
 1012458:	1000091e 	bne	r2,zero,1012480 <___vfiprintf_internal_r+0x1138>
 101245c:	a2c0100c 	andi	r11,r20,64
 1012460:	58000726 	beq	r11,zero,1012480 <___vfiprintf_internal_r+0x1138>
 1012464:	da802217 	ldw	r10,136(sp)
 1012468:	50800017 	ldw	r2,0(r10)
 101246c:	52800104 	addi	r10,r10,4
 1012470:	da802215 	stw	r10,136(sp)
 1012474:	da802317 	ldw	r10,140(sp)
 1012478:	1280000d 	sth	r10,0(r2)
 101247c:	003be706 	br	101141c <__alt_data_end+0xff81141c>
 1012480:	da802217 	ldw	r10,136(sp)
 1012484:	50800017 	ldw	r2,0(r10)
 1012488:	52800104 	addi	r10,r10,4
 101248c:	da802215 	stw	r10,136(sp)
 1012490:	da802317 	ldw	r10,140(sp)
 1012494:	12800015 	stw	r10,0(r2)
 1012498:	003be006 	br	101141c <__alt_data_end+0xff81141c>
 101249c:	a080100c 	andi	r2,r20,64
 10124a0:	da802217 	ldw	r10,136(sp)
 10124a4:	10003026 	beq	r2,zero,1012568 <___vfiprintf_internal_r+0x1220>
 10124a8:	5480000b 	ldhu	r18,0(r10)
 10124ac:	52800104 	addi	r10,r10,4
 10124b0:	0027883a 	mov	r19,zero
 10124b4:	da802215 	stw	r10,136(sp)
 10124b8:	003d8006 	br	1011abc <__alt_data_end+0xff811abc>
 10124bc:	80c00007 	ldb	r3,0(r16)
 10124c0:	003c0006 	br	10114c4 <__alt_data_end+0xff8114c4>
 10124c4:	a080100c 	andi	r2,r20,64
 10124c8:	d8001d85 	stb	zero,118(sp)
 10124cc:	da802217 	ldw	r10,136(sp)
 10124d0:	1000201e 	bne	r2,zero,1012554 <___vfiprintf_internal_r+0x120c>
 10124d4:	50800104 	addi	r2,r10,4
 10124d8:	54800017 	ldw	r18,0(r10)
 10124dc:	0027883a 	mov	r19,zero
 10124e0:	483def0e 	bge	r9,zero,1011ca0 <__alt_data_end+0xff811ca0>
 10124e4:	94c6b03a 	or	r3,r18,r19
 10124e8:	d8802215 	stw	r2,136(sp)
 10124ec:	183d4e1e 	bne	r3,zero,1011a28 <__alt_data_end+0xff811a28>
 10124f0:	0039883a 	mov	fp,zero
 10124f4:	0005883a 	mov	r2,zero
 10124f8:	003e0606 	br	1011d14 <__alt_data_end+0xff811d14>
 10124fc:	d9402117 	ldw	r5,132(sp)
 1012500:	d9002017 	ldw	r4,128(sp)
 1012504:	d9801a04 	addi	r6,sp,104
 1012508:	da402c15 	stw	r9,176(sp)
 101250c:	db802a15 	stw	r14,168(sp)
 1012510:	10112340 	call	1011234 <__sprint_r.part.0>
 1012514:	da402c17 	ldw	r9,176(sp)
 1012518:	db802a17 	ldw	r14,168(sp)
 101251c:	103ede1e 	bne	r2,zero,1012098 <__alt_data_end+0xff812098>
 1012520:	d9401b17 	ldw	r5,108(sp)
 1012524:	d8801c17 	ldw	r2,112(sp)
 1012528:	d811883a 	mov	r8,sp
 101252c:	29000044 	addi	r4,r5,1
 1012530:	003e7406 	br	1011f04 <__alt_data_end+0xff811f04>
 1012534:	00bfffc4 	movi	r2,-1
 1012538:	003c5806 	br	101169c <__alt_data_end+0xff81169c>
 101253c:	d811883a 	mov	r8,sp
 1012540:	003ee806 	br	10120e4 <__alt_data_end+0xff8120e4>
 1012544:	000b883a 	mov	r5,zero
 1012548:	01000044 	movi	r4,1
 101254c:	d811883a 	mov	r8,sp
 1012550:	003e7c06 	br	1011f44 <__alt_data_end+0xff811f44>
 1012554:	50800104 	addi	r2,r10,4
 1012558:	5480000b 	ldhu	r18,0(r10)
 101255c:	0027883a 	mov	r19,zero
 1012560:	483dcf0e 	bge	r9,zero,1011ca0 <__alt_data_end+0xff811ca0>
 1012564:	003fdf06 	br	10124e4 <__alt_data_end+0xff8124e4>
 1012568:	54800017 	ldw	r18,0(r10)
 101256c:	52800104 	addi	r10,r10,4
 1012570:	0027883a 	mov	r19,zero
 1012574:	da802215 	stw	r10,136(sp)
 1012578:	003d5006 	br	1011abc <__alt_data_end+0xff811abc>
 101257c:	50800104 	addi	r2,r10,4
 1012580:	5480000b 	ldhu	r18,0(r10)
 1012584:	0027883a 	mov	r19,zero
 1012588:	483f7d0e 	bge	r9,zero,1012380 <__alt_data_end+0xff812380>
 101258c:	003ddc06 	br	1011d00 <__alt_data_end+0xff811d00>
 1012590:	d8c02215 	stw	r3,136(sp)
 1012594:	0039883a 	mov	fp,zero
 1012598:	003ddb06 	br	1011d08 <__alt_data_end+0xff811d08>
 101259c:	028040b4 	movhi	r10,258
 10125a0:	52ab5f04 	addi	r10,r10,-21124
 10125a4:	da802415 	stw	r10,144(sp)
 10125a8:	003e8306 	br	1011fb8 <__alt_data_end+0xff811fb8>
 10125ac:	d8801c17 	ldw	r2,112(sp)
 10125b0:	dd002117 	ldw	r20,132(sp)
 10125b4:	103eb926 	beq	r2,zero,101209c <__alt_data_end+0xff81209c>
 10125b8:	d9002017 	ldw	r4,128(sp)
 10125bc:	d9801a04 	addi	r6,sp,104
 10125c0:	a00b883a 	mov	r5,r20
 10125c4:	10112340 	call	1011234 <__sprint_r.part.0>
 10125c8:	003eb406 	br	101209c <__alt_data_end+0xff81209c>
 10125cc:	80c00043 	ldbu	r3,1(r16)
 10125d0:	a5000814 	ori	r20,r20,32
 10125d4:	84000044 	addi	r16,r16,1
 10125d8:	18c03fcc 	andi	r3,r3,255
 10125dc:	18c0201c 	xori	r3,r3,128
 10125e0:	18ffe004 	addi	r3,r3,-128
 10125e4:	003bb706 	br	10114c4 <__alt_data_end+0xff8114c4>
 10125e8:	a809883a 	mov	r4,r21
 10125ec:	d8c02a15 	stw	r3,168(sp)
 10125f0:	da002b15 	stw	r8,172(sp)
 10125f4:	1009da40 	call	1009da4 <strlen>
 10125f8:	d8c02a17 	ldw	r3,168(sp)
 10125fc:	1027883a 	mov	r19,r2
 1012600:	df001d83 	ldbu	fp,118(sp)
 1012604:	d8c02215 	stw	r3,136(sp)
 1012608:	0013883a 	mov	r9,zero
 101260c:	da002b17 	ldw	r8,172(sp)
 1012610:	003c4d06 	br	1011748 <__alt_data_end+0xff811748>
 1012614:	d9402117 	ldw	r5,132(sp)
 1012618:	d9002017 	ldw	r4,128(sp)
 101261c:	d9801a04 	addi	r6,sp,104
 1012620:	da402c15 	stw	r9,176(sp)
 1012624:	10112340 	call	1011234 <__sprint_r.part.0>
 1012628:	da402c17 	ldw	r9,176(sp)
 101262c:	103e9a1e 	bne	r2,zero,1012098 <__alt_data_end+0xff812098>
 1012630:	d9401b17 	ldw	r5,108(sp)
 1012634:	d8801c17 	ldw	r2,112(sp)
 1012638:	d811883a 	mov	r8,sp
 101263c:	29000044 	addi	r4,r5,1
 1012640:	003e4206 	br	1011f4c <__alt_data_end+0xff811f4c>
 1012644:	d9401b17 	ldw	r5,108(sp)
 1012648:	010040b4 	movhi	r4,258
 101264c:	212b6304 	addi	r4,r4,-21108
 1012650:	d9002415 	stw	r4,144(sp)
 1012654:	29400044 	addi	r5,r5,1
 1012658:	003c6d06 	br	1011810 <__alt_data_end+0xff811810>
 101265c:	0039883a 	mov	fp,zero
 1012660:	00800084 	movi	r2,2
 1012664:	10803fcc 	andi	r2,r2,255
 1012668:	01000044 	movi	r4,1
 101266c:	11001e26 	beq	r2,r4,10126e8 <___vfiprintf_internal_r+0x13a0>
 1012670:	01000084 	movi	r4,2
 1012674:	11001e1e 	bne	r2,r4,10126f0 <___vfiprintf_internal_r+0x13a8>
 1012678:	1829883a 	mov	r20,r3
 101267c:	003eea06 	br	1012228 <__alt_data_end+0xff812228>
 1012680:	a007883a 	mov	r3,r20
 1012684:	00800044 	movi	r2,1
 1012688:	003ff606 	br	1012664 <__alt_data_end+0xff812664>
 101268c:	00800184 	movi	r2,6
 1012690:	1240012e 	bgeu	r2,r9,1012698 <___vfiprintf_internal_r+0x1350>
 1012694:	1013883a 	mov	r9,r2
 1012698:	4827883a 	mov	r19,r9
 101269c:	4825883a 	mov	r18,r9
 10126a0:	48001516 	blt	r9,zero,10126f8 <___vfiprintf_internal_r+0x13b0>
 10126a4:	054040b4 	movhi	r21,258
 10126a8:	d8c02215 	stw	r3,136(sp)
 10126ac:	ad6b0304 	addi	r21,r21,-21492
 10126b0:	003d1406 	br	1011b04 <__alt_data_end+0xff811b04>
 10126b4:	028040b4 	movhi	r10,258
 10126b8:	52ab5f04 	addi	r10,r10,-21124
 10126bc:	da802415 	stw	r10,144(sp)
 10126c0:	200d883a 	mov	r6,r4
 10126c4:	003c9106 	br	101190c <__alt_data_end+0xff81190c>
 10126c8:	5021883a 	mov	r16,r10
 10126cc:	0013883a 	mov	r9,zero
 10126d0:	003b7d06 	br	10114c8 <__alt_data_end+0xff8114c8>
 10126d4:	4827883a 	mov	r19,r9
 10126d8:	df001d83 	ldbu	fp,118(sp)
 10126dc:	d8c02215 	stw	r3,136(sp)
 10126e0:	0013883a 	mov	r9,zero
 10126e4:	003c1806 	br	1011748 <__alt_data_end+0xff811748>
 10126e8:	1829883a 	mov	r20,r3
 10126ec:	003d1806 	br	1011b50 <__alt_data_end+0xff811b50>
 10126f0:	1829883a 	mov	r20,r3
 10126f4:	003ccd06 	br	1011a2c <__alt_data_end+0xff811a2c>
 10126f8:	0025883a 	mov	r18,zero
 10126fc:	003fe906 	br	10126a4 <__alt_data_end+0xff8126a4>
 1012700:	d8802217 	ldw	r2,136(sp)
 1012704:	80c00043 	ldbu	r3,1(r16)
 1012708:	5021883a 	mov	r16,r10
 101270c:	12400017 	ldw	r9,0(r2)
 1012710:	10800104 	addi	r2,r2,4
 1012714:	d8802215 	stw	r2,136(sp)
 1012718:	483faf0e 	bge	r9,zero,10125d8 <__alt_data_end+0xff8125d8>
 101271c:	18c03fcc 	andi	r3,r3,255
 1012720:	18c0201c 	xori	r3,r3,128
 1012724:	027fffc4 	movi	r9,-1
 1012728:	18ffe004 	addi	r3,r3,-128
 101272c:	003b6506 	br	10114c4 <__alt_data_end+0xff8114c4>
 1012730:	d9c01d85 	stb	r7,118(sp)
 1012734:	003ca006 	br	10119b8 <__alt_data_end+0xff8119b8>
 1012738:	d9c01d85 	stb	r7,118(sp)
 101273c:	003cad06 	br	10119f4 <__alt_data_end+0xff8119f4>
 1012740:	d9c01d85 	stb	r7,118(sp)
 1012744:	003d7d06 	br	1011d3c <__alt_data_end+0xff811d3c>
 1012748:	d9c01d85 	stb	r7,118(sp)
 101274c:	003d5f06 	br	1011ccc <__alt_data_end+0xff811ccc>
 1012750:	a080004c 	andi	r2,r20,1
 1012754:	0039883a 	mov	fp,zero
 1012758:	10000526 	beq	r2,zero,1012770 <___vfiprintf_internal_r+0x1428>
 101275c:	00800c04 	movi	r2,48
 1012760:	d88019c5 	stb	r2,103(sp)
 1012764:	dcc02717 	ldw	r19,156(sp)
 1012768:	dd4019c4 	addi	r21,sp,103
 101276c:	003bf606 	br	1011748 <__alt_data_end+0xff811748>
 1012770:	0027883a 	mov	r19,zero
 1012774:	dd401a04 	addi	r21,sp,104
 1012778:	003bf306 	br	1011748 <__alt_data_end+0xff811748>
 101277c:	d9c01d85 	stb	r7,118(sp)
 1012780:	003dc806 	br	1011ea4 <__alt_data_end+0xff811ea4>
 1012784:	d9c01d85 	stb	r7,118(sp)
 1012788:	003d3a06 	br	1011c74 <__alt_data_end+0xff811c74>
 101278c:	d9c01d85 	stb	r7,118(sp)
 1012790:	003d2a06 	br	1011c3c <__alt_data_end+0xff811c3c>
 1012794:	d9c01d85 	stb	r7,118(sp)
 1012798:	003cde06 	br	1011b14 <__alt_data_end+0xff811b14>
 101279c:	d9c01d85 	stb	r7,118(sp)
 10127a0:	003cbc06 	br	1011a94 <__alt_data_end+0xff811a94>

010127a4 <__vfiprintf_internal>:
 10127a4:	008040b4 	movhi	r2,258
 10127a8:	10b39b04 	addi	r2,r2,-12692
 10127ac:	300f883a 	mov	r7,r6
 10127b0:	280d883a 	mov	r6,r5
 10127b4:	200b883a 	mov	r5,r4
 10127b8:	11000017 	ldw	r4,0(r2)
 10127bc:	10113481 	jmpi	1011348 <___vfiprintf_internal_r>

010127c0 <__sbprintf>:
 10127c0:	2880030b 	ldhu	r2,12(r5)
 10127c4:	2ac01917 	ldw	r11,100(r5)
 10127c8:	2a80038b 	ldhu	r10,14(r5)
 10127cc:	2a400717 	ldw	r9,28(r5)
 10127d0:	2a000917 	ldw	r8,36(r5)
 10127d4:	defee204 	addi	sp,sp,-1144
 10127d8:	00c10004 	movi	r3,1024
 10127dc:	dc011a15 	stw	r16,1128(sp)
 10127e0:	10bfff4c 	andi	r2,r2,65533
 10127e4:	2821883a 	mov	r16,r5
 10127e8:	d8cb883a 	add	r5,sp,r3
 10127ec:	dc811c15 	stw	r18,1136(sp)
 10127f0:	dc411b15 	stw	r17,1132(sp)
 10127f4:	dfc11d15 	stw	ra,1140(sp)
 10127f8:	2025883a 	mov	r18,r4
 10127fc:	d881030d 	sth	r2,1036(sp)
 1012800:	dac11915 	stw	r11,1124(sp)
 1012804:	da81038d 	sth	r10,1038(sp)
 1012808:	da410715 	stw	r9,1052(sp)
 101280c:	da010915 	stw	r8,1060(sp)
 1012810:	dec10015 	stw	sp,1024(sp)
 1012814:	dec10415 	stw	sp,1040(sp)
 1012818:	d8c10215 	stw	r3,1032(sp)
 101281c:	d8c10515 	stw	r3,1044(sp)
 1012820:	d8010615 	stw	zero,1048(sp)
 1012824:	10113480 	call	1011348 <___vfiprintf_internal_r>
 1012828:	1023883a 	mov	r17,r2
 101282c:	10000416 	blt	r2,zero,1012840 <__sbprintf+0x80>
 1012830:	d9410004 	addi	r5,sp,1024
 1012834:	9009883a 	mov	r4,r18
 1012838:	100dd040 	call	100dd04 <_fflush_r>
 101283c:	10000d1e 	bne	r2,zero,1012874 <__sbprintf+0xb4>
 1012840:	d881030b 	ldhu	r2,1036(sp)
 1012844:	1080100c 	andi	r2,r2,64
 1012848:	10000326 	beq	r2,zero,1012858 <__sbprintf+0x98>
 101284c:	8080030b 	ldhu	r2,12(r16)
 1012850:	10801014 	ori	r2,r2,64
 1012854:	8080030d 	sth	r2,12(r16)
 1012858:	8805883a 	mov	r2,r17
 101285c:	dfc11d17 	ldw	ra,1140(sp)
 1012860:	dc811c17 	ldw	r18,1136(sp)
 1012864:	dc411b17 	ldw	r17,1132(sp)
 1012868:	dc011a17 	ldw	r16,1128(sp)
 101286c:	dec11e04 	addi	sp,sp,1144
 1012870:	f800283a 	ret
 1012874:	047fffc4 	movi	r17,-1
 1012878:	003ff106 	br	1012840 <__alt_data_end+0xff812840>

0101287c <__swbuf_r>:
 101287c:	defffb04 	addi	sp,sp,-20
 1012880:	dcc00315 	stw	r19,12(sp)
 1012884:	dc800215 	stw	r18,8(sp)
 1012888:	dc000015 	stw	r16,0(sp)
 101288c:	dfc00415 	stw	ra,16(sp)
 1012890:	dc400115 	stw	r17,4(sp)
 1012894:	2025883a 	mov	r18,r4
 1012898:	2827883a 	mov	r19,r5
 101289c:	3021883a 	mov	r16,r6
 10128a0:	20000226 	beq	r4,zero,10128ac <__swbuf_r+0x30>
 10128a4:	20800e17 	ldw	r2,56(r4)
 10128a8:	10004226 	beq	r2,zero,10129b4 <__swbuf_r+0x138>
 10128ac:	80800617 	ldw	r2,24(r16)
 10128b0:	8100030b 	ldhu	r4,12(r16)
 10128b4:	80800215 	stw	r2,8(r16)
 10128b8:	2080020c 	andi	r2,r4,8
 10128bc:	10003626 	beq	r2,zero,1012998 <__swbuf_r+0x11c>
 10128c0:	80c00417 	ldw	r3,16(r16)
 10128c4:	18003426 	beq	r3,zero,1012998 <__swbuf_r+0x11c>
 10128c8:	2088000c 	andi	r2,r4,8192
 10128cc:	9c403fcc 	andi	r17,r19,255
 10128d0:	10001a26 	beq	r2,zero,101293c <__swbuf_r+0xc0>
 10128d4:	80800017 	ldw	r2,0(r16)
 10128d8:	81000517 	ldw	r4,20(r16)
 10128dc:	10c7c83a 	sub	r3,r2,r3
 10128e0:	1900200e 	bge	r3,r4,1012964 <__swbuf_r+0xe8>
 10128e4:	18c00044 	addi	r3,r3,1
 10128e8:	81000217 	ldw	r4,8(r16)
 10128ec:	11400044 	addi	r5,r2,1
 10128f0:	81400015 	stw	r5,0(r16)
 10128f4:	213fffc4 	addi	r4,r4,-1
 10128f8:	81000215 	stw	r4,8(r16)
 10128fc:	14c00005 	stb	r19,0(r2)
 1012900:	80800517 	ldw	r2,20(r16)
 1012904:	10c01e26 	beq	r2,r3,1012980 <__swbuf_r+0x104>
 1012908:	8080030b 	ldhu	r2,12(r16)
 101290c:	1080004c 	andi	r2,r2,1
 1012910:	10000226 	beq	r2,zero,101291c <__swbuf_r+0xa0>
 1012914:	00800284 	movi	r2,10
 1012918:	88801926 	beq	r17,r2,1012980 <__swbuf_r+0x104>
 101291c:	8805883a 	mov	r2,r17
 1012920:	dfc00417 	ldw	ra,16(sp)
 1012924:	dcc00317 	ldw	r19,12(sp)
 1012928:	dc800217 	ldw	r18,8(sp)
 101292c:	dc400117 	ldw	r17,4(sp)
 1012930:	dc000017 	ldw	r16,0(sp)
 1012934:	dec00504 	addi	sp,sp,20
 1012938:	f800283a 	ret
 101293c:	81401917 	ldw	r5,100(r16)
 1012940:	00b7ffc4 	movi	r2,-8193
 1012944:	21080014 	ori	r4,r4,8192
 1012948:	2884703a 	and	r2,r5,r2
 101294c:	80801915 	stw	r2,100(r16)
 1012950:	80800017 	ldw	r2,0(r16)
 1012954:	8100030d 	sth	r4,12(r16)
 1012958:	81000517 	ldw	r4,20(r16)
 101295c:	10c7c83a 	sub	r3,r2,r3
 1012960:	193fe016 	blt	r3,r4,10128e4 <__alt_data_end+0xff8128e4>
 1012964:	800b883a 	mov	r5,r16
 1012968:	9009883a 	mov	r4,r18
 101296c:	100dd040 	call	100dd04 <_fflush_r>
 1012970:	1000071e 	bne	r2,zero,1012990 <__swbuf_r+0x114>
 1012974:	80800017 	ldw	r2,0(r16)
 1012978:	00c00044 	movi	r3,1
 101297c:	003fda06 	br	10128e8 <__alt_data_end+0xff8128e8>
 1012980:	800b883a 	mov	r5,r16
 1012984:	9009883a 	mov	r4,r18
 1012988:	100dd040 	call	100dd04 <_fflush_r>
 101298c:	103fe326 	beq	r2,zero,101291c <__alt_data_end+0xff81291c>
 1012990:	00bfffc4 	movi	r2,-1
 1012994:	003fe206 	br	1012920 <__alt_data_end+0xff812920>
 1012998:	800b883a 	mov	r5,r16
 101299c:	9009883a 	mov	r4,r18
 10129a0:	100c10c0 	call	100c10c <__swsetup_r>
 10129a4:	103ffa1e 	bne	r2,zero,1012990 <__alt_data_end+0xff812990>
 10129a8:	8100030b 	ldhu	r4,12(r16)
 10129ac:	80c00417 	ldw	r3,16(r16)
 10129b0:	003fc506 	br	10128c8 <__alt_data_end+0xff8128c8>
 10129b4:	100e0e00 	call	100e0e0 <__sinit>
 10129b8:	003fbc06 	br	10128ac <__alt_data_end+0xff8128ac>

010129bc <__swbuf>:
 10129bc:	008040b4 	movhi	r2,258
 10129c0:	10b39b04 	addi	r2,r2,-12692
 10129c4:	280d883a 	mov	r6,r5
 10129c8:	200b883a 	mov	r5,r4
 10129cc:	11000017 	ldw	r4,0(r2)
 10129d0:	101287c1 	jmpi	101287c <__swbuf_r>

010129d4 <_write_r>:
 10129d4:	defffd04 	addi	sp,sp,-12
 10129d8:	2805883a 	mov	r2,r5
 10129dc:	dc000015 	stw	r16,0(sp)
 10129e0:	040040b4 	movhi	r16,258
 10129e4:	dc400115 	stw	r17,4(sp)
 10129e8:	300b883a 	mov	r5,r6
 10129ec:	84342704 	addi	r16,r16,-12132
 10129f0:	2023883a 	mov	r17,r4
 10129f4:	380d883a 	mov	r6,r7
 10129f8:	1009883a 	mov	r4,r2
 10129fc:	dfc00215 	stw	ra,8(sp)
 1012a00:	80000015 	stw	zero,0(r16)
 1012a04:	1016bd80 	call	1016bd8 <write>
 1012a08:	00ffffc4 	movi	r3,-1
 1012a0c:	10c00526 	beq	r2,r3,1012a24 <_write_r+0x50>
 1012a10:	dfc00217 	ldw	ra,8(sp)
 1012a14:	dc400117 	ldw	r17,4(sp)
 1012a18:	dc000017 	ldw	r16,0(sp)
 1012a1c:	dec00304 	addi	sp,sp,12
 1012a20:	f800283a 	ret
 1012a24:	80c00017 	ldw	r3,0(r16)
 1012a28:	183ff926 	beq	r3,zero,1012a10 <__alt_data_end+0xff812a10>
 1012a2c:	88c00015 	stw	r3,0(r17)
 1012a30:	003ff706 	br	1012a10 <__alt_data_end+0xff812a10>

01012a34 <_close_r>:
 1012a34:	defffd04 	addi	sp,sp,-12
 1012a38:	dc000015 	stw	r16,0(sp)
 1012a3c:	040040b4 	movhi	r16,258
 1012a40:	dc400115 	stw	r17,4(sp)
 1012a44:	84342704 	addi	r16,r16,-12132
 1012a48:	2023883a 	mov	r17,r4
 1012a4c:	2809883a 	mov	r4,r5
 1012a50:	dfc00215 	stw	ra,8(sp)
 1012a54:	80000015 	stw	zero,0(r16)
 1012a58:	10162a00 	call	10162a0 <close>
 1012a5c:	00ffffc4 	movi	r3,-1
 1012a60:	10c00526 	beq	r2,r3,1012a78 <_close_r+0x44>
 1012a64:	dfc00217 	ldw	ra,8(sp)
 1012a68:	dc400117 	ldw	r17,4(sp)
 1012a6c:	dc000017 	ldw	r16,0(sp)
 1012a70:	dec00304 	addi	sp,sp,12
 1012a74:	f800283a 	ret
 1012a78:	80c00017 	ldw	r3,0(r16)
 1012a7c:	183ff926 	beq	r3,zero,1012a64 <__alt_data_end+0xff812a64>
 1012a80:	88c00015 	stw	r3,0(r17)
 1012a84:	003ff706 	br	1012a64 <__alt_data_end+0xff812a64>

01012a88 <_calloc_r>:
 1012a88:	298b383a 	mul	r5,r5,r6
 1012a8c:	defffe04 	addi	sp,sp,-8
 1012a90:	dfc00115 	stw	ra,4(sp)
 1012a94:	dc000015 	stw	r16,0(sp)
 1012a98:	100ee400 	call	100ee40 <_malloc_r>
 1012a9c:	10002926 	beq	r2,zero,1012b44 <_calloc_r+0xbc>
 1012aa0:	11bfff17 	ldw	r6,-4(r2)
 1012aa4:	1021883a 	mov	r16,r2
 1012aa8:	00bfff04 	movi	r2,-4
 1012aac:	308c703a 	and	r6,r6,r2
 1012ab0:	00c00904 	movi	r3,36
 1012ab4:	308d883a 	add	r6,r6,r2
 1012ab8:	19801636 	bltu	r3,r6,1012b14 <_calloc_r+0x8c>
 1012abc:	008004c4 	movi	r2,19
 1012ac0:	11800b2e 	bgeu	r2,r6,1012af0 <_calloc_r+0x68>
 1012ac4:	80000015 	stw	zero,0(r16)
 1012ac8:	80000115 	stw	zero,4(r16)
 1012acc:	008006c4 	movi	r2,27
 1012ad0:	11801a2e 	bgeu	r2,r6,1012b3c <_calloc_r+0xb4>
 1012ad4:	80000215 	stw	zero,8(r16)
 1012ad8:	80000315 	stw	zero,12(r16)
 1012adc:	30c0151e 	bne	r6,r3,1012b34 <_calloc_r+0xac>
 1012ae0:	80000415 	stw	zero,16(r16)
 1012ae4:	80800604 	addi	r2,r16,24
 1012ae8:	80000515 	stw	zero,20(r16)
 1012aec:	00000106 	br	1012af4 <_calloc_r+0x6c>
 1012af0:	8005883a 	mov	r2,r16
 1012af4:	10000015 	stw	zero,0(r2)
 1012af8:	10000115 	stw	zero,4(r2)
 1012afc:	10000215 	stw	zero,8(r2)
 1012b00:	8005883a 	mov	r2,r16
 1012b04:	dfc00117 	ldw	ra,4(sp)
 1012b08:	dc000017 	ldw	r16,0(sp)
 1012b0c:	dec00204 	addi	sp,sp,8
 1012b10:	f800283a 	ret
 1012b14:	000b883a 	mov	r5,zero
 1012b18:	8009883a 	mov	r4,r16
 1012b1c:	1009b1c0 	call	1009b1c <memset>
 1012b20:	8005883a 	mov	r2,r16
 1012b24:	dfc00117 	ldw	ra,4(sp)
 1012b28:	dc000017 	ldw	r16,0(sp)
 1012b2c:	dec00204 	addi	sp,sp,8
 1012b30:	f800283a 	ret
 1012b34:	80800404 	addi	r2,r16,16
 1012b38:	003fee06 	br	1012af4 <__alt_data_end+0xff812af4>
 1012b3c:	80800204 	addi	r2,r16,8
 1012b40:	003fec06 	br	1012af4 <__alt_data_end+0xff812af4>
 1012b44:	0005883a 	mov	r2,zero
 1012b48:	003fee06 	br	1012b04 <__alt_data_end+0xff812b04>

01012b4c <_fclose_r>:
 1012b4c:	28003926 	beq	r5,zero,1012c34 <_fclose_r+0xe8>
 1012b50:	defffc04 	addi	sp,sp,-16
 1012b54:	dc400115 	stw	r17,4(sp)
 1012b58:	dc000015 	stw	r16,0(sp)
 1012b5c:	dfc00315 	stw	ra,12(sp)
 1012b60:	dc800215 	stw	r18,8(sp)
 1012b64:	2023883a 	mov	r17,r4
 1012b68:	2821883a 	mov	r16,r5
 1012b6c:	20000226 	beq	r4,zero,1012b78 <_fclose_r+0x2c>
 1012b70:	20800e17 	ldw	r2,56(r4)
 1012b74:	10002726 	beq	r2,zero,1012c14 <_fclose_r+0xc8>
 1012b78:	8080030f 	ldh	r2,12(r16)
 1012b7c:	1000071e 	bne	r2,zero,1012b9c <_fclose_r+0x50>
 1012b80:	0005883a 	mov	r2,zero
 1012b84:	dfc00317 	ldw	ra,12(sp)
 1012b88:	dc800217 	ldw	r18,8(sp)
 1012b8c:	dc400117 	ldw	r17,4(sp)
 1012b90:	dc000017 	ldw	r16,0(sp)
 1012b94:	dec00404 	addi	sp,sp,16
 1012b98:	f800283a 	ret
 1012b9c:	800b883a 	mov	r5,r16
 1012ba0:	8809883a 	mov	r4,r17
 1012ba4:	100dae80 	call	100dae8 <__sflush_r>
 1012ba8:	1025883a 	mov	r18,r2
 1012bac:	80800b17 	ldw	r2,44(r16)
 1012bb0:	10000426 	beq	r2,zero,1012bc4 <_fclose_r+0x78>
 1012bb4:	81400717 	ldw	r5,28(r16)
 1012bb8:	8809883a 	mov	r4,r17
 1012bbc:	103ee83a 	callr	r2
 1012bc0:	10001616 	blt	r2,zero,1012c1c <_fclose_r+0xd0>
 1012bc4:	8080030b 	ldhu	r2,12(r16)
 1012bc8:	1080200c 	andi	r2,r2,128
 1012bcc:	1000151e 	bne	r2,zero,1012c24 <_fclose_r+0xd8>
 1012bd0:	81400c17 	ldw	r5,48(r16)
 1012bd4:	28000526 	beq	r5,zero,1012bec <_fclose_r+0xa0>
 1012bd8:	80801004 	addi	r2,r16,64
 1012bdc:	28800226 	beq	r5,r2,1012be8 <_fclose_r+0x9c>
 1012be0:	8809883a 	mov	r4,r17
 1012be4:	100e2540 	call	100e254 <_free_r>
 1012be8:	80000c15 	stw	zero,48(r16)
 1012bec:	81401117 	ldw	r5,68(r16)
 1012bf0:	28000326 	beq	r5,zero,1012c00 <_fclose_r+0xb4>
 1012bf4:	8809883a 	mov	r4,r17
 1012bf8:	100e2540 	call	100e254 <_free_r>
 1012bfc:	80001115 	stw	zero,68(r16)
 1012c00:	100e0f00 	call	100e0f0 <__sfp_lock_acquire>
 1012c04:	8000030d 	sth	zero,12(r16)
 1012c08:	100e0f40 	call	100e0f4 <__sfp_lock_release>
 1012c0c:	9005883a 	mov	r2,r18
 1012c10:	003fdc06 	br	1012b84 <__alt_data_end+0xff812b84>
 1012c14:	100e0e00 	call	100e0e0 <__sinit>
 1012c18:	003fd706 	br	1012b78 <__alt_data_end+0xff812b78>
 1012c1c:	04bfffc4 	movi	r18,-1
 1012c20:	003fe806 	br	1012bc4 <__alt_data_end+0xff812bc4>
 1012c24:	81400417 	ldw	r5,16(r16)
 1012c28:	8809883a 	mov	r4,r17
 1012c2c:	100e2540 	call	100e254 <_free_r>
 1012c30:	003fe706 	br	1012bd0 <__alt_data_end+0xff812bd0>
 1012c34:	0005883a 	mov	r2,zero
 1012c38:	f800283a 	ret

01012c3c <fclose>:
 1012c3c:	008040b4 	movhi	r2,258
 1012c40:	10b39b04 	addi	r2,r2,-12692
 1012c44:	200b883a 	mov	r5,r4
 1012c48:	11000017 	ldw	r4,0(r2)
 1012c4c:	1012b4c1 	jmpi	1012b4c <_fclose_r>

01012c50 <__fputwc>:
 1012c50:	defff804 	addi	sp,sp,-32
 1012c54:	dcc00415 	stw	r19,16(sp)
 1012c58:	dc800315 	stw	r18,12(sp)
 1012c5c:	dc000115 	stw	r16,4(sp)
 1012c60:	dfc00715 	stw	ra,28(sp)
 1012c64:	dd400615 	stw	r21,24(sp)
 1012c68:	dd000515 	stw	r20,20(sp)
 1012c6c:	dc400215 	stw	r17,8(sp)
 1012c70:	2027883a 	mov	r19,r4
 1012c74:	2825883a 	mov	r18,r5
 1012c78:	3021883a 	mov	r16,r6
 1012c7c:	100ec300 	call	100ec30 <__locale_mb_cur_max>
 1012c80:	00c00044 	movi	r3,1
 1012c84:	10c03e26 	beq	r2,r3,1012d80 <__fputwc+0x130>
 1012c88:	81c01704 	addi	r7,r16,92
 1012c8c:	900d883a 	mov	r6,r18
 1012c90:	d80b883a 	mov	r5,sp
 1012c94:	9809883a 	mov	r4,r19
 1012c98:	1012fc80 	call	1012fc8 <_wcrtomb_r>
 1012c9c:	1029883a 	mov	r20,r2
 1012ca0:	00bfffc4 	movi	r2,-1
 1012ca4:	a0802026 	beq	r20,r2,1012d28 <__fputwc+0xd8>
 1012ca8:	d9400003 	ldbu	r5,0(sp)
 1012cac:	a0001c26 	beq	r20,zero,1012d20 <__fputwc+0xd0>
 1012cb0:	0023883a 	mov	r17,zero
 1012cb4:	05400284 	movi	r21,10
 1012cb8:	00000906 	br	1012ce0 <__fputwc+0x90>
 1012cbc:	80800017 	ldw	r2,0(r16)
 1012cc0:	11400005 	stb	r5,0(r2)
 1012cc4:	80c00017 	ldw	r3,0(r16)
 1012cc8:	18c00044 	addi	r3,r3,1
 1012ccc:	80c00015 	stw	r3,0(r16)
 1012cd0:	8c400044 	addi	r17,r17,1
 1012cd4:	dc45883a 	add	r2,sp,r17
 1012cd8:	8d00112e 	bgeu	r17,r20,1012d20 <__fputwc+0xd0>
 1012cdc:	11400003 	ldbu	r5,0(r2)
 1012ce0:	80c00217 	ldw	r3,8(r16)
 1012ce4:	18ffffc4 	addi	r3,r3,-1
 1012ce8:	80c00215 	stw	r3,8(r16)
 1012cec:	183ff30e 	bge	r3,zero,1012cbc <__alt_data_end+0xff812cbc>
 1012cf0:	80800617 	ldw	r2,24(r16)
 1012cf4:	18801916 	blt	r3,r2,1012d5c <__fputwc+0x10c>
 1012cf8:	80800017 	ldw	r2,0(r16)
 1012cfc:	11400005 	stb	r5,0(r2)
 1012d00:	80800017 	ldw	r2,0(r16)
 1012d04:	10c00003 	ldbu	r3,0(r2)
 1012d08:	10800044 	addi	r2,r2,1
 1012d0c:	1d402326 	beq	r3,r21,1012d9c <__fputwc+0x14c>
 1012d10:	80800015 	stw	r2,0(r16)
 1012d14:	8c400044 	addi	r17,r17,1
 1012d18:	dc45883a 	add	r2,sp,r17
 1012d1c:	8d3fef36 	bltu	r17,r20,1012cdc <__alt_data_end+0xff812cdc>
 1012d20:	9005883a 	mov	r2,r18
 1012d24:	00000406 	br	1012d38 <__fputwc+0xe8>
 1012d28:	80c0030b 	ldhu	r3,12(r16)
 1012d2c:	a005883a 	mov	r2,r20
 1012d30:	18c01014 	ori	r3,r3,64
 1012d34:	80c0030d 	sth	r3,12(r16)
 1012d38:	dfc00717 	ldw	ra,28(sp)
 1012d3c:	dd400617 	ldw	r21,24(sp)
 1012d40:	dd000517 	ldw	r20,20(sp)
 1012d44:	dcc00417 	ldw	r19,16(sp)
 1012d48:	dc800317 	ldw	r18,12(sp)
 1012d4c:	dc400217 	ldw	r17,8(sp)
 1012d50:	dc000117 	ldw	r16,4(sp)
 1012d54:	dec00804 	addi	sp,sp,32
 1012d58:	f800283a 	ret
 1012d5c:	800d883a 	mov	r6,r16
 1012d60:	29403fcc 	andi	r5,r5,255
 1012d64:	9809883a 	mov	r4,r19
 1012d68:	101287c0 	call	101287c <__swbuf_r>
 1012d6c:	10bfffe0 	cmpeqi	r2,r2,-1
 1012d70:	10803fcc 	andi	r2,r2,255
 1012d74:	103fd626 	beq	r2,zero,1012cd0 <__alt_data_end+0xff812cd0>
 1012d78:	00bfffc4 	movi	r2,-1
 1012d7c:	003fee06 	br	1012d38 <__alt_data_end+0xff812d38>
 1012d80:	90ffffc4 	addi	r3,r18,-1
 1012d84:	01003f84 	movi	r4,254
 1012d88:	20ffbf36 	bltu	r4,r3,1012c88 <__alt_data_end+0xff812c88>
 1012d8c:	900b883a 	mov	r5,r18
 1012d90:	dc800005 	stb	r18,0(sp)
 1012d94:	1029883a 	mov	r20,r2
 1012d98:	003fc506 	br	1012cb0 <__alt_data_end+0xff812cb0>
 1012d9c:	800d883a 	mov	r6,r16
 1012da0:	a80b883a 	mov	r5,r21
 1012da4:	9809883a 	mov	r4,r19
 1012da8:	101287c0 	call	101287c <__swbuf_r>
 1012dac:	10bfffe0 	cmpeqi	r2,r2,-1
 1012db0:	003fef06 	br	1012d70 <__alt_data_end+0xff812d70>

01012db4 <_fputwc_r>:
 1012db4:	3080030b 	ldhu	r2,12(r6)
 1012db8:	10c8000c 	andi	r3,r2,8192
 1012dbc:	1800051e 	bne	r3,zero,1012dd4 <_fputwc_r+0x20>
 1012dc0:	30c01917 	ldw	r3,100(r6)
 1012dc4:	10880014 	ori	r2,r2,8192
 1012dc8:	3080030d 	sth	r2,12(r6)
 1012dcc:	18880014 	ori	r2,r3,8192
 1012dd0:	30801915 	stw	r2,100(r6)
 1012dd4:	1012c501 	jmpi	1012c50 <__fputwc>

01012dd8 <fputwc>:
 1012dd8:	008040b4 	movhi	r2,258
 1012ddc:	defffc04 	addi	sp,sp,-16
 1012de0:	10b39b04 	addi	r2,r2,-12692
 1012de4:	dc000115 	stw	r16,4(sp)
 1012de8:	14000017 	ldw	r16,0(r2)
 1012dec:	dc400215 	stw	r17,8(sp)
 1012df0:	dfc00315 	stw	ra,12(sp)
 1012df4:	2023883a 	mov	r17,r4
 1012df8:	80000226 	beq	r16,zero,1012e04 <fputwc+0x2c>
 1012dfc:	80800e17 	ldw	r2,56(r16)
 1012e00:	10001026 	beq	r2,zero,1012e44 <fputwc+0x6c>
 1012e04:	2880030b 	ldhu	r2,12(r5)
 1012e08:	10c8000c 	andi	r3,r2,8192
 1012e0c:	1800051e 	bne	r3,zero,1012e24 <fputwc+0x4c>
 1012e10:	28c01917 	ldw	r3,100(r5)
 1012e14:	10880014 	ori	r2,r2,8192
 1012e18:	2880030d 	sth	r2,12(r5)
 1012e1c:	18880014 	ori	r2,r3,8192
 1012e20:	28801915 	stw	r2,100(r5)
 1012e24:	280d883a 	mov	r6,r5
 1012e28:	8009883a 	mov	r4,r16
 1012e2c:	880b883a 	mov	r5,r17
 1012e30:	dfc00317 	ldw	ra,12(sp)
 1012e34:	dc400217 	ldw	r17,8(sp)
 1012e38:	dc000117 	ldw	r16,4(sp)
 1012e3c:	dec00404 	addi	sp,sp,16
 1012e40:	1012c501 	jmpi	1012c50 <__fputwc>
 1012e44:	8009883a 	mov	r4,r16
 1012e48:	d9400015 	stw	r5,0(sp)
 1012e4c:	100e0e00 	call	100e0e0 <__sinit>
 1012e50:	d9400017 	ldw	r5,0(sp)
 1012e54:	003feb06 	br	1012e04 <__alt_data_end+0xff812e04>

01012e58 <_fstat_r>:
 1012e58:	defffd04 	addi	sp,sp,-12
 1012e5c:	2805883a 	mov	r2,r5
 1012e60:	dc000015 	stw	r16,0(sp)
 1012e64:	040040b4 	movhi	r16,258
 1012e68:	dc400115 	stw	r17,4(sp)
 1012e6c:	84342704 	addi	r16,r16,-12132
 1012e70:	2023883a 	mov	r17,r4
 1012e74:	300b883a 	mov	r5,r6
 1012e78:	1009883a 	mov	r4,r2
 1012e7c:	dfc00215 	stw	ra,8(sp)
 1012e80:	80000015 	stw	zero,0(r16)
 1012e84:	10163d80 	call	10163d8 <fstat>
 1012e88:	00ffffc4 	movi	r3,-1
 1012e8c:	10c00526 	beq	r2,r3,1012ea4 <_fstat_r+0x4c>
 1012e90:	dfc00217 	ldw	ra,8(sp)
 1012e94:	dc400117 	ldw	r17,4(sp)
 1012e98:	dc000017 	ldw	r16,0(sp)
 1012e9c:	dec00304 	addi	sp,sp,12
 1012ea0:	f800283a 	ret
 1012ea4:	80c00017 	ldw	r3,0(r16)
 1012ea8:	183ff926 	beq	r3,zero,1012e90 <__alt_data_end+0xff812e90>
 1012eac:	88c00015 	stw	r3,0(r17)
 1012eb0:	003ff706 	br	1012e90 <__alt_data_end+0xff812e90>

01012eb4 <_isatty_r>:
 1012eb4:	defffd04 	addi	sp,sp,-12
 1012eb8:	dc000015 	stw	r16,0(sp)
 1012ebc:	040040b4 	movhi	r16,258
 1012ec0:	dc400115 	stw	r17,4(sp)
 1012ec4:	84342704 	addi	r16,r16,-12132
 1012ec8:	2023883a 	mov	r17,r4
 1012ecc:	2809883a 	mov	r4,r5
 1012ed0:	dfc00215 	stw	ra,8(sp)
 1012ed4:	80000015 	stw	zero,0(r16)
 1012ed8:	10166740 	call	1016674 <isatty>
 1012edc:	00ffffc4 	movi	r3,-1
 1012ee0:	10c00526 	beq	r2,r3,1012ef8 <_isatty_r+0x44>
 1012ee4:	dfc00217 	ldw	ra,8(sp)
 1012ee8:	dc400117 	ldw	r17,4(sp)
 1012eec:	dc000017 	ldw	r16,0(sp)
 1012ef0:	dec00304 	addi	sp,sp,12
 1012ef4:	f800283a 	ret
 1012ef8:	80c00017 	ldw	r3,0(r16)
 1012efc:	183ff926 	beq	r3,zero,1012ee4 <__alt_data_end+0xff812ee4>
 1012f00:	88c00015 	stw	r3,0(r17)
 1012f04:	003ff706 	br	1012ee4 <__alt_data_end+0xff812ee4>

01012f08 <_lseek_r>:
 1012f08:	defffd04 	addi	sp,sp,-12
 1012f0c:	2805883a 	mov	r2,r5
 1012f10:	dc000015 	stw	r16,0(sp)
 1012f14:	040040b4 	movhi	r16,258
 1012f18:	dc400115 	stw	r17,4(sp)
 1012f1c:	300b883a 	mov	r5,r6
 1012f20:	84342704 	addi	r16,r16,-12132
 1012f24:	2023883a 	mov	r17,r4
 1012f28:	380d883a 	mov	r6,r7
 1012f2c:	1009883a 	mov	r4,r2
 1012f30:	dfc00215 	stw	ra,8(sp)
 1012f34:	80000015 	stw	zero,0(r16)
 1012f38:	10167540 	call	1016754 <lseek>
 1012f3c:	00ffffc4 	movi	r3,-1
 1012f40:	10c00526 	beq	r2,r3,1012f58 <_lseek_r+0x50>
 1012f44:	dfc00217 	ldw	ra,8(sp)
 1012f48:	dc400117 	ldw	r17,4(sp)
 1012f4c:	dc000017 	ldw	r16,0(sp)
 1012f50:	dec00304 	addi	sp,sp,12
 1012f54:	f800283a 	ret
 1012f58:	80c00017 	ldw	r3,0(r16)
 1012f5c:	183ff926 	beq	r3,zero,1012f44 <__alt_data_end+0xff812f44>
 1012f60:	88c00015 	stw	r3,0(r17)
 1012f64:	003ff706 	br	1012f44 <__alt_data_end+0xff812f44>

01012f68 <_read_r>:
 1012f68:	defffd04 	addi	sp,sp,-12
 1012f6c:	2805883a 	mov	r2,r5
 1012f70:	dc000015 	stw	r16,0(sp)
 1012f74:	040040b4 	movhi	r16,258
 1012f78:	dc400115 	stw	r17,4(sp)
 1012f7c:	300b883a 	mov	r5,r6
 1012f80:	84342704 	addi	r16,r16,-12132
 1012f84:	2023883a 	mov	r17,r4
 1012f88:	380d883a 	mov	r6,r7
 1012f8c:	1009883a 	mov	r4,r2
 1012f90:	dfc00215 	stw	ra,8(sp)
 1012f94:	80000015 	stw	zero,0(r16)
 1012f98:	10169280 	call	1016928 <read>
 1012f9c:	00ffffc4 	movi	r3,-1
 1012fa0:	10c00526 	beq	r2,r3,1012fb8 <_read_r+0x50>
 1012fa4:	dfc00217 	ldw	ra,8(sp)
 1012fa8:	dc400117 	ldw	r17,4(sp)
 1012fac:	dc000017 	ldw	r16,0(sp)
 1012fb0:	dec00304 	addi	sp,sp,12
 1012fb4:	f800283a 	ret
 1012fb8:	80c00017 	ldw	r3,0(r16)
 1012fbc:	183ff926 	beq	r3,zero,1012fa4 <__alt_data_end+0xff812fa4>
 1012fc0:	88c00015 	stw	r3,0(r17)
 1012fc4:	003ff706 	br	1012fa4 <__alt_data_end+0xff812fa4>

01012fc8 <_wcrtomb_r>:
 1012fc8:	defff604 	addi	sp,sp,-40
 1012fcc:	008040b4 	movhi	r2,258
 1012fd0:	dc800815 	stw	r18,32(sp)
 1012fd4:	dc400715 	stw	r17,28(sp)
 1012fd8:	dc000615 	stw	r16,24(sp)
 1012fdc:	10b39f04 	addi	r2,r2,-12676
 1012fe0:	dfc00915 	stw	ra,36(sp)
 1012fe4:	2021883a 	mov	r16,r4
 1012fe8:	3823883a 	mov	r17,r7
 1012fec:	14800017 	ldw	r18,0(r2)
 1012ff0:	28001426 	beq	r5,zero,1013044 <_wcrtomb_r+0x7c>
 1012ff4:	d9400415 	stw	r5,16(sp)
 1012ff8:	d9800515 	stw	r6,20(sp)
 1012ffc:	100ec240 	call	100ec24 <__locale_charset>
 1013000:	d9800517 	ldw	r6,20(sp)
 1013004:	d9400417 	ldw	r5,16(sp)
 1013008:	100f883a 	mov	r7,r2
 101300c:	dc400015 	stw	r17,0(sp)
 1013010:	8009883a 	mov	r4,r16
 1013014:	903ee83a 	callr	r18
 1013018:	00ffffc4 	movi	r3,-1
 101301c:	10c0031e 	bne	r2,r3,101302c <_wcrtomb_r+0x64>
 1013020:	88000015 	stw	zero,0(r17)
 1013024:	00c02284 	movi	r3,138
 1013028:	80c00015 	stw	r3,0(r16)
 101302c:	dfc00917 	ldw	ra,36(sp)
 1013030:	dc800817 	ldw	r18,32(sp)
 1013034:	dc400717 	ldw	r17,28(sp)
 1013038:	dc000617 	ldw	r16,24(sp)
 101303c:	dec00a04 	addi	sp,sp,40
 1013040:	f800283a 	ret
 1013044:	100ec240 	call	100ec24 <__locale_charset>
 1013048:	100f883a 	mov	r7,r2
 101304c:	dc400015 	stw	r17,0(sp)
 1013050:	000d883a 	mov	r6,zero
 1013054:	d9400104 	addi	r5,sp,4
 1013058:	8009883a 	mov	r4,r16
 101305c:	903ee83a 	callr	r18
 1013060:	003fed06 	br	1013018 <__alt_data_end+0xff813018>

01013064 <wcrtomb>:
 1013064:	defff604 	addi	sp,sp,-40
 1013068:	008040b4 	movhi	r2,258
 101306c:	dc800615 	stw	r18,24(sp)
 1013070:	dc400515 	stw	r17,20(sp)
 1013074:	10b39b04 	addi	r2,r2,-12692
 1013078:	dfc00915 	stw	ra,36(sp)
 101307c:	dd000815 	stw	r20,32(sp)
 1013080:	dcc00715 	stw	r19,28(sp)
 1013084:	dc000415 	stw	r16,16(sp)
 1013088:	3025883a 	mov	r18,r6
 101308c:	14400017 	ldw	r17,0(r2)
 1013090:	20001926 	beq	r4,zero,10130f8 <wcrtomb+0x94>
 1013094:	008040b4 	movhi	r2,258
 1013098:	10b39f04 	addi	r2,r2,-12676
 101309c:	15000017 	ldw	r20,0(r2)
 10130a0:	2021883a 	mov	r16,r4
 10130a4:	2827883a 	mov	r19,r5
 10130a8:	100ec240 	call	100ec24 <__locale_charset>
 10130ac:	100f883a 	mov	r7,r2
 10130b0:	dc800015 	stw	r18,0(sp)
 10130b4:	980d883a 	mov	r6,r19
 10130b8:	800b883a 	mov	r5,r16
 10130bc:	8809883a 	mov	r4,r17
 10130c0:	a03ee83a 	callr	r20
 10130c4:	00ffffc4 	movi	r3,-1
 10130c8:	10c0031e 	bne	r2,r3,10130d8 <wcrtomb+0x74>
 10130cc:	90000015 	stw	zero,0(r18)
 10130d0:	00c02284 	movi	r3,138
 10130d4:	88c00015 	stw	r3,0(r17)
 10130d8:	dfc00917 	ldw	ra,36(sp)
 10130dc:	dd000817 	ldw	r20,32(sp)
 10130e0:	dcc00717 	ldw	r19,28(sp)
 10130e4:	dc800617 	ldw	r18,24(sp)
 10130e8:	dc400517 	ldw	r17,20(sp)
 10130ec:	dc000417 	ldw	r16,16(sp)
 10130f0:	dec00a04 	addi	sp,sp,40
 10130f4:	f800283a 	ret
 10130f8:	008040b4 	movhi	r2,258
 10130fc:	10b39f04 	addi	r2,r2,-12676
 1013100:	14000017 	ldw	r16,0(r2)
 1013104:	100ec240 	call	100ec24 <__locale_charset>
 1013108:	100f883a 	mov	r7,r2
 101310c:	dc800015 	stw	r18,0(sp)
 1013110:	000d883a 	mov	r6,zero
 1013114:	d9400104 	addi	r5,sp,4
 1013118:	8809883a 	mov	r4,r17
 101311c:	803ee83a 	callr	r16
 1013120:	003fe806 	br	10130c4 <__alt_data_end+0xff8130c4>

01013124 <__ascii_wctomb>:
 1013124:	28000526 	beq	r5,zero,101313c <__ascii_wctomb+0x18>
 1013128:	00803fc4 	movi	r2,255
 101312c:	11800536 	bltu	r2,r6,1013144 <__ascii_wctomb+0x20>
 1013130:	29800005 	stb	r6,0(r5)
 1013134:	00800044 	movi	r2,1
 1013138:	f800283a 	ret
 101313c:	0005883a 	mov	r2,zero
 1013140:	f800283a 	ret
 1013144:	00802284 	movi	r2,138
 1013148:	20800015 	stw	r2,0(r4)
 101314c:	00bfffc4 	movi	r2,-1
 1013150:	f800283a 	ret

01013154 <_wctomb_r>:
 1013154:	008040b4 	movhi	r2,258
 1013158:	defff904 	addi	sp,sp,-28
 101315c:	10b39f04 	addi	r2,r2,-12676
 1013160:	dfc00615 	stw	ra,24(sp)
 1013164:	dc400515 	stw	r17,20(sp)
 1013168:	dc000415 	stw	r16,16(sp)
 101316c:	3823883a 	mov	r17,r7
 1013170:	14000017 	ldw	r16,0(r2)
 1013174:	d9000115 	stw	r4,4(sp)
 1013178:	d9400215 	stw	r5,8(sp)
 101317c:	d9800315 	stw	r6,12(sp)
 1013180:	100ec240 	call	100ec24 <__locale_charset>
 1013184:	d9800317 	ldw	r6,12(sp)
 1013188:	d9400217 	ldw	r5,8(sp)
 101318c:	d9000117 	ldw	r4,4(sp)
 1013190:	100f883a 	mov	r7,r2
 1013194:	dc400015 	stw	r17,0(sp)
 1013198:	803ee83a 	callr	r16
 101319c:	dfc00617 	ldw	ra,24(sp)
 10131a0:	dc400517 	ldw	r17,20(sp)
 10131a4:	dc000417 	ldw	r16,16(sp)
 10131a8:	dec00704 	addi	sp,sp,28
 10131ac:	f800283a 	ret

010131b0 <__udivdi3>:
 10131b0:	defff504 	addi	sp,sp,-44
 10131b4:	dcc00415 	stw	r19,16(sp)
 10131b8:	dc000115 	stw	r16,4(sp)
 10131bc:	dfc00a15 	stw	ra,40(sp)
 10131c0:	df000915 	stw	fp,36(sp)
 10131c4:	ddc00815 	stw	r23,32(sp)
 10131c8:	dd800715 	stw	r22,28(sp)
 10131cc:	dd400615 	stw	r21,24(sp)
 10131d0:	dd000515 	stw	r20,20(sp)
 10131d4:	dc800315 	stw	r18,12(sp)
 10131d8:	dc400215 	stw	r17,8(sp)
 10131dc:	2027883a 	mov	r19,r4
 10131e0:	2821883a 	mov	r16,r5
 10131e4:	3800411e 	bne	r7,zero,10132ec <__udivdi3+0x13c>
 10131e8:	3023883a 	mov	r17,r6
 10131ec:	2025883a 	mov	r18,r4
 10131f0:	2980522e 	bgeu	r5,r6,101333c <__udivdi3+0x18c>
 10131f4:	00bfffd4 	movui	r2,65535
 10131f8:	282d883a 	mov	r22,r5
 10131fc:	1180a836 	bltu	r2,r6,10134a0 <__udivdi3+0x2f0>
 1013200:	00803fc4 	movi	r2,255
 1013204:	1185803a 	cmpltu	r2,r2,r6
 1013208:	100490fa 	slli	r2,r2,3
 101320c:	3086d83a 	srl	r3,r6,r2
 1013210:	010040b4 	movhi	r4,258
 1013214:	212ab3c4 	addi	r4,r4,-21809
 1013218:	20c7883a 	add	r3,r4,r3
 101321c:	18c00003 	ldbu	r3,0(r3)
 1013220:	1885883a 	add	r2,r3,r2
 1013224:	00c00804 	movi	r3,32
 1013228:	1887c83a 	sub	r3,r3,r2
 101322c:	18000526 	beq	r3,zero,1013244 <__udivdi3+0x94>
 1013230:	80e0983a 	sll	r16,r16,r3
 1013234:	9884d83a 	srl	r2,r19,r2
 1013238:	30e2983a 	sll	r17,r6,r3
 101323c:	98e4983a 	sll	r18,r19,r3
 1013240:	142cb03a 	or	r22,r2,r16
 1013244:	882ad43a 	srli	r21,r17,16
 1013248:	b009883a 	mov	r4,r22
 101324c:	8d3fffcc 	andi	r20,r17,65535
 1013250:	a80b883a 	mov	r5,r21
 1013254:	10098080 	call	1009808 <__umodsi3>
 1013258:	b009883a 	mov	r4,r22
 101325c:	a80b883a 	mov	r5,r21
 1013260:	1027883a 	mov	r19,r2
 1013264:	10097a40 	call	10097a4 <__udivsi3>
 1013268:	102d883a 	mov	r22,r2
 101326c:	9826943a 	slli	r19,r19,16
 1013270:	9004d43a 	srli	r2,r18,16
 1013274:	a5a1383a 	mul	r16,r20,r22
 1013278:	14c4b03a 	or	r2,r2,r19
 101327c:	1400052e 	bgeu	r2,r16,1013294 <__udivdi3+0xe4>
 1013280:	1445883a 	add	r2,r2,r17
 1013284:	b0ffffc4 	addi	r3,r22,-1
 1013288:	14400136 	bltu	r2,r17,1013290 <__udivdi3+0xe0>
 101328c:	14012336 	bltu	r2,r16,101371c <__udivdi3+0x56c>
 1013290:	182d883a 	mov	r22,r3
 1013294:	1421c83a 	sub	r16,r2,r16
 1013298:	a80b883a 	mov	r5,r21
 101329c:	8009883a 	mov	r4,r16
 10132a0:	10098080 	call	1009808 <__umodsi3>
 10132a4:	1027883a 	mov	r19,r2
 10132a8:	a80b883a 	mov	r5,r21
 10132ac:	8009883a 	mov	r4,r16
 10132b0:	10097a40 	call	10097a4 <__udivsi3>
 10132b4:	9826943a 	slli	r19,r19,16
 10132b8:	a0a9383a 	mul	r20,r20,r2
 10132bc:	94bfffcc 	andi	r18,r18,65535
 10132c0:	94e4b03a 	or	r18,r18,r19
 10132c4:	9500052e 	bgeu	r18,r20,10132dc <__udivdi3+0x12c>
 10132c8:	8ca5883a 	add	r18,r17,r18
 10132cc:	10ffffc4 	addi	r3,r2,-1
 10132d0:	9440f136 	bltu	r18,r17,1013698 <__udivdi3+0x4e8>
 10132d4:	9500f02e 	bgeu	r18,r20,1013698 <__udivdi3+0x4e8>
 10132d8:	10bfff84 	addi	r2,r2,-2
 10132dc:	b00c943a 	slli	r6,r22,16
 10132e0:	0007883a 	mov	r3,zero
 10132e4:	3084b03a 	or	r2,r6,r2
 10132e8:	00005906 	br	1013450 <__udivdi3+0x2a0>
 10132ec:	29c05636 	bltu	r5,r7,1013448 <__udivdi3+0x298>
 10132f0:	00bfffd4 	movui	r2,65535
 10132f4:	11c0622e 	bgeu	r2,r7,1013480 <__udivdi3+0x2d0>
 10132f8:	00804034 	movhi	r2,256
 10132fc:	10bfffc4 	addi	r2,r2,-1
 1013300:	11c0ee36 	bltu	r2,r7,10136bc <__udivdi3+0x50c>
 1013304:	00800404 	movi	r2,16
 1013308:	3886d83a 	srl	r3,r7,r2
 101330c:	010040b4 	movhi	r4,258
 1013310:	212ab3c4 	addi	r4,r4,-21809
 1013314:	20c7883a 	add	r3,r4,r3
 1013318:	18c00003 	ldbu	r3,0(r3)
 101331c:	05400804 	movi	r21,32
 1013320:	1885883a 	add	r2,r3,r2
 1013324:	a8abc83a 	sub	r21,r21,r2
 1013328:	a800621e 	bne	r21,zero,10134b4 <__udivdi3+0x304>
 101332c:	3c00e936 	bltu	r7,r16,10136d4 <__udivdi3+0x524>
 1013330:	9985403a 	cmpgeu	r2,r19,r6
 1013334:	0007883a 	mov	r3,zero
 1013338:	00004506 	br	1013450 <__udivdi3+0x2a0>
 101333c:	3000041e 	bne	r6,zero,1013350 <__udivdi3+0x1a0>
 1013340:	000b883a 	mov	r5,zero
 1013344:	01000044 	movi	r4,1
 1013348:	10097a40 	call	10097a4 <__udivsi3>
 101334c:	1023883a 	mov	r17,r2
 1013350:	00bfffd4 	movui	r2,65535
 1013354:	14404e2e 	bgeu	r2,r17,1013490 <__udivdi3+0x2e0>
 1013358:	00804034 	movhi	r2,256
 101335c:	10bfffc4 	addi	r2,r2,-1
 1013360:	1440d836 	bltu	r2,r17,10136c4 <__udivdi3+0x514>
 1013364:	00800404 	movi	r2,16
 1013368:	8886d83a 	srl	r3,r17,r2
 101336c:	010040b4 	movhi	r4,258
 1013370:	212ab3c4 	addi	r4,r4,-21809
 1013374:	20c7883a 	add	r3,r4,r3
 1013378:	18c00003 	ldbu	r3,0(r3)
 101337c:	1885883a 	add	r2,r3,r2
 1013380:	00c00804 	movi	r3,32
 1013384:	1887c83a 	sub	r3,r3,r2
 1013388:	18008f1e 	bne	r3,zero,10135c8 <__udivdi3+0x418>
 101338c:	882ad43a 	srli	r21,r17,16
 1013390:	8461c83a 	sub	r16,r16,r17
 1013394:	8d3fffcc 	andi	r20,r17,65535
 1013398:	00c00044 	movi	r3,1
 101339c:	8009883a 	mov	r4,r16
 10133a0:	a80b883a 	mov	r5,r21
 10133a4:	d8c00015 	stw	r3,0(sp)
 10133a8:	10098080 	call	1009808 <__umodsi3>
 10133ac:	8009883a 	mov	r4,r16
 10133b0:	a80b883a 	mov	r5,r21
 10133b4:	1027883a 	mov	r19,r2
 10133b8:	10097a40 	call	10097a4 <__udivsi3>
 10133bc:	9826943a 	slli	r19,r19,16
 10133c0:	9008d43a 	srli	r4,r18,16
 10133c4:	1521383a 	mul	r16,r2,r20
 10133c8:	102d883a 	mov	r22,r2
 10133cc:	24c8b03a 	or	r4,r4,r19
 10133d0:	d8c00017 	ldw	r3,0(sp)
 10133d4:	2400052e 	bgeu	r4,r16,10133ec <__udivdi3+0x23c>
 10133d8:	2449883a 	add	r4,r4,r17
 10133dc:	b0bfffc4 	addi	r2,r22,-1
 10133e0:	24400136 	bltu	r4,r17,10133e8 <__udivdi3+0x238>
 10133e4:	2400ca36 	bltu	r4,r16,1013710 <__udivdi3+0x560>
 10133e8:	102d883a 	mov	r22,r2
 10133ec:	2421c83a 	sub	r16,r4,r16
 10133f0:	a80b883a 	mov	r5,r21
 10133f4:	8009883a 	mov	r4,r16
 10133f8:	d8c00015 	stw	r3,0(sp)
 10133fc:	10098080 	call	1009808 <__umodsi3>
 1013400:	1027883a 	mov	r19,r2
 1013404:	a80b883a 	mov	r5,r21
 1013408:	8009883a 	mov	r4,r16
 101340c:	10097a40 	call	10097a4 <__udivsi3>
 1013410:	9826943a 	slli	r19,r19,16
 1013414:	1529383a 	mul	r20,r2,r20
 1013418:	94bfffcc 	andi	r18,r18,65535
 101341c:	94e4b03a 	or	r18,r18,r19
 1013420:	d8c00017 	ldw	r3,0(sp)
 1013424:	9500052e 	bgeu	r18,r20,101343c <__udivdi3+0x28c>
 1013428:	8ca5883a 	add	r18,r17,r18
 101342c:	113fffc4 	addi	r4,r2,-1
 1013430:	94409736 	bltu	r18,r17,1013690 <__udivdi3+0x4e0>
 1013434:	9500962e 	bgeu	r18,r20,1013690 <__udivdi3+0x4e0>
 1013438:	10bfff84 	addi	r2,r2,-2
 101343c:	b00c943a 	slli	r6,r22,16
 1013440:	3084b03a 	or	r2,r6,r2
 1013444:	00000206 	br	1013450 <__udivdi3+0x2a0>
 1013448:	0007883a 	mov	r3,zero
 101344c:	0005883a 	mov	r2,zero
 1013450:	dfc00a17 	ldw	ra,40(sp)
 1013454:	df000917 	ldw	fp,36(sp)
 1013458:	ddc00817 	ldw	r23,32(sp)
 101345c:	dd800717 	ldw	r22,28(sp)
 1013460:	dd400617 	ldw	r21,24(sp)
 1013464:	dd000517 	ldw	r20,20(sp)
 1013468:	dcc00417 	ldw	r19,16(sp)
 101346c:	dc800317 	ldw	r18,12(sp)
 1013470:	dc400217 	ldw	r17,8(sp)
 1013474:	dc000117 	ldw	r16,4(sp)
 1013478:	dec00b04 	addi	sp,sp,44
 101347c:	f800283a 	ret
 1013480:	00803fc4 	movi	r2,255
 1013484:	11c5803a 	cmpltu	r2,r2,r7
 1013488:	100490fa 	slli	r2,r2,3
 101348c:	003f9e06 	br	1013308 <__alt_data_end+0xff813308>
 1013490:	00803fc4 	movi	r2,255
 1013494:	1445803a 	cmpltu	r2,r2,r17
 1013498:	100490fa 	slli	r2,r2,3
 101349c:	003fb206 	br	1013368 <__alt_data_end+0xff813368>
 10134a0:	00804034 	movhi	r2,256
 10134a4:	10bfffc4 	addi	r2,r2,-1
 10134a8:	11808836 	bltu	r2,r6,10136cc <__udivdi3+0x51c>
 10134ac:	00800404 	movi	r2,16
 10134b0:	003f5606 	br	101320c <__alt_data_end+0xff81320c>
 10134b4:	30aed83a 	srl	r23,r6,r2
 10134b8:	3d4e983a 	sll	r7,r7,r21
 10134bc:	80acd83a 	srl	r22,r16,r2
 10134c0:	9884d83a 	srl	r2,r19,r2
 10134c4:	3deeb03a 	or	r23,r7,r23
 10134c8:	b824d43a 	srli	r18,r23,16
 10134cc:	8560983a 	sll	r16,r16,r21
 10134d0:	b009883a 	mov	r4,r22
 10134d4:	900b883a 	mov	r5,r18
 10134d8:	3568983a 	sll	r20,r6,r21
 10134dc:	1420b03a 	or	r16,r2,r16
 10134e0:	10098080 	call	1009808 <__umodsi3>
 10134e4:	b009883a 	mov	r4,r22
 10134e8:	900b883a 	mov	r5,r18
 10134ec:	1023883a 	mov	r17,r2
 10134f0:	10097a40 	call	10097a4 <__udivsi3>
 10134f4:	8808943a 	slli	r4,r17,16
 10134f8:	bf3fffcc 	andi	fp,r23,65535
 10134fc:	8006d43a 	srli	r3,r16,16
 1013500:	e0a3383a 	mul	r17,fp,r2
 1013504:	100d883a 	mov	r6,r2
 1013508:	1906b03a 	or	r3,r3,r4
 101350c:	1c40042e 	bgeu	r3,r17,1013520 <__udivdi3+0x370>
 1013510:	1dc7883a 	add	r3,r3,r23
 1013514:	10bfffc4 	addi	r2,r2,-1
 1013518:	1dc0752e 	bgeu	r3,r23,10136f0 <__udivdi3+0x540>
 101351c:	100d883a 	mov	r6,r2
 1013520:	1c63c83a 	sub	r17,r3,r17
 1013524:	900b883a 	mov	r5,r18
 1013528:	8809883a 	mov	r4,r17
 101352c:	d9800015 	stw	r6,0(sp)
 1013530:	10098080 	call	1009808 <__umodsi3>
 1013534:	102d883a 	mov	r22,r2
 1013538:	8809883a 	mov	r4,r17
 101353c:	900b883a 	mov	r5,r18
 1013540:	10097a40 	call	10097a4 <__udivsi3>
 1013544:	b02c943a 	slli	r22,r22,16
 1013548:	e089383a 	mul	r4,fp,r2
 101354c:	843fffcc 	andi	r16,r16,65535
 1013550:	85a0b03a 	or	r16,r16,r22
 1013554:	d9800017 	ldw	r6,0(sp)
 1013558:	8100042e 	bgeu	r16,r4,101356c <__udivdi3+0x3bc>
 101355c:	85e1883a 	add	r16,r16,r23
 1013560:	10ffffc4 	addi	r3,r2,-1
 1013564:	85c05e2e 	bgeu	r16,r23,10136e0 <__udivdi3+0x530>
 1013568:	1805883a 	mov	r2,r3
 101356c:	300c943a 	slli	r6,r6,16
 1013570:	a17fffcc 	andi	r5,r20,65535
 1013574:	a028d43a 	srli	r20,r20,16
 1013578:	3084b03a 	or	r2,r6,r2
 101357c:	10ffffcc 	andi	r3,r2,65535
 1013580:	100cd43a 	srli	r6,r2,16
 1013584:	194f383a 	mul	r7,r3,r5
 1013588:	1d07383a 	mul	r3,r3,r20
 101358c:	314b383a 	mul	r5,r6,r5
 1013590:	3810d43a 	srli	r8,r7,16
 1013594:	8121c83a 	sub	r16,r16,r4
 1013598:	1947883a 	add	r3,r3,r5
 101359c:	40c7883a 	add	r3,r8,r3
 10135a0:	350d383a 	mul	r6,r6,r20
 10135a4:	1940022e 	bgeu	r3,r5,10135b0 <__udivdi3+0x400>
 10135a8:	01000074 	movhi	r4,1
 10135ac:	310d883a 	add	r6,r6,r4
 10135b0:	1828d43a 	srli	r20,r3,16
 10135b4:	a18d883a 	add	r6,r20,r6
 10135b8:	81803e36 	bltu	r16,r6,10136b4 <__udivdi3+0x504>
 10135bc:	81803826 	beq	r16,r6,10136a0 <__udivdi3+0x4f0>
 10135c0:	0007883a 	mov	r3,zero
 10135c4:	003fa206 	br	1013450 <__alt_data_end+0xff813450>
 10135c8:	88e2983a 	sll	r17,r17,r3
 10135cc:	80a8d83a 	srl	r20,r16,r2
 10135d0:	80e0983a 	sll	r16,r16,r3
 10135d4:	882ad43a 	srli	r21,r17,16
 10135d8:	9884d83a 	srl	r2,r19,r2
 10135dc:	a009883a 	mov	r4,r20
 10135e0:	a80b883a 	mov	r5,r21
 10135e4:	142eb03a 	or	r23,r2,r16
 10135e8:	98e4983a 	sll	r18,r19,r3
 10135ec:	10098080 	call	1009808 <__umodsi3>
 10135f0:	a009883a 	mov	r4,r20
 10135f4:	a80b883a 	mov	r5,r21
 10135f8:	1021883a 	mov	r16,r2
 10135fc:	10097a40 	call	10097a4 <__udivsi3>
 1013600:	1039883a 	mov	fp,r2
 1013604:	8d3fffcc 	andi	r20,r17,65535
 1013608:	8020943a 	slli	r16,r16,16
 101360c:	b804d43a 	srli	r2,r23,16
 1013610:	a72d383a 	mul	r22,r20,fp
 1013614:	1404b03a 	or	r2,r2,r16
 1013618:	1580062e 	bgeu	r2,r22,1013634 <__udivdi3+0x484>
 101361c:	1445883a 	add	r2,r2,r17
 1013620:	e0ffffc4 	addi	r3,fp,-1
 1013624:	14403836 	bltu	r2,r17,1013708 <__udivdi3+0x558>
 1013628:	1580372e 	bgeu	r2,r22,1013708 <__udivdi3+0x558>
 101362c:	e73fff84 	addi	fp,fp,-2
 1013630:	1445883a 	add	r2,r2,r17
 1013634:	15adc83a 	sub	r22,r2,r22
 1013638:	a80b883a 	mov	r5,r21
 101363c:	b009883a 	mov	r4,r22
 1013640:	10098080 	call	1009808 <__umodsi3>
 1013644:	1027883a 	mov	r19,r2
 1013648:	b009883a 	mov	r4,r22
 101364c:	a80b883a 	mov	r5,r21
 1013650:	10097a40 	call	10097a4 <__udivsi3>
 1013654:	9826943a 	slli	r19,r19,16
 1013658:	a0a1383a 	mul	r16,r20,r2
 101365c:	b93fffcc 	andi	r4,r23,65535
 1013660:	24c8b03a 	or	r4,r4,r19
 1013664:	2400062e 	bgeu	r4,r16,1013680 <__udivdi3+0x4d0>
 1013668:	2449883a 	add	r4,r4,r17
 101366c:	10ffffc4 	addi	r3,r2,-1
 1013670:	24402336 	bltu	r4,r17,1013700 <__udivdi3+0x550>
 1013674:	2400222e 	bgeu	r4,r16,1013700 <__udivdi3+0x550>
 1013678:	10bfff84 	addi	r2,r2,-2
 101367c:	2449883a 	add	r4,r4,r17
 1013680:	e038943a 	slli	fp,fp,16
 1013684:	2421c83a 	sub	r16,r4,r16
 1013688:	e086b03a 	or	r3,fp,r2
 101368c:	003f4306 	br	101339c <__alt_data_end+0xff81339c>
 1013690:	2005883a 	mov	r2,r4
 1013694:	003f6906 	br	101343c <__alt_data_end+0xff81343c>
 1013698:	1805883a 	mov	r2,r3
 101369c:	003f0f06 	br	10132dc <__alt_data_end+0xff8132dc>
 10136a0:	1806943a 	slli	r3,r3,16
 10136a4:	9d66983a 	sll	r19,r19,r21
 10136a8:	39ffffcc 	andi	r7,r7,65535
 10136ac:	19c7883a 	add	r3,r3,r7
 10136b0:	98ffc32e 	bgeu	r19,r3,10135c0 <__alt_data_end+0xff8135c0>
 10136b4:	10bfffc4 	addi	r2,r2,-1
 10136b8:	003fc106 	br	10135c0 <__alt_data_end+0xff8135c0>
 10136bc:	00800604 	movi	r2,24
 10136c0:	003f1106 	br	1013308 <__alt_data_end+0xff813308>
 10136c4:	00800604 	movi	r2,24
 10136c8:	003f2706 	br	1013368 <__alt_data_end+0xff813368>
 10136cc:	00800604 	movi	r2,24
 10136d0:	003ece06 	br	101320c <__alt_data_end+0xff81320c>
 10136d4:	0007883a 	mov	r3,zero
 10136d8:	00800044 	movi	r2,1
 10136dc:	003f5c06 	br	1013450 <__alt_data_end+0xff813450>
 10136e0:	813fa12e 	bgeu	r16,r4,1013568 <__alt_data_end+0xff813568>
 10136e4:	10bfff84 	addi	r2,r2,-2
 10136e8:	85e1883a 	add	r16,r16,r23
 10136ec:	003f9f06 	br	101356c <__alt_data_end+0xff81356c>
 10136f0:	1c7f8a2e 	bgeu	r3,r17,101351c <__alt_data_end+0xff81351c>
 10136f4:	31bfff84 	addi	r6,r6,-2
 10136f8:	1dc7883a 	add	r3,r3,r23
 10136fc:	003f8806 	br	1013520 <__alt_data_end+0xff813520>
 1013700:	1805883a 	mov	r2,r3
 1013704:	003fde06 	br	1013680 <__alt_data_end+0xff813680>
 1013708:	1839883a 	mov	fp,r3
 101370c:	003fc906 	br	1013634 <__alt_data_end+0xff813634>
 1013710:	b5bfff84 	addi	r22,r22,-2
 1013714:	2449883a 	add	r4,r4,r17
 1013718:	003f3406 	br	10133ec <__alt_data_end+0xff8133ec>
 101371c:	b5bfff84 	addi	r22,r22,-2
 1013720:	1445883a 	add	r2,r2,r17
 1013724:	003edb06 	br	1013294 <__alt_data_end+0xff813294>

01013728 <__umoddi3>:
 1013728:	defff404 	addi	sp,sp,-48
 101372c:	df000a15 	stw	fp,40(sp)
 1013730:	dc400315 	stw	r17,12(sp)
 1013734:	dc000215 	stw	r16,8(sp)
 1013738:	dfc00b15 	stw	ra,44(sp)
 101373c:	ddc00915 	stw	r23,36(sp)
 1013740:	dd800815 	stw	r22,32(sp)
 1013744:	dd400715 	stw	r21,28(sp)
 1013748:	dd000615 	stw	r20,24(sp)
 101374c:	dcc00515 	stw	r19,20(sp)
 1013750:	dc800415 	stw	r18,16(sp)
 1013754:	2021883a 	mov	r16,r4
 1013758:	2823883a 	mov	r17,r5
 101375c:	2839883a 	mov	fp,r5
 1013760:	38003c1e 	bne	r7,zero,1013854 <__umoddi3+0x12c>
 1013764:	3027883a 	mov	r19,r6
 1013768:	2029883a 	mov	r20,r4
 101376c:	2980512e 	bgeu	r5,r6,10138b4 <__umoddi3+0x18c>
 1013770:	00bfffd4 	movui	r2,65535
 1013774:	11809a36 	bltu	r2,r6,10139e0 <__umoddi3+0x2b8>
 1013778:	01003fc4 	movi	r4,255
 101377c:	2189803a 	cmpltu	r4,r4,r6
 1013780:	200890fa 	slli	r4,r4,3
 1013784:	3104d83a 	srl	r2,r6,r4
 1013788:	00c040b4 	movhi	r3,258
 101378c:	18eab3c4 	addi	r3,r3,-21809
 1013790:	1885883a 	add	r2,r3,r2
 1013794:	10c00003 	ldbu	r3,0(r2)
 1013798:	00800804 	movi	r2,32
 101379c:	1909883a 	add	r4,r3,r4
 10137a0:	1125c83a 	sub	r18,r2,r4
 10137a4:	90000526 	beq	r18,zero,10137bc <__umoddi3+0x94>
 10137a8:	8ca2983a 	sll	r17,r17,r18
 10137ac:	8108d83a 	srl	r4,r16,r4
 10137b0:	34a6983a 	sll	r19,r6,r18
 10137b4:	84a8983a 	sll	r20,r16,r18
 10137b8:	2478b03a 	or	fp,r4,r17
 10137bc:	982ed43a 	srli	r23,r19,16
 10137c0:	e009883a 	mov	r4,fp
 10137c4:	9dbfffcc 	andi	r22,r19,65535
 10137c8:	b80b883a 	mov	r5,r23
 10137cc:	10098080 	call	1009808 <__umodsi3>
 10137d0:	e009883a 	mov	r4,fp
 10137d4:	b80b883a 	mov	r5,r23
 10137d8:	102b883a 	mov	r21,r2
 10137dc:	10097a40 	call	10097a4 <__udivsi3>
 10137e0:	a806943a 	slli	r3,r21,16
 10137e4:	a008d43a 	srli	r4,r20,16
 10137e8:	b085383a 	mul	r2,r22,r2
 10137ec:	20c8b03a 	or	r4,r4,r3
 10137f0:	2080032e 	bgeu	r4,r2,1013800 <__umoddi3+0xd8>
 10137f4:	24c9883a 	add	r4,r4,r19
 10137f8:	24c00136 	bltu	r4,r19,1013800 <__umoddi3+0xd8>
 10137fc:	20811036 	bltu	r4,r2,1013c40 <__umoddi3+0x518>
 1013800:	20abc83a 	sub	r21,r4,r2
 1013804:	b80b883a 	mov	r5,r23
 1013808:	a809883a 	mov	r4,r21
 101380c:	10098080 	call	1009808 <__umodsi3>
 1013810:	1023883a 	mov	r17,r2
 1013814:	b80b883a 	mov	r5,r23
 1013818:	a809883a 	mov	r4,r21
 101381c:	10097a40 	call	10097a4 <__udivsi3>
 1013820:	8822943a 	slli	r17,r17,16
 1013824:	b085383a 	mul	r2,r22,r2
 1013828:	a0ffffcc 	andi	r3,r20,65535
 101382c:	1c46b03a 	or	r3,r3,r17
 1013830:	1880042e 	bgeu	r3,r2,1013844 <__umoddi3+0x11c>
 1013834:	1cc7883a 	add	r3,r3,r19
 1013838:	1cc00236 	bltu	r3,r19,1013844 <__umoddi3+0x11c>
 101383c:	1880012e 	bgeu	r3,r2,1013844 <__umoddi3+0x11c>
 1013840:	1cc7883a 	add	r3,r3,r19
 1013844:	1885c83a 	sub	r2,r3,r2
 1013848:	1484d83a 	srl	r2,r2,r18
 101384c:	0007883a 	mov	r3,zero
 1013850:	00004f06 	br	1013990 <__umoddi3+0x268>
 1013854:	29c04c36 	bltu	r5,r7,1013988 <__umoddi3+0x260>
 1013858:	00bfffd4 	movui	r2,65535
 101385c:	11c0582e 	bgeu	r2,r7,10139c0 <__umoddi3+0x298>
 1013860:	00804034 	movhi	r2,256
 1013864:	10bfffc4 	addi	r2,r2,-1
 1013868:	11c0e736 	bltu	r2,r7,1013c08 <__umoddi3+0x4e0>
 101386c:	01000404 	movi	r4,16
 1013870:	3904d83a 	srl	r2,r7,r4
 1013874:	00c040b4 	movhi	r3,258
 1013878:	18eab3c4 	addi	r3,r3,-21809
 101387c:	1885883a 	add	r2,r3,r2
 1013880:	14c00003 	ldbu	r19,0(r2)
 1013884:	00c00804 	movi	r3,32
 1013888:	9927883a 	add	r19,r19,r4
 101388c:	1ce9c83a 	sub	r20,r3,r19
 1013890:	a000581e 	bne	r20,zero,10139f4 <__umoddi3+0x2cc>
 1013894:	3c400136 	bltu	r7,r17,101389c <__umoddi3+0x174>
 1013898:	8180eb36 	bltu	r16,r6,1013c48 <__umoddi3+0x520>
 101389c:	8185c83a 	sub	r2,r16,r6
 10138a0:	89e3c83a 	sub	r17,r17,r7
 10138a4:	8089803a 	cmpltu	r4,r16,r2
 10138a8:	8939c83a 	sub	fp,r17,r4
 10138ac:	e007883a 	mov	r3,fp
 10138b0:	00003706 	br	1013990 <__umoddi3+0x268>
 10138b4:	3000041e 	bne	r6,zero,10138c8 <__umoddi3+0x1a0>
 10138b8:	000b883a 	mov	r5,zero
 10138bc:	01000044 	movi	r4,1
 10138c0:	10097a40 	call	10097a4 <__udivsi3>
 10138c4:	1027883a 	mov	r19,r2
 10138c8:	00bfffd4 	movui	r2,65535
 10138cc:	14c0402e 	bgeu	r2,r19,10139d0 <__umoddi3+0x2a8>
 10138d0:	00804034 	movhi	r2,256
 10138d4:	10bfffc4 	addi	r2,r2,-1
 10138d8:	14c0cd36 	bltu	r2,r19,1013c10 <__umoddi3+0x4e8>
 10138dc:	00800404 	movi	r2,16
 10138e0:	9886d83a 	srl	r3,r19,r2
 10138e4:	010040b4 	movhi	r4,258
 10138e8:	212ab3c4 	addi	r4,r4,-21809
 10138ec:	20c7883a 	add	r3,r4,r3
 10138f0:	18c00003 	ldbu	r3,0(r3)
 10138f4:	1887883a 	add	r3,r3,r2
 10138f8:	00800804 	movi	r2,32
 10138fc:	10e5c83a 	sub	r18,r2,r3
 1013900:	9000901e 	bne	r18,zero,1013b44 <__umoddi3+0x41c>
 1013904:	982cd43a 	srli	r22,r19,16
 1013908:	8ce3c83a 	sub	r17,r17,r19
 101390c:	9d7fffcc 	andi	r21,r19,65535
 1013910:	b00b883a 	mov	r5,r22
 1013914:	8809883a 	mov	r4,r17
 1013918:	10098080 	call	1009808 <__umodsi3>
 101391c:	8809883a 	mov	r4,r17
 1013920:	b00b883a 	mov	r5,r22
 1013924:	1021883a 	mov	r16,r2
 1013928:	10097a40 	call	10097a4 <__udivsi3>
 101392c:	8006943a 	slli	r3,r16,16
 1013930:	a008d43a 	srli	r4,r20,16
 1013934:	1545383a 	mul	r2,r2,r21
 1013938:	20c8b03a 	or	r4,r4,r3
 101393c:	2080042e 	bgeu	r4,r2,1013950 <__umoddi3+0x228>
 1013940:	24c9883a 	add	r4,r4,r19
 1013944:	24c00236 	bltu	r4,r19,1013950 <__umoddi3+0x228>
 1013948:	2080012e 	bgeu	r4,r2,1013950 <__umoddi3+0x228>
 101394c:	24c9883a 	add	r4,r4,r19
 1013950:	20a1c83a 	sub	r16,r4,r2
 1013954:	b00b883a 	mov	r5,r22
 1013958:	8009883a 	mov	r4,r16
 101395c:	10098080 	call	1009808 <__umodsi3>
 1013960:	1023883a 	mov	r17,r2
 1013964:	b00b883a 	mov	r5,r22
 1013968:	8009883a 	mov	r4,r16
 101396c:	10097a40 	call	10097a4 <__udivsi3>
 1013970:	8822943a 	slli	r17,r17,16
 1013974:	1545383a 	mul	r2,r2,r21
 1013978:	a53fffcc 	andi	r20,r20,65535
 101397c:	a446b03a 	or	r3,r20,r17
 1013980:	18bfb02e 	bgeu	r3,r2,1013844 <__alt_data_end+0xff813844>
 1013984:	003fab06 	br	1013834 <__alt_data_end+0xff813834>
 1013988:	2005883a 	mov	r2,r4
 101398c:	2807883a 	mov	r3,r5
 1013990:	dfc00b17 	ldw	ra,44(sp)
 1013994:	df000a17 	ldw	fp,40(sp)
 1013998:	ddc00917 	ldw	r23,36(sp)
 101399c:	dd800817 	ldw	r22,32(sp)
 10139a0:	dd400717 	ldw	r21,28(sp)
 10139a4:	dd000617 	ldw	r20,24(sp)
 10139a8:	dcc00517 	ldw	r19,20(sp)
 10139ac:	dc800417 	ldw	r18,16(sp)
 10139b0:	dc400317 	ldw	r17,12(sp)
 10139b4:	dc000217 	ldw	r16,8(sp)
 10139b8:	dec00c04 	addi	sp,sp,48
 10139bc:	f800283a 	ret
 10139c0:	04c03fc4 	movi	r19,255
 10139c4:	99c9803a 	cmpltu	r4,r19,r7
 10139c8:	200890fa 	slli	r4,r4,3
 10139cc:	003fa806 	br	1013870 <__alt_data_end+0xff813870>
 10139d0:	00803fc4 	movi	r2,255
 10139d4:	14c5803a 	cmpltu	r2,r2,r19
 10139d8:	100490fa 	slli	r2,r2,3
 10139dc:	003fc006 	br	10138e0 <__alt_data_end+0xff8138e0>
 10139e0:	00804034 	movhi	r2,256
 10139e4:	10bfffc4 	addi	r2,r2,-1
 10139e8:	11808b36 	bltu	r2,r6,1013c18 <__umoddi3+0x4f0>
 10139ec:	01000404 	movi	r4,16
 10139f0:	003f6406 	br	1013784 <__alt_data_end+0xff813784>
 10139f4:	34c4d83a 	srl	r2,r6,r19
 10139f8:	3d0e983a 	sll	r7,r7,r20
 10139fc:	8cf8d83a 	srl	fp,r17,r19
 1013a00:	8d10983a 	sll	r8,r17,r20
 1013a04:	38aab03a 	or	r21,r7,r2
 1013a08:	a82cd43a 	srli	r22,r21,16
 1013a0c:	84e2d83a 	srl	r17,r16,r19
 1013a10:	e009883a 	mov	r4,fp
 1013a14:	b00b883a 	mov	r5,r22
 1013a18:	8a22b03a 	or	r17,r17,r8
 1013a1c:	3524983a 	sll	r18,r6,r20
 1013a20:	10098080 	call	1009808 <__umodsi3>
 1013a24:	e009883a 	mov	r4,fp
 1013a28:	b00b883a 	mov	r5,r22
 1013a2c:	102f883a 	mov	r23,r2
 1013a30:	10097a40 	call	10097a4 <__udivsi3>
 1013a34:	100d883a 	mov	r6,r2
 1013a38:	b808943a 	slli	r4,r23,16
 1013a3c:	aa3fffcc 	andi	r8,r21,65535
 1013a40:	8804d43a 	srli	r2,r17,16
 1013a44:	41af383a 	mul	r23,r8,r6
 1013a48:	8520983a 	sll	r16,r16,r20
 1013a4c:	1104b03a 	or	r2,r2,r4
 1013a50:	15c0042e 	bgeu	r2,r23,1013a64 <__umoddi3+0x33c>
 1013a54:	1545883a 	add	r2,r2,r21
 1013a58:	30ffffc4 	addi	r3,r6,-1
 1013a5c:	1540742e 	bgeu	r2,r21,1013c30 <__umoddi3+0x508>
 1013a60:	180d883a 	mov	r6,r3
 1013a64:	15efc83a 	sub	r23,r2,r23
 1013a68:	b00b883a 	mov	r5,r22
 1013a6c:	b809883a 	mov	r4,r23
 1013a70:	d9800115 	stw	r6,4(sp)
 1013a74:	da000015 	stw	r8,0(sp)
 1013a78:	10098080 	call	1009808 <__umodsi3>
 1013a7c:	b00b883a 	mov	r5,r22
 1013a80:	b809883a 	mov	r4,r23
 1013a84:	1039883a 	mov	fp,r2
 1013a88:	10097a40 	call	10097a4 <__udivsi3>
 1013a8c:	da000017 	ldw	r8,0(sp)
 1013a90:	e038943a 	slli	fp,fp,16
 1013a94:	100b883a 	mov	r5,r2
 1013a98:	4089383a 	mul	r4,r8,r2
 1013a9c:	8a3fffcc 	andi	r8,r17,65535
 1013aa0:	4710b03a 	or	r8,r8,fp
 1013aa4:	d9800117 	ldw	r6,4(sp)
 1013aa8:	4100042e 	bgeu	r8,r4,1013abc <__umoddi3+0x394>
 1013aac:	4551883a 	add	r8,r8,r21
 1013ab0:	10bfffc4 	addi	r2,r2,-1
 1013ab4:	45405a2e 	bgeu	r8,r21,1013c20 <__umoddi3+0x4f8>
 1013ab8:	100b883a 	mov	r5,r2
 1013abc:	300c943a 	slli	r6,r6,16
 1013ac0:	91ffffcc 	andi	r7,r18,65535
 1013ac4:	9004d43a 	srli	r2,r18,16
 1013ac8:	314cb03a 	or	r6,r6,r5
 1013acc:	317fffcc 	andi	r5,r6,65535
 1013ad0:	300cd43a 	srli	r6,r6,16
 1013ad4:	29d3383a 	mul	r9,r5,r7
 1013ad8:	288b383a 	mul	r5,r5,r2
 1013adc:	31cf383a 	mul	r7,r6,r7
 1013ae0:	4806d43a 	srli	r3,r9,16
 1013ae4:	4111c83a 	sub	r8,r8,r4
 1013ae8:	29cb883a 	add	r5,r5,r7
 1013aec:	194b883a 	add	r5,r3,r5
 1013af0:	3085383a 	mul	r2,r6,r2
 1013af4:	29c0022e 	bgeu	r5,r7,1013b00 <__umoddi3+0x3d8>
 1013af8:	00c00074 	movhi	r3,1
 1013afc:	10c5883a 	add	r2,r2,r3
 1013b00:	2808d43a 	srli	r4,r5,16
 1013b04:	280a943a 	slli	r5,r5,16
 1013b08:	4a7fffcc 	andi	r9,r9,65535
 1013b0c:	2085883a 	add	r2,r4,r2
 1013b10:	2a4b883a 	add	r5,r5,r9
 1013b14:	40803636 	bltu	r8,r2,1013bf0 <__umoddi3+0x4c8>
 1013b18:	40804d26 	beq	r8,r2,1013c50 <__umoddi3+0x528>
 1013b1c:	4089c83a 	sub	r4,r8,r2
 1013b20:	280f883a 	mov	r7,r5
 1013b24:	81cfc83a 	sub	r7,r16,r7
 1013b28:	81c7803a 	cmpltu	r3,r16,r7
 1013b2c:	20c7c83a 	sub	r3,r4,r3
 1013b30:	1cc4983a 	sll	r2,r3,r19
 1013b34:	3d0ed83a 	srl	r7,r7,r20
 1013b38:	1d06d83a 	srl	r3,r3,r20
 1013b3c:	11c4b03a 	or	r2,r2,r7
 1013b40:	003f9306 	br	1013990 <__alt_data_end+0xff813990>
 1013b44:	9ca6983a 	sll	r19,r19,r18
 1013b48:	88e8d83a 	srl	r20,r17,r3
 1013b4c:	80c4d83a 	srl	r2,r16,r3
 1013b50:	982cd43a 	srli	r22,r19,16
 1013b54:	8ca2983a 	sll	r17,r17,r18
 1013b58:	a009883a 	mov	r4,r20
 1013b5c:	b00b883a 	mov	r5,r22
 1013b60:	1478b03a 	or	fp,r2,r17
 1013b64:	10098080 	call	1009808 <__umodsi3>
 1013b68:	a009883a 	mov	r4,r20
 1013b6c:	b00b883a 	mov	r5,r22
 1013b70:	1023883a 	mov	r17,r2
 1013b74:	10097a40 	call	10097a4 <__udivsi3>
 1013b78:	9d7fffcc 	andi	r21,r19,65535
 1013b7c:	880a943a 	slli	r5,r17,16
 1013b80:	e008d43a 	srli	r4,fp,16
 1013b84:	a885383a 	mul	r2,r21,r2
 1013b88:	84a8983a 	sll	r20,r16,r18
 1013b8c:	2148b03a 	or	r4,r4,r5
 1013b90:	2080042e 	bgeu	r4,r2,1013ba4 <__umoddi3+0x47c>
 1013b94:	24c9883a 	add	r4,r4,r19
 1013b98:	24c00236 	bltu	r4,r19,1013ba4 <__umoddi3+0x47c>
 1013b9c:	2080012e 	bgeu	r4,r2,1013ba4 <__umoddi3+0x47c>
 1013ba0:	24c9883a 	add	r4,r4,r19
 1013ba4:	20a3c83a 	sub	r17,r4,r2
 1013ba8:	b00b883a 	mov	r5,r22
 1013bac:	8809883a 	mov	r4,r17
 1013bb0:	10098080 	call	1009808 <__umodsi3>
 1013bb4:	102f883a 	mov	r23,r2
 1013bb8:	8809883a 	mov	r4,r17
 1013bbc:	b00b883a 	mov	r5,r22
 1013bc0:	10097a40 	call	10097a4 <__udivsi3>
 1013bc4:	b82e943a 	slli	r23,r23,16
 1013bc8:	a885383a 	mul	r2,r21,r2
 1013bcc:	e13fffcc 	andi	r4,fp,65535
 1013bd0:	25c8b03a 	or	r4,r4,r23
 1013bd4:	2080042e 	bgeu	r4,r2,1013be8 <__umoddi3+0x4c0>
 1013bd8:	24c9883a 	add	r4,r4,r19
 1013bdc:	24c00236 	bltu	r4,r19,1013be8 <__umoddi3+0x4c0>
 1013be0:	2080012e 	bgeu	r4,r2,1013be8 <__umoddi3+0x4c0>
 1013be4:	24c9883a 	add	r4,r4,r19
 1013be8:	20a3c83a 	sub	r17,r4,r2
 1013bec:	003f4806 	br	1013910 <__alt_data_end+0xff813910>
 1013bf0:	2c8fc83a 	sub	r7,r5,r18
 1013bf4:	1545c83a 	sub	r2,r2,r21
 1013bf8:	29cb803a 	cmpltu	r5,r5,r7
 1013bfc:	1145c83a 	sub	r2,r2,r5
 1013c00:	4089c83a 	sub	r4,r8,r2
 1013c04:	003fc706 	br	1013b24 <__alt_data_end+0xff813b24>
 1013c08:	01000604 	movi	r4,24
 1013c0c:	003f1806 	br	1013870 <__alt_data_end+0xff813870>
 1013c10:	00800604 	movi	r2,24
 1013c14:	003f3206 	br	10138e0 <__alt_data_end+0xff8138e0>
 1013c18:	01000604 	movi	r4,24
 1013c1c:	003ed906 	br	1013784 <__alt_data_end+0xff813784>
 1013c20:	413fa52e 	bgeu	r8,r4,1013ab8 <__alt_data_end+0xff813ab8>
 1013c24:	297fff84 	addi	r5,r5,-2
 1013c28:	4551883a 	add	r8,r8,r21
 1013c2c:	003fa306 	br	1013abc <__alt_data_end+0xff813abc>
 1013c30:	15ff8b2e 	bgeu	r2,r23,1013a60 <__alt_data_end+0xff813a60>
 1013c34:	31bfff84 	addi	r6,r6,-2
 1013c38:	1545883a 	add	r2,r2,r21
 1013c3c:	003f8906 	br	1013a64 <__alt_data_end+0xff813a64>
 1013c40:	24c9883a 	add	r4,r4,r19
 1013c44:	003eee06 	br	1013800 <__alt_data_end+0xff813800>
 1013c48:	8005883a 	mov	r2,r16
 1013c4c:	003f1706 	br	10138ac <__alt_data_end+0xff8138ac>
 1013c50:	817fe736 	bltu	r16,r5,1013bf0 <__alt_data_end+0xff813bf0>
 1013c54:	280f883a 	mov	r7,r5
 1013c58:	0009883a 	mov	r4,zero
 1013c5c:	003fb106 	br	1013b24 <__alt_data_end+0xff813b24>

01013c60 <__adddf3>:
 1013c60:	02c00434 	movhi	r11,16
 1013c64:	5affffc4 	addi	r11,r11,-1
 1013c68:	2806d7fa 	srli	r3,r5,31
 1013c6c:	2ad4703a 	and	r10,r5,r11
 1013c70:	3ad2703a 	and	r9,r7,r11
 1013c74:	3804d53a 	srli	r2,r7,20
 1013c78:	3018d77a 	srli	r12,r6,29
 1013c7c:	280ad53a 	srli	r5,r5,20
 1013c80:	501490fa 	slli	r10,r10,3
 1013c84:	2010d77a 	srli	r8,r4,29
 1013c88:	481290fa 	slli	r9,r9,3
 1013c8c:	380ed7fa 	srli	r7,r7,31
 1013c90:	defffb04 	addi	sp,sp,-20
 1013c94:	dc800215 	stw	r18,8(sp)
 1013c98:	dc400115 	stw	r17,4(sp)
 1013c9c:	dc000015 	stw	r16,0(sp)
 1013ca0:	dfc00415 	stw	ra,16(sp)
 1013ca4:	dcc00315 	stw	r19,12(sp)
 1013ca8:	1c803fcc 	andi	r18,r3,255
 1013cac:	2c01ffcc 	andi	r16,r5,2047
 1013cb0:	5210b03a 	or	r8,r10,r8
 1013cb4:	202290fa 	slli	r17,r4,3
 1013cb8:	1081ffcc 	andi	r2,r2,2047
 1013cbc:	4b12b03a 	or	r9,r9,r12
 1013cc0:	300c90fa 	slli	r6,r6,3
 1013cc4:	91c07526 	beq	r18,r7,1013e9c <__adddf3+0x23c>
 1013cc8:	8087c83a 	sub	r3,r16,r2
 1013ccc:	00c0ab0e 	bge	zero,r3,1013f7c <__adddf3+0x31c>
 1013cd0:	10002a1e 	bne	r2,zero,1013d7c <__adddf3+0x11c>
 1013cd4:	4984b03a 	or	r2,r9,r6
 1013cd8:	1000961e 	bne	r2,zero,1013f34 <__adddf3+0x2d4>
 1013cdc:	888001cc 	andi	r2,r17,7
 1013ce0:	10000726 	beq	r2,zero,1013d00 <__adddf3+0xa0>
 1013ce4:	888003cc 	andi	r2,r17,15
 1013ce8:	00c00104 	movi	r3,4
 1013cec:	10c00426 	beq	r2,r3,1013d00 <__adddf3+0xa0>
 1013cf0:	88c7883a 	add	r3,r17,r3
 1013cf4:	1c63803a 	cmpltu	r17,r3,r17
 1013cf8:	4451883a 	add	r8,r8,r17
 1013cfc:	1823883a 	mov	r17,r3
 1013d00:	4080202c 	andhi	r2,r8,128
 1013d04:	10005926 	beq	r2,zero,1013e6c <__adddf3+0x20c>
 1013d08:	84000044 	addi	r16,r16,1
 1013d0c:	0081ffc4 	movi	r2,2047
 1013d10:	8080ba26 	beq	r16,r2,1013ffc <__adddf3+0x39c>
 1013d14:	00bfe034 	movhi	r2,65408
 1013d18:	10bfffc4 	addi	r2,r2,-1
 1013d1c:	4090703a 	and	r8,r8,r2
 1013d20:	4004977a 	slli	r2,r8,29
 1013d24:	4010927a 	slli	r8,r8,9
 1013d28:	8822d0fa 	srli	r17,r17,3
 1013d2c:	8401ffcc 	andi	r16,r16,2047
 1013d30:	4010d33a 	srli	r8,r8,12
 1013d34:	9007883a 	mov	r3,r18
 1013d38:	1444b03a 	or	r2,r2,r17
 1013d3c:	8401ffcc 	andi	r16,r16,2047
 1013d40:	8020953a 	slli	r16,r16,20
 1013d44:	18c03fcc 	andi	r3,r3,255
 1013d48:	01000434 	movhi	r4,16
 1013d4c:	213fffc4 	addi	r4,r4,-1
 1013d50:	180697fa 	slli	r3,r3,31
 1013d54:	4110703a 	and	r8,r8,r4
 1013d58:	4410b03a 	or	r8,r8,r16
 1013d5c:	40c6b03a 	or	r3,r8,r3
 1013d60:	dfc00417 	ldw	ra,16(sp)
 1013d64:	dcc00317 	ldw	r19,12(sp)
 1013d68:	dc800217 	ldw	r18,8(sp)
 1013d6c:	dc400117 	ldw	r17,4(sp)
 1013d70:	dc000017 	ldw	r16,0(sp)
 1013d74:	dec00504 	addi	sp,sp,20
 1013d78:	f800283a 	ret
 1013d7c:	0081ffc4 	movi	r2,2047
 1013d80:	80bfd626 	beq	r16,r2,1013cdc <__alt_data_end+0xff813cdc>
 1013d84:	4a402034 	orhi	r9,r9,128
 1013d88:	00800e04 	movi	r2,56
 1013d8c:	10c09f16 	blt	r2,r3,101400c <__adddf3+0x3ac>
 1013d90:	008007c4 	movi	r2,31
 1013d94:	10c0c216 	blt	r2,r3,10140a0 <__adddf3+0x440>
 1013d98:	00800804 	movi	r2,32
 1013d9c:	10c5c83a 	sub	r2,r2,r3
 1013da0:	488a983a 	sll	r5,r9,r2
 1013da4:	30c8d83a 	srl	r4,r6,r3
 1013da8:	3084983a 	sll	r2,r6,r2
 1013dac:	48c6d83a 	srl	r3,r9,r3
 1013db0:	290cb03a 	or	r6,r5,r4
 1013db4:	1004c03a 	cmpne	r2,r2,zero
 1013db8:	308cb03a 	or	r6,r6,r2
 1013dbc:	898dc83a 	sub	r6,r17,r6
 1013dc0:	89a3803a 	cmpltu	r17,r17,r6
 1013dc4:	40d1c83a 	sub	r8,r8,r3
 1013dc8:	4451c83a 	sub	r8,r8,r17
 1013dcc:	3023883a 	mov	r17,r6
 1013dd0:	4080202c 	andhi	r2,r8,128
 1013dd4:	10002326 	beq	r2,zero,1013e64 <__adddf3+0x204>
 1013dd8:	04c02034 	movhi	r19,128
 1013ddc:	9cffffc4 	addi	r19,r19,-1
 1013de0:	44e6703a 	and	r19,r8,r19
 1013de4:	98007626 	beq	r19,zero,1013fc0 <__adddf3+0x360>
 1013de8:	9809883a 	mov	r4,r19
 1013dec:	10099700 	call	1009970 <__clzsi2>
 1013df0:	10fffe04 	addi	r3,r2,-8
 1013df4:	010007c4 	movi	r4,31
 1013df8:	20c07716 	blt	r4,r3,1013fd8 <__adddf3+0x378>
 1013dfc:	00800804 	movi	r2,32
 1013e00:	10c5c83a 	sub	r2,r2,r3
 1013e04:	8884d83a 	srl	r2,r17,r2
 1013e08:	98d0983a 	sll	r8,r19,r3
 1013e0c:	88e2983a 	sll	r17,r17,r3
 1013e10:	1204b03a 	or	r2,r2,r8
 1013e14:	1c007416 	blt	r3,r16,1013fe8 <__adddf3+0x388>
 1013e18:	1c21c83a 	sub	r16,r3,r16
 1013e1c:	82000044 	addi	r8,r16,1
 1013e20:	00c007c4 	movi	r3,31
 1013e24:	1a009116 	blt	r3,r8,101406c <__adddf3+0x40c>
 1013e28:	00c00804 	movi	r3,32
 1013e2c:	1a07c83a 	sub	r3,r3,r8
 1013e30:	8a08d83a 	srl	r4,r17,r8
 1013e34:	88e2983a 	sll	r17,r17,r3
 1013e38:	10c6983a 	sll	r3,r2,r3
 1013e3c:	1210d83a 	srl	r8,r2,r8
 1013e40:	8804c03a 	cmpne	r2,r17,zero
 1013e44:	1906b03a 	or	r3,r3,r4
 1013e48:	18a2b03a 	or	r17,r3,r2
 1013e4c:	0021883a 	mov	r16,zero
 1013e50:	003fa206 	br	1013cdc <__alt_data_end+0xff813cdc>
 1013e54:	1890b03a 	or	r8,r3,r2
 1013e58:	40017d26 	beq	r8,zero,1014450 <__adddf3+0x7f0>
 1013e5c:	1011883a 	mov	r8,r2
 1013e60:	1823883a 	mov	r17,r3
 1013e64:	888001cc 	andi	r2,r17,7
 1013e68:	103f9e1e 	bne	r2,zero,1013ce4 <__alt_data_end+0xff813ce4>
 1013e6c:	4004977a 	slli	r2,r8,29
 1013e70:	8822d0fa 	srli	r17,r17,3
 1013e74:	4010d0fa 	srli	r8,r8,3
 1013e78:	9007883a 	mov	r3,r18
 1013e7c:	1444b03a 	or	r2,r2,r17
 1013e80:	0101ffc4 	movi	r4,2047
 1013e84:	81002426 	beq	r16,r4,1013f18 <__adddf3+0x2b8>
 1013e88:	8120703a 	and	r16,r16,r4
 1013e8c:	01000434 	movhi	r4,16
 1013e90:	213fffc4 	addi	r4,r4,-1
 1013e94:	4110703a 	and	r8,r8,r4
 1013e98:	003fa806 	br	1013d3c <__alt_data_end+0xff813d3c>
 1013e9c:	8089c83a 	sub	r4,r16,r2
 1013ea0:	01005e0e 	bge	zero,r4,101401c <__adddf3+0x3bc>
 1013ea4:	10002b26 	beq	r2,zero,1013f54 <__adddf3+0x2f4>
 1013ea8:	0081ffc4 	movi	r2,2047
 1013eac:	80bf8b26 	beq	r16,r2,1013cdc <__alt_data_end+0xff813cdc>
 1013eb0:	4a402034 	orhi	r9,r9,128
 1013eb4:	00800e04 	movi	r2,56
 1013eb8:	1100a40e 	bge	r2,r4,101414c <__adddf3+0x4ec>
 1013ebc:	498cb03a 	or	r6,r9,r6
 1013ec0:	300ac03a 	cmpne	r5,r6,zero
 1013ec4:	0013883a 	mov	r9,zero
 1013ec8:	2c4b883a 	add	r5,r5,r17
 1013ecc:	2c63803a 	cmpltu	r17,r5,r17
 1013ed0:	4a11883a 	add	r8,r9,r8
 1013ed4:	8a11883a 	add	r8,r17,r8
 1013ed8:	2823883a 	mov	r17,r5
 1013edc:	4080202c 	andhi	r2,r8,128
 1013ee0:	103fe026 	beq	r2,zero,1013e64 <__alt_data_end+0xff813e64>
 1013ee4:	84000044 	addi	r16,r16,1
 1013ee8:	0081ffc4 	movi	r2,2047
 1013eec:	8080d226 	beq	r16,r2,1014238 <__adddf3+0x5d8>
 1013ef0:	00bfe034 	movhi	r2,65408
 1013ef4:	10bfffc4 	addi	r2,r2,-1
 1013ef8:	4090703a 	and	r8,r8,r2
 1013efc:	880ad07a 	srli	r5,r17,1
 1013f00:	400897fa 	slli	r4,r8,31
 1013f04:	88c0004c 	andi	r3,r17,1
 1013f08:	28e2b03a 	or	r17,r5,r3
 1013f0c:	4010d07a 	srli	r8,r8,1
 1013f10:	2462b03a 	or	r17,r4,r17
 1013f14:	003f7106 	br	1013cdc <__alt_data_end+0xff813cdc>
 1013f18:	4088b03a 	or	r4,r8,r2
 1013f1c:	20014526 	beq	r4,zero,1014434 <__adddf3+0x7d4>
 1013f20:	01000434 	movhi	r4,16
 1013f24:	42000234 	orhi	r8,r8,8
 1013f28:	213fffc4 	addi	r4,r4,-1
 1013f2c:	4110703a 	and	r8,r8,r4
 1013f30:	003f8206 	br	1013d3c <__alt_data_end+0xff813d3c>
 1013f34:	18ffffc4 	addi	r3,r3,-1
 1013f38:	1800491e 	bne	r3,zero,1014060 <__adddf3+0x400>
 1013f3c:	898bc83a 	sub	r5,r17,r6
 1013f40:	8963803a 	cmpltu	r17,r17,r5
 1013f44:	4251c83a 	sub	r8,r8,r9
 1013f48:	4451c83a 	sub	r8,r8,r17
 1013f4c:	2823883a 	mov	r17,r5
 1013f50:	003f9f06 	br	1013dd0 <__alt_data_end+0xff813dd0>
 1013f54:	4984b03a 	or	r2,r9,r6
 1013f58:	103f6026 	beq	r2,zero,1013cdc <__alt_data_end+0xff813cdc>
 1013f5c:	213fffc4 	addi	r4,r4,-1
 1013f60:	2000931e 	bne	r4,zero,10141b0 <__adddf3+0x550>
 1013f64:	898d883a 	add	r6,r17,r6
 1013f68:	3463803a 	cmpltu	r17,r6,r17
 1013f6c:	4251883a 	add	r8,r8,r9
 1013f70:	8a11883a 	add	r8,r17,r8
 1013f74:	3023883a 	mov	r17,r6
 1013f78:	003fd806 	br	1013edc <__alt_data_end+0xff813edc>
 1013f7c:	1800541e 	bne	r3,zero,10140d0 <__adddf3+0x470>
 1013f80:	80800044 	addi	r2,r16,1
 1013f84:	1081ffcc 	andi	r2,r2,2047
 1013f88:	00c00044 	movi	r3,1
 1013f8c:	1880a00e 	bge	r3,r2,1014210 <__adddf3+0x5b0>
 1013f90:	8989c83a 	sub	r4,r17,r6
 1013f94:	8905803a 	cmpltu	r2,r17,r4
 1013f98:	4267c83a 	sub	r19,r8,r9
 1013f9c:	98a7c83a 	sub	r19,r19,r2
 1013fa0:	9880202c 	andhi	r2,r19,128
 1013fa4:	10006326 	beq	r2,zero,1014134 <__adddf3+0x4d4>
 1013fa8:	3463c83a 	sub	r17,r6,r17
 1013fac:	4a07c83a 	sub	r3,r9,r8
 1013fb0:	344d803a 	cmpltu	r6,r6,r17
 1013fb4:	19a7c83a 	sub	r19,r3,r6
 1013fb8:	3825883a 	mov	r18,r7
 1013fbc:	983f8a1e 	bne	r19,zero,1013de8 <__alt_data_end+0xff813de8>
 1013fc0:	8809883a 	mov	r4,r17
 1013fc4:	10099700 	call	1009970 <__clzsi2>
 1013fc8:	10800804 	addi	r2,r2,32
 1013fcc:	10fffe04 	addi	r3,r2,-8
 1013fd0:	010007c4 	movi	r4,31
 1013fd4:	20ff890e 	bge	r4,r3,1013dfc <__alt_data_end+0xff813dfc>
 1013fd8:	10bff604 	addi	r2,r2,-40
 1013fdc:	8884983a 	sll	r2,r17,r2
 1013fe0:	0023883a 	mov	r17,zero
 1013fe4:	1c3f8c0e 	bge	r3,r16,1013e18 <__alt_data_end+0xff813e18>
 1013fe8:	023fe034 	movhi	r8,65408
 1013fec:	423fffc4 	addi	r8,r8,-1
 1013ff0:	80e1c83a 	sub	r16,r16,r3
 1013ff4:	1210703a 	and	r8,r2,r8
 1013ff8:	003f3806 	br	1013cdc <__alt_data_end+0xff813cdc>
 1013ffc:	9007883a 	mov	r3,r18
 1014000:	0011883a 	mov	r8,zero
 1014004:	0005883a 	mov	r2,zero
 1014008:	003f4c06 	br	1013d3c <__alt_data_end+0xff813d3c>
 101400c:	498cb03a 	or	r6,r9,r6
 1014010:	300cc03a 	cmpne	r6,r6,zero
 1014014:	0007883a 	mov	r3,zero
 1014018:	003f6806 	br	1013dbc <__alt_data_end+0xff813dbc>
 101401c:	20009c1e 	bne	r4,zero,1014290 <__adddf3+0x630>
 1014020:	80800044 	addi	r2,r16,1
 1014024:	1141ffcc 	andi	r5,r2,2047
 1014028:	01000044 	movi	r4,1
 101402c:	2140670e 	bge	r4,r5,10141cc <__adddf3+0x56c>
 1014030:	0101ffc4 	movi	r4,2047
 1014034:	11007f26 	beq	r2,r4,1014234 <__adddf3+0x5d4>
 1014038:	898d883a 	add	r6,r17,r6
 101403c:	4247883a 	add	r3,r8,r9
 1014040:	3451803a 	cmpltu	r8,r6,r17
 1014044:	40d1883a 	add	r8,r8,r3
 1014048:	402297fa 	slli	r17,r8,31
 101404c:	300cd07a 	srli	r6,r6,1
 1014050:	4010d07a 	srli	r8,r8,1
 1014054:	1021883a 	mov	r16,r2
 1014058:	89a2b03a 	or	r17,r17,r6
 101405c:	003f1f06 	br	1013cdc <__alt_data_end+0xff813cdc>
 1014060:	0081ffc4 	movi	r2,2047
 1014064:	80bf481e 	bne	r16,r2,1013d88 <__alt_data_end+0xff813d88>
 1014068:	003f1c06 	br	1013cdc <__alt_data_end+0xff813cdc>
 101406c:	843ff844 	addi	r16,r16,-31
 1014070:	01000804 	movi	r4,32
 1014074:	1406d83a 	srl	r3,r2,r16
 1014078:	41005026 	beq	r8,r4,10141bc <__adddf3+0x55c>
 101407c:	01001004 	movi	r4,64
 1014080:	2211c83a 	sub	r8,r4,r8
 1014084:	1204983a 	sll	r2,r2,r8
 1014088:	88a2b03a 	or	r17,r17,r2
 101408c:	8822c03a 	cmpne	r17,r17,zero
 1014090:	1c62b03a 	or	r17,r3,r17
 1014094:	0011883a 	mov	r8,zero
 1014098:	0021883a 	mov	r16,zero
 101409c:	003f7106 	br	1013e64 <__alt_data_end+0xff813e64>
 10140a0:	193ff804 	addi	r4,r3,-32
 10140a4:	00800804 	movi	r2,32
 10140a8:	4908d83a 	srl	r4,r9,r4
 10140ac:	18804526 	beq	r3,r2,10141c4 <__adddf3+0x564>
 10140b0:	00801004 	movi	r2,64
 10140b4:	10c5c83a 	sub	r2,r2,r3
 10140b8:	4886983a 	sll	r3,r9,r2
 10140bc:	198cb03a 	or	r6,r3,r6
 10140c0:	300cc03a 	cmpne	r6,r6,zero
 10140c4:	218cb03a 	or	r6,r4,r6
 10140c8:	0007883a 	mov	r3,zero
 10140cc:	003f3b06 	br	1013dbc <__alt_data_end+0xff813dbc>
 10140d0:	80002a26 	beq	r16,zero,101417c <__adddf3+0x51c>
 10140d4:	0101ffc4 	movi	r4,2047
 10140d8:	11006826 	beq	r2,r4,101427c <__adddf3+0x61c>
 10140dc:	00c7c83a 	sub	r3,zero,r3
 10140e0:	42002034 	orhi	r8,r8,128
 10140e4:	01000e04 	movi	r4,56
 10140e8:	20c07c16 	blt	r4,r3,10142dc <__adddf3+0x67c>
 10140ec:	010007c4 	movi	r4,31
 10140f0:	20c0da16 	blt	r4,r3,101445c <__adddf3+0x7fc>
 10140f4:	01000804 	movi	r4,32
 10140f8:	20c9c83a 	sub	r4,r4,r3
 10140fc:	4114983a 	sll	r10,r8,r4
 1014100:	88cad83a 	srl	r5,r17,r3
 1014104:	8908983a 	sll	r4,r17,r4
 1014108:	40c6d83a 	srl	r3,r8,r3
 101410c:	5162b03a 	or	r17,r10,r5
 1014110:	2008c03a 	cmpne	r4,r4,zero
 1014114:	8922b03a 	or	r17,r17,r4
 1014118:	3463c83a 	sub	r17,r6,r17
 101411c:	48c7c83a 	sub	r3,r9,r3
 1014120:	344d803a 	cmpltu	r6,r6,r17
 1014124:	1991c83a 	sub	r8,r3,r6
 1014128:	1021883a 	mov	r16,r2
 101412c:	3825883a 	mov	r18,r7
 1014130:	003f2706 	br	1013dd0 <__alt_data_end+0xff813dd0>
 1014134:	24d0b03a 	or	r8,r4,r19
 1014138:	40001b1e 	bne	r8,zero,10141a8 <__adddf3+0x548>
 101413c:	0005883a 	mov	r2,zero
 1014140:	0007883a 	mov	r3,zero
 1014144:	0021883a 	mov	r16,zero
 1014148:	003f4d06 	br	1013e80 <__alt_data_end+0xff813e80>
 101414c:	008007c4 	movi	r2,31
 1014150:	11003c16 	blt	r2,r4,1014244 <__adddf3+0x5e4>
 1014154:	00800804 	movi	r2,32
 1014158:	1105c83a 	sub	r2,r2,r4
 101415c:	488e983a 	sll	r7,r9,r2
 1014160:	310ad83a 	srl	r5,r6,r4
 1014164:	3084983a 	sll	r2,r6,r2
 1014168:	4912d83a 	srl	r9,r9,r4
 101416c:	394ab03a 	or	r5,r7,r5
 1014170:	1004c03a 	cmpne	r2,r2,zero
 1014174:	288ab03a 	or	r5,r5,r2
 1014178:	003f5306 	br	1013ec8 <__alt_data_end+0xff813ec8>
 101417c:	4448b03a 	or	r4,r8,r17
 1014180:	20003e26 	beq	r4,zero,101427c <__adddf3+0x61c>
 1014184:	00c6303a 	nor	r3,zero,r3
 1014188:	18003a1e 	bne	r3,zero,1014274 <__adddf3+0x614>
 101418c:	3463c83a 	sub	r17,r6,r17
 1014190:	4a07c83a 	sub	r3,r9,r8
 1014194:	344d803a 	cmpltu	r6,r6,r17
 1014198:	1991c83a 	sub	r8,r3,r6
 101419c:	1021883a 	mov	r16,r2
 10141a0:	3825883a 	mov	r18,r7
 10141a4:	003f0a06 	br	1013dd0 <__alt_data_end+0xff813dd0>
 10141a8:	2023883a 	mov	r17,r4
 10141ac:	003f0d06 	br	1013de4 <__alt_data_end+0xff813de4>
 10141b0:	0081ffc4 	movi	r2,2047
 10141b4:	80bf3f1e 	bne	r16,r2,1013eb4 <__alt_data_end+0xff813eb4>
 10141b8:	003ec806 	br	1013cdc <__alt_data_end+0xff813cdc>
 10141bc:	0005883a 	mov	r2,zero
 10141c0:	003fb106 	br	1014088 <__alt_data_end+0xff814088>
 10141c4:	0007883a 	mov	r3,zero
 10141c8:	003fbc06 	br	10140bc <__alt_data_end+0xff8140bc>
 10141cc:	4444b03a 	or	r2,r8,r17
 10141d0:	8000871e 	bne	r16,zero,10143f0 <__adddf3+0x790>
 10141d4:	1000ba26 	beq	r2,zero,10144c0 <__adddf3+0x860>
 10141d8:	4984b03a 	or	r2,r9,r6
 10141dc:	103ebf26 	beq	r2,zero,1013cdc <__alt_data_end+0xff813cdc>
 10141e0:	8985883a 	add	r2,r17,r6
 10141e4:	4247883a 	add	r3,r8,r9
 10141e8:	1451803a 	cmpltu	r8,r2,r17
 10141ec:	40d1883a 	add	r8,r8,r3
 10141f0:	40c0202c 	andhi	r3,r8,128
 10141f4:	1023883a 	mov	r17,r2
 10141f8:	183f1a26 	beq	r3,zero,1013e64 <__alt_data_end+0xff813e64>
 10141fc:	00bfe034 	movhi	r2,65408
 1014200:	10bfffc4 	addi	r2,r2,-1
 1014204:	2021883a 	mov	r16,r4
 1014208:	4090703a 	and	r8,r8,r2
 101420c:	003eb306 	br	1013cdc <__alt_data_end+0xff813cdc>
 1014210:	4444b03a 	or	r2,r8,r17
 1014214:	8000291e 	bne	r16,zero,10142bc <__adddf3+0x65c>
 1014218:	10004b1e 	bne	r2,zero,1014348 <__adddf3+0x6e8>
 101421c:	4990b03a 	or	r8,r9,r6
 1014220:	40008b26 	beq	r8,zero,1014450 <__adddf3+0x7f0>
 1014224:	4811883a 	mov	r8,r9
 1014228:	3023883a 	mov	r17,r6
 101422c:	3825883a 	mov	r18,r7
 1014230:	003eaa06 	br	1013cdc <__alt_data_end+0xff813cdc>
 1014234:	1021883a 	mov	r16,r2
 1014238:	0011883a 	mov	r8,zero
 101423c:	0005883a 	mov	r2,zero
 1014240:	003f0f06 	br	1013e80 <__alt_data_end+0xff813e80>
 1014244:	217ff804 	addi	r5,r4,-32
 1014248:	00800804 	movi	r2,32
 101424c:	494ad83a 	srl	r5,r9,r5
 1014250:	20807d26 	beq	r4,r2,1014448 <__adddf3+0x7e8>
 1014254:	00801004 	movi	r2,64
 1014258:	1109c83a 	sub	r4,r2,r4
 101425c:	4912983a 	sll	r9,r9,r4
 1014260:	498cb03a 	or	r6,r9,r6
 1014264:	300cc03a 	cmpne	r6,r6,zero
 1014268:	298ab03a 	or	r5,r5,r6
 101426c:	0013883a 	mov	r9,zero
 1014270:	003f1506 	br	1013ec8 <__alt_data_end+0xff813ec8>
 1014274:	0101ffc4 	movi	r4,2047
 1014278:	113f9a1e 	bne	r2,r4,10140e4 <__alt_data_end+0xff8140e4>
 101427c:	4811883a 	mov	r8,r9
 1014280:	3023883a 	mov	r17,r6
 1014284:	1021883a 	mov	r16,r2
 1014288:	3825883a 	mov	r18,r7
 101428c:	003e9306 	br	1013cdc <__alt_data_end+0xff813cdc>
 1014290:	8000161e 	bne	r16,zero,10142ec <__adddf3+0x68c>
 1014294:	444ab03a 	or	r5,r8,r17
 1014298:	28005126 	beq	r5,zero,10143e0 <__adddf3+0x780>
 101429c:	0108303a 	nor	r4,zero,r4
 10142a0:	20004d1e 	bne	r4,zero,10143d8 <__adddf3+0x778>
 10142a4:	89a3883a 	add	r17,r17,r6
 10142a8:	4253883a 	add	r9,r8,r9
 10142ac:	898d803a 	cmpltu	r6,r17,r6
 10142b0:	3251883a 	add	r8,r6,r9
 10142b4:	1021883a 	mov	r16,r2
 10142b8:	003f0806 	br	1013edc <__alt_data_end+0xff813edc>
 10142bc:	1000301e 	bne	r2,zero,1014380 <__adddf3+0x720>
 10142c0:	4984b03a 	or	r2,r9,r6
 10142c4:	10007126 	beq	r2,zero,101448c <__adddf3+0x82c>
 10142c8:	4811883a 	mov	r8,r9
 10142cc:	3023883a 	mov	r17,r6
 10142d0:	3825883a 	mov	r18,r7
 10142d4:	0401ffc4 	movi	r16,2047
 10142d8:	003e8006 	br	1013cdc <__alt_data_end+0xff813cdc>
 10142dc:	4462b03a 	or	r17,r8,r17
 10142e0:	8822c03a 	cmpne	r17,r17,zero
 10142e4:	0007883a 	mov	r3,zero
 10142e8:	003f8b06 	br	1014118 <__alt_data_end+0xff814118>
 10142ec:	0141ffc4 	movi	r5,2047
 10142f0:	11403b26 	beq	r2,r5,10143e0 <__adddf3+0x780>
 10142f4:	0109c83a 	sub	r4,zero,r4
 10142f8:	42002034 	orhi	r8,r8,128
 10142fc:	01400e04 	movi	r5,56
 1014300:	29006716 	blt	r5,r4,10144a0 <__adddf3+0x840>
 1014304:	014007c4 	movi	r5,31
 1014308:	29007016 	blt	r5,r4,10144cc <__adddf3+0x86c>
 101430c:	01400804 	movi	r5,32
 1014310:	290bc83a 	sub	r5,r5,r4
 1014314:	4154983a 	sll	r10,r8,r5
 1014318:	890ed83a 	srl	r7,r17,r4
 101431c:	894a983a 	sll	r5,r17,r5
 1014320:	4108d83a 	srl	r4,r8,r4
 1014324:	51e2b03a 	or	r17,r10,r7
 1014328:	280ac03a 	cmpne	r5,r5,zero
 101432c:	8962b03a 	or	r17,r17,r5
 1014330:	89a3883a 	add	r17,r17,r6
 1014334:	2253883a 	add	r9,r4,r9
 1014338:	898d803a 	cmpltu	r6,r17,r6
 101433c:	3251883a 	add	r8,r6,r9
 1014340:	1021883a 	mov	r16,r2
 1014344:	003ee506 	br	1013edc <__alt_data_end+0xff813edc>
 1014348:	4984b03a 	or	r2,r9,r6
 101434c:	103e6326 	beq	r2,zero,1013cdc <__alt_data_end+0xff813cdc>
 1014350:	8987c83a 	sub	r3,r17,r6
 1014354:	88c9803a 	cmpltu	r4,r17,r3
 1014358:	4245c83a 	sub	r2,r8,r9
 101435c:	1105c83a 	sub	r2,r2,r4
 1014360:	1100202c 	andhi	r4,r2,128
 1014364:	203ebb26 	beq	r4,zero,1013e54 <__alt_data_end+0xff813e54>
 1014368:	3463c83a 	sub	r17,r6,r17
 101436c:	4a07c83a 	sub	r3,r9,r8
 1014370:	344d803a 	cmpltu	r6,r6,r17
 1014374:	1991c83a 	sub	r8,r3,r6
 1014378:	3825883a 	mov	r18,r7
 101437c:	003e5706 	br	1013cdc <__alt_data_end+0xff813cdc>
 1014380:	4984b03a 	or	r2,r9,r6
 1014384:	10002e26 	beq	r2,zero,1014440 <__adddf3+0x7e0>
 1014388:	4004d0fa 	srli	r2,r8,3
 101438c:	8822d0fa 	srli	r17,r17,3
 1014390:	4010977a 	slli	r8,r8,29
 1014394:	10c0022c 	andhi	r3,r2,8
 1014398:	4462b03a 	or	r17,r8,r17
 101439c:	18000826 	beq	r3,zero,10143c0 <__adddf3+0x760>
 10143a0:	4808d0fa 	srli	r4,r9,3
 10143a4:	20c0022c 	andhi	r3,r4,8
 10143a8:	1800051e 	bne	r3,zero,10143c0 <__adddf3+0x760>
 10143ac:	300cd0fa 	srli	r6,r6,3
 10143b0:	4806977a 	slli	r3,r9,29
 10143b4:	2005883a 	mov	r2,r4
 10143b8:	3825883a 	mov	r18,r7
 10143bc:	19a2b03a 	or	r17,r3,r6
 10143c0:	8810d77a 	srli	r8,r17,29
 10143c4:	100490fa 	slli	r2,r2,3
 10143c8:	882290fa 	slli	r17,r17,3
 10143cc:	0401ffc4 	movi	r16,2047
 10143d0:	4090b03a 	or	r8,r8,r2
 10143d4:	003e4106 	br	1013cdc <__alt_data_end+0xff813cdc>
 10143d8:	0141ffc4 	movi	r5,2047
 10143dc:	117fc71e 	bne	r2,r5,10142fc <__alt_data_end+0xff8142fc>
 10143e0:	4811883a 	mov	r8,r9
 10143e4:	3023883a 	mov	r17,r6
 10143e8:	1021883a 	mov	r16,r2
 10143ec:	003e3b06 	br	1013cdc <__alt_data_end+0xff813cdc>
 10143f0:	10002f26 	beq	r2,zero,10144b0 <__adddf3+0x850>
 10143f4:	4984b03a 	or	r2,r9,r6
 10143f8:	10001126 	beq	r2,zero,1014440 <__adddf3+0x7e0>
 10143fc:	4004d0fa 	srli	r2,r8,3
 1014400:	8822d0fa 	srli	r17,r17,3
 1014404:	4010977a 	slli	r8,r8,29
 1014408:	10c0022c 	andhi	r3,r2,8
 101440c:	4462b03a 	or	r17,r8,r17
 1014410:	183feb26 	beq	r3,zero,10143c0 <__alt_data_end+0xff8143c0>
 1014414:	4808d0fa 	srli	r4,r9,3
 1014418:	20c0022c 	andhi	r3,r4,8
 101441c:	183fe81e 	bne	r3,zero,10143c0 <__alt_data_end+0xff8143c0>
 1014420:	300cd0fa 	srli	r6,r6,3
 1014424:	4806977a 	slli	r3,r9,29
 1014428:	2005883a 	mov	r2,r4
 101442c:	19a2b03a 	or	r17,r3,r6
 1014430:	003fe306 	br	10143c0 <__alt_data_end+0xff8143c0>
 1014434:	0011883a 	mov	r8,zero
 1014438:	0005883a 	mov	r2,zero
 101443c:	003e3f06 	br	1013d3c <__alt_data_end+0xff813d3c>
 1014440:	0401ffc4 	movi	r16,2047
 1014444:	003e2506 	br	1013cdc <__alt_data_end+0xff813cdc>
 1014448:	0013883a 	mov	r9,zero
 101444c:	003f8406 	br	1014260 <__alt_data_end+0xff814260>
 1014450:	0005883a 	mov	r2,zero
 1014454:	0007883a 	mov	r3,zero
 1014458:	003e8906 	br	1013e80 <__alt_data_end+0xff813e80>
 101445c:	197ff804 	addi	r5,r3,-32
 1014460:	01000804 	movi	r4,32
 1014464:	414ad83a 	srl	r5,r8,r5
 1014468:	19002426 	beq	r3,r4,10144fc <__adddf3+0x89c>
 101446c:	01001004 	movi	r4,64
 1014470:	20c7c83a 	sub	r3,r4,r3
 1014474:	40c6983a 	sll	r3,r8,r3
 1014478:	1c46b03a 	or	r3,r3,r17
 101447c:	1806c03a 	cmpne	r3,r3,zero
 1014480:	28e2b03a 	or	r17,r5,r3
 1014484:	0007883a 	mov	r3,zero
 1014488:	003f2306 	br	1014118 <__alt_data_end+0xff814118>
 101448c:	0007883a 	mov	r3,zero
 1014490:	5811883a 	mov	r8,r11
 1014494:	00bfffc4 	movi	r2,-1
 1014498:	0401ffc4 	movi	r16,2047
 101449c:	003e7806 	br	1013e80 <__alt_data_end+0xff813e80>
 10144a0:	4462b03a 	or	r17,r8,r17
 10144a4:	8822c03a 	cmpne	r17,r17,zero
 10144a8:	0009883a 	mov	r4,zero
 10144ac:	003fa006 	br	1014330 <__alt_data_end+0xff814330>
 10144b0:	4811883a 	mov	r8,r9
 10144b4:	3023883a 	mov	r17,r6
 10144b8:	0401ffc4 	movi	r16,2047
 10144bc:	003e0706 	br	1013cdc <__alt_data_end+0xff813cdc>
 10144c0:	4811883a 	mov	r8,r9
 10144c4:	3023883a 	mov	r17,r6
 10144c8:	003e0406 	br	1013cdc <__alt_data_end+0xff813cdc>
 10144cc:	21fff804 	addi	r7,r4,-32
 10144d0:	01400804 	movi	r5,32
 10144d4:	41ced83a 	srl	r7,r8,r7
 10144d8:	21400a26 	beq	r4,r5,1014504 <__adddf3+0x8a4>
 10144dc:	01401004 	movi	r5,64
 10144e0:	2909c83a 	sub	r4,r5,r4
 10144e4:	4108983a 	sll	r4,r8,r4
 10144e8:	2448b03a 	or	r4,r4,r17
 10144ec:	2008c03a 	cmpne	r4,r4,zero
 10144f0:	3922b03a 	or	r17,r7,r4
 10144f4:	0009883a 	mov	r4,zero
 10144f8:	003f8d06 	br	1014330 <__alt_data_end+0xff814330>
 10144fc:	0007883a 	mov	r3,zero
 1014500:	003fdd06 	br	1014478 <__alt_data_end+0xff814478>
 1014504:	0009883a 	mov	r4,zero
 1014508:	003ff706 	br	10144e8 <__alt_data_end+0xff8144e8>

0101450c <__divdf3>:
 101450c:	defff204 	addi	sp,sp,-56
 1014510:	dd400915 	stw	r21,36(sp)
 1014514:	282ad53a 	srli	r21,r5,20
 1014518:	dd000815 	stw	r20,32(sp)
 101451c:	2828d7fa 	srli	r20,r5,31
 1014520:	dc000415 	stw	r16,16(sp)
 1014524:	04000434 	movhi	r16,16
 1014528:	df000c15 	stw	fp,48(sp)
 101452c:	843fffc4 	addi	r16,r16,-1
 1014530:	dfc00d15 	stw	ra,52(sp)
 1014534:	ddc00b15 	stw	r23,44(sp)
 1014538:	dd800a15 	stw	r22,40(sp)
 101453c:	dcc00715 	stw	r19,28(sp)
 1014540:	dc800615 	stw	r18,24(sp)
 1014544:	dc400515 	stw	r17,20(sp)
 1014548:	ad41ffcc 	andi	r21,r21,2047
 101454c:	2c20703a 	and	r16,r5,r16
 1014550:	a7003fcc 	andi	fp,r20,255
 1014554:	a8006126 	beq	r21,zero,10146dc <__divdf3+0x1d0>
 1014558:	0081ffc4 	movi	r2,2047
 101455c:	2025883a 	mov	r18,r4
 1014560:	a8803726 	beq	r21,r2,1014640 <__divdf3+0x134>
 1014564:	80800434 	orhi	r2,r16,16
 1014568:	100490fa 	slli	r2,r2,3
 101456c:	2020d77a 	srli	r16,r4,29
 1014570:	202490fa 	slli	r18,r4,3
 1014574:	ad7f0044 	addi	r21,r21,-1023
 1014578:	80a0b03a 	or	r16,r16,r2
 101457c:	0027883a 	mov	r19,zero
 1014580:	0013883a 	mov	r9,zero
 1014584:	3804d53a 	srli	r2,r7,20
 1014588:	382cd7fa 	srli	r22,r7,31
 101458c:	04400434 	movhi	r17,16
 1014590:	8c7fffc4 	addi	r17,r17,-1
 1014594:	1081ffcc 	andi	r2,r2,2047
 1014598:	3011883a 	mov	r8,r6
 101459c:	3c62703a 	and	r17,r7,r17
 10145a0:	b5c03fcc 	andi	r23,r22,255
 10145a4:	10006c26 	beq	r2,zero,1014758 <__divdf3+0x24c>
 10145a8:	00c1ffc4 	movi	r3,2047
 10145ac:	10c06426 	beq	r2,r3,1014740 <__divdf3+0x234>
 10145b0:	88c00434 	orhi	r3,r17,16
 10145b4:	180690fa 	slli	r3,r3,3
 10145b8:	3022d77a 	srli	r17,r6,29
 10145bc:	301090fa 	slli	r8,r6,3
 10145c0:	10bf0044 	addi	r2,r2,-1023
 10145c4:	88e2b03a 	or	r17,r17,r3
 10145c8:	000f883a 	mov	r7,zero
 10145cc:	a58cf03a 	xor	r6,r20,r22
 10145d0:	3cc8b03a 	or	r4,r7,r19
 10145d4:	a8abc83a 	sub	r21,r21,r2
 10145d8:	008003c4 	movi	r2,15
 10145dc:	3007883a 	mov	r3,r6
 10145e0:	34c03fcc 	andi	r19,r6,255
 10145e4:	11009036 	bltu	r2,r4,1014828 <__divdf3+0x31c>
 10145e8:	200890ba 	slli	r4,r4,2
 10145ec:	00804074 	movhi	r2,257
 10145f0:	10918004 	addi	r2,r2,17920
 10145f4:	2089883a 	add	r4,r4,r2
 10145f8:	20800017 	ldw	r2,0(r4)
 10145fc:	1000683a 	jmp	r2
 1014600:	01014828 	cmpgeui	r4,zero,1312
 1014604:	01014678 	rdprs	r4,zero,1305
 1014608:	01014818 	cmpnei	r4,zero,1312
 101460c:	0101466c 	andhi	r4,zero,1305
 1014610:	01014818 	cmpnei	r4,zero,1312
 1014614:	010147ec 	andhi	r4,zero,1311
 1014618:	01014818 	cmpnei	r4,zero,1312
 101461c:	0101466c 	andhi	r4,zero,1305
 1014620:	01014678 	rdprs	r4,zero,1305
 1014624:	01014678 	rdprs	r4,zero,1305
 1014628:	010147ec 	andhi	r4,zero,1311
 101462c:	0101466c 	andhi	r4,zero,1305
 1014630:	0101465c 	xori	r4,zero,1305
 1014634:	0101465c 	xori	r4,zero,1305
 1014638:	0101465c 	xori	r4,zero,1305
 101463c:	01014b0c 	andi	r4,zero,1324
 1014640:	2404b03a 	or	r2,r4,r16
 1014644:	1000661e 	bne	r2,zero,10147e0 <__divdf3+0x2d4>
 1014648:	04c00204 	movi	r19,8
 101464c:	0021883a 	mov	r16,zero
 1014650:	0025883a 	mov	r18,zero
 1014654:	02400084 	movi	r9,2
 1014658:	003fca06 	br	1014584 <__alt_data_end+0xff814584>
 101465c:	8023883a 	mov	r17,r16
 1014660:	9011883a 	mov	r8,r18
 1014664:	e02f883a 	mov	r23,fp
 1014668:	480f883a 	mov	r7,r9
 101466c:	00800084 	movi	r2,2
 1014670:	3881311e 	bne	r7,r2,1014b38 <__divdf3+0x62c>
 1014674:	b827883a 	mov	r19,r23
 1014678:	98c0004c 	andi	r3,r19,1
 101467c:	0081ffc4 	movi	r2,2047
 1014680:	000b883a 	mov	r5,zero
 1014684:	0025883a 	mov	r18,zero
 1014688:	1004953a 	slli	r2,r2,20
 101468c:	18c03fcc 	andi	r3,r3,255
 1014690:	04400434 	movhi	r17,16
 1014694:	8c7fffc4 	addi	r17,r17,-1
 1014698:	180697fa 	slli	r3,r3,31
 101469c:	2c4a703a 	and	r5,r5,r17
 10146a0:	288ab03a 	or	r5,r5,r2
 10146a4:	28c6b03a 	or	r3,r5,r3
 10146a8:	9005883a 	mov	r2,r18
 10146ac:	dfc00d17 	ldw	ra,52(sp)
 10146b0:	df000c17 	ldw	fp,48(sp)
 10146b4:	ddc00b17 	ldw	r23,44(sp)
 10146b8:	dd800a17 	ldw	r22,40(sp)
 10146bc:	dd400917 	ldw	r21,36(sp)
 10146c0:	dd000817 	ldw	r20,32(sp)
 10146c4:	dcc00717 	ldw	r19,28(sp)
 10146c8:	dc800617 	ldw	r18,24(sp)
 10146cc:	dc400517 	ldw	r17,20(sp)
 10146d0:	dc000417 	ldw	r16,16(sp)
 10146d4:	dec00e04 	addi	sp,sp,56
 10146d8:	f800283a 	ret
 10146dc:	2404b03a 	or	r2,r4,r16
 10146e0:	2027883a 	mov	r19,r4
 10146e4:	10003926 	beq	r2,zero,10147cc <__divdf3+0x2c0>
 10146e8:	80012e26 	beq	r16,zero,1014ba4 <__divdf3+0x698>
 10146ec:	8009883a 	mov	r4,r16
 10146f0:	d9800315 	stw	r6,12(sp)
 10146f4:	d9c00215 	stw	r7,8(sp)
 10146f8:	10099700 	call	1009970 <__clzsi2>
 10146fc:	d9800317 	ldw	r6,12(sp)
 1014700:	d9c00217 	ldw	r7,8(sp)
 1014704:	113ffd44 	addi	r4,r2,-11
 1014708:	00c00704 	movi	r3,28
 101470c:	19012116 	blt	r3,r4,1014b94 <__divdf3+0x688>
 1014710:	00c00744 	movi	r3,29
 1014714:	147ffe04 	addi	r17,r2,-8
 1014718:	1907c83a 	sub	r3,r3,r4
 101471c:	8460983a 	sll	r16,r16,r17
 1014720:	98c6d83a 	srl	r3,r19,r3
 1014724:	9c64983a 	sll	r18,r19,r17
 1014728:	1c20b03a 	or	r16,r3,r16
 101472c:	1080fcc4 	addi	r2,r2,1011
 1014730:	00abc83a 	sub	r21,zero,r2
 1014734:	0027883a 	mov	r19,zero
 1014738:	0013883a 	mov	r9,zero
 101473c:	003f9106 	br	1014584 <__alt_data_end+0xff814584>
 1014740:	3446b03a 	or	r3,r6,r17
 1014744:	18001f1e 	bne	r3,zero,10147c4 <__divdf3+0x2b8>
 1014748:	0023883a 	mov	r17,zero
 101474c:	0011883a 	mov	r8,zero
 1014750:	01c00084 	movi	r7,2
 1014754:	003f9d06 	br	10145cc <__alt_data_end+0xff8145cc>
 1014758:	3446b03a 	or	r3,r6,r17
 101475c:	18001526 	beq	r3,zero,10147b4 <__divdf3+0x2a8>
 1014760:	88011b26 	beq	r17,zero,1014bd0 <__divdf3+0x6c4>
 1014764:	8809883a 	mov	r4,r17
 1014768:	d9800315 	stw	r6,12(sp)
 101476c:	da400115 	stw	r9,4(sp)
 1014770:	10099700 	call	1009970 <__clzsi2>
 1014774:	d9800317 	ldw	r6,12(sp)
 1014778:	da400117 	ldw	r9,4(sp)
 101477c:	113ffd44 	addi	r4,r2,-11
 1014780:	00c00704 	movi	r3,28
 1014784:	19010e16 	blt	r3,r4,1014bc0 <__divdf3+0x6b4>
 1014788:	00c00744 	movi	r3,29
 101478c:	123ffe04 	addi	r8,r2,-8
 1014790:	1907c83a 	sub	r3,r3,r4
 1014794:	8a22983a 	sll	r17,r17,r8
 1014798:	30c6d83a 	srl	r3,r6,r3
 101479c:	3210983a 	sll	r8,r6,r8
 10147a0:	1c62b03a 	or	r17,r3,r17
 10147a4:	1080fcc4 	addi	r2,r2,1011
 10147a8:	0085c83a 	sub	r2,zero,r2
 10147ac:	000f883a 	mov	r7,zero
 10147b0:	003f8606 	br	10145cc <__alt_data_end+0xff8145cc>
 10147b4:	0023883a 	mov	r17,zero
 10147b8:	0011883a 	mov	r8,zero
 10147bc:	01c00044 	movi	r7,1
 10147c0:	003f8206 	br	10145cc <__alt_data_end+0xff8145cc>
 10147c4:	01c000c4 	movi	r7,3
 10147c8:	003f8006 	br	10145cc <__alt_data_end+0xff8145cc>
 10147cc:	04c00104 	movi	r19,4
 10147d0:	0021883a 	mov	r16,zero
 10147d4:	0025883a 	mov	r18,zero
 10147d8:	02400044 	movi	r9,1
 10147dc:	003f6906 	br	1014584 <__alt_data_end+0xff814584>
 10147e0:	04c00304 	movi	r19,12
 10147e4:	024000c4 	movi	r9,3
 10147e8:	003f6606 	br	1014584 <__alt_data_end+0xff814584>
 10147ec:	01400434 	movhi	r5,16
 10147f0:	0007883a 	mov	r3,zero
 10147f4:	297fffc4 	addi	r5,r5,-1
 10147f8:	04bfffc4 	movi	r18,-1
 10147fc:	0081ffc4 	movi	r2,2047
 1014800:	003fa106 	br	1014688 <__alt_data_end+0xff814688>
 1014804:	00c00044 	movi	r3,1
 1014808:	1887c83a 	sub	r3,r3,r2
 101480c:	01000e04 	movi	r4,56
 1014810:	20c1210e 	bge	r4,r3,1014c98 <__divdf3+0x78c>
 1014814:	98c0004c 	andi	r3,r19,1
 1014818:	0005883a 	mov	r2,zero
 101481c:	000b883a 	mov	r5,zero
 1014820:	0025883a 	mov	r18,zero
 1014824:	003f9806 	br	1014688 <__alt_data_end+0xff814688>
 1014828:	8c00fd36 	bltu	r17,r16,1014c20 <__divdf3+0x714>
 101482c:	8440fb26 	beq	r16,r17,1014c1c <__divdf3+0x710>
 1014830:	8007883a 	mov	r3,r16
 1014834:	ad7fffc4 	addi	r21,r21,-1
 1014838:	0021883a 	mov	r16,zero
 101483c:	4004d63a 	srli	r2,r8,24
 1014840:	8822923a 	slli	r17,r17,8
 1014844:	1809883a 	mov	r4,r3
 1014848:	402c923a 	slli	r22,r8,8
 101484c:	88b8b03a 	or	fp,r17,r2
 1014850:	e028d43a 	srli	r20,fp,16
 1014854:	d8c00015 	stw	r3,0(sp)
 1014858:	e5ffffcc 	andi	r23,fp,65535
 101485c:	a00b883a 	mov	r5,r20
 1014860:	10097a40 	call	10097a4 <__udivsi3>
 1014864:	d8c00017 	ldw	r3,0(sp)
 1014868:	a00b883a 	mov	r5,r20
 101486c:	d8800315 	stw	r2,12(sp)
 1014870:	1809883a 	mov	r4,r3
 1014874:	10098080 	call	1009808 <__umodsi3>
 1014878:	d9800317 	ldw	r6,12(sp)
 101487c:	1006943a 	slli	r3,r2,16
 1014880:	9004d43a 	srli	r2,r18,16
 1014884:	b9a3383a 	mul	r17,r23,r6
 1014888:	10c4b03a 	or	r2,r2,r3
 101488c:	1440062e 	bgeu	r2,r17,10148a8 <__divdf3+0x39c>
 1014890:	1705883a 	add	r2,r2,fp
 1014894:	30ffffc4 	addi	r3,r6,-1
 1014898:	1700ee36 	bltu	r2,fp,1014c54 <__divdf3+0x748>
 101489c:	1440ed2e 	bgeu	r2,r17,1014c54 <__divdf3+0x748>
 10148a0:	31bfff84 	addi	r6,r6,-2
 10148a4:	1705883a 	add	r2,r2,fp
 10148a8:	1463c83a 	sub	r17,r2,r17
 10148ac:	a00b883a 	mov	r5,r20
 10148b0:	8809883a 	mov	r4,r17
 10148b4:	d9800315 	stw	r6,12(sp)
 10148b8:	10097a40 	call	10097a4 <__udivsi3>
 10148bc:	a00b883a 	mov	r5,r20
 10148c0:	8809883a 	mov	r4,r17
 10148c4:	d8800215 	stw	r2,8(sp)
 10148c8:	10098080 	call	1009808 <__umodsi3>
 10148cc:	d9c00217 	ldw	r7,8(sp)
 10148d0:	1004943a 	slli	r2,r2,16
 10148d4:	94bfffcc 	andi	r18,r18,65535
 10148d8:	b9d1383a 	mul	r8,r23,r7
 10148dc:	90a4b03a 	or	r18,r18,r2
 10148e0:	d9800317 	ldw	r6,12(sp)
 10148e4:	9200062e 	bgeu	r18,r8,1014900 <__divdf3+0x3f4>
 10148e8:	9725883a 	add	r18,r18,fp
 10148ec:	38bfffc4 	addi	r2,r7,-1
 10148f0:	9700d636 	bltu	r18,fp,1014c4c <__divdf3+0x740>
 10148f4:	9200d52e 	bgeu	r18,r8,1014c4c <__divdf3+0x740>
 10148f8:	39ffff84 	addi	r7,r7,-2
 10148fc:	9725883a 	add	r18,r18,fp
 1014900:	3004943a 	slli	r2,r6,16
 1014904:	b012d43a 	srli	r9,r22,16
 1014908:	b1bfffcc 	andi	r6,r22,65535
 101490c:	11e2b03a 	or	r17,r2,r7
 1014910:	8806d43a 	srli	r3,r17,16
 1014914:	893fffcc 	andi	r4,r17,65535
 1014918:	218b383a 	mul	r5,r4,r6
 101491c:	30c5383a 	mul	r2,r6,r3
 1014920:	2249383a 	mul	r4,r4,r9
 1014924:	280ed43a 	srli	r7,r5,16
 1014928:	9225c83a 	sub	r18,r18,r8
 101492c:	2089883a 	add	r4,r4,r2
 1014930:	3909883a 	add	r4,r7,r4
 1014934:	1a47383a 	mul	r3,r3,r9
 1014938:	2080022e 	bgeu	r4,r2,1014944 <__divdf3+0x438>
 101493c:	00800074 	movhi	r2,1
 1014940:	1887883a 	add	r3,r3,r2
 1014944:	2004d43a 	srli	r2,r4,16
 1014948:	2008943a 	slli	r4,r4,16
 101494c:	297fffcc 	andi	r5,r5,65535
 1014950:	10c7883a 	add	r3,r2,r3
 1014954:	2149883a 	add	r4,r4,r5
 1014958:	90c0a536 	bltu	r18,r3,1014bf0 <__divdf3+0x6e4>
 101495c:	90c0bf26 	beq	r18,r3,1014c5c <__divdf3+0x750>
 1014960:	90c7c83a 	sub	r3,r18,r3
 1014964:	810fc83a 	sub	r7,r16,r4
 1014968:	81e5803a 	cmpltu	r18,r16,r7
 101496c:	1ca5c83a 	sub	r18,r3,r18
 1014970:	e480c126 	beq	fp,r18,1014c78 <__divdf3+0x76c>
 1014974:	a00b883a 	mov	r5,r20
 1014978:	9009883a 	mov	r4,r18
 101497c:	d9800315 	stw	r6,12(sp)
 1014980:	d9c00215 	stw	r7,8(sp)
 1014984:	da400115 	stw	r9,4(sp)
 1014988:	10097a40 	call	10097a4 <__udivsi3>
 101498c:	a00b883a 	mov	r5,r20
 1014990:	9009883a 	mov	r4,r18
 1014994:	d8800015 	stw	r2,0(sp)
 1014998:	10098080 	call	1009808 <__umodsi3>
 101499c:	d9c00217 	ldw	r7,8(sp)
 10149a0:	da000017 	ldw	r8,0(sp)
 10149a4:	1006943a 	slli	r3,r2,16
 10149a8:	3804d43a 	srli	r2,r7,16
 10149ac:	ba21383a 	mul	r16,r23,r8
 10149b0:	d9800317 	ldw	r6,12(sp)
 10149b4:	10c4b03a 	or	r2,r2,r3
 10149b8:	da400117 	ldw	r9,4(sp)
 10149bc:	1400062e 	bgeu	r2,r16,10149d8 <__divdf3+0x4cc>
 10149c0:	1705883a 	add	r2,r2,fp
 10149c4:	40ffffc4 	addi	r3,r8,-1
 10149c8:	1700ad36 	bltu	r2,fp,1014c80 <__divdf3+0x774>
 10149cc:	1400ac2e 	bgeu	r2,r16,1014c80 <__divdf3+0x774>
 10149d0:	423fff84 	addi	r8,r8,-2
 10149d4:	1705883a 	add	r2,r2,fp
 10149d8:	1421c83a 	sub	r16,r2,r16
 10149dc:	a00b883a 	mov	r5,r20
 10149e0:	8009883a 	mov	r4,r16
 10149e4:	d9800315 	stw	r6,12(sp)
 10149e8:	d9c00215 	stw	r7,8(sp)
 10149ec:	da000015 	stw	r8,0(sp)
 10149f0:	da400115 	stw	r9,4(sp)
 10149f4:	10097a40 	call	10097a4 <__udivsi3>
 10149f8:	8009883a 	mov	r4,r16
 10149fc:	a00b883a 	mov	r5,r20
 1014a00:	1025883a 	mov	r18,r2
 1014a04:	10098080 	call	1009808 <__umodsi3>
 1014a08:	d9c00217 	ldw	r7,8(sp)
 1014a0c:	1004943a 	slli	r2,r2,16
 1014a10:	bcaf383a 	mul	r23,r23,r18
 1014a14:	393fffcc 	andi	r4,r7,65535
 1014a18:	2088b03a 	or	r4,r4,r2
 1014a1c:	d9800317 	ldw	r6,12(sp)
 1014a20:	da000017 	ldw	r8,0(sp)
 1014a24:	da400117 	ldw	r9,4(sp)
 1014a28:	25c0062e 	bgeu	r4,r23,1014a44 <__divdf3+0x538>
 1014a2c:	2709883a 	add	r4,r4,fp
 1014a30:	90bfffc4 	addi	r2,r18,-1
 1014a34:	27009436 	bltu	r4,fp,1014c88 <__divdf3+0x77c>
 1014a38:	25c0932e 	bgeu	r4,r23,1014c88 <__divdf3+0x77c>
 1014a3c:	94bfff84 	addi	r18,r18,-2
 1014a40:	2709883a 	add	r4,r4,fp
 1014a44:	4004943a 	slli	r2,r8,16
 1014a48:	25efc83a 	sub	r23,r4,r23
 1014a4c:	1490b03a 	or	r8,r2,r18
 1014a50:	4008d43a 	srli	r4,r8,16
 1014a54:	40ffffcc 	andi	r3,r8,65535
 1014a58:	30c5383a 	mul	r2,r6,r3
 1014a5c:	1a47383a 	mul	r3,r3,r9
 1014a60:	310d383a 	mul	r6,r6,r4
 1014a64:	100ad43a 	srli	r5,r2,16
 1014a68:	4913383a 	mul	r9,r9,r4
 1014a6c:	1987883a 	add	r3,r3,r6
 1014a70:	28c7883a 	add	r3,r5,r3
 1014a74:	1980022e 	bgeu	r3,r6,1014a80 <__divdf3+0x574>
 1014a78:	01000074 	movhi	r4,1
 1014a7c:	4913883a 	add	r9,r9,r4
 1014a80:	1808d43a 	srli	r4,r3,16
 1014a84:	1806943a 	slli	r3,r3,16
 1014a88:	10bfffcc 	andi	r2,r2,65535
 1014a8c:	2253883a 	add	r9,r4,r9
 1014a90:	1887883a 	add	r3,r3,r2
 1014a94:	ba403836 	bltu	r23,r9,1014b78 <__divdf3+0x66c>
 1014a98:	ba403626 	beq	r23,r9,1014b74 <__divdf3+0x668>
 1014a9c:	42000054 	ori	r8,r8,1
 1014aa0:	a880ffc4 	addi	r2,r21,1023
 1014aa4:	00bf570e 	bge	zero,r2,1014804 <__alt_data_end+0xff814804>
 1014aa8:	40c001cc 	andi	r3,r8,7
 1014aac:	18000726 	beq	r3,zero,1014acc <__divdf3+0x5c0>
 1014ab0:	40c003cc 	andi	r3,r8,15
 1014ab4:	01000104 	movi	r4,4
 1014ab8:	19000426 	beq	r3,r4,1014acc <__divdf3+0x5c0>
 1014abc:	4107883a 	add	r3,r8,r4
 1014ac0:	1a11803a 	cmpltu	r8,r3,r8
 1014ac4:	8a23883a 	add	r17,r17,r8
 1014ac8:	1811883a 	mov	r8,r3
 1014acc:	88c0402c 	andhi	r3,r17,256
 1014ad0:	18000426 	beq	r3,zero,1014ae4 <__divdf3+0x5d8>
 1014ad4:	00ffc034 	movhi	r3,65280
 1014ad8:	18ffffc4 	addi	r3,r3,-1
 1014adc:	a8810004 	addi	r2,r21,1024
 1014ae0:	88e2703a 	and	r17,r17,r3
 1014ae4:	00c1ff84 	movi	r3,2046
 1014ae8:	18bee316 	blt	r3,r2,1014678 <__alt_data_end+0xff814678>
 1014aec:	8824977a 	slli	r18,r17,29
 1014af0:	4010d0fa 	srli	r8,r8,3
 1014af4:	8822927a 	slli	r17,r17,9
 1014af8:	1081ffcc 	andi	r2,r2,2047
 1014afc:	9224b03a 	or	r18,r18,r8
 1014b00:	880ad33a 	srli	r5,r17,12
 1014b04:	98c0004c 	andi	r3,r19,1
 1014b08:	003edf06 	br	1014688 <__alt_data_end+0xff814688>
 1014b0c:	8080022c 	andhi	r2,r16,8
 1014b10:	10001226 	beq	r2,zero,1014b5c <__divdf3+0x650>
 1014b14:	8880022c 	andhi	r2,r17,8
 1014b18:	1000101e 	bne	r2,zero,1014b5c <__divdf3+0x650>
 1014b1c:	00800434 	movhi	r2,16
 1014b20:	89400234 	orhi	r5,r17,8
 1014b24:	10bfffc4 	addi	r2,r2,-1
 1014b28:	b007883a 	mov	r3,r22
 1014b2c:	288a703a 	and	r5,r5,r2
 1014b30:	4025883a 	mov	r18,r8
 1014b34:	003f3106 	br	10147fc <__alt_data_end+0xff8147fc>
 1014b38:	008000c4 	movi	r2,3
 1014b3c:	3880a626 	beq	r7,r2,1014dd8 <__divdf3+0x8cc>
 1014b40:	00800044 	movi	r2,1
 1014b44:	3880521e 	bne	r7,r2,1014c90 <__divdf3+0x784>
 1014b48:	b807883a 	mov	r3,r23
 1014b4c:	0005883a 	mov	r2,zero
 1014b50:	000b883a 	mov	r5,zero
 1014b54:	0025883a 	mov	r18,zero
 1014b58:	003ecb06 	br	1014688 <__alt_data_end+0xff814688>
 1014b5c:	00800434 	movhi	r2,16
 1014b60:	81400234 	orhi	r5,r16,8
 1014b64:	10bfffc4 	addi	r2,r2,-1
 1014b68:	a007883a 	mov	r3,r20
 1014b6c:	288a703a 	and	r5,r5,r2
 1014b70:	003f2206 	br	10147fc <__alt_data_end+0xff8147fc>
 1014b74:	183fca26 	beq	r3,zero,1014aa0 <__alt_data_end+0xff814aa0>
 1014b78:	e5ef883a 	add	r23,fp,r23
 1014b7c:	40bfffc4 	addi	r2,r8,-1
 1014b80:	bf00392e 	bgeu	r23,fp,1014c68 <__divdf3+0x75c>
 1014b84:	1011883a 	mov	r8,r2
 1014b88:	ba7fc41e 	bne	r23,r9,1014a9c <__alt_data_end+0xff814a9c>
 1014b8c:	b0ffc31e 	bne	r22,r3,1014a9c <__alt_data_end+0xff814a9c>
 1014b90:	003fc306 	br	1014aa0 <__alt_data_end+0xff814aa0>
 1014b94:	143ff604 	addi	r16,r2,-40
 1014b98:	9c20983a 	sll	r16,r19,r16
 1014b9c:	0025883a 	mov	r18,zero
 1014ba0:	003ee206 	br	101472c <__alt_data_end+0xff81472c>
 1014ba4:	d9800315 	stw	r6,12(sp)
 1014ba8:	d9c00215 	stw	r7,8(sp)
 1014bac:	10099700 	call	1009970 <__clzsi2>
 1014bb0:	10800804 	addi	r2,r2,32
 1014bb4:	d9c00217 	ldw	r7,8(sp)
 1014bb8:	d9800317 	ldw	r6,12(sp)
 1014bbc:	003ed106 	br	1014704 <__alt_data_end+0xff814704>
 1014bc0:	147ff604 	addi	r17,r2,-40
 1014bc4:	3462983a 	sll	r17,r6,r17
 1014bc8:	0011883a 	mov	r8,zero
 1014bcc:	003ef506 	br	10147a4 <__alt_data_end+0xff8147a4>
 1014bd0:	3009883a 	mov	r4,r6
 1014bd4:	d9800315 	stw	r6,12(sp)
 1014bd8:	da400115 	stw	r9,4(sp)
 1014bdc:	10099700 	call	1009970 <__clzsi2>
 1014be0:	10800804 	addi	r2,r2,32
 1014be4:	da400117 	ldw	r9,4(sp)
 1014be8:	d9800317 	ldw	r6,12(sp)
 1014bec:	003ee306 	br	101477c <__alt_data_end+0xff81477c>
 1014bf0:	85a1883a 	add	r16,r16,r22
 1014bf4:	8585803a 	cmpltu	r2,r16,r22
 1014bf8:	1705883a 	add	r2,r2,fp
 1014bfc:	14a5883a 	add	r18,r2,r18
 1014c00:	88bfffc4 	addi	r2,r17,-1
 1014c04:	e4800c2e 	bgeu	fp,r18,1014c38 <__divdf3+0x72c>
 1014c08:	90c03e36 	bltu	r18,r3,1014d04 <__divdf3+0x7f8>
 1014c0c:	1c806926 	beq	r3,r18,1014db4 <__divdf3+0x8a8>
 1014c10:	90c7c83a 	sub	r3,r18,r3
 1014c14:	1023883a 	mov	r17,r2
 1014c18:	003f5206 	br	1014964 <__alt_data_end+0xff814964>
 1014c1c:	923f0436 	bltu	r18,r8,1014830 <__alt_data_end+0xff814830>
 1014c20:	800897fa 	slli	r4,r16,31
 1014c24:	9004d07a 	srli	r2,r18,1
 1014c28:	8006d07a 	srli	r3,r16,1
 1014c2c:	902097fa 	slli	r16,r18,31
 1014c30:	20a4b03a 	or	r18,r4,r2
 1014c34:	003f0106 	br	101483c <__alt_data_end+0xff81483c>
 1014c38:	e4bff51e 	bne	fp,r18,1014c10 <__alt_data_end+0xff814c10>
 1014c3c:	85bff22e 	bgeu	r16,r22,1014c08 <__alt_data_end+0xff814c08>
 1014c40:	e0c7c83a 	sub	r3,fp,r3
 1014c44:	1023883a 	mov	r17,r2
 1014c48:	003f4606 	br	1014964 <__alt_data_end+0xff814964>
 1014c4c:	100f883a 	mov	r7,r2
 1014c50:	003f2b06 	br	1014900 <__alt_data_end+0xff814900>
 1014c54:	180d883a 	mov	r6,r3
 1014c58:	003f1306 	br	10148a8 <__alt_data_end+0xff8148a8>
 1014c5c:	813fe436 	bltu	r16,r4,1014bf0 <__alt_data_end+0xff814bf0>
 1014c60:	0007883a 	mov	r3,zero
 1014c64:	003f3f06 	br	1014964 <__alt_data_end+0xff814964>
 1014c68:	ba402c36 	bltu	r23,r9,1014d1c <__divdf3+0x810>
 1014c6c:	4dc05426 	beq	r9,r23,1014dc0 <__divdf3+0x8b4>
 1014c70:	1011883a 	mov	r8,r2
 1014c74:	003f8906 	br	1014a9c <__alt_data_end+0xff814a9c>
 1014c78:	023fffc4 	movi	r8,-1
 1014c7c:	003f8806 	br	1014aa0 <__alt_data_end+0xff814aa0>
 1014c80:	1811883a 	mov	r8,r3
 1014c84:	003f5406 	br	10149d8 <__alt_data_end+0xff8149d8>
 1014c88:	1025883a 	mov	r18,r2
 1014c8c:	003f6d06 	br	1014a44 <__alt_data_end+0xff814a44>
 1014c90:	b827883a 	mov	r19,r23
 1014c94:	003f8206 	br	1014aa0 <__alt_data_end+0xff814aa0>
 1014c98:	010007c4 	movi	r4,31
 1014c9c:	20c02616 	blt	r4,r3,1014d38 <__divdf3+0x82c>
 1014ca0:	00800804 	movi	r2,32
 1014ca4:	10c5c83a 	sub	r2,r2,r3
 1014ca8:	888a983a 	sll	r5,r17,r2
 1014cac:	40c8d83a 	srl	r4,r8,r3
 1014cb0:	4084983a 	sll	r2,r8,r2
 1014cb4:	88e2d83a 	srl	r17,r17,r3
 1014cb8:	2906b03a 	or	r3,r5,r4
 1014cbc:	1004c03a 	cmpne	r2,r2,zero
 1014cc0:	1886b03a 	or	r3,r3,r2
 1014cc4:	188001cc 	andi	r2,r3,7
 1014cc8:	10000726 	beq	r2,zero,1014ce8 <__divdf3+0x7dc>
 1014ccc:	188003cc 	andi	r2,r3,15
 1014cd0:	01000104 	movi	r4,4
 1014cd4:	11000426 	beq	r2,r4,1014ce8 <__divdf3+0x7dc>
 1014cd8:	1805883a 	mov	r2,r3
 1014cdc:	10c00104 	addi	r3,r2,4
 1014ce0:	1885803a 	cmpltu	r2,r3,r2
 1014ce4:	88a3883a 	add	r17,r17,r2
 1014ce8:	8880202c 	andhi	r2,r17,128
 1014cec:	10002726 	beq	r2,zero,1014d8c <__divdf3+0x880>
 1014cf0:	98c0004c 	andi	r3,r19,1
 1014cf4:	00800044 	movi	r2,1
 1014cf8:	000b883a 	mov	r5,zero
 1014cfc:	0025883a 	mov	r18,zero
 1014d00:	003e6106 	br	1014688 <__alt_data_end+0xff814688>
 1014d04:	85a1883a 	add	r16,r16,r22
 1014d08:	8585803a 	cmpltu	r2,r16,r22
 1014d0c:	1705883a 	add	r2,r2,fp
 1014d10:	14a5883a 	add	r18,r2,r18
 1014d14:	8c7fff84 	addi	r17,r17,-2
 1014d18:	003f1106 	br	1014960 <__alt_data_end+0xff814960>
 1014d1c:	b589883a 	add	r4,r22,r22
 1014d20:	25ad803a 	cmpltu	r22,r4,r22
 1014d24:	b739883a 	add	fp,r22,fp
 1014d28:	40bfff84 	addi	r2,r8,-2
 1014d2c:	bf2f883a 	add	r23,r23,fp
 1014d30:	202d883a 	mov	r22,r4
 1014d34:	003f9306 	br	1014b84 <__alt_data_end+0xff814b84>
 1014d38:	013ff844 	movi	r4,-31
 1014d3c:	2085c83a 	sub	r2,r4,r2
 1014d40:	8888d83a 	srl	r4,r17,r2
 1014d44:	00800804 	movi	r2,32
 1014d48:	18802126 	beq	r3,r2,1014dd0 <__divdf3+0x8c4>
 1014d4c:	00801004 	movi	r2,64
 1014d50:	10c5c83a 	sub	r2,r2,r3
 1014d54:	8884983a 	sll	r2,r17,r2
 1014d58:	1204b03a 	or	r2,r2,r8
 1014d5c:	1004c03a 	cmpne	r2,r2,zero
 1014d60:	2084b03a 	or	r2,r4,r2
 1014d64:	144001cc 	andi	r17,r2,7
 1014d68:	88000d1e 	bne	r17,zero,1014da0 <__divdf3+0x894>
 1014d6c:	000b883a 	mov	r5,zero
 1014d70:	1024d0fa 	srli	r18,r2,3
 1014d74:	98c0004c 	andi	r3,r19,1
 1014d78:	0005883a 	mov	r2,zero
 1014d7c:	9464b03a 	or	r18,r18,r17
 1014d80:	003e4106 	br	1014688 <__alt_data_end+0xff814688>
 1014d84:	1007883a 	mov	r3,r2
 1014d88:	0023883a 	mov	r17,zero
 1014d8c:	880a927a 	slli	r5,r17,9
 1014d90:	1805883a 	mov	r2,r3
 1014d94:	8822977a 	slli	r17,r17,29
 1014d98:	280ad33a 	srli	r5,r5,12
 1014d9c:	003ff406 	br	1014d70 <__alt_data_end+0xff814d70>
 1014da0:	10c003cc 	andi	r3,r2,15
 1014da4:	01000104 	movi	r4,4
 1014da8:	193ff626 	beq	r3,r4,1014d84 <__alt_data_end+0xff814d84>
 1014dac:	0023883a 	mov	r17,zero
 1014db0:	003fca06 	br	1014cdc <__alt_data_end+0xff814cdc>
 1014db4:	813fd336 	bltu	r16,r4,1014d04 <__alt_data_end+0xff814d04>
 1014db8:	1023883a 	mov	r17,r2
 1014dbc:	003fa806 	br	1014c60 <__alt_data_end+0xff814c60>
 1014dc0:	b0ffd636 	bltu	r22,r3,1014d1c <__alt_data_end+0xff814d1c>
 1014dc4:	1011883a 	mov	r8,r2
 1014dc8:	b0ff341e 	bne	r22,r3,1014a9c <__alt_data_end+0xff814a9c>
 1014dcc:	003f3406 	br	1014aa0 <__alt_data_end+0xff814aa0>
 1014dd0:	0005883a 	mov	r2,zero
 1014dd4:	003fe006 	br	1014d58 <__alt_data_end+0xff814d58>
 1014dd8:	00800434 	movhi	r2,16
 1014ddc:	89400234 	orhi	r5,r17,8
 1014de0:	10bfffc4 	addi	r2,r2,-1
 1014de4:	b807883a 	mov	r3,r23
 1014de8:	288a703a 	and	r5,r5,r2
 1014dec:	4025883a 	mov	r18,r8
 1014df0:	003e8206 	br	10147fc <__alt_data_end+0xff8147fc>

01014df4 <__eqdf2>:
 1014df4:	2804d53a 	srli	r2,r5,20
 1014df8:	3806d53a 	srli	r3,r7,20
 1014dfc:	02000434 	movhi	r8,16
 1014e00:	423fffc4 	addi	r8,r8,-1
 1014e04:	1081ffcc 	andi	r2,r2,2047
 1014e08:	0281ffc4 	movi	r10,2047
 1014e0c:	2a12703a 	and	r9,r5,r8
 1014e10:	18c1ffcc 	andi	r3,r3,2047
 1014e14:	3a10703a 	and	r8,r7,r8
 1014e18:	280ad7fa 	srli	r5,r5,31
 1014e1c:	380ed7fa 	srli	r7,r7,31
 1014e20:	12801026 	beq	r2,r10,1014e64 <__eqdf2+0x70>
 1014e24:	0281ffc4 	movi	r10,2047
 1014e28:	1a800a26 	beq	r3,r10,1014e54 <__eqdf2+0x60>
 1014e2c:	10c00226 	beq	r2,r3,1014e38 <__eqdf2+0x44>
 1014e30:	00800044 	movi	r2,1
 1014e34:	f800283a 	ret
 1014e38:	4a3ffd1e 	bne	r9,r8,1014e30 <__alt_data_end+0xff814e30>
 1014e3c:	21bffc1e 	bne	r4,r6,1014e30 <__alt_data_end+0xff814e30>
 1014e40:	29c00c26 	beq	r5,r7,1014e74 <__eqdf2+0x80>
 1014e44:	103ffa1e 	bne	r2,zero,1014e30 <__alt_data_end+0xff814e30>
 1014e48:	2244b03a 	or	r2,r4,r9
 1014e4c:	1004c03a 	cmpne	r2,r2,zero
 1014e50:	f800283a 	ret
 1014e54:	3214b03a 	or	r10,r6,r8
 1014e58:	503ff426 	beq	r10,zero,1014e2c <__alt_data_end+0xff814e2c>
 1014e5c:	00800044 	movi	r2,1
 1014e60:	f800283a 	ret
 1014e64:	2254b03a 	or	r10,r4,r9
 1014e68:	503fee26 	beq	r10,zero,1014e24 <__alt_data_end+0xff814e24>
 1014e6c:	00800044 	movi	r2,1
 1014e70:	f800283a 	ret
 1014e74:	0005883a 	mov	r2,zero
 1014e78:	f800283a 	ret

01014e7c <__gedf2>:
 1014e7c:	2804d53a 	srli	r2,r5,20
 1014e80:	3806d53a 	srli	r3,r7,20
 1014e84:	02000434 	movhi	r8,16
 1014e88:	423fffc4 	addi	r8,r8,-1
 1014e8c:	1081ffcc 	andi	r2,r2,2047
 1014e90:	0241ffc4 	movi	r9,2047
 1014e94:	2a14703a 	and	r10,r5,r8
 1014e98:	18c1ffcc 	andi	r3,r3,2047
 1014e9c:	3a10703a 	and	r8,r7,r8
 1014ea0:	280ad7fa 	srli	r5,r5,31
 1014ea4:	380ed7fa 	srli	r7,r7,31
 1014ea8:	12401d26 	beq	r2,r9,1014f20 <__gedf2+0xa4>
 1014eac:	0241ffc4 	movi	r9,2047
 1014eb0:	1a401226 	beq	r3,r9,1014efc <__gedf2+0x80>
 1014eb4:	1000081e 	bne	r2,zero,1014ed8 <__gedf2+0x5c>
 1014eb8:	2296b03a 	or	r11,r4,r10
 1014ebc:	5813003a 	cmpeq	r9,r11,zero
 1014ec0:	1800091e 	bne	r3,zero,1014ee8 <__gedf2+0x6c>
 1014ec4:	3218b03a 	or	r12,r6,r8
 1014ec8:	6000071e 	bne	r12,zero,1014ee8 <__gedf2+0x6c>
 1014ecc:	0005883a 	mov	r2,zero
 1014ed0:	5800101e 	bne	r11,zero,1014f14 <__gedf2+0x98>
 1014ed4:	f800283a 	ret
 1014ed8:	18000c1e 	bne	r3,zero,1014f0c <__gedf2+0x90>
 1014edc:	3212b03a 	or	r9,r6,r8
 1014ee0:	48000c26 	beq	r9,zero,1014f14 <__gedf2+0x98>
 1014ee4:	0013883a 	mov	r9,zero
 1014ee8:	39c03fcc 	andi	r7,r7,255
 1014eec:	48000826 	beq	r9,zero,1014f10 <__gedf2+0x94>
 1014ef0:	38000926 	beq	r7,zero,1014f18 <__gedf2+0x9c>
 1014ef4:	00800044 	movi	r2,1
 1014ef8:	f800283a 	ret
 1014efc:	3212b03a 	or	r9,r6,r8
 1014f00:	483fec26 	beq	r9,zero,1014eb4 <__alt_data_end+0xff814eb4>
 1014f04:	00bfff84 	movi	r2,-2
 1014f08:	f800283a 	ret
 1014f0c:	39c03fcc 	andi	r7,r7,255
 1014f10:	29c00626 	beq	r5,r7,1014f2c <__gedf2+0xb0>
 1014f14:	283ff726 	beq	r5,zero,1014ef4 <__alt_data_end+0xff814ef4>
 1014f18:	00bfffc4 	movi	r2,-1
 1014f1c:	f800283a 	ret
 1014f20:	2292b03a 	or	r9,r4,r10
 1014f24:	483fe126 	beq	r9,zero,1014eac <__alt_data_end+0xff814eac>
 1014f28:	003ff606 	br	1014f04 <__alt_data_end+0xff814f04>
 1014f2c:	18bff916 	blt	r3,r2,1014f14 <__alt_data_end+0xff814f14>
 1014f30:	10c00316 	blt	r2,r3,1014f40 <__gedf2+0xc4>
 1014f34:	42bff736 	bltu	r8,r10,1014f14 <__alt_data_end+0xff814f14>
 1014f38:	52000326 	beq	r10,r8,1014f48 <__gedf2+0xcc>
 1014f3c:	5200042e 	bgeu	r10,r8,1014f50 <__gedf2+0xd4>
 1014f40:	283fec1e 	bne	r5,zero,1014ef4 <__alt_data_end+0xff814ef4>
 1014f44:	003ff406 	br	1014f18 <__alt_data_end+0xff814f18>
 1014f48:	313ff236 	bltu	r6,r4,1014f14 <__alt_data_end+0xff814f14>
 1014f4c:	21bffc36 	bltu	r4,r6,1014f40 <__alt_data_end+0xff814f40>
 1014f50:	0005883a 	mov	r2,zero
 1014f54:	f800283a 	ret

01014f58 <__ledf2>:
 1014f58:	2804d53a 	srli	r2,r5,20
 1014f5c:	3810d53a 	srli	r8,r7,20
 1014f60:	00c00434 	movhi	r3,16
 1014f64:	18ffffc4 	addi	r3,r3,-1
 1014f68:	1081ffcc 	andi	r2,r2,2047
 1014f6c:	0241ffc4 	movi	r9,2047
 1014f70:	28d4703a 	and	r10,r5,r3
 1014f74:	4201ffcc 	andi	r8,r8,2047
 1014f78:	38c6703a 	and	r3,r7,r3
 1014f7c:	280ad7fa 	srli	r5,r5,31
 1014f80:	380ed7fa 	srli	r7,r7,31
 1014f84:	12401f26 	beq	r2,r9,1015004 <__ledf2+0xac>
 1014f88:	0241ffc4 	movi	r9,2047
 1014f8c:	42401426 	beq	r8,r9,1014fe0 <__ledf2+0x88>
 1014f90:	1000091e 	bne	r2,zero,1014fb8 <__ledf2+0x60>
 1014f94:	2296b03a 	or	r11,r4,r10
 1014f98:	5813003a 	cmpeq	r9,r11,zero
 1014f9c:	29403fcc 	andi	r5,r5,255
 1014fa0:	40000a1e 	bne	r8,zero,1014fcc <__ledf2+0x74>
 1014fa4:	30d8b03a 	or	r12,r6,r3
 1014fa8:	6000081e 	bne	r12,zero,1014fcc <__ledf2+0x74>
 1014fac:	0005883a 	mov	r2,zero
 1014fb0:	5800111e 	bne	r11,zero,1014ff8 <__ledf2+0xa0>
 1014fb4:	f800283a 	ret
 1014fb8:	29403fcc 	andi	r5,r5,255
 1014fbc:	40000c1e 	bne	r8,zero,1014ff0 <__ledf2+0x98>
 1014fc0:	30d2b03a 	or	r9,r6,r3
 1014fc4:	48000c26 	beq	r9,zero,1014ff8 <__ledf2+0xa0>
 1014fc8:	0013883a 	mov	r9,zero
 1014fcc:	39c03fcc 	andi	r7,r7,255
 1014fd0:	48000826 	beq	r9,zero,1014ff4 <__ledf2+0x9c>
 1014fd4:	38001126 	beq	r7,zero,101501c <__ledf2+0xc4>
 1014fd8:	00800044 	movi	r2,1
 1014fdc:	f800283a 	ret
 1014fe0:	30d2b03a 	or	r9,r6,r3
 1014fe4:	483fea26 	beq	r9,zero,1014f90 <__alt_data_end+0xff814f90>
 1014fe8:	00800084 	movi	r2,2
 1014fec:	f800283a 	ret
 1014ff0:	39c03fcc 	andi	r7,r7,255
 1014ff4:	39400726 	beq	r7,r5,1015014 <__ledf2+0xbc>
 1014ff8:	2800081e 	bne	r5,zero,101501c <__ledf2+0xc4>
 1014ffc:	00800044 	movi	r2,1
 1015000:	f800283a 	ret
 1015004:	2292b03a 	or	r9,r4,r10
 1015008:	483fdf26 	beq	r9,zero,1014f88 <__alt_data_end+0xff814f88>
 101500c:	00800084 	movi	r2,2
 1015010:	f800283a 	ret
 1015014:	4080030e 	bge	r8,r2,1015024 <__ledf2+0xcc>
 1015018:	383fef26 	beq	r7,zero,1014fd8 <__alt_data_end+0xff814fd8>
 101501c:	00bfffc4 	movi	r2,-1
 1015020:	f800283a 	ret
 1015024:	123feb16 	blt	r2,r8,1014fd4 <__alt_data_end+0xff814fd4>
 1015028:	1abff336 	bltu	r3,r10,1014ff8 <__alt_data_end+0xff814ff8>
 101502c:	50c00326 	beq	r10,r3,101503c <__ledf2+0xe4>
 1015030:	50c0042e 	bgeu	r10,r3,1015044 <__ledf2+0xec>
 1015034:	283fe81e 	bne	r5,zero,1014fd8 <__alt_data_end+0xff814fd8>
 1015038:	003ff806 	br	101501c <__alt_data_end+0xff81501c>
 101503c:	313fee36 	bltu	r6,r4,1014ff8 <__alt_data_end+0xff814ff8>
 1015040:	21bffc36 	bltu	r4,r6,1015034 <__alt_data_end+0xff815034>
 1015044:	0005883a 	mov	r2,zero
 1015048:	f800283a 	ret

0101504c <__muldf3>:
 101504c:	defff304 	addi	sp,sp,-52
 1015050:	2804d53a 	srli	r2,r5,20
 1015054:	dd800915 	stw	r22,36(sp)
 1015058:	282cd7fa 	srli	r22,r5,31
 101505c:	dc000315 	stw	r16,12(sp)
 1015060:	04000434 	movhi	r16,16
 1015064:	dd400815 	stw	r21,32(sp)
 1015068:	dc800515 	stw	r18,20(sp)
 101506c:	843fffc4 	addi	r16,r16,-1
 1015070:	dfc00c15 	stw	ra,48(sp)
 1015074:	df000b15 	stw	fp,44(sp)
 1015078:	ddc00a15 	stw	r23,40(sp)
 101507c:	dd000715 	stw	r20,28(sp)
 1015080:	dcc00615 	stw	r19,24(sp)
 1015084:	dc400415 	stw	r17,16(sp)
 1015088:	1481ffcc 	andi	r18,r2,2047
 101508c:	2c20703a 	and	r16,r5,r16
 1015090:	b02b883a 	mov	r21,r22
 1015094:	b2403fcc 	andi	r9,r22,255
 1015098:	90006026 	beq	r18,zero,101521c <__muldf3+0x1d0>
 101509c:	0081ffc4 	movi	r2,2047
 10150a0:	2029883a 	mov	r20,r4
 10150a4:	90803626 	beq	r18,r2,1015180 <__muldf3+0x134>
 10150a8:	80800434 	orhi	r2,r16,16
 10150ac:	100490fa 	slli	r2,r2,3
 10150b0:	2020d77a 	srli	r16,r4,29
 10150b4:	202890fa 	slli	r20,r4,3
 10150b8:	94bf0044 	addi	r18,r18,-1023
 10150bc:	80a0b03a 	or	r16,r16,r2
 10150c0:	0027883a 	mov	r19,zero
 10150c4:	0039883a 	mov	fp,zero
 10150c8:	3804d53a 	srli	r2,r7,20
 10150cc:	382ed7fa 	srli	r23,r7,31
 10150d0:	04400434 	movhi	r17,16
 10150d4:	8c7fffc4 	addi	r17,r17,-1
 10150d8:	1081ffcc 	andi	r2,r2,2047
 10150dc:	3011883a 	mov	r8,r6
 10150e0:	3c62703a 	and	r17,r7,r17
 10150e4:	ba803fcc 	andi	r10,r23,255
 10150e8:	10006d26 	beq	r2,zero,10152a0 <__muldf3+0x254>
 10150ec:	00c1ffc4 	movi	r3,2047
 10150f0:	10c06526 	beq	r2,r3,1015288 <__muldf3+0x23c>
 10150f4:	88c00434 	orhi	r3,r17,16
 10150f8:	180690fa 	slli	r3,r3,3
 10150fc:	3022d77a 	srli	r17,r6,29
 1015100:	301090fa 	slli	r8,r6,3
 1015104:	10bf0044 	addi	r2,r2,-1023
 1015108:	88e2b03a 	or	r17,r17,r3
 101510c:	000b883a 	mov	r5,zero
 1015110:	9085883a 	add	r2,r18,r2
 1015114:	2cc8b03a 	or	r4,r5,r19
 1015118:	00c003c4 	movi	r3,15
 101511c:	bdacf03a 	xor	r22,r23,r22
 1015120:	12c00044 	addi	r11,r2,1
 1015124:	19009936 	bltu	r3,r4,101538c <__muldf3+0x340>
 1015128:	200890ba 	slli	r4,r4,2
 101512c:	00c04074 	movhi	r3,257
 1015130:	18d45004 	addi	r3,r3,20800
 1015134:	20c9883a 	add	r4,r4,r3
 1015138:	20c00017 	ldw	r3,0(r4)
 101513c:	1800683a 	jmp	r3
 1015140:	0101538c 	andi	r4,zero,1358
 1015144:	010151a0 	cmpeqi	r4,zero,1350
 1015148:	010151a0 	cmpeqi	r4,zero,1350
 101514c:	0101519c 	xori	r4,zero,1350
 1015150:	01015368 	cmpgeui	r4,zero,1357
 1015154:	01015368 	cmpgeui	r4,zero,1357
 1015158:	01015350 	cmplti	r4,zero,1357
 101515c:	0101519c 	xori	r4,zero,1350
 1015160:	01015368 	cmpgeui	r4,zero,1357
 1015164:	01015350 	cmplti	r4,zero,1357
 1015168:	01015368 	cmpgeui	r4,zero,1357
 101516c:	0101519c 	xori	r4,zero,1350
 1015170:	01015378 	rdprs	r4,zero,1357
 1015174:	01015378 	rdprs	r4,zero,1357
 1015178:	01015378 	rdprs	r4,zero,1357
 101517c:	01015594 	movui	r4,1366
 1015180:	2404b03a 	or	r2,r4,r16
 1015184:	10006f1e 	bne	r2,zero,1015344 <__muldf3+0x2f8>
 1015188:	04c00204 	movi	r19,8
 101518c:	0021883a 	mov	r16,zero
 1015190:	0029883a 	mov	r20,zero
 1015194:	07000084 	movi	fp,2
 1015198:	003fcb06 	br	10150c8 <__alt_data_end+0xff8150c8>
 101519c:	502d883a 	mov	r22,r10
 10151a0:	00800084 	movi	r2,2
 10151a4:	28805726 	beq	r5,r2,1015304 <__muldf3+0x2b8>
 10151a8:	008000c4 	movi	r2,3
 10151ac:	28816626 	beq	r5,r2,1015748 <__muldf3+0x6fc>
 10151b0:	00800044 	movi	r2,1
 10151b4:	2881411e 	bne	r5,r2,10156bc <__muldf3+0x670>
 10151b8:	b02b883a 	mov	r21,r22
 10151bc:	0005883a 	mov	r2,zero
 10151c0:	000b883a 	mov	r5,zero
 10151c4:	0029883a 	mov	r20,zero
 10151c8:	1004953a 	slli	r2,r2,20
 10151cc:	a8c03fcc 	andi	r3,r21,255
 10151d0:	04400434 	movhi	r17,16
 10151d4:	8c7fffc4 	addi	r17,r17,-1
 10151d8:	180697fa 	slli	r3,r3,31
 10151dc:	2c4a703a 	and	r5,r5,r17
 10151e0:	288ab03a 	or	r5,r5,r2
 10151e4:	28c6b03a 	or	r3,r5,r3
 10151e8:	a005883a 	mov	r2,r20
 10151ec:	dfc00c17 	ldw	ra,48(sp)
 10151f0:	df000b17 	ldw	fp,44(sp)
 10151f4:	ddc00a17 	ldw	r23,40(sp)
 10151f8:	dd800917 	ldw	r22,36(sp)
 10151fc:	dd400817 	ldw	r21,32(sp)
 1015200:	dd000717 	ldw	r20,28(sp)
 1015204:	dcc00617 	ldw	r19,24(sp)
 1015208:	dc800517 	ldw	r18,20(sp)
 101520c:	dc400417 	ldw	r17,16(sp)
 1015210:	dc000317 	ldw	r16,12(sp)
 1015214:	dec00d04 	addi	sp,sp,52
 1015218:	f800283a 	ret
 101521c:	2404b03a 	or	r2,r4,r16
 1015220:	2027883a 	mov	r19,r4
 1015224:	10004226 	beq	r2,zero,1015330 <__muldf3+0x2e4>
 1015228:	8000fc26 	beq	r16,zero,101561c <__muldf3+0x5d0>
 101522c:	8009883a 	mov	r4,r16
 1015230:	d9800215 	stw	r6,8(sp)
 1015234:	d9c00015 	stw	r7,0(sp)
 1015238:	da400115 	stw	r9,4(sp)
 101523c:	10099700 	call	1009970 <__clzsi2>
 1015240:	d9800217 	ldw	r6,8(sp)
 1015244:	d9c00017 	ldw	r7,0(sp)
 1015248:	da400117 	ldw	r9,4(sp)
 101524c:	113ffd44 	addi	r4,r2,-11
 1015250:	00c00704 	movi	r3,28
 1015254:	1900ed16 	blt	r3,r4,101560c <__muldf3+0x5c0>
 1015258:	00c00744 	movi	r3,29
 101525c:	147ffe04 	addi	r17,r2,-8
 1015260:	1907c83a 	sub	r3,r3,r4
 1015264:	8460983a 	sll	r16,r16,r17
 1015268:	98c6d83a 	srl	r3,r19,r3
 101526c:	9c68983a 	sll	r20,r19,r17
 1015270:	1c20b03a 	or	r16,r3,r16
 1015274:	1080fcc4 	addi	r2,r2,1011
 1015278:	00a5c83a 	sub	r18,zero,r2
 101527c:	0027883a 	mov	r19,zero
 1015280:	0039883a 	mov	fp,zero
 1015284:	003f9006 	br	10150c8 <__alt_data_end+0xff8150c8>
 1015288:	3446b03a 	or	r3,r6,r17
 101528c:	1800261e 	bne	r3,zero,1015328 <__muldf3+0x2dc>
 1015290:	0023883a 	mov	r17,zero
 1015294:	0011883a 	mov	r8,zero
 1015298:	01400084 	movi	r5,2
 101529c:	003f9c06 	br	1015110 <__alt_data_end+0xff815110>
 10152a0:	3446b03a 	or	r3,r6,r17
 10152a4:	18001c26 	beq	r3,zero,1015318 <__muldf3+0x2cc>
 10152a8:	8800ce26 	beq	r17,zero,10155e4 <__muldf3+0x598>
 10152ac:	8809883a 	mov	r4,r17
 10152b0:	d9800215 	stw	r6,8(sp)
 10152b4:	da400115 	stw	r9,4(sp)
 10152b8:	da800015 	stw	r10,0(sp)
 10152bc:	10099700 	call	1009970 <__clzsi2>
 10152c0:	d9800217 	ldw	r6,8(sp)
 10152c4:	da400117 	ldw	r9,4(sp)
 10152c8:	da800017 	ldw	r10,0(sp)
 10152cc:	113ffd44 	addi	r4,r2,-11
 10152d0:	00c00704 	movi	r3,28
 10152d4:	1900bf16 	blt	r3,r4,10155d4 <__muldf3+0x588>
 10152d8:	00c00744 	movi	r3,29
 10152dc:	123ffe04 	addi	r8,r2,-8
 10152e0:	1907c83a 	sub	r3,r3,r4
 10152e4:	8a22983a 	sll	r17,r17,r8
 10152e8:	30c6d83a 	srl	r3,r6,r3
 10152ec:	3210983a 	sll	r8,r6,r8
 10152f0:	1c62b03a 	or	r17,r3,r17
 10152f4:	1080fcc4 	addi	r2,r2,1011
 10152f8:	0085c83a 	sub	r2,zero,r2
 10152fc:	000b883a 	mov	r5,zero
 1015300:	003f8306 	br	1015110 <__alt_data_end+0xff815110>
 1015304:	b02b883a 	mov	r21,r22
 1015308:	0081ffc4 	movi	r2,2047
 101530c:	000b883a 	mov	r5,zero
 1015310:	0029883a 	mov	r20,zero
 1015314:	003fac06 	br	10151c8 <__alt_data_end+0xff8151c8>
 1015318:	0023883a 	mov	r17,zero
 101531c:	0011883a 	mov	r8,zero
 1015320:	01400044 	movi	r5,1
 1015324:	003f7a06 	br	1015110 <__alt_data_end+0xff815110>
 1015328:	014000c4 	movi	r5,3
 101532c:	003f7806 	br	1015110 <__alt_data_end+0xff815110>
 1015330:	04c00104 	movi	r19,4
 1015334:	0021883a 	mov	r16,zero
 1015338:	0029883a 	mov	r20,zero
 101533c:	07000044 	movi	fp,1
 1015340:	003f6106 	br	10150c8 <__alt_data_end+0xff8150c8>
 1015344:	04c00304 	movi	r19,12
 1015348:	070000c4 	movi	fp,3
 101534c:	003f5e06 	br	10150c8 <__alt_data_end+0xff8150c8>
 1015350:	01400434 	movhi	r5,16
 1015354:	002b883a 	mov	r21,zero
 1015358:	297fffc4 	addi	r5,r5,-1
 101535c:	053fffc4 	movi	r20,-1
 1015360:	0081ffc4 	movi	r2,2047
 1015364:	003f9806 	br	10151c8 <__alt_data_end+0xff8151c8>
 1015368:	8023883a 	mov	r17,r16
 101536c:	a011883a 	mov	r8,r20
 1015370:	e00b883a 	mov	r5,fp
 1015374:	003f8a06 	br	10151a0 <__alt_data_end+0xff8151a0>
 1015378:	8023883a 	mov	r17,r16
 101537c:	a011883a 	mov	r8,r20
 1015380:	482d883a 	mov	r22,r9
 1015384:	e00b883a 	mov	r5,fp
 1015388:	003f8506 	br	10151a0 <__alt_data_end+0xff8151a0>
 101538c:	a00ad43a 	srli	r5,r20,16
 1015390:	401ad43a 	srli	r13,r8,16
 1015394:	a53fffcc 	andi	r20,r20,65535
 1015398:	423fffcc 	andi	r8,r8,65535
 101539c:	4519383a 	mul	r12,r8,r20
 10153a0:	4147383a 	mul	r3,r8,r5
 10153a4:	6d09383a 	mul	r4,r13,r20
 10153a8:	600cd43a 	srli	r6,r12,16
 10153ac:	2b5d383a 	mul	r14,r5,r13
 10153b0:	20c9883a 	add	r4,r4,r3
 10153b4:	310d883a 	add	r6,r6,r4
 10153b8:	30c0022e 	bgeu	r6,r3,10153c4 <__muldf3+0x378>
 10153bc:	00c00074 	movhi	r3,1
 10153c0:	70dd883a 	add	r14,r14,r3
 10153c4:	8826d43a 	srli	r19,r17,16
 10153c8:	8bffffcc 	andi	r15,r17,65535
 10153cc:	7d23383a 	mul	r17,r15,r20
 10153d0:	7949383a 	mul	r4,r15,r5
 10153d4:	9d29383a 	mul	r20,r19,r20
 10153d8:	8814d43a 	srli	r10,r17,16
 10153dc:	3012943a 	slli	r9,r6,16
 10153e0:	a129883a 	add	r20,r20,r4
 10153e4:	633fffcc 	andi	r12,r12,65535
 10153e8:	5515883a 	add	r10,r10,r20
 10153ec:	3006d43a 	srli	r3,r6,16
 10153f0:	4b13883a 	add	r9,r9,r12
 10153f4:	2ccb383a 	mul	r5,r5,r19
 10153f8:	5100022e 	bgeu	r10,r4,1015404 <__muldf3+0x3b8>
 10153fc:	01000074 	movhi	r4,1
 1015400:	290b883a 	add	r5,r5,r4
 1015404:	802ad43a 	srli	r21,r16,16
 1015408:	843fffcc 	andi	r16,r16,65535
 101540c:	440d383a 	mul	r6,r8,r16
 1015410:	4565383a 	mul	r18,r8,r21
 1015414:	8349383a 	mul	r4,r16,r13
 1015418:	500e943a 	slli	r7,r10,16
 101541c:	3010d43a 	srli	r8,r6,16
 1015420:	5028d43a 	srli	r20,r10,16
 1015424:	2489883a 	add	r4,r4,r18
 1015428:	8abfffcc 	andi	r10,r17,65535
 101542c:	3a95883a 	add	r10,r7,r10
 1015430:	4119883a 	add	r12,r8,r4
 1015434:	a169883a 	add	r20,r20,r5
 1015438:	1a87883a 	add	r3,r3,r10
 101543c:	6d5b383a 	mul	r13,r13,r21
 1015440:	6480022e 	bgeu	r12,r18,101544c <__muldf3+0x400>
 1015444:	01000074 	movhi	r4,1
 1015448:	691b883a 	add	r13,r13,r4
 101544c:	7c25383a 	mul	r18,r15,r16
 1015450:	7d4b383a 	mul	r5,r15,r21
 1015454:	84cf383a 	mul	r7,r16,r19
 1015458:	901ed43a 	srli	r15,r18,16
 101545c:	6008d43a 	srli	r4,r12,16
 1015460:	6010943a 	slli	r8,r12,16
 1015464:	394f883a 	add	r7,r7,r5
 1015468:	333fffcc 	andi	r12,r6,65535
 101546c:	79df883a 	add	r15,r15,r7
 1015470:	235b883a 	add	r13,r4,r13
 1015474:	9d63383a 	mul	r17,r19,r21
 1015478:	4309883a 	add	r4,r8,r12
 101547c:	7940022e 	bgeu	r15,r5,1015488 <__muldf3+0x43c>
 1015480:	01400074 	movhi	r5,1
 1015484:	8963883a 	add	r17,r17,r5
 1015488:	780a943a 	slli	r5,r15,16
 101548c:	91bfffcc 	andi	r6,r18,65535
 1015490:	70c7883a 	add	r3,r14,r3
 1015494:	298d883a 	add	r6,r5,r6
 1015498:	1a8f803a 	cmpltu	r7,r3,r10
 101549c:	350b883a 	add	r5,r6,r20
 10154a0:	20c7883a 	add	r3,r4,r3
 10154a4:	3955883a 	add	r10,r7,r5
 10154a8:	1909803a 	cmpltu	r4,r3,r4
 10154ac:	6a91883a 	add	r8,r13,r10
 10154b0:	780cd43a 	srli	r6,r15,16
 10154b4:	2219883a 	add	r12,r4,r8
 10154b8:	2d0b803a 	cmpltu	r5,r5,r20
 10154bc:	51cf803a 	cmpltu	r7,r10,r7
 10154c0:	29ceb03a 	or	r7,r5,r7
 10154c4:	4351803a 	cmpltu	r8,r8,r13
 10154c8:	610b803a 	cmpltu	r5,r12,r4
 10154cc:	4148b03a 	or	r4,r8,r5
 10154d0:	398f883a 	add	r7,r7,r6
 10154d4:	3909883a 	add	r4,r7,r4
 10154d8:	1810927a 	slli	r8,r3,9
 10154dc:	2449883a 	add	r4,r4,r17
 10154e0:	2008927a 	slli	r4,r4,9
 10154e4:	6022d5fa 	srli	r17,r12,23
 10154e8:	1806d5fa 	srli	r3,r3,23
 10154ec:	4252b03a 	or	r9,r8,r9
 10154f0:	600a927a 	slli	r5,r12,9
 10154f4:	4810c03a 	cmpne	r8,r9,zero
 10154f8:	2462b03a 	or	r17,r4,r17
 10154fc:	40c6b03a 	or	r3,r8,r3
 1015500:	8900402c 	andhi	r4,r17,256
 1015504:	1950b03a 	or	r8,r3,r5
 1015508:	20000726 	beq	r4,zero,1015528 <__muldf3+0x4dc>
 101550c:	4006d07a 	srli	r3,r8,1
 1015510:	880497fa 	slli	r2,r17,31
 1015514:	4200004c 	andi	r8,r8,1
 1015518:	8822d07a 	srli	r17,r17,1
 101551c:	1a10b03a 	or	r8,r3,r8
 1015520:	1210b03a 	or	r8,r2,r8
 1015524:	5805883a 	mov	r2,r11
 1015528:	1140ffc4 	addi	r5,r2,1023
 101552c:	0140440e 	bge	zero,r5,1015640 <__muldf3+0x5f4>
 1015530:	40c001cc 	andi	r3,r8,7
 1015534:	18000726 	beq	r3,zero,1015554 <__muldf3+0x508>
 1015538:	40c003cc 	andi	r3,r8,15
 101553c:	01000104 	movi	r4,4
 1015540:	19000426 	beq	r3,r4,1015554 <__muldf3+0x508>
 1015544:	4107883a 	add	r3,r8,r4
 1015548:	1a11803a 	cmpltu	r8,r3,r8
 101554c:	8a23883a 	add	r17,r17,r8
 1015550:	1811883a 	mov	r8,r3
 1015554:	88c0402c 	andhi	r3,r17,256
 1015558:	18000426 	beq	r3,zero,101556c <__muldf3+0x520>
 101555c:	11410004 	addi	r5,r2,1024
 1015560:	00bfc034 	movhi	r2,65280
 1015564:	10bfffc4 	addi	r2,r2,-1
 1015568:	88a2703a 	and	r17,r17,r2
 101556c:	0081ff84 	movi	r2,2046
 1015570:	117f6416 	blt	r2,r5,1015304 <__alt_data_end+0xff815304>
 1015574:	8828977a 	slli	r20,r17,29
 1015578:	4010d0fa 	srli	r8,r8,3
 101557c:	8822927a 	slli	r17,r17,9
 1015580:	2881ffcc 	andi	r2,r5,2047
 1015584:	a228b03a 	or	r20,r20,r8
 1015588:	880ad33a 	srli	r5,r17,12
 101558c:	b02b883a 	mov	r21,r22
 1015590:	003f0d06 	br	10151c8 <__alt_data_end+0xff8151c8>
 1015594:	8080022c 	andhi	r2,r16,8
 1015598:	10000926 	beq	r2,zero,10155c0 <__muldf3+0x574>
 101559c:	8880022c 	andhi	r2,r17,8
 10155a0:	1000071e 	bne	r2,zero,10155c0 <__muldf3+0x574>
 10155a4:	00800434 	movhi	r2,16
 10155a8:	89400234 	orhi	r5,r17,8
 10155ac:	10bfffc4 	addi	r2,r2,-1
 10155b0:	b82b883a 	mov	r21,r23
 10155b4:	288a703a 	and	r5,r5,r2
 10155b8:	4029883a 	mov	r20,r8
 10155bc:	003f6806 	br	1015360 <__alt_data_end+0xff815360>
 10155c0:	00800434 	movhi	r2,16
 10155c4:	81400234 	orhi	r5,r16,8
 10155c8:	10bfffc4 	addi	r2,r2,-1
 10155cc:	288a703a 	and	r5,r5,r2
 10155d0:	003f6306 	br	1015360 <__alt_data_end+0xff815360>
 10155d4:	147ff604 	addi	r17,r2,-40
 10155d8:	3462983a 	sll	r17,r6,r17
 10155dc:	0011883a 	mov	r8,zero
 10155e0:	003f4406 	br	10152f4 <__alt_data_end+0xff8152f4>
 10155e4:	3009883a 	mov	r4,r6
 10155e8:	d9800215 	stw	r6,8(sp)
 10155ec:	da400115 	stw	r9,4(sp)
 10155f0:	da800015 	stw	r10,0(sp)
 10155f4:	10099700 	call	1009970 <__clzsi2>
 10155f8:	10800804 	addi	r2,r2,32
 10155fc:	da800017 	ldw	r10,0(sp)
 1015600:	da400117 	ldw	r9,4(sp)
 1015604:	d9800217 	ldw	r6,8(sp)
 1015608:	003f3006 	br	10152cc <__alt_data_end+0xff8152cc>
 101560c:	143ff604 	addi	r16,r2,-40
 1015610:	9c20983a 	sll	r16,r19,r16
 1015614:	0029883a 	mov	r20,zero
 1015618:	003f1606 	br	1015274 <__alt_data_end+0xff815274>
 101561c:	d9800215 	stw	r6,8(sp)
 1015620:	d9c00015 	stw	r7,0(sp)
 1015624:	da400115 	stw	r9,4(sp)
 1015628:	10099700 	call	1009970 <__clzsi2>
 101562c:	10800804 	addi	r2,r2,32
 1015630:	da400117 	ldw	r9,4(sp)
 1015634:	d9c00017 	ldw	r7,0(sp)
 1015638:	d9800217 	ldw	r6,8(sp)
 101563c:	003f0306 	br	101524c <__alt_data_end+0xff81524c>
 1015640:	00c00044 	movi	r3,1
 1015644:	1947c83a 	sub	r3,r3,r5
 1015648:	00800e04 	movi	r2,56
 101564c:	10feda16 	blt	r2,r3,10151b8 <__alt_data_end+0xff8151b8>
 1015650:	008007c4 	movi	r2,31
 1015654:	10c01b16 	blt	r2,r3,10156c4 <__muldf3+0x678>
 1015658:	00800804 	movi	r2,32
 101565c:	10c5c83a 	sub	r2,r2,r3
 1015660:	888a983a 	sll	r5,r17,r2
 1015664:	40c8d83a 	srl	r4,r8,r3
 1015668:	4084983a 	sll	r2,r8,r2
 101566c:	88e2d83a 	srl	r17,r17,r3
 1015670:	2906b03a 	or	r3,r5,r4
 1015674:	1004c03a 	cmpne	r2,r2,zero
 1015678:	1886b03a 	or	r3,r3,r2
 101567c:	188001cc 	andi	r2,r3,7
 1015680:	10000726 	beq	r2,zero,10156a0 <__muldf3+0x654>
 1015684:	188003cc 	andi	r2,r3,15
 1015688:	01000104 	movi	r4,4
 101568c:	11000426 	beq	r2,r4,10156a0 <__muldf3+0x654>
 1015690:	1805883a 	mov	r2,r3
 1015694:	10c00104 	addi	r3,r2,4
 1015698:	1885803a 	cmpltu	r2,r3,r2
 101569c:	88a3883a 	add	r17,r17,r2
 10156a0:	8880202c 	andhi	r2,r17,128
 10156a4:	10001c26 	beq	r2,zero,1015718 <__muldf3+0x6cc>
 10156a8:	b02b883a 	mov	r21,r22
 10156ac:	00800044 	movi	r2,1
 10156b0:	000b883a 	mov	r5,zero
 10156b4:	0029883a 	mov	r20,zero
 10156b8:	003ec306 	br	10151c8 <__alt_data_end+0xff8151c8>
 10156bc:	5805883a 	mov	r2,r11
 10156c0:	003f9906 	br	1015528 <__alt_data_end+0xff815528>
 10156c4:	00bff844 	movi	r2,-31
 10156c8:	1145c83a 	sub	r2,r2,r5
 10156cc:	8888d83a 	srl	r4,r17,r2
 10156d0:	00800804 	movi	r2,32
 10156d4:	18801a26 	beq	r3,r2,1015740 <__muldf3+0x6f4>
 10156d8:	00801004 	movi	r2,64
 10156dc:	10c5c83a 	sub	r2,r2,r3
 10156e0:	8884983a 	sll	r2,r17,r2
 10156e4:	1204b03a 	or	r2,r2,r8
 10156e8:	1004c03a 	cmpne	r2,r2,zero
 10156ec:	2084b03a 	or	r2,r4,r2
 10156f0:	144001cc 	andi	r17,r2,7
 10156f4:	88000d1e 	bne	r17,zero,101572c <__muldf3+0x6e0>
 10156f8:	000b883a 	mov	r5,zero
 10156fc:	1028d0fa 	srli	r20,r2,3
 1015700:	b02b883a 	mov	r21,r22
 1015704:	0005883a 	mov	r2,zero
 1015708:	a468b03a 	or	r20,r20,r17
 101570c:	003eae06 	br	10151c8 <__alt_data_end+0xff8151c8>
 1015710:	1007883a 	mov	r3,r2
 1015714:	0023883a 	mov	r17,zero
 1015718:	880a927a 	slli	r5,r17,9
 101571c:	1805883a 	mov	r2,r3
 1015720:	8822977a 	slli	r17,r17,29
 1015724:	280ad33a 	srli	r5,r5,12
 1015728:	003ff406 	br	10156fc <__alt_data_end+0xff8156fc>
 101572c:	10c003cc 	andi	r3,r2,15
 1015730:	01000104 	movi	r4,4
 1015734:	193ff626 	beq	r3,r4,1015710 <__alt_data_end+0xff815710>
 1015738:	0023883a 	mov	r17,zero
 101573c:	003fd506 	br	1015694 <__alt_data_end+0xff815694>
 1015740:	0005883a 	mov	r2,zero
 1015744:	003fe706 	br	10156e4 <__alt_data_end+0xff8156e4>
 1015748:	00800434 	movhi	r2,16
 101574c:	89400234 	orhi	r5,r17,8
 1015750:	10bfffc4 	addi	r2,r2,-1
 1015754:	b02b883a 	mov	r21,r22
 1015758:	288a703a 	and	r5,r5,r2
 101575c:	4029883a 	mov	r20,r8
 1015760:	003eff06 	br	1015360 <__alt_data_end+0xff815360>

01015764 <__subdf3>:
 1015764:	02000434 	movhi	r8,16
 1015768:	423fffc4 	addi	r8,r8,-1
 101576c:	defffb04 	addi	sp,sp,-20
 1015770:	2a14703a 	and	r10,r5,r8
 1015774:	3812d53a 	srli	r9,r7,20
 1015778:	3a10703a 	and	r8,r7,r8
 101577c:	2006d77a 	srli	r3,r4,29
 1015780:	3004d77a 	srli	r2,r6,29
 1015784:	dc000015 	stw	r16,0(sp)
 1015788:	501490fa 	slli	r10,r10,3
 101578c:	2820d53a 	srli	r16,r5,20
 1015790:	401090fa 	slli	r8,r8,3
 1015794:	dc800215 	stw	r18,8(sp)
 1015798:	dc400115 	stw	r17,4(sp)
 101579c:	dfc00415 	stw	ra,16(sp)
 10157a0:	202290fa 	slli	r17,r4,3
 10157a4:	dcc00315 	stw	r19,12(sp)
 10157a8:	4a41ffcc 	andi	r9,r9,2047
 10157ac:	0101ffc4 	movi	r4,2047
 10157b0:	2824d7fa 	srli	r18,r5,31
 10157b4:	8401ffcc 	andi	r16,r16,2047
 10157b8:	50c6b03a 	or	r3,r10,r3
 10157bc:	380ed7fa 	srli	r7,r7,31
 10157c0:	408ab03a 	or	r5,r8,r2
 10157c4:	300c90fa 	slli	r6,r6,3
 10157c8:	49009626 	beq	r9,r4,1015a24 <__subdf3+0x2c0>
 10157cc:	39c0005c 	xori	r7,r7,1
 10157d0:	8245c83a 	sub	r2,r16,r9
 10157d4:	3c807426 	beq	r7,r18,10159a8 <__subdf3+0x244>
 10157d8:	0080af0e 	bge	zero,r2,1015a98 <__subdf3+0x334>
 10157dc:	48002a1e 	bne	r9,zero,1015888 <__subdf3+0x124>
 10157e0:	2988b03a 	or	r4,r5,r6
 10157e4:	20009a1e 	bne	r4,zero,1015a50 <__subdf3+0x2ec>
 10157e8:	888001cc 	andi	r2,r17,7
 10157ec:	10000726 	beq	r2,zero,101580c <__subdf3+0xa8>
 10157f0:	888003cc 	andi	r2,r17,15
 10157f4:	01000104 	movi	r4,4
 10157f8:	11000426 	beq	r2,r4,101580c <__subdf3+0xa8>
 10157fc:	890b883a 	add	r5,r17,r4
 1015800:	2c63803a 	cmpltu	r17,r5,r17
 1015804:	1c47883a 	add	r3,r3,r17
 1015808:	2823883a 	mov	r17,r5
 101580c:	1880202c 	andhi	r2,r3,128
 1015810:	10005926 	beq	r2,zero,1015978 <__subdf3+0x214>
 1015814:	84000044 	addi	r16,r16,1
 1015818:	0081ffc4 	movi	r2,2047
 101581c:	8080be26 	beq	r16,r2,1015b18 <__subdf3+0x3b4>
 1015820:	017fe034 	movhi	r5,65408
 1015824:	297fffc4 	addi	r5,r5,-1
 1015828:	1946703a 	and	r3,r3,r5
 101582c:	1804977a 	slli	r2,r3,29
 1015830:	1806927a 	slli	r3,r3,9
 1015834:	8822d0fa 	srli	r17,r17,3
 1015838:	8401ffcc 	andi	r16,r16,2047
 101583c:	180ad33a 	srli	r5,r3,12
 1015840:	9100004c 	andi	r4,r18,1
 1015844:	1444b03a 	or	r2,r2,r17
 1015848:	80c1ffcc 	andi	r3,r16,2047
 101584c:	1820953a 	slli	r16,r3,20
 1015850:	20c03fcc 	andi	r3,r4,255
 1015854:	180897fa 	slli	r4,r3,31
 1015858:	00c00434 	movhi	r3,16
 101585c:	18ffffc4 	addi	r3,r3,-1
 1015860:	28c6703a 	and	r3,r5,r3
 1015864:	1c06b03a 	or	r3,r3,r16
 1015868:	1906b03a 	or	r3,r3,r4
 101586c:	dfc00417 	ldw	ra,16(sp)
 1015870:	dcc00317 	ldw	r19,12(sp)
 1015874:	dc800217 	ldw	r18,8(sp)
 1015878:	dc400117 	ldw	r17,4(sp)
 101587c:	dc000017 	ldw	r16,0(sp)
 1015880:	dec00504 	addi	sp,sp,20
 1015884:	f800283a 	ret
 1015888:	0101ffc4 	movi	r4,2047
 101588c:	813fd626 	beq	r16,r4,10157e8 <__alt_data_end+0xff8157e8>
 1015890:	29402034 	orhi	r5,r5,128
 1015894:	01000e04 	movi	r4,56
 1015898:	2080a316 	blt	r4,r2,1015b28 <__subdf3+0x3c4>
 101589c:	010007c4 	movi	r4,31
 10158a0:	2080c616 	blt	r4,r2,1015bbc <__subdf3+0x458>
 10158a4:	01000804 	movi	r4,32
 10158a8:	2089c83a 	sub	r4,r4,r2
 10158ac:	2910983a 	sll	r8,r5,r4
 10158b0:	308ed83a 	srl	r7,r6,r2
 10158b4:	3108983a 	sll	r4,r6,r4
 10158b8:	2884d83a 	srl	r2,r5,r2
 10158bc:	41ccb03a 	or	r6,r8,r7
 10158c0:	2008c03a 	cmpne	r4,r4,zero
 10158c4:	310cb03a 	or	r6,r6,r4
 10158c8:	898dc83a 	sub	r6,r17,r6
 10158cc:	89a3803a 	cmpltu	r17,r17,r6
 10158d0:	1887c83a 	sub	r3,r3,r2
 10158d4:	1c47c83a 	sub	r3,r3,r17
 10158d8:	3023883a 	mov	r17,r6
 10158dc:	1880202c 	andhi	r2,r3,128
 10158e0:	10002326 	beq	r2,zero,1015970 <__subdf3+0x20c>
 10158e4:	04c02034 	movhi	r19,128
 10158e8:	9cffffc4 	addi	r19,r19,-1
 10158ec:	1ce6703a 	and	r19,r3,r19
 10158f0:	98007a26 	beq	r19,zero,1015adc <__subdf3+0x378>
 10158f4:	9809883a 	mov	r4,r19
 10158f8:	10099700 	call	1009970 <__clzsi2>
 10158fc:	113ffe04 	addi	r4,r2,-8
 1015900:	00c007c4 	movi	r3,31
 1015904:	19007b16 	blt	r3,r4,1015af4 <__subdf3+0x390>
 1015908:	00800804 	movi	r2,32
 101590c:	1105c83a 	sub	r2,r2,r4
 1015910:	8884d83a 	srl	r2,r17,r2
 1015914:	9906983a 	sll	r3,r19,r4
 1015918:	8922983a 	sll	r17,r17,r4
 101591c:	10c4b03a 	or	r2,r2,r3
 1015920:	24007816 	blt	r4,r16,1015b04 <__subdf3+0x3a0>
 1015924:	2421c83a 	sub	r16,r4,r16
 1015928:	80c00044 	addi	r3,r16,1
 101592c:	010007c4 	movi	r4,31
 1015930:	20c09516 	blt	r4,r3,1015b88 <__subdf3+0x424>
 1015934:	01400804 	movi	r5,32
 1015938:	28cbc83a 	sub	r5,r5,r3
 101593c:	88c8d83a 	srl	r4,r17,r3
 1015940:	8962983a 	sll	r17,r17,r5
 1015944:	114a983a 	sll	r5,r2,r5
 1015948:	10c6d83a 	srl	r3,r2,r3
 101594c:	8804c03a 	cmpne	r2,r17,zero
 1015950:	290ab03a 	or	r5,r5,r4
 1015954:	28a2b03a 	or	r17,r5,r2
 1015958:	0021883a 	mov	r16,zero
 101595c:	003fa206 	br	10157e8 <__alt_data_end+0xff8157e8>
 1015960:	2090b03a 	or	r8,r4,r2
 1015964:	40018e26 	beq	r8,zero,1015fa0 <__subdf3+0x83c>
 1015968:	1007883a 	mov	r3,r2
 101596c:	2023883a 	mov	r17,r4
 1015970:	888001cc 	andi	r2,r17,7
 1015974:	103f9e1e 	bne	r2,zero,10157f0 <__alt_data_end+0xff8157f0>
 1015978:	1804977a 	slli	r2,r3,29
 101597c:	8822d0fa 	srli	r17,r17,3
 1015980:	1810d0fa 	srli	r8,r3,3
 1015984:	9100004c 	andi	r4,r18,1
 1015988:	1444b03a 	or	r2,r2,r17
 101598c:	00c1ffc4 	movi	r3,2047
 1015990:	80c02826 	beq	r16,r3,1015a34 <__subdf3+0x2d0>
 1015994:	01400434 	movhi	r5,16
 1015998:	297fffc4 	addi	r5,r5,-1
 101599c:	80e0703a 	and	r16,r16,r3
 10159a0:	414a703a 	and	r5,r8,r5
 10159a4:	003fa806 	br	1015848 <__alt_data_end+0xff815848>
 10159a8:	0080630e 	bge	zero,r2,1015b38 <__subdf3+0x3d4>
 10159ac:	48003026 	beq	r9,zero,1015a70 <__subdf3+0x30c>
 10159b0:	0101ffc4 	movi	r4,2047
 10159b4:	813f8c26 	beq	r16,r4,10157e8 <__alt_data_end+0xff8157e8>
 10159b8:	29402034 	orhi	r5,r5,128
 10159bc:	01000e04 	movi	r4,56
 10159c0:	2080a90e 	bge	r4,r2,1015c68 <__subdf3+0x504>
 10159c4:	298cb03a 	or	r6,r5,r6
 10159c8:	3012c03a 	cmpne	r9,r6,zero
 10159cc:	0005883a 	mov	r2,zero
 10159d0:	4c53883a 	add	r9,r9,r17
 10159d4:	4c63803a 	cmpltu	r17,r9,r17
 10159d8:	10c7883a 	add	r3,r2,r3
 10159dc:	88c7883a 	add	r3,r17,r3
 10159e0:	4823883a 	mov	r17,r9
 10159e4:	1880202c 	andhi	r2,r3,128
 10159e8:	1000d026 	beq	r2,zero,1015d2c <__subdf3+0x5c8>
 10159ec:	84000044 	addi	r16,r16,1
 10159f0:	0081ffc4 	movi	r2,2047
 10159f4:	8080fe26 	beq	r16,r2,1015df0 <__subdf3+0x68c>
 10159f8:	00bfe034 	movhi	r2,65408
 10159fc:	10bfffc4 	addi	r2,r2,-1
 1015a00:	1886703a 	and	r3,r3,r2
 1015a04:	880ad07a 	srli	r5,r17,1
 1015a08:	180497fa 	slli	r2,r3,31
 1015a0c:	8900004c 	andi	r4,r17,1
 1015a10:	2922b03a 	or	r17,r5,r4
 1015a14:	1806d07a 	srli	r3,r3,1
 1015a18:	1462b03a 	or	r17,r2,r17
 1015a1c:	3825883a 	mov	r18,r7
 1015a20:	003f7106 	br	10157e8 <__alt_data_end+0xff8157e8>
 1015a24:	2984b03a 	or	r2,r5,r6
 1015a28:	103f6826 	beq	r2,zero,10157cc <__alt_data_end+0xff8157cc>
 1015a2c:	39c03fcc 	andi	r7,r7,255
 1015a30:	003f6706 	br	10157d0 <__alt_data_end+0xff8157d0>
 1015a34:	4086b03a 	or	r3,r8,r2
 1015a38:	18015226 	beq	r3,zero,1015f84 <__subdf3+0x820>
 1015a3c:	00c00434 	movhi	r3,16
 1015a40:	41400234 	orhi	r5,r8,8
 1015a44:	18ffffc4 	addi	r3,r3,-1
 1015a48:	28ca703a 	and	r5,r5,r3
 1015a4c:	003f7e06 	br	1015848 <__alt_data_end+0xff815848>
 1015a50:	10bfffc4 	addi	r2,r2,-1
 1015a54:	1000491e 	bne	r2,zero,1015b7c <__subdf3+0x418>
 1015a58:	898fc83a 	sub	r7,r17,r6
 1015a5c:	89e3803a 	cmpltu	r17,r17,r7
 1015a60:	1947c83a 	sub	r3,r3,r5
 1015a64:	1c47c83a 	sub	r3,r3,r17
 1015a68:	3823883a 	mov	r17,r7
 1015a6c:	003f9b06 	br	10158dc <__alt_data_end+0xff8158dc>
 1015a70:	2988b03a 	or	r4,r5,r6
 1015a74:	203f5c26 	beq	r4,zero,10157e8 <__alt_data_end+0xff8157e8>
 1015a78:	10bfffc4 	addi	r2,r2,-1
 1015a7c:	1000931e 	bne	r2,zero,1015ccc <__subdf3+0x568>
 1015a80:	898d883a 	add	r6,r17,r6
 1015a84:	3463803a 	cmpltu	r17,r6,r17
 1015a88:	1947883a 	add	r3,r3,r5
 1015a8c:	88c7883a 	add	r3,r17,r3
 1015a90:	3023883a 	mov	r17,r6
 1015a94:	003fd306 	br	10159e4 <__alt_data_end+0xff8159e4>
 1015a98:	1000541e 	bne	r2,zero,1015bec <__subdf3+0x488>
 1015a9c:	80800044 	addi	r2,r16,1
 1015aa0:	1081ffcc 	andi	r2,r2,2047
 1015aa4:	01000044 	movi	r4,1
 1015aa8:	2080a20e 	bge	r4,r2,1015d34 <__subdf3+0x5d0>
 1015aac:	8989c83a 	sub	r4,r17,r6
 1015ab0:	8905803a 	cmpltu	r2,r17,r4
 1015ab4:	1967c83a 	sub	r19,r3,r5
 1015ab8:	98a7c83a 	sub	r19,r19,r2
 1015abc:	9880202c 	andhi	r2,r19,128
 1015ac0:	10006326 	beq	r2,zero,1015c50 <__subdf3+0x4ec>
 1015ac4:	3463c83a 	sub	r17,r6,r17
 1015ac8:	28c7c83a 	sub	r3,r5,r3
 1015acc:	344d803a 	cmpltu	r6,r6,r17
 1015ad0:	19a7c83a 	sub	r19,r3,r6
 1015ad4:	3825883a 	mov	r18,r7
 1015ad8:	983f861e 	bne	r19,zero,10158f4 <__alt_data_end+0xff8158f4>
 1015adc:	8809883a 	mov	r4,r17
 1015ae0:	10099700 	call	1009970 <__clzsi2>
 1015ae4:	10800804 	addi	r2,r2,32
 1015ae8:	113ffe04 	addi	r4,r2,-8
 1015aec:	00c007c4 	movi	r3,31
 1015af0:	193f850e 	bge	r3,r4,1015908 <__alt_data_end+0xff815908>
 1015af4:	10bff604 	addi	r2,r2,-40
 1015af8:	8884983a 	sll	r2,r17,r2
 1015afc:	0023883a 	mov	r17,zero
 1015b00:	243f880e 	bge	r4,r16,1015924 <__alt_data_end+0xff815924>
 1015b04:	00ffe034 	movhi	r3,65408
 1015b08:	18ffffc4 	addi	r3,r3,-1
 1015b0c:	8121c83a 	sub	r16,r16,r4
 1015b10:	10c6703a 	and	r3,r2,r3
 1015b14:	003f3406 	br	10157e8 <__alt_data_end+0xff8157e8>
 1015b18:	9100004c 	andi	r4,r18,1
 1015b1c:	000b883a 	mov	r5,zero
 1015b20:	0005883a 	mov	r2,zero
 1015b24:	003f4806 	br	1015848 <__alt_data_end+0xff815848>
 1015b28:	298cb03a 	or	r6,r5,r6
 1015b2c:	300cc03a 	cmpne	r6,r6,zero
 1015b30:	0005883a 	mov	r2,zero
 1015b34:	003f6406 	br	10158c8 <__alt_data_end+0xff8158c8>
 1015b38:	10009a1e 	bne	r2,zero,1015da4 <__subdf3+0x640>
 1015b3c:	82400044 	addi	r9,r16,1
 1015b40:	4881ffcc 	andi	r2,r9,2047
 1015b44:	02800044 	movi	r10,1
 1015b48:	5080670e 	bge	r10,r2,1015ce8 <__subdf3+0x584>
 1015b4c:	0081ffc4 	movi	r2,2047
 1015b50:	4880af26 	beq	r9,r2,1015e10 <__subdf3+0x6ac>
 1015b54:	898d883a 	add	r6,r17,r6
 1015b58:	1945883a 	add	r2,r3,r5
 1015b5c:	3447803a 	cmpltu	r3,r6,r17
 1015b60:	1887883a 	add	r3,r3,r2
 1015b64:	182297fa 	slli	r17,r3,31
 1015b68:	300cd07a 	srli	r6,r6,1
 1015b6c:	1806d07a 	srli	r3,r3,1
 1015b70:	4821883a 	mov	r16,r9
 1015b74:	89a2b03a 	or	r17,r17,r6
 1015b78:	003f1b06 	br	10157e8 <__alt_data_end+0xff8157e8>
 1015b7c:	0101ffc4 	movi	r4,2047
 1015b80:	813f441e 	bne	r16,r4,1015894 <__alt_data_end+0xff815894>
 1015b84:	003f1806 	br	10157e8 <__alt_data_end+0xff8157e8>
 1015b88:	843ff844 	addi	r16,r16,-31
 1015b8c:	01400804 	movi	r5,32
 1015b90:	1408d83a 	srl	r4,r2,r16
 1015b94:	19405026 	beq	r3,r5,1015cd8 <__subdf3+0x574>
 1015b98:	01401004 	movi	r5,64
 1015b9c:	28c7c83a 	sub	r3,r5,r3
 1015ba0:	10c4983a 	sll	r2,r2,r3
 1015ba4:	88a2b03a 	or	r17,r17,r2
 1015ba8:	8822c03a 	cmpne	r17,r17,zero
 1015bac:	2462b03a 	or	r17,r4,r17
 1015bb0:	0007883a 	mov	r3,zero
 1015bb4:	0021883a 	mov	r16,zero
 1015bb8:	003f6d06 	br	1015970 <__alt_data_end+0xff815970>
 1015bbc:	11fff804 	addi	r7,r2,-32
 1015bc0:	01000804 	movi	r4,32
 1015bc4:	29ced83a 	srl	r7,r5,r7
 1015bc8:	11004526 	beq	r2,r4,1015ce0 <__subdf3+0x57c>
 1015bcc:	01001004 	movi	r4,64
 1015bd0:	2089c83a 	sub	r4,r4,r2
 1015bd4:	2904983a 	sll	r2,r5,r4
 1015bd8:	118cb03a 	or	r6,r2,r6
 1015bdc:	300cc03a 	cmpne	r6,r6,zero
 1015be0:	398cb03a 	or	r6,r7,r6
 1015be4:	0005883a 	mov	r2,zero
 1015be8:	003f3706 	br	10158c8 <__alt_data_end+0xff8158c8>
 1015bec:	80002a26 	beq	r16,zero,1015c98 <__subdf3+0x534>
 1015bf0:	0101ffc4 	movi	r4,2047
 1015bf4:	49006626 	beq	r9,r4,1015d90 <__subdf3+0x62c>
 1015bf8:	0085c83a 	sub	r2,zero,r2
 1015bfc:	18c02034 	orhi	r3,r3,128
 1015c00:	01000e04 	movi	r4,56
 1015c04:	20807e16 	blt	r4,r2,1015e00 <__subdf3+0x69c>
 1015c08:	010007c4 	movi	r4,31
 1015c0c:	2080e716 	blt	r4,r2,1015fac <__subdf3+0x848>
 1015c10:	01000804 	movi	r4,32
 1015c14:	2089c83a 	sub	r4,r4,r2
 1015c18:	1914983a 	sll	r10,r3,r4
 1015c1c:	8890d83a 	srl	r8,r17,r2
 1015c20:	8908983a 	sll	r4,r17,r4
 1015c24:	1884d83a 	srl	r2,r3,r2
 1015c28:	5222b03a 	or	r17,r10,r8
 1015c2c:	2006c03a 	cmpne	r3,r4,zero
 1015c30:	88e2b03a 	or	r17,r17,r3
 1015c34:	3463c83a 	sub	r17,r6,r17
 1015c38:	2885c83a 	sub	r2,r5,r2
 1015c3c:	344d803a 	cmpltu	r6,r6,r17
 1015c40:	1187c83a 	sub	r3,r2,r6
 1015c44:	4821883a 	mov	r16,r9
 1015c48:	3825883a 	mov	r18,r7
 1015c4c:	003f2306 	br	10158dc <__alt_data_end+0xff8158dc>
 1015c50:	24d0b03a 	or	r8,r4,r19
 1015c54:	40001b1e 	bne	r8,zero,1015cc4 <__subdf3+0x560>
 1015c58:	0005883a 	mov	r2,zero
 1015c5c:	0009883a 	mov	r4,zero
 1015c60:	0021883a 	mov	r16,zero
 1015c64:	003f4906 	br	101598c <__alt_data_end+0xff81598c>
 1015c68:	010007c4 	movi	r4,31
 1015c6c:	20803a16 	blt	r4,r2,1015d58 <__subdf3+0x5f4>
 1015c70:	01000804 	movi	r4,32
 1015c74:	2089c83a 	sub	r4,r4,r2
 1015c78:	2912983a 	sll	r9,r5,r4
 1015c7c:	3090d83a 	srl	r8,r6,r2
 1015c80:	3108983a 	sll	r4,r6,r4
 1015c84:	2884d83a 	srl	r2,r5,r2
 1015c88:	4a12b03a 	or	r9,r9,r8
 1015c8c:	2008c03a 	cmpne	r4,r4,zero
 1015c90:	4912b03a 	or	r9,r9,r4
 1015c94:	003f4e06 	br	10159d0 <__alt_data_end+0xff8159d0>
 1015c98:	1c48b03a 	or	r4,r3,r17
 1015c9c:	20003c26 	beq	r4,zero,1015d90 <__subdf3+0x62c>
 1015ca0:	0084303a 	nor	r2,zero,r2
 1015ca4:	1000381e 	bne	r2,zero,1015d88 <__subdf3+0x624>
 1015ca8:	3463c83a 	sub	r17,r6,r17
 1015cac:	28c5c83a 	sub	r2,r5,r3
 1015cb0:	344d803a 	cmpltu	r6,r6,r17
 1015cb4:	1187c83a 	sub	r3,r2,r6
 1015cb8:	4821883a 	mov	r16,r9
 1015cbc:	3825883a 	mov	r18,r7
 1015cc0:	003f0606 	br	10158dc <__alt_data_end+0xff8158dc>
 1015cc4:	2023883a 	mov	r17,r4
 1015cc8:	003f0906 	br	10158f0 <__alt_data_end+0xff8158f0>
 1015ccc:	0101ffc4 	movi	r4,2047
 1015cd0:	813f3a1e 	bne	r16,r4,10159bc <__alt_data_end+0xff8159bc>
 1015cd4:	003ec406 	br	10157e8 <__alt_data_end+0xff8157e8>
 1015cd8:	0005883a 	mov	r2,zero
 1015cdc:	003fb106 	br	1015ba4 <__alt_data_end+0xff815ba4>
 1015ce0:	0005883a 	mov	r2,zero
 1015ce4:	003fbc06 	br	1015bd8 <__alt_data_end+0xff815bd8>
 1015ce8:	1c44b03a 	or	r2,r3,r17
 1015cec:	80008e1e 	bne	r16,zero,1015f28 <__subdf3+0x7c4>
 1015cf0:	1000c826 	beq	r2,zero,1016014 <__subdf3+0x8b0>
 1015cf4:	2984b03a 	or	r2,r5,r6
 1015cf8:	103ebb26 	beq	r2,zero,10157e8 <__alt_data_end+0xff8157e8>
 1015cfc:	8989883a 	add	r4,r17,r6
 1015d00:	1945883a 	add	r2,r3,r5
 1015d04:	2447803a 	cmpltu	r3,r4,r17
 1015d08:	1887883a 	add	r3,r3,r2
 1015d0c:	1880202c 	andhi	r2,r3,128
 1015d10:	2023883a 	mov	r17,r4
 1015d14:	103f1626 	beq	r2,zero,1015970 <__alt_data_end+0xff815970>
 1015d18:	00bfe034 	movhi	r2,65408
 1015d1c:	10bfffc4 	addi	r2,r2,-1
 1015d20:	5021883a 	mov	r16,r10
 1015d24:	1886703a 	and	r3,r3,r2
 1015d28:	003eaf06 	br	10157e8 <__alt_data_end+0xff8157e8>
 1015d2c:	3825883a 	mov	r18,r7
 1015d30:	003f0f06 	br	1015970 <__alt_data_end+0xff815970>
 1015d34:	1c44b03a 	or	r2,r3,r17
 1015d38:	8000251e 	bne	r16,zero,1015dd0 <__subdf3+0x66c>
 1015d3c:	1000661e 	bne	r2,zero,1015ed8 <__subdf3+0x774>
 1015d40:	2990b03a 	or	r8,r5,r6
 1015d44:	40009626 	beq	r8,zero,1015fa0 <__subdf3+0x83c>
 1015d48:	2807883a 	mov	r3,r5
 1015d4c:	3023883a 	mov	r17,r6
 1015d50:	3825883a 	mov	r18,r7
 1015d54:	003ea406 	br	10157e8 <__alt_data_end+0xff8157e8>
 1015d58:	127ff804 	addi	r9,r2,-32
 1015d5c:	01000804 	movi	r4,32
 1015d60:	2a52d83a 	srl	r9,r5,r9
 1015d64:	11008c26 	beq	r2,r4,1015f98 <__subdf3+0x834>
 1015d68:	01001004 	movi	r4,64
 1015d6c:	2085c83a 	sub	r2,r4,r2
 1015d70:	2884983a 	sll	r2,r5,r2
 1015d74:	118cb03a 	or	r6,r2,r6
 1015d78:	300cc03a 	cmpne	r6,r6,zero
 1015d7c:	4992b03a 	or	r9,r9,r6
 1015d80:	0005883a 	mov	r2,zero
 1015d84:	003f1206 	br	10159d0 <__alt_data_end+0xff8159d0>
 1015d88:	0101ffc4 	movi	r4,2047
 1015d8c:	493f9c1e 	bne	r9,r4,1015c00 <__alt_data_end+0xff815c00>
 1015d90:	2807883a 	mov	r3,r5
 1015d94:	3023883a 	mov	r17,r6
 1015d98:	4821883a 	mov	r16,r9
 1015d9c:	3825883a 	mov	r18,r7
 1015da0:	003e9106 	br	10157e8 <__alt_data_end+0xff8157e8>
 1015da4:	80001f1e 	bne	r16,zero,1015e24 <__subdf3+0x6c0>
 1015da8:	1c48b03a 	or	r4,r3,r17
 1015dac:	20005a26 	beq	r4,zero,1015f18 <__subdf3+0x7b4>
 1015db0:	0084303a 	nor	r2,zero,r2
 1015db4:	1000561e 	bne	r2,zero,1015f10 <__subdf3+0x7ac>
 1015db8:	89a3883a 	add	r17,r17,r6
 1015dbc:	1945883a 	add	r2,r3,r5
 1015dc0:	898d803a 	cmpltu	r6,r17,r6
 1015dc4:	3087883a 	add	r3,r6,r2
 1015dc8:	4821883a 	mov	r16,r9
 1015dcc:	003f0506 	br	10159e4 <__alt_data_end+0xff8159e4>
 1015dd0:	10002b1e 	bne	r2,zero,1015e80 <__subdf3+0x71c>
 1015dd4:	2984b03a 	or	r2,r5,r6
 1015dd8:	10008026 	beq	r2,zero,1015fdc <__subdf3+0x878>
 1015ddc:	2807883a 	mov	r3,r5
 1015de0:	3023883a 	mov	r17,r6
 1015de4:	3825883a 	mov	r18,r7
 1015de8:	0401ffc4 	movi	r16,2047
 1015dec:	003e7e06 	br	10157e8 <__alt_data_end+0xff8157e8>
 1015df0:	3809883a 	mov	r4,r7
 1015df4:	0011883a 	mov	r8,zero
 1015df8:	0005883a 	mov	r2,zero
 1015dfc:	003ee306 	br	101598c <__alt_data_end+0xff81598c>
 1015e00:	1c62b03a 	or	r17,r3,r17
 1015e04:	8822c03a 	cmpne	r17,r17,zero
 1015e08:	0005883a 	mov	r2,zero
 1015e0c:	003f8906 	br	1015c34 <__alt_data_end+0xff815c34>
 1015e10:	3809883a 	mov	r4,r7
 1015e14:	4821883a 	mov	r16,r9
 1015e18:	0011883a 	mov	r8,zero
 1015e1c:	0005883a 	mov	r2,zero
 1015e20:	003eda06 	br	101598c <__alt_data_end+0xff81598c>
 1015e24:	0101ffc4 	movi	r4,2047
 1015e28:	49003b26 	beq	r9,r4,1015f18 <__subdf3+0x7b4>
 1015e2c:	0085c83a 	sub	r2,zero,r2
 1015e30:	18c02034 	orhi	r3,r3,128
 1015e34:	01000e04 	movi	r4,56
 1015e38:	20806e16 	blt	r4,r2,1015ff4 <__subdf3+0x890>
 1015e3c:	010007c4 	movi	r4,31
 1015e40:	20807716 	blt	r4,r2,1016020 <__subdf3+0x8bc>
 1015e44:	01000804 	movi	r4,32
 1015e48:	2089c83a 	sub	r4,r4,r2
 1015e4c:	1914983a 	sll	r10,r3,r4
 1015e50:	8890d83a 	srl	r8,r17,r2
 1015e54:	8908983a 	sll	r4,r17,r4
 1015e58:	1884d83a 	srl	r2,r3,r2
 1015e5c:	5222b03a 	or	r17,r10,r8
 1015e60:	2006c03a 	cmpne	r3,r4,zero
 1015e64:	88e2b03a 	or	r17,r17,r3
 1015e68:	89a3883a 	add	r17,r17,r6
 1015e6c:	1145883a 	add	r2,r2,r5
 1015e70:	898d803a 	cmpltu	r6,r17,r6
 1015e74:	3087883a 	add	r3,r6,r2
 1015e78:	4821883a 	mov	r16,r9
 1015e7c:	003ed906 	br	10159e4 <__alt_data_end+0xff8159e4>
 1015e80:	2984b03a 	or	r2,r5,r6
 1015e84:	10004226 	beq	r2,zero,1015f90 <__subdf3+0x82c>
 1015e88:	1808d0fa 	srli	r4,r3,3
 1015e8c:	8822d0fa 	srli	r17,r17,3
 1015e90:	1806977a 	slli	r3,r3,29
 1015e94:	2080022c 	andhi	r2,r4,8
 1015e98:	1c62b03a 	or	r17,r3,r17
 1015e9c:	10000826 	beq	r2,zero,1015ec0 <__subdf3+0x75c>
 1015ea0:	2812d0fa 	srli	r9,r5,3
 1015ea4:	4880022c 	andhi	r2,r9,8
 1015ea8:	1000051e 	bne	r2,zero,1015ec0 <__subdf3+0x75c>
 1015eac:	300cd0fa 	srli	r6,r6,3
 1015eb0:	2804977a 	slli	r2,r5,29
 1015eb4:	4809883a 	mov	r4,r9
 1015eb8:	3825883a 	mov	r18,r7
 1015ebc:	11a2b03a 	or	r17,r2,r6
 1015ec0:	8806d77a 	srli	r3,r17,29
 1015ec4:	200890fa 	slli	r4,r4,3
 1015ec8:	882290fa 	slli	r17,r17,3
 1015ecc:	0401ffc4 	movi	r16,2047
 1015ed0:	1906b03a 	or	r3,r3,r4
 1015ed4:	003e4406 	br	10157e8 <__alt_data_end+0xff8157e8>
 1015ed8:	2984b03a 	or	r2,r5,r6
 1015edc:	103e4226 	beq	r2,zero,10157e8 <__alt_data_end+0xff8157e8>
 1015ee0:	8989c83a 	sub	r4,r17,r6
 1015ee4:	8911803a 	cmpltu	r8,r17,r4
 1015ee8:	1945c83a 	sub	r2,r3,r5
 1015eec:	1205c83a 	sub	r2,r2,r8
 1015ef0:	1200202c 	andhi	r8,r2,128
 1015ef4:	403e9a26 	beq	r8,zero,1015960 <__alt_data_end+0xff815960>
 1015ef8:	3463c83a 	sub	r17,r6,r17
 1015efc:	28c5c83a 	sub	r2,r5,r3
 1015f00:	344d803a 	cmpltu	r6,r6,r17
 1015f04:	1187c83a 	sub	r3,r2,r6
 1015f08:	3825883a 	mov	r18,r7
 1015f0c:	003e3606 	br	10157e8 <__alt_data_end+0xff8157e8>
 1015f10:	0101ffc4 	movi	r4,2047
 1015f14:	493fc71e 	bne	r9,r4,1015e34 <__alt_data_end+0xff815e34>
 1015f18:	2807883a 	mov	r3,r5
 1015f1c:	3023883a 	mov	r17,r6
 1015f20:	4821883a 	mov	r16,r9
 1015f24:	003e3006 	br	10157e8 <__alt_data_end+0xff8157e8>
 1015f28:	10003626 	beq	r2,zero,1016004 <__subdf3+0x8a0>
 1015f2c:	2984b03a 	or	r2,r5,r6
 1015f30:	10001726 	beq	r2,zero,1015f90 <__subdf3+0x82c>
 1015f34:	1808d0fa 	srli	r4,r3,3
 1015f38:	8822d0fa 	srli	r17,r17,3
 1015f3c:	1806977a 	slli	r3,r3,29
 1015f40:	2080022c 	andhi	r2,r4,8
 1015f44:	1c62b03a 	or	r17,r3,r17
 1015f48:	10000726 	beq	r2,zero,1015f68 <__subdf3+0x804>
 1015f4c:	2812d0fa 	srli	r9,r5,3
 1015f50:	4880022c 	andhi	r2,r9,8
 1015f54:	1000041e 	bne	r2,zero,1015f68 <__subdf3+0x804>
 1015f58:	300cd0fa 	srli	r6,r6,3
 1015f5c:	2804977a 	slli	r2,r5,29
 1015f60:	4809883a 	mov	r4,r9
 1015f64:	11a2b03a 	or	r17,r2,r6
 1015f68:	8806d77a 	srli	r3,r17,29
 1015f6c:	200890fa 	slli	r4,r4,3
 1015f70:	882290fa 	slli	r17,r17,3
 1015f74:	3825883a 	mov	r18,r7
 1015f78:	1906b03a 	or	r3,r3,r4
 1015f7c:	0401ffc4 	movi	r16,2047
 1015f80:	003e1906 	br	10157e8 <__alt_data_end+0xff8157e8>
 1015f84:	000b883a 	mov	r5,zero
 1015f88:	0005883a 	mov	r2,zero
 1015f8c:	003e2e06 	br	1015848 <__alt_data_end+0xff815848>
 1015f90:	0401ffc4 	movi	r16,2047
 1015f94:	003e1406 	br	10157e8 <__alt_data_end+0xff8157e8>
 1015f98:	0005883a 	mov	r2,zero
 1015f9c:	003f7506 	br	1015d74 <__alt_data_end+0xff815d74>
 1015fa0:	0005883a 	mov	r2,zero
 1015fa4:	0009883a 	mov	r4,zero
 1015fa8:	003e7806 	br	101598c <__alt_data_end+0xff81598c>
 1015fac:	123ff804 	addi	r8,r2,-32
 1015fb0:	01000804 	movi	r4,32
 1015fb4:	1a10d83a 	srl	r8,r3,r8
 1015fb8:	11002526 	beq	r2,r4,1016050 <__subdf3+0x8ec>
 1015fbc:	01001004 	movi	r4,64
 1015fc0:	2085c83a 	sub	r2,r4,r2
 1015fc4:	1884983a 	sll	r2,r3,r2
 1015fc8:	1444b03a 	or	r2,r2,r17
 1015fcc:	1004c03a 	cmpne	r2,r2,zero
 1015fd0:	40a2b03a 	or	r17,r8,r2
 1015fd4:	0005883a 	mov	r2,zero
 1015fd8:	003f1606 	br	1015c34 <__alt_data_end+0xff815c34>
 1015fdc:	02000434 	movhi	r8,16
 1015fe0:	0009883a 	mov	r4,zero
 1015fe4:	423fffc4 	addi	r8,r8,-1
 1015fe8:	00bfffc4 	movi	r2,-1
 1015fec:	0401ffc4 	movi	r16,2047
 1015ff0:	003e6606 	br	101598c <__alt_data_end+0xff81598c>
 1015ff4:	1c62b03a 	or	r17,r3,r17
 1015ff8:	8822c03a 	cmpne	r17,r17,zero
 1015ffc:	0005883a 	mov	r2,zero
 1016000:	003f9906 	br	1015e68 <__alt_data_end+0xff815e68>
 1016004:	2807883a 	mov	r3,r5
 1016008:	3023883a 	mov	r17,r6
 101600c:	0401ffc4 	movi	r16,2047
 1016010:	003df506 	br	10157e8 <__alt_data_end+0xff8157e8>
 1016014:	2807883a 	mov	r3,r5
 1016018:	3023883a 	mov	r17,r6
 101601c:	003df206 	br	10157e8 <__alt_data_end+0xff8157e8>
 1016020:	123ff804 	addi	r8,r2,-32
 1016024:	01000804 	movi	r4,32
 1016028:	1a10d83a 	srl	r8,r3,r8
 101602c:	11000a26 	beq	r2,r4,1016058 <__subdf3+0x8f4>
 1016030:	01001004 	movi	r4,64
 1016034:	2085c83a 	sub	r2,r4,r2
 1016038:	1884983a 	sll	r2,r3,r2
 101603c:	1444b03a 	or	r2,r2,r17
 1016040:	1004c03a 	cmpne	r2,r2,zero
 1016044:	40a2b03a 	or	r17,r8,r2
 1016048:	0005883a 	mov	r2,zero
 101604c:	003f8606 	br	1015e68 <__alt_data_end+0xff815e68>
 1016050:	0005883a 	mov	r2,zero
 1016054:	003fdc06 	br	1015fc8 <__alt_data_end+0xff815fc8>
 1016058:	0005883a 	mov	r2,zero
 101605c:	003ff706 	br	101603c <__alt_data_end+0xff81603c>

01016060 <__fixdfsi>:
 1016060:	280cd53a 	srli	r6,r5,20
 1016064:	00c00434 	movhi	r3,16
 1016068:	18ffffc4 	addi	r3,r3,-1
 101606c:	3181ffcc 	andi	r6,r6,2047
 1016070:	01c0ff84 	movi	r7,1022
 1016074:	28c6703a 	and	r3,r5,r3
 1016078:	280ad7fa 	srli	r5,r5,31
 101607c:	3980120e 	bge	r7,r6,10160c8 <__fixdfsi+0x68>
 1016080:	00810744 	movi	r2,1053
 1016084:	11800c16 	blt	r2,r6,10160b8 <__fixdfsi+0x58>
 1016088:	00810cc4 	movi	r2,1075
 101608c:	1185c83a 	sub	r2,r2,r6
 1016090:	01c007c4 	movi	r7,31
 1016094:	18c00434 	orhi	r3,r3,16
 1016098:	38800d16 	blt	r7,r2,10160d0 <__fixdfsi+0x70>
 101609c:	31befb44 	addi	r6,r6,-1043
 10160a0:	2084d83a 	srl	r2,r4,r2
 10160a4:	1986983a 	sll	r3,r3,r6
 10160a8:	1884b03a 	or	r2,r3,r2
 10160ac:	28000726 	beq	r5,zero,10160cc <__fixdfsi+0x6c>
 10160b0:	0085c83a 	sub	r2,zero,r2
 10160b4:	f800283a 	ret
 10160b8:	00a00034 	movhi	r2,32768
 10160bc:	10bfffc4 	addi	r2,r2,-1
 10160c0:	2885883a 	add	r2,r5,r2
 10160c4:	f800283a 	ret
 10160c8:	0005883a 	mov	r2,zero
 10160cc:	f800283a 	ret
 10160d0:	008104c4 	movi	r2,1043
 10160d4:	1185c83a 	sub	r2,r2,r6
 10160d8:	1884d83a 	srl	r2,r3,r2
 10160dc:	003ff306 	br	10160ac <__alt_data_end+0xff8160ac>

010160e0 <__floatsidf>:
 10160e0:	defffd04 	addi	sp,sp,-12
 10160e4:	dfc00215 	stw	ra,8(sp)
 10160e8:	dc400115 	stw	r17,4(sp)
 10160ec:	dc000015 	stw	r16,0(sp)
 10160f0:	20002b26 	beq	r4,zero,10161a0 <__floatsidf+0xc0>
 10160f4:	2023883a 	mov	r17,r4
 10160f8:	2020d7fa 	srli	r16,r4,31
 10160fc:	20002d16 	blt	r4,zero,10161b4 <__floatsidf+0xd4>
 1016100:	8809883a 	mov	r4,r17
 1016104:	10099700 	call	1009970 <__clzsi2>
 1016108:	01410784 	movi	r5,1054
 101610c:	288bc83a 	sub	r5,r5,r2
 1016110:	01010cc4 	movi	r4,1075
 1016114:	2149c83a 	sub	r4,r4,r5
 1016118:	00c007c4 	movi	r3,31
 101611c:	1900160e 	bge	r3,r4,1016178 <__floatsidf+0x98>
 1016120:	00c104c4 	movi	r3,1043
 1016124:	1947c83a 	sub	r3,r3,r5
 1016128:	88c6983a 	sll	r3,r17,r3
 101612c:	00800434 	movhi	r2,16
 1016130:	10bfffc4 	addi	r2,r2,-1
 1016134:	1886703a 	and	r3,r3,r2
 1016138:	2941ffcc 	andi	r5,r5,2047
 101613c:	800d883a 	mov	r6,r16
 1016140:	0005883a 	mov	r2,zero
 1016144:	280a953a 	slli	r5,r5,20
 1016148:	31803fcc 	andi	r6,r6,255
 101614c:	01000434 	movhi	r4,16
 1016150:	300c97fa 	slli	r6,r6,31
 1016154:	213fffc4 	addi	r4,r4,-1
 1016158:	1906703a 	and	r3,r3,r4
 101615c:	1946b03a 	or	r3,r3,r5
 1016160:	1986b03a 	or	r3,r3,r6
 1016164:	dfc00217 	ldw	ra,8(sp)
 1016168:	dc400117 	ldw	r17,4(sp)
 101616c:	dc000017 	ldw	r16,0(sp)
 1016170:	dec00304 	addi	sp,sp,12
 1016174:	f800283a 	ret
 1016178:	00c002c4 	movi	r3,11
 101617c:	1887c83a 	sub	r3,r3,r2
 1016180:	88c6d83a 	srl	r3,r17,r3
 1016184:	8904983a 	sll	r2,r17,r4
 1016188:	01000434 	movhi	r4,16
 101618c:	213fffc4 	addi	r4,r4,-1
 1016190:	2941ffcc 	andi	r5,r5,2047
 1016194:	1906703a 	and	r3,r3,r4
 1016198:	800d883a 	mov	r6,r16
 101619c:	003fe906 	br	1016144 <__alt_data_end+0xff816144>
 10161a0:	000d883a 	mov	r6,zero
 10161a4:	000b883a 	mov	r5,zero
 10161a8:	0007883a 	mov	r3,zero
 10161ac:	0005883a 	mov	r2,zero
 10161b0:	003fe406 	br	1016144 <__alt_data_end+0xff816144>
 10161b4:	0123c83a 	sub	r17,zero,r4
 10161b8:	003fd106 	br	1016100 <__alt_data_end+0xff816100>

010161bc <__floatunsidf>:
 10161bc:	defffe04 	addi	sp,sp,-8
 10161c0:	dc000015 	stw	r16,0(sp)
 10161c4:	dfc00115 	stw	ra,4(sp)
 10161c8:	2021883a 	mov	r16,r4
 10161cc:	20002226 	beq	r4,zero,1016258 <__floatunsidf+0x9c>
 10161d0:	10099700 	call	1009970 <__clzsi2>
 10161d4:	01010784 	movi	r4,1054
 10161d8:	2089c83a 	sub	r4,r4,r2
 10161dc:	01810cc4 	movi	r6,1075
 10161e0:	310dc83a 	sub	r6,r6,r4
 10161e4:	00c007c4 	movi	r3,31
 10161e8:	1980120e 	bge	r3,r6,1016234 <__floatunsidf+0x78>
 10161ec:	00c104c4 	movi	r3,1043
 10161f0:	1907c83a 	sub	r3,r3,r4
 10161f4:	80ca983a 	sll	r5,r16,r3
 10161f8:	00800434 	movhi	r2,16
 10161fc:	10bfffc4 	addi	r2,r2,-1
 1016200:	2101ffcc 	andi	r4,r4,2047
 1016204:	0021883a 	mov	r16,zero
 1016208:	288a703a 	and	r5,r5,r2
 101620c:	2008953a 	slli	r4,r4,20
 1016210:	00c00434 	movhi	r3,16
 1016214:	18ffffc4 	addi	r3,r3,-1
 1016218:	28c6703a 	and	r3,r5,r3
 101621c:	8005883a 	mov	r2,r16
 1016220:	1906b03a 	or	r3,r3,r4
 1016224:	dfc00117 	ldw	ra,4(sp)
 1016228:	dc000017 	ldw	r16,0(sp)
 101622c:	dec00204 	addi	sp,sp,8
 1016230:	f800283a 	ret
 1016234:	00c002c4 	movi	r3,11
 1016238:	188bc83a 	sub	r5,r3,r2
 101623c:	814ad83a 	srl	r5,r16,r5
 1016240:	00c00434 	movhi	r3,16
 1016244:	18ffffc4 	addi	r3,r3,-1
 1016248:	81a0983a 	sll	r16,r16,r6
 101624c:	2101ffcc 	andi	r4,r4,2047
 1016250:	28ca703a 	and	r5,r5,r3
 1016254:	003fed06 	br	101620c <__alt_data_end+0xff81620c>
 1016258:	0009883a 	mov	r4,zero
 101625c:	000b883a 	mov	r5,zero
 1016260:	003fea06 	br	101620c <__alt_data_end+0xff81620c>

01016264 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 1016264:	defffe04 	addi	sp,sp,-8
 1016268:	dfc00115 	stw	ra,4(sp)
 101626c:	df000015 	stw	fp,0(sp)
 1016270:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 1016274:	d0a02c17 	ldw	r2,-32592(gp)
 1016278:	10000326 	beq	r2,zero,1016288 <alt_get_errno+0x24>
 101627c:	d0a02c17 	ldw	r2,-32592(gp)
 1016280:	103ee83a 	callr	r2
 1016284:	00000106 	br	101628c <alt_get_errno+0x28>
 1016288:	d0a0ae04 	addi	r2,gp,-32072
}
 101628c:	e037883a 	mov	sp,fp
 1016290:	dfc00117 	ldw	ra,4(sp)
 1016294:	df000017 	ldw	fp,0(sp)
 1016298:	dec00204 	addi	sp,sp,8
 101629c:	f800283a 	ret

010162a0 <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
 10162a0:	defffb04 	addi	sp,sp,-20
 10162a4:	dfc00415 	stw	ra,16(sp)
 10162a8:	df000315 	stw	fp,12(sp)
 10162ac:	df000304 	addi	fp,sp,12
 10162b0:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
 10162b4:	e0bfff17 	ldw	r2,-4(fp)
 10162b8:	10000616 	blt	r2,zero,10162d4 <close+0x34>
 10162bc:	e0bfff17 	ldw	r2,-4(fp)
 10162c0:	10c00324 	muli	r3,r2,12
 10162c4:	008040b4 	movhi	r2,258
 10162c8:	10ae7a04 	addi	r2,r2,-17944
 10162cc:	1885883a 	add	r2,r3,r2
 10162d0:	00000106 	br	10162d8 <close+0x38>
 10162d4:	0005883a 	mov	r2,zero
 10162d8:	e0bffd15 	stw	r2,-12(fp)

  if (fd)
 10162dc:	e0bffd17 	ldw	r2,-12(fp)
 10162e0:	10001926 	beq	r2,zero,1016348 <close+0xa8>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
 10162e4:	e0bffd17 	ldw	r2,-12(fp)
 10162e8:	10800017 	ldw	r2,0(r2)
 10162ec:	10800417 	ldw	r2,16(r2)
 10162f0:	10000626 	beq	r2,zero,101630c <close+0x6c>
 10162f4:	e0bffd17 	ldw	r2,-12(fp)
 10162f8:	10800017 	ldw	r2,0(r2)
 10162fc:	10800417 	ldw	r2,16(r2)
 1016300:	e13ffd17 	ldw	r4,-12(fp)
 1016304:	103ee83a 	callr	r2
 1016308:	00000106 	br	1016310 <close+0x70>
 101630c:	0005883a 	mov	r2,zero
 1016310:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
 1016314:	e13fff17 	ldw	r4,-4(fp)
 1016318:	1016a240 	call	1016a24 <alt_release_fd>
    if (rval < 0)
 101631c:	e0bffe17 	ldw	r2,-8(fp)
 1016320:	1000070e 	bge	r2,zero,1016340 <close+0xa0>
    {
      ALT_ERRNO = -rval;
 1016324:	10162640 	call	1016264 <alt_get_errno>
 1016328:	1007883a 	mov	r3,r2
 101632c:	e0bffe17 	ldw	r2,-8(fp)
 1016330:	0085c83a 	sub	r2,zero,r2
 1016334:	18800015 	stw	r2,0(r3)
      return -1;
 1016338:	00bfffc4 	movi	r2,-1
 101633c:	00000706 	br	101635c <close+0xbc>
    }
    return 0;
 1016340:	0005883a 	mov	r2,zero
 1016344:	00000506 	br	101635c <close+0xbc>
  }
  else
  {
    ALT_ERRNO = EBADFD;
 1016348:	10162640 	call	1016264 <alt_get_errno>
 101634c:	1007883a 	mov	r3,r2
 1016350:	00801444 	movi	r2,81
 1016354:	18800015 	stw	r2,0(r3)
    return -1;
 1016358:	00bfffc4 	movi	r2,-1
  }
}
 101635c:	e037883a 	mov	sp,fp
 1016360:	dfc00117 	ldw	ra,4(sp)
 1016364:	df000017 	ldw	fp,0(sp)
 1016368:	dec00204 	addi	sp,sp,8
 101636c:	f800283a 	ret

01016370 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
 1016370:	defffc04 	addi	sp,sp,-16
 1016374:	df000315 	stw	fp,12(sp)
 1016378:	df000304 	addi	fp,sp,12
 101637c:	e13ffd15 	stw	r4,-12(fp)
 1016380:	e17ffe15 	stw	r5,-8(fp)
 1016384:	e1bfff15 	stw	r6,-4(fp)
  return len;
 1016388:	e0bfff17 	ldw	r2,-4(fp)
}
 101638c:	e037883a 	mov	sp,fp
 1016390:	df000017 	ldw	fp,0(sp)
 1016394:	dec00104 	addi	sp,sp,4
 1016398:	f800283a 	ret

0101639c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 101639c:	defffe04 	addi	sp,sp,-8
 10163a0:	dfc00115 	stw	ra,4(sp)
 10163a4:	df000015 	stw	fp,0(sp)
 10163a8:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 10163ac:	d0a02c17 	ldw	r2,-32592(gp)
 10163b0:	10000326 	beq	r2,zero,10163c0 <alt_get_errno+0x24>
 10163b4:	d0a02c17 	ldw	r2,-32592(gp)
 10163b8:	103ee83a 	callr	r2
 10163bc:	00000106 	br	10163c4 <alt_get_errno+0x28>
 10163c0:	d0a0ae04 	addi	r2,gp,-32072
}
 10163c4:	e037883a 	mov	sp,fp
 10163c8:	dfc00117 	ldw	ra,4(sp)
 10163cc:	df000017 	ldw	fp,0(sp)
 10163d0:	dec00204 	addi	sp,sp,8
 10163d4:	f800283a 	ret

010163d8 <fstat>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_FSTAT (int file, struct stat *st)
{
 10163d8:	defffb04 	addi	sp,sp,-20
 10163dc:	dfc00415 	stw	ra,16(sp)
 10163e0:	df000315 	stw	fp,12(sp)
 10163e4:	df000304 	addi	fp,sp,12
 10163e8:	e13ffe15 	stw	r4,-8(fp)
 10163ec:	e17fff15 	stw	r5,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 10163f0:	e0bffe17 	ldw	r2,-8(fp)
 10163f4:	10000616 	blt	r2,zero,1016410 <fstat+0x38>
 10163f8:	e0bffe17 	ldw	r2,-8(fp)
 10163fc:	10c00324 	muli	r3,r2,12
 1016400:	008040b4 	movhi	r2,258
 1016404:	10ae7a04 	addi	r2,r2,-17944
 1016408:	1885883a 	add	r2,r3,r2
 101640c:	00000106 	br	1016414 <fstat+0x3c>
 1016410:	0005883a 	mov	r2,zero
 1016414:	e0bffd15 	stw	r2,-12(fp)
  
  if (fd)
 1016418:	e0bffd17 	ldw	r2,-12(fp)
 101641c:	10001026 	beq	r2,zero,1016460 <fstat+0x88>
  {
    /* Call the drivers fstat() function to fill out the "st" structure. */

    if (fd->dev->fstat)
 1016420:	e0bffd17 	ldw	r2,-12(fp)
 1016424:	10800017 	ldw	r2,0(r2)
 1016428:	10800817 	ldw	r2,32(r2)
 101642c:	10000726 	beq	r2,zero,101644c <fstat+0x74>
    {
      return fd->dev->fstat(fd, st);
 1016430:	e0bffd17 	ldw	r2,-12(fp)
 1016434:	10800017 	ldw	r2,0(r2)
 1016438:	10800817 	ldw	r2,32(r2)
 101643c:	e17fff17 	ldw	r5,-4(fp)
 1016440:	e13ffd17 	ldw	r4,-12(fp)
 1016444:	103ee83a 	callr	r2
 1016448:	00000a06 	br	1016474 <fstat+0x9c>
     * device.
     */
 
    else
    {
      st->st_mode = _IFCHR;
 101644c:	e0bfff17 	ldw	r2,-4(fp)
 1016450:	00c80004 	movi	r3,8192
 1016454:	10c00115 	stw	r3,4(r2)
      return 0;
 1016458:	0005883a 	mov	r2,zero
 101645c:	00000506 	br	1016474 <fstat+0x9c>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
 1016460:	101639c0 	call	101639c <alt_get_errno>
 1016464:	1007883a 	mov	r3,r2
 1016468:	00801444 	movi	r2,81
 101646c:	18800015 	stw	r2,0(r3)
    return -1;
 1016470:	00bfffc4 	movi	r2,-1
  }
}
 1016474:	e037883a 	mov	sp,fp
 1016478:	dfc00117 	ldw	ra,4(sp)
 101647c:	df000017 	ldw	fp,0(sp)
 1016480:	dec00204 	addi	sp,sp,8
 1016484:	f800283a 	ret

01016488 <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
 1016488:	defff904 	addi	sp,sp,-28
 101648c:	dfc00615 	stw	ra,24(sp)
 1016490:	df000515 	stw	fp,20(sp)
 1016494:	df000504 	addi	fp,sp,20
 1016498:	e13ffc15 	stw	r4,-16(fp)
 101649c:	e17ffd15 	stw	r5,-12(fp)
 10164a0:	e1bffe15 	stw	r6,-8(fp)
 10164a4:	e1ffff15 	stw	r7,-4(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
 10164a8:	e0800217 	ldw	r2,8(fp)
 10164ac:	d8800015 	stw	r2,0(sp)
 10164b0:	e1ffff17 	ldw	r7,-4(fp)
 10164b4:	e1bffe17 	ldw	r6,-8(fp)
 10164b8:	e17ffd17 	ldw	r5,-12(fp)
 10164bc:	e13ffc17 	ldw	r4,-16(fp)
 10164c0:	1003e540 	call	1003e54 <alt_iic_isr_register>
}  
 10164c4:	e037883a 	mov	sp,fp
 10164c8:	dfc00117 	ldw	ra,4(sp)
 10164cc:	df000017 	ldw	fp,0(sp)
 10164d0:	dec00204 	addi	sp,sp,8
 10164d4:	f800283a 	ret

010164d8 <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
 10164d8:	defff904 	addi	sp,sp,-28
 10164dc:	df000615 	stw	fp,24(sp)
 10164e0:	df000604 	addi	fp,sp,24
 10164e4:	e13ffe15 	stw	r4,-8(fp)
 10164e8:	e17fff15 	stw	r5,-4(fp)
 10164ec:	e0bfff17 	ldw	r2,-4(fp)
 10164f0:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 10164f4:	0005303a 	rdctl	r2,status
 10164f8:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 10164fc:	e0fffb17 	ldw	r3,-20(fp)
 1016500:	00bfff84 	movi	r2,-2
 1016504:	1884703a 	and	r2,r3,r2
 1016508:	1001703a 	wrctl	status,r2
  
  return context;
 101650c:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 1016510:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active |= (1 << id);
 1016514:	00c00044 	movi	r3,1
 1016518:	e0bffa17 	ldw	r2,-24(fp)
 101651c:	1884983a 	sll	r2,r3,r2
 1016520:	1007883a 	mov	r3,r2
 1016524:	d0a0af17 	ldw	r2,-32068(gp)
 1016528:	1884b03a 	or	r2,r3,r2
 101652c:	d0a0af15 	stw	r2,-32068(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 1016530:	d0a0af17 	ldw	r2,-32068(gp)
 1016534:	100170fa 	wrctl	ienable,r2
 1016538:	e0bffc17 	ldw	r2,-16(fp)
 101653c:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 1016540:	e0bffd17 	ldw	r2,-12(fp)
 1016544:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 1016548:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
 101654c:	0001883a 	nop
}
 1016550:	e037883a 	mov	sp,fp
 1016554:	df000017 	ldw	fp,0(sp)
 1016558:	dec00104 	addi	sp,sp,4
 101655c:	f800283a 	ret

01016560 <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
 1016560:	defff904 	addi	sp,sp,-28
 1016564:	df000615 	stw	fp,24(sp)
 1016568:	df000604 	addi	fp,sp,24
 101656c:	e13ffe15 	stw	r4,-8(fp)
 1016570:	e17fff15 	stw	r5,-4(fp)
 1016574:	e0bfff17 	ldw	r2,-4(fp)
 1016578:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 101657c:	0005303a 	rdctl	r2,status
 1016580:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1016584:	e0fffb17 	ldw	r3,-20(fp)
 1016588:	00bfff84 	movi	r2,-2
 101658c:	1884703a 	and	r2,r3,r2
 1016590:	1001703a 	wrctl	status,r2
  
  return context;
 1016594:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 1016598:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active &= ~(1 << id);
 101659c:	00c00044 	movi	r3,1
 10165a0:	e0bffa17 	ldw	r2,-24(fp)
 10165a4:	1884983a 	sll	r2,r3,r2
 10165a8:	0084303a 	nor	r2,zero,r2
 10165ac:	1007883a 	mov	r3,r2
 10165b0:	d0a0af17 	ldw	r2,-32068(gp)
 10165b4:	1884703a 	and	r2,r3,r2
 10165b8:	d0a0af15 	stw	r2,-32068(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 10165bc:	d0a0af17 	ldw	r2,-32068(gp)
 10165c0:	100170fa 	wrctl	ienable,r2
 10165c4:	e0bffc17 	ldw	r2,-16(fp)
 10165c8:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 10165cc:	e0bffd17 	ldw	r2,-12(fp)
 10165d0:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 10165d4:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
 10165d8:	0001883a 	nop
}
 10165dc:	e037883a 	mov	sp,fp
 10165e0:	df000017 	ldw	fp,0(sp)
 10165e4:	dec00104 	addi	sp,sp,4
 10165e8:	f800283a 	ret

010165ec <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
 10165ec:	defffc04 	addi	sp,sp,-16
 10165f0:	df000315 	stw	fp,12(sp)
 10165f4:	df000304 	addi	fp,sp,12
 10165f8:	e13ffe15 	stw	r4,-8(fp)
 10165fc:	e17fff15 	stw	r5,-4(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
 1016600:	000530fa 	rdctl	r2,ienable
 1016604:	e0bffd15 	stw	r2,-12(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
 1016608:	00c00044 	movi	r3,1
 101660c:	e0bfff17 	ldw	r2,-4(fp)
 1016610:	1884983a 	sll	r2,r3,r2
 1016614:	1007883a 	mov	r3,r2
 1016618:	e0bffd17 	ldw	r2,-12(fp)
 101661c:	1884703a 	and	r2,r3,r2
 1016620:	1004c03a 	cmpne	r2,r2,zero
 1016624:	10803fcc 	andi	r2,r2,255
}
 1016628:	e037883a 	mov	sp,fp
 101662c:	df000017 	ldw	fp,0(sp)
 1016630:	dec00104 	addi	sp,sp,4
 1016634:	f800283a 	ret

01016638 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 1016638:	defffe04 	addi	sp,sp,-8
 101663c:	dfc00115 	stw	ra,4(sp)
 1016640:	df000015 	stw	fp,0(sp)
 1016644:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 1016648:	d0a02c17 	ldw	r2,-32592(gp)
 101664c:	10000326 	beq	r2,zero,101665c <alt_get_errno+0x24>
 1016650:	d0a02c17 	ldw	r2,-32592(gp)
 1016654:	103ee83a 	callr	r2
 1016658:	00000106 	br	1016660 <alt_get_errno+0x28>
 101665c:	d0a0ae04 	addi	r2,gp,-32072
}
 1016660:	e037883a 	mov	sp,fp
 1016664:	dfc00117 	ldw	ra,4(sp)
 1016668:	df000017 	ldw	fp,0(sp)
 101666c:	dec00204 	addi	sp,sp,8
 1016670:	f800283a 	ret

01016674 <isatty>:
 *
 * ALT_ISATTY is mapped onto the isatty() system call in alt_syscall.h
 */
 
int ALT_ISATTY (int file)
{
 1016674:	deffed04 	addi	sp,sp,-76
 1016678:	dfc01215 	stw	ra,72(sp)
 101667c:	df001115 	stw	fp,68(sp)
 1016680:	df001104 	addi	fp,sp,68
 1016684:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 1016688:	e0bfff17 	ldw	r2,-4(fp)
 101668c:	10000616 	blt	r2,zero,10166a8 <isatty+0x34>
 1016690:	e0bfff17 	ldw	r2,-4(fp)
 1016694:	10c00324 	muli	r3,r2,12
 1016698:	008040b4 	movhi	r2,258
 101669c:	10ae7a04 	addi	r2,r2,-17944
 10166a0:	1885883a 	add	r2,r3,r2
 10166a4:	00000106 	br	10166ac <isatty+0x38>
 10166a8:	0005883a 	mov	r2,zero
 10166ac:	e0bfef15 	stw	r2,-68(fp)
  
  if (fd)
 10166b0:	e0bfef17 	ldw	r2,-68(fp)
 10166b4:	10000e26 	beq	r2,zero,10166f0 <isatty+0x7c>
    /*
     * If a device driver does not provide an fstat() function, then it is 
     * treated as a terminal device by default.
     */

    if (!fd->dev->fstat)
 10166b8:	e0bfef17 	ldw	r2,-68(fp)
 10166bc:	10800017 	ldw	r2,0(r2)
 10166c0:	10800817 	ldw	r2,32(r2)
 10166c4:	1000021e 	bne	r2,zero,10166d0 <isatty+0x5c>
    {
      return 1;
 10166c8:	00800044 	movi	r2,1
 10166cc:	00000d06 	br	1016704 <isatty+0x90>
     * this is called so that the device can identify itself.
     */ 

    else
    {
      fstat (file, &stat);
 10166d0:	e0bff004 	addi	r2,fp,-64
 10166d4:	100b883a 	mov	r5,r2
 10166d8:	e13fff17 	ldw	r4,-4(fp)
 10166dc:	10163d80 	call	10163d8 <fstat>
      return (stat.st_mode == _IFCHR) ? 1 : 0;
 10166e0:	e0bff117 	ldw	r2,-60(fp)
 10166e4:	10880020 	cmpeqi	r2,r2,8192
 10166e8:	10803fcc 	andi	r2,r2,255
 10166ec:	00000506 	br	1016704 <isatty+0x90>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
 10166f0:	10166380 	call	1016638 <alt_get_errno>
 10166f4:	1007883a 	mov	r3,r2
 10166f8:	00801444 	movi	r2,81
 10166fc:	18800015 	stw	r2,0(r3)
    return 0;
 1016700:	0005883a 	mov	r2,zero
  }
}
 1016704:	e037883a 	mov	sp,fp
 1016708:	dfc00117 	ldw	ra,4(sp)
 101670c:	df000017 	ldw	fp,0(sp)
 1016710:	dec00204 	addi	sp,sp,8
 1016714:	f800283a 	ret

01016718 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 1016718:	defffe04 	addi	sp,sp,-8
 101671c:	dfc00115 	stw	ra,4(sp)
 1016720:	df000015 	stw	fp,0(sp)
 1016724:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 1016728:	d0a02c17 	ldw	r2,-32592(gp)
 101672c:	10000326 	beq	r2,zero,101673c <alt_get_errno+0x24>
 1016730:	d0a02c17 	ldw	r2,-32592(gp)
 1016734:	103ee83a 	callr	r2
 1016738:	00000106 	br	1016740 <alt_get_errno+0x28>
 101673c:	d0a0ae04 	addi	r2,gp,-32072
}
 1016740:	e037883a 	mov	sp,fp
 1016744:	dfc00117 	ldw	ra,4(sp)
 1016748:	df000017 	ldw	fp,0(sp)
 101674c:	dec00204 	addi	sp,sp,8
 1016750:	f800283a 	ret

01016754 <lseek>:
 * ALT_LSEEK is mapped onto the lseek() system call in alt_syscall.h
 *
 */

off_t ALT_LSEEK (int file, off_t ptr, int dir)
{
 1016754:	defff904 	addi	sp,sp,-28
 1016758:	dfc00615 	stw	ra,24(sp)
 101675c:	df000515 	stw	fp,20(sp)
 1016760:	df000504 	addi	fp,sp,20
 1016764:	e13ffd15 	stw	r4,-12(fp)
 1016768:	e17ffe15 	stw	r5,-8(fp)
 101676c:	e1bfff15 	stw	r6,-4(fp)
  alt_fd* fd;
  off_t   rc = 0; 
 1016770:	e03ffb15 	stw	zero,-20(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 1016774:	e0bffd17 	ldw	r2,-12(fp)
 1016778:	10000616 	blt	r2,zero,1016794 <lseek+0x40>
 101677c:	e0bffd17 	ldw	r2,-12(fp)
 1016780:	10c00324 	muli	r3,r2,12
 1016784:	008040b4 	movhi	r2,258
 1016788:	10ae7a04 	addi	r2,r2,-17944
 101678c:	1885883a 	add	r2,r3,r2
 1016790:	00000106 	br	1016798 <lseek+0x44>
 1016794:	0005883a 	mov	r2,zero
 1016798:	e0bffc15 	stw	r2,-16(fp)
  
  if (fd) 
 101679c:	e0bffc17 	ldw	r2,-16(fp)
 10167a0:	10001026 	beq	r2,zero,10167e4 <lseek+0x90>
    /*
     * If the device driver provides an implementation of the lseek() function,
     * then call that to process the request.
     */
 
    if (fd->dev->lseek)
 10167a4:	e0bffc17 	ldw	r2,-16(fp)
 10167a8:	10800017 	ldw	r2,0(r2)
 10167ac:	10800717 	ldw	r2,28(r2)
 10167b0:	10000926 	beq	r2,zero,10167d8 <lseek+0x84>
    {
      rc = fd->dev->lseek(fd, ptr, dir);
 10167b4:	e0bffc17 	ldw	r2,-16(fp)
 10167b8:	10800017 	ldw	r2,0(r2)
 10167bc:	10800717 	ldw	r2,28(r2)
 10167c0:	e1bfff17 	ldw	r6,-4(fp)
 10167c4:	e17ffe17 	ldw	r5,-8(fp)
 10167c8:	e13ffc17 	ldw	r4,-16(fp)
 10167cc:	103ee83a 	callr	r2
 10167d0:	e0bffb15 	stw	r2,-20(fp)
 10167d4:	00000506 	br	10167ec <lseek+0x98>
     * Otherwise return an error.
     */

    else
    {
      rc = -ENOTSUP;
 10167d8:	00bfde84 	movi	r2,-134
 10167dc:	e0bffb15 	stw	r2,-20(fp)
 10167e0:	00000206 	br	10167ec <lseek+0x98>
    }
  }
  else  
  {
    rc = -EBADFD;
 10167e4:	00bfebc4 	movi	r2,-81
 10167e8:	e0bffb15 	stw	r2,-20(fp)
  }

  if (rc < 0)
 10167ec:	e0bffb17 	ldw	r2,-20(fp)
 10167f0:	1000070e 	bge	r2,zero,1016810 <lseek+0xbc>
  {
    ALT_ERRNO = -rc;
 10167f4:	10167180 	call	1016718 <alt_get_errno>
 10167f8:	1007883a 	mov	r3,r2
 10167fc:	e0bffb17 	ldw	r2,-20(fp)
 1016800:	0085c83a 	sub	r2,zero,r2
 1016804:	18800015 	stw	r2,0(r3)
    rc = -1;
 1016808:	00bfffc4 	movi	r2,-1
 101680c:	e0bffb15 	stw	r2,-20(fp)
  }

  return rc;
 1016810:	e0bffb17 	ldw	r2,-20(fp)
}
 1016814:	e037883a 	mov	sp,fp
 1016818:	dfc00117 	ldw	ra,4(sp)
 101681c:	df000017 	ldw	fp,0(sp)
 1016820:	dec00204 	addi	sp,sp,8
 1016824:	f800283a 	ret

01016828 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
 1016828:	defffd04 	addi	sp,sp,-12
 101682c:	dfc00215 	stw	ra,8(sp)
 1016830:	df000115 	stw	fp,4(sp)
 1016834:	df000104 	addi	fp,sp,4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
 1016838:	0009883a 	mov	r4,zero
 101683c:	1016d040 	call	1016d04 <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();
 1016840:	0001883a 	nop
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
 1016844:	1016d3c0 	call	1016d3c <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
 1016848:	018040b4 	movhi	r6,258
 101684c:	31ab6a04 	addi	r6,r6,-21080
 1016850:	014040b4 	movhi	r5,258
 1016854:	296b6a04 	addi	r5,r5,-21080
 1016858:	010040b4 	movhi	r4,258
 101685c:	212b6a04 	addi	r4,r4,-21080
 1016860:	1019d680 	call	1019d68 <alt_io_redirect>
  /* 
   * Call the C++ constructors 
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling C++ constructors.\r\n");
  _do_ctors ();
 1016864:	1019a980 	call	1019a98 <_do_ctors>
   * redefined as _exit()). This is in the interest of reducing code footprint,
   * in that the atexit() overhead is removed when it's not needed.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling atexit.\r\n");
  atexit (_do_dtors);
 1016868:	010040b4 	movhi	r4,258
 101686c:	2126be04 	addi	r4,r4,-25864
 1016870:	101a3ac0 	call	101a3ac <atexit>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
 1016874:	d0a0b017 	ldw	r2,-32064(gp)
 1016878:	d0e0b117 	ldw	r3,-32060(gp)
 101687c:	d120b217 	ldw	r4,-32056(gp)
 1016880:	200d883a 	mov	r6,r4
 1016884:	180b883a 	mov	r5,r3
 1016888:	1009883a 	mov	r4,r2
 101688c:	10088840 	call	1008884 <main>
 1016890:	e0bfff15 	stw	r2,-4(fp)
  close(STDOUT_FILENO);
 1016894:	01000044 	movi	r4,1
 1016898:	10162a00 	call	10162a0 <close>
  exit (result);
 101689c:	e13fff17 	ldw	r4,-4(fp)
 10168a0:	101a3c00 	call	101a3c0 <exit>

010168a4 <__malloc_lock>:
 * configuration is single threaded, so there is nothing to do here. Note that 
 * this requires that malloc is never called by an interrupt service routine.
 */

void __malloc_lock ( struct _reent *_r )
{
 10168a4:	defffe04 	addi	sp,sp,-8
 10168a8:	df000115 	stw	fp,4(sp)
 10168ac:	df000104 	addi	fp,sp,4
 10168b0:	e13fff15 	stw	r4,-4(fp)
}
 10168b4:	0001883a 	nop
 10168b8:	e037883a 	mov	sp,fp
 10168bc:	df000017 	ldw	fp,0(sp)
 10168c0:	dec00104 	addi	sp,sp,4
 10168c4:	f800283a 	ret

010168c8 <__malloc_unlock>:
/*
 *
 */

void __malloc_unlock ( struct _reent *_r )
{
 10168c8:	defffe04 	addi	sp,sp,-8
 10168cc:	df000115 	stw	fp,4(sp)
 10168d0:	df000104 	addi	fp,sp,4
 10168d4:	e13fff15 	stw	r4,-4(fp)
}
 10168d8:	0001883a 	nop
 10168dc:	e037883a 	mov	sp,fp
 10168e0:	df000017 	ldw	fp,0(sp)
 10168e4:	dec00104 	addi	sp,sp,4
 10168e8:	f800283a 	ret

010168ec <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 10168ec:	defffe04 	addi	sp,sp,-8
 10168f0:	dfc00115 	stw	ra,4(sp)
 10168f4:	df000015 	stw	fp,0(sp)
 10168f8:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 10168fc:	d0a02c17 	ldw	r2,-32592(gp)
 1016900:	10000326 	beq	r2,zero,1016910 <alt_get_errno+0x24>
 1016904:	d0a02c17 	ldw	r2,-32592(gp)
 1016908:	103ee83a 	callr	r2
 101690c:	00000106 	br	1016914 <alt_get_errno+0x28>
 1016910:	d0a0ae04 	addi	r2,gp,-32072
}
 1016914:	e037883a 	mov	sp,fp
 1016918:	dfc00117 	ldw	ra,4(sp)
 101691c:	df000017 	ldw	fp,0(sp)
 1016920:	dec00204 	addi	sp,sp,8
 1016924:	f800283a 	ret

01016928 <read>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_READ (int file, void *ptr, size_t len)
{
 1016928:	defff904 	addi	sp,sp,-28
 101692c:	dfc00615 	stw	ra,24(sp)
 1016930:	df000515 	stw	fp,20(sp)
 1016934:	df000504 	addi	fp,sp,20
 1016938:	e13ffd15 	stw	r4,-12(fp)
 101693c:	e17ffe15 	stw	r5,-8(fp)
 1016940:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 1016944:	e0bffd17 	ldw	r2,-12(fp)
 1016948:	10000616 	blt	r2,zero,1016964 <read+0x3c>
 101694c:	e0bffd17 	ldw	r2,-12(fp)
 1016950:	10c00324 	muli	r3,r2,12
 1016954:	008040b4 	movhi	r2,258
 1016958:	10ae7a04 	addi	r2,r2,-17944
 101695c:	1885883a 	add	r2,r3,r2
 1016960:	00000106 	br	1016968 <read+0x40>
 1016964:	0005883a 	mov	r2,zero
 1016968:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
 101696c:	e0bffb17 	ldw	r2,-20(fp)
 1016970:	10002226 	beq	r2,zero,10169fc <read+0xd4>
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
 1016974:	e0bffb17 	ldw	r2,-20(fp)
 1016978:	10800217 	ldw	r2,8(r2)
 101697c:	108000cc 	andi	r2,r2,3
 1016980:	10800060 	cmpeqi	r2,r2,1
 1016984:	1000181e 	bne	r2,zero,10169e8 <read+0xc0>
        (fd->dev->read))
 1016988:	e0bffb17 	ldw	r2,-20(fp)
 101698c:	10800017 	ldw	r2,0(r2)
 1016990:	10800517 	ldw	r2,20(r2)
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
 1016994:	10001426 	beq	r2,zero,10169e8 <read+0xc0>
        (fd->dev->read))
      {
        if ((rval = fd->dev->read(fd, ptr, len)) < 0)
 1016998:	e0bffb17 	ldw	r2,-20(fp)
 101699c:	10800017 	ldw	r2,0(r2)
 10169a0:	10800517 	ldw	r2,20(r2)
 10169a4:	e0ffff17 	ldw	r3,-4(fp)
 10169a8:	180d883a 	mov	r6,r3
 10169ac:	e17ffe17 	ldw	r5,-8(fp)
 10169b0:	e13ffb17 	ldw	r4,-20(fp)
 10169b4:	103ee83a 	callr	r2
 10169b8:	e0bffc15 	stw	r2,-16(fp)
 10169bc:	e0bffc17 	ldw	r2,-16(fp)
 10169c0:	1000070e 	bge	r2,zero,10169e0 <read+0xb8>
        {
          ALT_ERRNO = -rval;
 10169c4:	10168ec0 	call	10168ec <alt_get_errno>
 10169c8:	1007883a 	mov	r3,r2
 10169cc:	e0bffc17 	ldw	r2,-16(fp)
 10169d0:	0085c83a 	sub	r2,zero,r2
 10169d4:	18800015 	stw	r2,0(r3)
          return -1;
 10169d8:	00bfffc4 	movi	r2,-1
 10169dc:	00000c06 	br	1016a10 <read+0xe8>
        }
        return rval;
 10169e0:	e0bffc17 	ldw	r2,-16(fp)
 10169e4:	00000a06 	br	1016a10 <read+0xe8>
      }
      else
      {
        ALT_ERRNO = EACCES;
 10169e8:	10168ec0 	call	10168ec <alt_get_errno>
 10169ec:	1007883a 	mov	r3,r2
 10169f0:	00800344 	movi	r2,13
 10169f4:	18800015 	stw	r2,0(r3)
 10169f8:	00000406 	br	1016a0c <read+0xe4>
      }
    }
  else
  {
    ALT_ERRNO = EBADFD;
 10169fc:	10168ec0 	call	10168ec <alt_get_errno>
 1016a00:	1007883a 	mov	r3,r2
 1016a04:	00801444 	movi	r2,81
 1016a08:	18800015 	stw	r2,0(r3)
  }
  return -1;
 1016a0c:	00bfffc4 	movi	r2,-1
}
 1016a10:	e037883a 	mov	sp,fp
 1016a14:	dfc00117 	ldw	ra,4(sp)
 1016a18:	df000017 	ldw	fp,0(sp)
 1016a1c:	dec00204 	addi	sp,sp,8
 1016a20:	f800283a 	ret

01016a24 <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
 1016a24:	defffe04 	addi	sp,sp,-8
 1016a28:	df000115 	stw	fp,4(sp)
 1016a2c:	df000104 	addi	fp,sp,4
 1016a30:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
 1016a34:	e0bfff17 	ldw	r2,-4(fp)
 1016a38:	108000d0 	cmplti	r2,r2,3
 1016a3c:	10000d1e 	bne	r2,zero,1016a74 <alt_release_fd+0x50>
  {
    alt_fd_list[fd].fd_flags = 0;
 1016a40:	008040b4 	movhi	r2,258
 1016a44:	10ae7a04 	addi	r2,r2,-17944
 1016a48:	e0ffff17 	ldw	r3,-4(fp)
 1016a4c:	18c00324 	muli	r3,r3,12
 1016a50:	10c5883a 	add	r2,r2,r3
 1016a54:	10800204 	addi	r2,r2,8
 1016a58:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
 1016a5c:	008040b4 	movhi	r2,258
 1016a60:	10ae7a04 	addi	r2,r2,-17944
 1016a64:	e0ffff17 	ldw	r3,-4(fp)
 1016a68:	18c00324 	muli	r3,r3,12
 1016a6c:	10c5883a 	add	r2,r2,r3
 1016a70:	10000015 	stw	zero,0(r2)
  }
}
 1016a74:	0001883a 	nop
 1016a78:	e037883a 	mov	sp,fp
 1016a7c:	df000017 	ldw	fp,0(sp)
 1016a80:	dec00104 	addi	sp,sp,4
 1016a84:	f800283a 	ret

01016a88 <alt_remap_cached>:
 * Return a pointer that should be used to access the cached memory.
 */

void* 
alt_remap_cached(volatile void* ptr, alt_u32 len)
{
 1016a88:	defffd04 	addi	sp,sp,-12
 1016a8c:	df000215 	stw	fp,8(sp)
 1016a90:	df000204 	addi	fp,sp,8
 1016a94:	e13ffe15 	stw	r4,-8(fp)
 1016a98:	e17fff15 	stw	r5,-4(fp)
#if ALT_CPU_DCACHE_SIZE > 0
#ifdef ALT_CPU_DCACHE_BYPASS_MASK
  return (void*) (((alt_u32)ptr) & ~ALT_CPU_DCACHE_BYPASS_MASK);
 1016a9c:	e0fffe17 	ldw	r3,-8(fp)
 1016aa0:	00a00034 	movhi	r2,32768
 1016aa4:	10bfffc4 	addi	r2,r2,-1
 1016aa8:	1884703a 	and	r2,r3,r2
#endif /* No address mask option enabled. */
#else /* No data cache */
  /* Nothing needs to be done to the pointer. */
  return (void*) ptr;
#endif /* No data cache */
}
 1016aac:	e037883a 	mov	sp,fp
 1016ab0:	df000017 	ldw	fp,0(sp)
 1016ab4:	dec00104 	addi	sp,sp,4
 1016ab8:	f800283a 	ret

01016abc <sbrk>:
#endif
 
caddr_t ALT_SBRK (int incr) __attribute__ ((no_instrument_function ));

caddr_t ALT_SBRK (int incr)
{ 
 1016abc:	defff904 	addi	sp,sp,-28
 1016ac0:	df000615 	stw	fp,24(sp)
 1016ac4:	df000604 	addi	fp,sp,24
 1016ac8:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1016acc:	0005303a 	rdctl	r2,status
 1016ad0:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1016ad4:	e0fffe17 	ldw	r3,-8(fp)
 1016ad8:	00bfff84 	movi	r2,-2
 1016adc:	1884703a 	and	r2,r3,r2
 1016ae0:	1001703a 	wrctl	status,r2
  
  return context;
 1016ae4:	e0bffe17 	ldw	r2,-8(fp)
  alt_irq_context context;
  char *prev_heap_end; 

  context = alt_irq_disable_all();
 1016ae8:	e0bffb15 	stw	r2,-20(fp)

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
 1016aec:	d0a02e17 	ldw	r2,-32584(gp)
 1016af0:	10c000c4 	addi	r3,r2,3
 1016af4:	00bfff04 	movi	r2,-4
 1016af8:	1884703a 	and	r2,r3,r2
 1016afc:	d0a02e15 	stw	r2,-32584(gp)
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
 1016b00:	d0e02e17 	ldw	r3,-32584(gp)
 1016b04:	e0bfff17 	ldw	r2,-4(fp)
 1016b08:	1887883a 	add	r3,r3,r2
 1016b0c:	00806034 	movhi	r2,384
 1016b10:	10800004 	addi	r2,r2,0
 1016b14:	10c0062e 	bgeu	r2,r3,1016b30 <sbrk+0x74>
 1016b18:	e0bffb17 	ldw	r2,-20(fp)
 1016b1c:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 1016b20:	e0bffa17 	ldw	r2,-24(fp)
 1016b24:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
    return (caddr_t)-1;
 1016b28:	00bfffc4 	movi	r2,-1
 1016b2c:	00000b06 	br	1016b5c <sbrk+0xa0>
  }
#endif

  prev_heap_end = heap_end; 
 1016b30:	d0a02e17 	ldw	r2,-32584(gp)
 1016b34:	e0bffd15 	stw	r2,-12(fp)
  heap_end += incr; 
 1016b38:	d0e02e17 	ldw	r3,-32584(gp)
 1016b3c:	e0bfff17 	ldw	r2,-4(fp)
 1016b40:	1885883a 	add	r2,r3,r2
 1016b44:	d0a02e15 	stw	r2,-32584(gp)
 1016b48:	e0bffb17 	ldw	r2,-20(fp)
 1016b4c:	e0bffc15 	stw	r2,-16(fp)
 1016b50:	e0bffc17 	ldw	r2,-16(fp)
 1016b54:	1001703a 	wrctl	status,r2

#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
 1016b58:	e0bffd17 	ldw	r2,-12(fp)
} 
 1016b5c:	e037883a 	mov	sp,fp
 1016b60:	df000017 	ldw	fp,0(sp)
 1016b64:	dec00104 	addi	sp,sp,4
 1016b68:	f800283a 	ret

01016b6c <usleep>:
#if defined (__GNUC__) && __GNUC__ >= 4
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
 1016b6c:	defffd04 	addi	sp,sp,-12
 1016b70:	dfc00215 	stw	ra,8(sp)
 1016b74:	df000115 	stw	fp,4(sp)
 1016b78:	df000104 	addi	fp,sp,4
 1016b7c:	e13fff15 	stw	r4,-4(fp)
  return alt_busy_sleep(us);
 1016b80:	e13fff17 	ldw	r4,-4(fp)
 1016b84:	10197e80 	call	10197e8 <alt_busy_sleep>
}
 1016b88:	e037883a 	mov	sp,fp
 1016b8c:	dfc00117 	ldw	ra,4(sp)
 1016b90:	df000017 	ldw	fp,0(sp)
 1016b94:	dec00204 	addi	sp,sp,8
 1016b98:	f800283a 	ret

01016b9c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 1016b9c:	defffe04 	addi	sp,sp,-8
 1016ba0:	dfc00115 	stw	ra,4(sp)
 1016ba4:	df000015 	stw	fp,0(sp)
 1016ba8:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 1016bac:	d0a02c17 	ldw	r2,-32592(gp)
 1016bb0:	10000326 	beq	r2,zero,1016bc0 <alt_get_errno+0x24>
 1016bb4:	d0a02c17 	ldw	r2,-32592(gp)
 1016bb8:	103ee83a 	callr	r2
 1016bbc:	00000106 	br	1016bc4 <alt_get_errno+0x28>
 1016bc0:	d0a0ae04 	addi	r2,gp,-32072
}
 1016bc4:	e037883a 	mov	sp,fp
 1016bc8:	dfc00117 	ldw	ra,4(sp)
 1016bcc:	df000017 	ldw	fp,0(sp)
 1016bd0:	dec00204 	addi	sp,sp,8
 1016bd4:	f800283a 	ret

01016bd8 <write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
 1016bd8:	defff904 	addi	sp,sp,-28
 1016bdc:	dfc00615 	stw	ra,24(sp)
 1016be0:	df000515 	stw	fp,20(sp)
 1016be4:	df000504 	addi	fp,sp,20
 1016be8:	e13ffd15 	stw	r4,-12(fp)
 1016bec:	e17ffe15 	stw	r5,-8(fp)
 1016bf0:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 1016bf4:	e0bffd17 	ldw	r2,-12(fp)
 1016bf8:	10000616 	blt	r2,zero,1016c14 <write+0x3c>
 1016bfc:	e0bffd17 	ldw	r2,-12(fp)
 1016c00:	10c00324 	muli	r3,r2,12
 1016c04:	008040b4 	movhi	r2,258
 1016c08:	10ae7a04 	addi	r2,r2,-17944
 1016c0c:	1885883a 	add	r2,r3,r2
 1016c10:	00000106 	br	1016c18 <write+0x40>
 1016c14:	0005883a 	mov	r2,zero
 1016c18:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
 1016c1c:	e0bffb17 	ldw	r2,-20(fp)
 1016c20:	10002126 	beq	r2,zero,1016ca8 <write+0xd0>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
 1016c24:	e0bffb17 	ldw	r2,-20(fp)
 1016c28:	10800217 	ldw	r2,8(r2)
 1016c2c:	108000cc 	andi	r2,r2,3
 1016c30:	10001826 	beq	r2,zero,1016c94 <write+0xbc>
 1016c34:	e0bffb17 	ldw	r2,-20(fp)
 1016c38:	10800017 	ldw	r2,0(r2)
 1016c3c:	10800617 	ldw	r2,24(r2)
 1016c40:	10001426 	beq	r2,zero,1016c94 <write+0xbc>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
 1016c44:	e0bffb17 	ldw	r2,-20(fp)
 1016c48:	10800017 	ldw	r2,0(r2)
 1016c4c:	10800617 	ldw	r2,24(r2)
 1016c50:	e0ffff17 	ldw	r3,-4(fp)
 1016c54:	180d883a 	mov	r6,r3
 1016c58:	e17ffe17 	ldw	r5,-8(fp)
 1016c5c:	e13ffb17 	ldw	r4,-20(fp)
 1016c60:	103ee83a 	callr	r2
 1016c64:	e0bffc15 	stw	r2,-16(fp)
 1016c68:	e0bffc17 	ldw	r2,-16(fp)
 1016c6c:	1000070e 	bge	r2,zero,1016c8c <write+0xb4>
      {
        ALT_ERRNO = -rval;
 1016c70:	1016b9c0 	call	1016b9c <alt_get_errno>
 1016c74:	1007883a 	mov	r3,r2
 1016c78:	e0bffc17 	ldw	r2,-16(fp)
 1016c7c:	0085c83a 	sub	r2,zero,r2
 1016c80:	18800015 	stw	r2,0(r3)
        return -1;
 1016c84:	00bfffc4 	movi	r2,-1
 1016c88:	00000c06 	br	1016cbc <write+0xe4>
      }
      return rval;
 1016c8c:	e0bffc17 	ldw	r2,-16(fp)
 1016c90:	00000a06 	br	1016cbc <write+0xe4>
    }
    else
    {
      ALT_ERRNO = EACCES;
 1016c94:	1016b9c0 	call	1016b9c <alt_get_errno>
 1016c98:	1007883a 	mov	r3,r2
 1016c9c:	00800344 	movi	r2,13
 1016ca0:	18800015 	stw	r2,0(r3)
 1016ca4:	00000406 	br	1016cb8 <write+0xe0>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
 1016ca8:	1016b9c0 	call	1016b9c <alt_get_errno>
 1016cac:	1007883a 	mov	r3,r2
 1016cb0:	00801444 	movi	r2,81
 1016cb4:	18800015 	stw	r2,0(r3)
  }
  return -1;
 1016cb8:	00bfffc4 	movi	r2,-1
}
 1016cbc:	e037883a 	mov	sp,fp
 1016cc0:	dfc00117 	ldw	ra,4(sp)
 1016cc4:	df000017 	ldw	fp,0(sp)
 1016cc8:	dec00204 	addi	sp,sp,8
 1016ccc:	f800283a 	ret

01016cd0 <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
 1016cd0:	defffd04 	addi	sp,sp,-12
 1016cd4:	dfc00215 	stw	ra,8(sp)
 1016cd8:	df000115 	stw	fp,4(sp)
 1016cdc:	df000104 	addi	fp,sp,4
 1016ce0:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
 1016ce4:	d1602904 	addi	r5,gp,-32604
 1016ce8:	e13fff17 	ldw	r4,-4(fp)
 1016cec:	10199f40 	call	10199f4 <alt_dev_llist_insert>
}
 1016cf0:	e037883a 	mov	sp,fp
 1016cf4:	dfc00117 	ldw	ra,4(sp)
 1016cf8:	df000017 	ldw	fp,0(sp)
 1016cfc:	dec00204 	addi	sp,sp,8
 1016d00:	f800283a 	ret

01016d04 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
 1016d04:	defffd04 	addi	sp,sp,-12
 1016d08:	dfc00215 	stw	ra,8(sp)
 1016d0c:	df000115 	stw	fp,4(sp)
 1016d10:	df000104 	addi	fp,sp,4
 1016d14:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( NIOS2_0, nios2_0);
 1016d18:	101a1dc0 	call	101a1dc <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
 1016d1c:	00800044 	movi	r2,1
 1016d20:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
 1016d24:	0001883a 	nop
 1016d28:	e037883a 	mov	sp,fp
 1016d2c:	dfc00117 	ldw	ra,4(sp)
 1016d30:	df000017 	ldw	fp,0(sp)
 1016d34:	dec00204 	addi	sp,sp,8
 1016d38:	f800283a 	ret

01016d3c <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
 1016d3c:	defffe04 	addi	sp,sp,-8
 1016d40:	dfc00115 	stw	ra,4(sp)
 1016d44:	df000015 	stw	fp,0(sp)
 1016d48:	d839883a 	mov	fp,sp
    ALTERA_AVALON_TIMER_INIT ( SYS_CLK_TIMER, sys_clk_timer);
 1016d4c:	01c0fa04 	movi	r7,1000
 1016d50:	018000c4 	movi	r6,3
 1016d54:	000b883a 	mov	r5,zero
 1016d58:	01068004 	movi	r4,6656
 1016d5c:	10178bc0 	call	10178bc <alt_avalon_timer_sc_init>
    ALTERA_AVALON_JTAG_UART_INIT ( JTAGUART_0, jtaguart_0);
 1016d60:	01800044 	movi	r6,1
 1016d64:	000b883a 	mov	r5,zero
 1016d68:	010040b4 	movhi	r4,258
 1016d6c:	212ee404 	addi	r4,r4,-17520
 1016d70:	1016f400 	call	1016f40 <altera_avalon_jtag_uart_init>
 1016d74:	010040b4 	movhi	r4,258
 1016d78:	212eda04 	addi	r4,r4,-17560
 1016d7c:	1016cd00 	call	1016cd0 <alt_dev_reg>
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID_QSYS_0, sysid_qsys_0);
 1016d80:	0001883a 	nop
    ALTERA_AVALON_UART_INIT ( UART, uart);
 1016d84:	01800084 	movi	r6,2
 1016d88:	000b883a 	mov	r5,zero
 1016d8c:	010040b4 	movhi	r4,258
 1016d90:	2132fc04 	addi	r4,r4,-13328
 1016d94:	1017a480 	call	1017a48 <altera_avalon_uart_init>
 1016d98:	010040b4 	movhi	r4,258
 1016d9c:	2132f204 	addi	r4,r4,-13368
 1016da0:	1016cd00 	call	1016cd0 <alt_dev_reg>
    ALTERA_MODULAR_ADC_INIT ( MODULAR_ADC_0, modular_adc_0);
 1016da4:	01800104 	movi	r6,4
 1016da8:	000b883a 	mov	r5,zero
 1016dac:	010040b4 	movhi	r4,258
 1016db0:	21332304 	addi	r4,r4,-13172
 1016db4:	10183640 	call	1018364 <altera_modular_adc_init>
    ALTERA_ONCHIP_FLASH_INIT ( ONCHIP_FLASH_0, onchip_flash_0);
 1016db8:	010040b4 	movhi	r4,258
 1016dbc:	21333204 	addi	r4,r4,-13112
 1016dc0:	10190300 	call	1019030 <altera_onchip_flash_init>
    ETH_OCM_INIT ( ETH_OCM_0, eth_ocm_0);
}
 1016dc4:	0001883a 	nop
 1016dc8:	e037883a 	mov	sp,fp
 1016dcc:	dfc00117 	ldw	ra,4(sp)
 1016dd0:	df000017 	ldw	fp,0(sp)
 1016dd4:	dec00204 	addi	sp,sp,8
 1016dd8:	f800283a 	ret

01016ddc <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
 1016ddc:	defffa04 	addi	sp,sp,-24
 1016de0:	dfc00515 	stw	ra,20(sp)
 1016de4:	df000415 	stw	fp,16(sp)
 1016de8:	df000404 	addi	fp,sp,16
 1016dec:	e13ffd15 	stw	r4,-12(fp)
 1016df0:	e17ffe15 	stw	r5,-8(fp)
 1016df4:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 1016df8:	e0bffd17 	ldw	r2,-12(fp)
 1016dfc:	10800017 	ldw	r2,0(r2)
 1016e00:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
 1016e04:	e0bffc17 	ldw	r2,-16(fp)
 1016e08:	10c00a04 	addi	r3,r2,40
 1016e0c:	e0bffd17 	ldw	r2,-12(fp)
 1016e10:	10800217 	ldw	r2,8(r2)
 1016e14:	100f883a 	mov	r7,r2
 1016e18:	e1bfff17 	ldw	r6,-4(fp)
 1016e1c:	e17ffe17 	ldw	r5,-8(fp)
 1016e20:	1809883a 	mov	r4,r3
 1016e24:	10174040 	call	1017404 <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
 1016e28:	e037883a 	mov	sp,fp
 1016e2c:	dfc00117 	ldw	ra,4(sp)
 1016e30:	df000017 	ldw	fp,0(sp)
 1016e34:	dec00204 	addi	sp,sp,8
 1016e38:	f800283a 	ret

01016e3c <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
 1016e3c:	defffa04 	addi	sp,sp,-24
 1016e40:	dfc00515 	stw	ra,20(sp)
 1016e44:	df000415 	stw	fp,16(sp)
 1016e48:	df000404 	addi	fp,sp,16
 1016e4c:	e13ffd15 	stw	r4,-12(fp)
 1016e50:	e17ffe15 	stw	r5,-8(fp)
 1016e54:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 1016e58:	e0bffd17 	ldw	r2,-12(fp)
 1016e5c:	10800017 	ldw	r2,0(r2)
 1016e60:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
 1016e64:	e0bffc17 	ldw	r2,-16(fp)
 1016e68:	10c00a04 	addi	r3,r2,40
 1016e6c:	e0bffd17 	ldw	r2,-12(fp)
 1016e70:	10800217 	ldw	r2,8(r2)
 1016e74:	100f883a 	mov	r7,r2
 1016e78:	e1bfff17 	ldw	r6,-4(fp)
 1016e7c:	e17ffe17 	ldw	r5,-8(fp)
 1016e80:	1809883a 	mov	r4,r3
 1016e84:	10176200 	call	1017620 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
 1016e88:	e037883a 	mov	sp,fp
 1016e8c:	dfc00117 	ldw	ra,4(sp)
 1016e90:	df000017 	ldw	fp,0(sp)
 1016e94:	dec00204 	addi	sp,sp,8
 1016e98:	f800283a 	ret

01016e9c <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
 1016e9c:	defffc04 	addi	sp,sp,-16
 1016ea0:	dfc00315 	stw	ra,12(sp)
 1016ea4:	df000215 	stw	fp,8(sp)
 1016ea8:	df000204 	addi	fp,sp,8
 1016eac:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 1016eb0:	e0bfff17 	ldw	r2,-4(fp)
 1016eb4:	10800017 	ldw	r2,0(r2)
 1016eb8:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
 1016ebc:	e0bffe17 	ldw	r2,-8(fp)
 1016ec0:	10c00a04 	addi	r3,r2,40
 1016ec4:	e0bfff17 	ldw	r2,-4(fp)
 1016ec8:	10800217 	ldw	r2,8(r2)
 1016ecc:	100b883a 	mov	r5,r2
 1016ed0:	1809883a 	mov	r4,r3
 1016ed4:	10172ac0 	call	10172ac <altera_avalon_jtag_uart_close>
}
 1016ed8:	e037883a 	mov	sp,fp
 1016edc:	dfc00117 	ldw	ra,4(sp)
 1016ee0:	df000017 	ldw	fp,0(sp)
 1016ee4:	dec00204 	addi	sp,sp,8
 1016ee8:	f800283a 	ret

01016eec <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
 1016eec:	defffa04 	addi	sp,sp,-24
 1016ef0:	dfc00515 	stw	ra,20(sp)
 1016ef4:	df000415 	stw	fp,16(sp)
 1016ef8:	df000404 	addi	fp,sp,16
 1016efc:	e13ffd15 	stw	r4,-12(fp)
 1016f00:	e17ffe15 	stw	r5,-8(fp)
 1016f04:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
 1016f08:	e0bffd17 	ldw	r2,-12(fp)
 1016f0c:	10800017 	ldw	r2,0(r2)
 1016f10:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
 1016f14:	e0bffc17 	ldw	r2,-16(fp)
 1016f18:	10800a04 	addi	r2,r2,40
 1016f1c:	e1bfff17 	ldw	r6,-4(fp)
 1016f20:	e17ffe17 	ldw	r5,-8(fp)
 1016f24:	1009883a 	mov	r4,r2
 1016f28:	10173140 	call	1017314 <altera_avalon_jtag_uart_ioctl>
}
 1016f2c:	e037883a 	mov	sp,fp
 1016f30:	dfc00117 	ldw	ra,4(sp)
 1016f34:	df000017 	ldw	fp,0(sp)
 1016f38:	dec00204 	addi	sp,sp,8
 1016f3c:	f800283a 	ret

01016f40 <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
 1016f40:	defffa04 	addi	sp,sp,-24
 1016f44:	dfc00515 	stw	ra,20(sp)
 1016f48:	df000415 	stw	fp,16(sp)
 1016f4c:	df000404 	addi	fp,sp,16
 1016f50:	e13ffd15 	stw	r4,-12(fp)
 1016f54:	e17ffe15 	stw	r5,-8(fp)
 1016f58:	e1bfff15 	stw	r6,-4(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
  ALT_SEM_CREATE(&sp->read_lock, 1);
  ALT_SEM_CREATE(&sp->write_lock, 1);

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 1016f5c:	e0bffd17 	ldw	r2,-12(fp)
 1016f60:	00c00044 	movi	r3,1
 1016f64:	10c00815 	stw	r3,32(r2)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
 1016f68:	e0bffd17 	ldw	r2,-12(fp)
 1016f6c:	10800017 	ldw	r2,0(r2)
 1016f70:	10800104 	addi	r2,r2,4
 1016f74:	1007883a 	mov	r3,r2
 1016f78:	e0bffd17 	ldw	r2,-12(fp)
 1016f7c:	10800817 	ldw	r2,32(r2)
 1016f80:	18800035 	stwio	r2,0(r3)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
 1016f84:	e0bffe17 	ldw	r2,-8(fp)
 1016f88:	e0ffff17 	ldw	r3,-4(fp)
 1016f8c:	d8000015 	stw	zero,0(sp)
 1016f90:	e1fffd17 	ldw	r7,-12(fp)
 1016f94:	01804074 	movhi	r6,257
 1016f98:	319c0004 	addi	r6,r6,28672
 1016f9c:	180b883a 	mov	r5,r3
 1016fa0:	1009883a 	mov	r4,r2
 1016fa4:	10164880 	call	1016488 <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
 1016fa8:	e0bffd17 	ldw	r2,-12(fp)
 1016fac:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
 1016fb0:	e0bffd17 	ldw	r2,-12(fp)
 1016fb4:	10800204 	addi	r2,r2,8
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 1016fb8:	d0e0b317 	ldw	r3,-32052(gp)
 1016fbc:	e1fffd17 	ldw	r7,-12(fp)
 1016fc0:	01804074 	movhi	r6,257
 1016fc4:	319c8304 	addi	r6,r6,29196
 1016fc8:	180b883a 	mov	r5,r3
 1016fcc:	1009883a 	mov	r4,r2
 1016fd0:	10196bc0 	call	10196bc <alt_alarm_start>
 1016fd4:	1000040e 	bge	r2,zero,1016fe8 <altera_avalon_jtag_uart_init+0xa8>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
 1016fd8:	e0fffd17 	ldw	r3,-12(fp)
 1016fdc:	00a00034 	movhi	r2,32768
 1016fe0:	10bfffc4 	addi	r2,r2,-1
 1016fe4:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
}
 1016fe8:	0001883a 	nop
 1016fec:	e037883a 	mov	sp,fp
 1016ff0:	dfc00117 	ldw	ra,4(sp)
 1016ff4:	df000017 	ldw	fp,0(sp)
 1016ff8:	dec00204 	addi	sp,sp,8
 1016ffc:	f800283a 	ret

01017000 <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
 1017000:	defff804 	addi	sp,sp,-32
 1017004:	df000715 	stw	fp,28(sp)
 1017008:	df000704 	addi	fp,sp,28
 101700c:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
 1017010:	e0bfff17 	ldw	r2,-4(fp)
 1017014:	e0bffb15 	stw	r2,-20(fp)
  unsigned int base = sp->base;
 1017018:	e0bffb17 	ldw	r2,-20(fp)
 101701c:	10800017 	ldw	r2,0(r2)
 1017020:	e0bffc15 	stw	r2,-16(fp)
  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 1017024:	e0bffc17 	ldw	r2,-16(fp)
 1017028:	10800104 	addi	r2,r2,4
 101702c:	10800037 	ldwio	r2,0(r2)
 1017030:	e0bffd15 	stw	r2,-12(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
 1017034:	e0bffd17 	ldw	r2,-12(fp)
 1017038:	1080c00c 	andi	r2,r2,768
 101703c:	10006d26 	beq	r2,zero,10171f4 <altera_avalon_jtag_uart_irq+0x1f4>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
 1017040:	e0bffd17 	ldw	r2,-12(fp)
 1017044:	1080400c 	andi	r2,r2,256
 1017048:	10003526 	beq	r2,zero,1017120 <altera_avalon_jtag_uart_irq+0x120>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
 101704c:	00800074 	movhi	r2,1
 1017050:	e0bff915 	stw	r2,-28(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 1017054:	e0bffb17 	ldw	r2,-20(fp)
 1017058:	10800a17 	ldw	r2,40(r2)
 101705c:	10800044 	addi	r2,r2,1
 1017060:	1081ffcc 	andi	r2,r2,2047
 1017064:	e0bffe15 	stw	r2,-8(fp)
        if (next == sp->rx_out)
 1017068:	e0bffb17 	ldw	r2,-20(fp)
 101706c:	10c00b17 	ldw	r3,44(r2)
 1017070:	e0bffe17 	ldw	r2,-8(fp)
 1017074:	18801526 	beq	r3,r2,10170cc <altera_avalon_jtag_uart_irq+0xcc>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
 1017078:	e0bffc17 	ldw	r2,-16(fp)
 101707c:	10800037 	ldwio	r2,0(r2)
 1017080:	e0bff915 	stw	r2,-28(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
 1017084:	e0bff917 	ldw	r2,-28(fp)
 1017088:	10a0000c 	andi	r2,r2,32768
 101708c:	10001126 	beq	r2,zero,10170d4 <altera_avalon_jtag_uart_irq+0xd4>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
 1017090:	e0bffb17 	ldw	r2,-20(fp)
 1017094:	10800a17 	ldw	r2,40(r2)
 1017098:	e0fff917 	ldw	r3,-28(fp)
 101709c:	1809883a 	mov	r4,r3
 10170a0:	e0fffb17 	ldw	r3,-20(fp)
 10170a4:	1885883a 	add	r2,r3,r2
 10170a8:	10800e04 	addi	r2,r2,56
 10170ac:	11000005 	stb	r4,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 10170b0:	e0bffb17 	ldw	r2,-20(fp)
 10170b4:	10800a17 	ldw	r2,40(r2)
 10170b8:	10800044 	addi	r2,r2,1
 10170bc:	10c1ffcc 	andi	r3,r2,2047
 10170c0:	e0bffb17 	ldw	r2,-20(fp)
 10170c4:	10c00a15 	stw	r3,40(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }
 10170c8:	003fe206 	br	1017054 <__alt_data_end+0xff817054>
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
        if (next == sp->rx_out)
          break;
 10170cc:	0001883a 	nop
 10170d0:	00000106 	br	10170d8 <altera_avalon_jtag_uart_irq+0xd8>
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
          break;
 10170d4:	0001883a 	nop

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
 10170d8:	e0bff917 	ldw	r2,-28(fp)
 10170dc:	10bfffec 	andhi	r2,r2,65535
 10170e0:	10000f26 	beq	r2,zero,1017120 <altera_avalon_jtag_uart_irq+0x120>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 10170e4:	e0bffb17 	ldw	r2,-20(fp)
 10170e8:	10c00817 	ldw	r3,32(r2)
 10170ec:	00bfff84 	movi	r2,-2
 10170f0:	1886703a 	and	r3,r3,r2
 10170f4:	e0bffb17 	ldw	r2,-20(fp)
 10170f8:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
 10170fc:	e0bffc17 	ldw	r2,-16(fp)
 1017100:	10800104 	addi	r2,r2,4
 1017104:	1007883a 	mov	r3,r2
 1017108:	e0bffb17 	ldw	r2,-20(fp)
 101710c:	10800817 	ldw	r2,32(r2)
 1017110:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 1017114:	e0bffc17 	ldw	r2,-16(fp)
 1017118:	10800104 	addi	r2,r2,4
 101711c:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
 1017120:	e0bffd17 	ldw	r2,-12(fp)
 1017124:	1080800c 	andi	r2,r2,512
 1017128:	103fbe26 	beq	r2,zero,1017024 <__alt_data_end+0xff817024>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
 101712c:	e0bffd17 	ldw	r2,-12(fp)
 1017130:	1004d43a 	srli	r2,r2,16
 1017134:	e0bffa15 	stw	r2,-24(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
 1017138:	00001406 	br	101718c <altera_avalon_jtag_uart_irq+0x18c>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
 101713c:	e0bffc17 	ldw	r2,-16(fp)
 1017140:	e0fffb17 	ldw	r3,-20(fp)
 1017144:	18c00d17 	ldw	r3,52(r3)
 1017148:	e13ffb17 	ldw	r4,-20(fp)
 101714c:	20c7883a 	add	r3,r4,r3
 1017150:	18c20e04 	addi	r3,r3,2104
 1017154:	18c00003 	ldbu	r3,0(r3)
 1017158:	18c03fcc 	andi	r3,r3,255
 101715c:	18c0201c 	xori	r3,r3,128
 1017160:	18ffe004 	addi	r3,r3,-128
 1017164:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 1017168:	e0bffb17 	ldw	r2,-20(fp)
 101716c:	10800d17 	ldw	r2,52(r2)
 1017170:	10800044 	addi	r2,r2,1
 1017174:	10c1ffcc 	andi	r3,r2,2047
 1017178:	e0bffb17 	ldw	r2,-20(fp)
 101717c:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
 1017180:	e0bffa17 	ldw	r2,-24(fp)
 1017184:	10bfffc4 	addi	r2,r2,-1
 1017188:	e0bffa15 	stw	r2,-24(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
 101718c:	e0bffa17 	ldw	r2,-24(fp)
 1017190:	10000526 	beq	r2,zero,10171a8 <altera_avalon_jtag_uart_irq+0x1a8>
 1017194:	e0bffb17 	ldw	r2,-20(fp)
 1017198:	10c00d17 	ldw	r3,52(r2)
 101719c:	e0bffb17 	ldw	r2,-20(fp)
 10171a0:	10800c17 	ldw	r2,48(r2)
 10171a4:	18bfe51e 	bne	r3,r2,101713c <__alt_data_end+0xff81713c>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
 10171a8:	e0bffa17 	ldw	r2,-24(fp)
 10171ac:	103f9d26 	beq	r2,zero,1017024 <__alt_data_end+0xff817024>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 10171b0:	e0bffb17 	ldw	r2,-20(fp)
 10171b4:	10c00817 	ldw	r3,32(r2)
 10171b8:	00bfff44 	movi	r2,-3
 10171bc:	1886703a 	and	r3,r3,r2
 10171c0:	e0bffb17 	ldw	r2,-20(fp)
 10171c4:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 10171c8:	e0bffb17 	ldw	r2,-20(fp)
 10171cc:	10800017 	ldw	r2,0(r2)
 10171d0:	10800104 	addi	r2,r2,4
 10171d4:	1007883a 	mov	r3,r2
 10171d8:	e0bffb17 	ldw	r2,-20(fp)
 10171dc:	10800817 	ldw	r2,32(r2)
 10171e0:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 10171e4:	e0bffc17 	ldw	r2,-16(fp)
 10171e8:	10800104 	addi	r2,r2,4
 10171ec:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
 10171f0:	003f8c06 	br	1017024 <__alt_data_end+0xff817024>
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
      break;
 10171f4:	0001883a 	nop
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
      }
    }
  }
}
 10171f8:	0001883a 	nop
 10171fc:	e037883a 	mov	sp,fp
 1017200:	df000017 	ldw	fp,0(sp)
 1017204:	dec00104 	addi	sp,sp,4
 1017208:	f800283a 	ret

0101720c <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
 101720c:	defff804 	addi	sp,sp,-32
 1017210:	df000715 	stw	fp,28(sp)
 1017214:	df000704 	addi	fp,sp,28
 1017218:	e13ffb15 	stw	r4,-20(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
 101721c:	e0bffb17 	ldw	r2,-20(fp)
 1017220:	e0bff915 	stw	r2,-28(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
 1017224:	e0bff917 	ldw	r2,-28(fp)
 1017228:	10800017 	ldw	r2,0(r2)
 101722c:	10800104 	addi	r2,r2,4
 1017230:	10800037 	ldwio	r2,0(r2)
 1017234:	e0bffa15 	stw	r2,-24(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
 1017238:	e0bffa17 	ldw	r2,-24(fp)
 101723c:	1081000c 	andi	r2,r2,1024
 1017240:	10000b26 	beq	r2,zero,1017270 <altera_avalon_jtag_uart_timeout+0x64>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
 1017244:	e0bff917 	ldw	r2,-28(fp)
 1017248:	10800017 	ldw	r2,0(r2)
 101724c:	10800104 	addi	r2,r2,4
 1017250:	1007883a 	mov	r3,r2
 1017254:	e0bff917 	ldw	r2,-28(fp)
 1017258:	10800817 	ldw	r2,32(r2)
 101725c:	10810014 	ori	r2,r2,1024
 1017260:	18800035 	stwio	r2,0(r3)
    sp->host_inactive = 0;
 1017264:	e0bff917 	ldw	r2,-28(fp)
 1017268:	10000915 	stw	zero,36(r2)
 101726c:	00000a06 	br	1017298 <altera_avalon_jtag_uart_timeout+0x8c>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
 1017270:	e0bff917 	ldw	r2,-28(fp)
 1017274:	10c00917 	ldw	r3,36(r2)
 1017278:	00a00034 	movhi	r2,32768
 101727c:	10bfff04 	addi	r2,r2,-4
 1017280:	10c00536 	bltu	r2,r3,1017298 <altera_avalon_jtag_uart_timeout+0x8c>
    sp->host_inactive++;
 1017284:	e0bff917 	ldw	r2,-28(fp)
 1017288:	10800917 	ldw	r2,36(r2)
 101728c:	10c00044 	addi	r3,r2,1
 1017290:	e0bff917 	ldw	r2,-28(fp)
 1017294:	10c00915 	stw	r3,36(r2)
 1017298:	d0a0b317 	ldw	r2,-32052(gp)
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
    }
  }

  return alt_ticks_per_second();
}
 101729c:	e037883a 	mov	sp,fp
 10172a0:	df000017 	ldw	fp,0(sp)
 10172a4:	dec00104 	addi	sp,sp,4
 10172a8:	f800283a 	ret

010172ac <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
 10172ac:	defffd04 	addi	sp,sp,-12
 10172b0:	df000215 	stw	fp,8(sp)
 10172b4:	df000204 	addi	fp,sp,8
 10172b8:	e13ffe15 	stw	r4,-8(fp)
 10172bc:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 10172c0:	00000506 	br	10172d8 <altera_avalon_jtag_uart_close+0x2c>
    if (flags & O_NONBLOCK) {
 10172c4:	e0bfff17 	ldw	r2,-4(fp)
 10172c8:	1090000c 	andi	r2,r2,16384
 10172cc:	10000226 	beq	r2,zero,10172d8 <altera_avalon_jtag_uart_close+0x2c>
      return -EWOULDBLOCK; 
 10172d0:	00bffd44 	movi	r2,-11
 10172d4:	00000b06 	br	1017304 <altera_avalon_jtag_uart_close+0x58>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 10172d8:	e0bffe17 	ldw	r2,-8(fp)
 10172dc:	10c00d17 	ldw	r3,52(r2)
 10172e0:	e0bffe17 	ldw	r2,-8(fp)
 10172e4:	10800c17 	ldw	r2,48(r2)
 10172e8:	18800526 	beq	r3,r2,1017300 <altera_avalon_jtag_uart_close+0x54>
 10172ec:	e0bffe17 	ldw	r2,-8(fp)
 10172f0:	10c00917 	ldw	r3,36(r2)
 10172f4:	e0bffe17 	ldw	r2,-8(fp)
 10172f8:	10800117 	ldw	r2,4(r2)
 10172fc:	18bff136 	bltu	r3,r2,10172c4 <__alt_data_end+0xff8172c4>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
 1017300:	0005883a 	mov	r2,zero
}
 1017304:	e037883a 	mov	sp,fp
 1017308:	df000017 	ldw	fp,0(sp)
 101730c:	dec00104 	addi	sp,sp,4
 1017310:	f800283a 	ret

01017314 <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
 1017314:	defffa04 	addi	sp,sp,-24
 1017318:	df000515 	stw	fp,20(sp)
 101731c:	df000504 	addi	fp,sp,20
 1017320:	e13ffd15 	stw	r4,-12(fp)
 1017324:	e17ffe15 	stw	r5,-8(fp)
 1017328:	e1bfff15 	stw	r6,-4(fp)
  int rc = -ENOTTY;
 101732c:	00bff9c4 	movi	r2,-25
 1017330:	e0bffb15 	stw	r2,-20(fp)

  switch (req)
 1017334:	e0bffe17 	ldw	r2,-8(fp)
 1017338:	10da8060 	cmpeqi	r3,r2,27137
 101733c:	1800031e 	bne	r3,zero,101734c <altera_avalon_jtag_uart_ioctl+0x38>
 1017340:	109a80a0 	cmpeqi	r2,r2,27138
 1017344:	1000181e 	bne	r2,zero,10173a8 <altera_avalon_jtag_uart_ioctl+0x94>
      rc = 0;
    }
    break;

  default:
    break;
 1017348:	00002906 	br	10173f0 <altera_avalon_jtag_uart_ioctl+0xdc>

  switch (req)
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
 101734c:	e0bffd17 	ldw	r2,-12(fp)
 1017350:	10c00117 	ldw	r3,4(r2)
 1017354:	00a00034 	movhi	r2,32768
 1017358:	10bfffc4 	addi	r2,r2,-1
 101735c:	18802126 	beq	r3,r2,10173e4 <altera_avalon_jtag_uart_ioctl+0xd0>
    {
      int timeout = *((int *)arg);
 1017360:	e0bfff17 	ldw	r2,-4(fp)
 1017364:	10800017 	ldw	r2,0(r2)
 1017368:	e0bffc15 	stw	r2,-16(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
 101736c:	e0bffc17 	ldw	r2,-16(fp)
 1017370:	10800090 	cmplti	r2,r2,2
 1017374:	1000061e 	bne	r2,zero,1017390 <altera_avalon_jtag_uart_ioctl+0x7c>
 1017378:	e0fffc17 	ldw	r3,-16(fp)
 101737c:	00a00034 	movhi	r2,32768
 1017380:	10bfffc4 	addi	r2,r2,-1
 1017384:	18800226 	beq	r3,r2,1017390 <altera_avalon_jtag_uart_ioctl+0x7c>
 1017388:	e0bffc17 	ldw	r2,-16(fp)
 101738c:	00000206 	br	1017398 <altera_avalon_jtag_uart_ioctl+0x84>
 1017390:	00a00034 	movhi	r2,32768
 1017394:	10bfff84 	addi	r2,r2,-2
 1017398:	e0fffd17 	ldw	r3,-12(fp)
 101739c:	18800115 	stw	r2,4(r3)
      rc = 0;
 10173a0:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
 10173a4:	00000f06 	br	10173e4 <altera_avalon_jtag_uart_ioctl+0xd0>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
 10173a8:	e0bffd17 	ldw	r2,-12(fp)
 10173ac:	10c00117 	ldw	r3,4(r2)
 10173b0:	00a00034 	movhi	r2,32768
 10173b4:	10bfffc4 	addi	r2,r2,-1
 10173b8:	18800c26 	beq	r3,r2,10173ec <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
 10173bc:	e0bffd17 	ldw	r2,-12(fp)
 10173c0:	10c00917 	ldw	r3,36(r2)
 10173c4:	e0bffd17 	ldw	r2,-12(fp)
 10173c8:	10800117 	ldw	r2,4(r2)
 10173cc:	1885803a 	cmpltu	r2,r3,r2
 10173d0:	10c03fcc 	andi	r3,r2,255
 10173d4:	e0bfff17 	ldw	r2,-4(fp)
 10173d8:	10c00015 	stw	r3,0(r2)
      rc = 0;
 10173dc:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
 10173e0:	00000206 	br	10173ec <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      int timeout = *((int *)arg);
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
      rc = 0;
    }
    break;
 10173e4:	0001883a 	nop
 10173e8:	00000106 	br	10173f0 <altera_avalon_jtag_uart_ioctl+0xdc>
    if (sp->timeout != INT_MAX)
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
      rc = 0;
    }
    break;
 10173ec:	0001883a 	nop

  default:
    break;
  }

  return rc;
 10173f0:	e0bffb17 	ldw	r2,-20(fp)
}
 10173f4:	e037883a 	mov	sp,fp
 10173f8:	df000017 	ldw	fp,0(sp)
 10173fc:	dec00104 	addi	sp,sp,4
 1017400:	f800283a 	ret

01017404 <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
 1017404:	defff304 	addi	sp,sp,-52
 1017408:	dfc00c15 	stw	ra,48(sp)
 101740c:	df000b15 	stw	fp,44(sp)
 1017410:	df000b04 	addi	fp,sp,44
 1017414:	e13ffc15 	stw	r4,-16(fp)
 1017418:	e17ffd15 	stw	r5,-12(fp)
 101741c:	e1bffe15 	stw	r6,-8(fp)
 1017420:	e1ffff15 	stw	r7,-4(fp)
  char * ptr = buffer;
 1017424:	e0bffd17 	ldw	r2,-12(fp)
 1017428:	e0bff515 	stw	r2,-44(fp)
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
 101742c:	00004706 	br	101754c <altera_avalon_jtag_uart_read+0x148>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
 1017430:	e0bffc17 	ldw	r2,-16(fp)
 1017434:	10800a17 	ldw	r2,40(r2)
 1017438:	e0bff715 	stw	r2,-36(fp)
      out = sp->rx_out;
 101743c:	e0bffc17 	ldw	r2,-16(fp)
 1017440:	10800b17 	ldw	r2,44(r2)
 1017444:	e0bff815 	stw	r2,-32(fp)

      if (in >= out)
 1017448:	e0fff717 	ldw	r3,-36(fp)
 101744c:	e0bff817 	ldw	r2,-32(fp)
 1017450:	18800536 	bltu	r3,r2,1017468 <altera_avalon_jtag_uart_read+0x64>
        n = in - out;
 1017454:	e0fff717 	ldw	r3,-36(fp)
 1017458:	e0bff817 	ldw	r2,-32(fp)
 101745c:	1885c83a 	sub	r2,r3,r2
 1017460:	e0bff615 	stw	r2,-40(fp)
 1017464:	00000406 	br	1017478 <altera_avalon_jtag_uart_read+0x74>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
 1017468:	00c20004 	movi	r3,2048
 101746c:	e0bff817 	ldw	r2,-32(fp)
 1017470:	1885c83a 	sub	r2,r3,r2
 1017474:	e0bff615 	stw	r2,-40(fp)

      if (n == 0)
 1017478:	e0bff617 	ldw	r2,-40(fp)
 101747c:	10001e26 	beq	r2,zero,10174f8 <altera_avalon_jtag_uart_read+0xf4>
        break; /* No more data available */

      if (n > space)
 1017480:	e0fffe17 	ldw	r3,-8(fp)
 1017484:	e0bff617 	ldw	r2,-40(fp)
 1017488:	1880022e 	bgeu	r3,r2,1017494 <altera_avalon_jtag_uart_read+0x90>
        n = space;
 101748c:	e0bffe17 	ldw	r2,-8(fp)
 1017490:	e0bff615 	stw	r2,-40(fp)

      memcpy(ptr, sp->rx_buf + out, n);
 1017494:	e0bffc17 	ldw	r2,-16(fp)
 1017498:	10c00e04 	addi	r3,r2,56
 101749c:	e0bff817 	ldw	r2,-32(fp)
 10174a0:	1885883a 	add	r2,r3,r2
 10174a4:	e1bff617 	ldw	r6,-40(fp)
 10174a8:	100b883a 	mov	r5,r2
 10174ac:	e13ff517 	ldw	r4,-44(fp)
 10174b0:	10099d40 	call	10099d4 <memcpy>
      ptr   += n;
 10174b4:	e0fff517 	ldw	r3,-44(fp)
 10174b8:	e0bff617 	ldw	r2,-40(fp)
 10174bc:	1885883a 	add	r2,r3,r2
 10174c0:	e0bff515 	stw	r2,-44(fp)
      space -= n;
 10174c4:	e0fffe17 	ldw	r3,-8(fp)
 10174c8:	e0bff617 	ldw	r2,-40(fp)
 10174cc:	1885c83a 	sub	r2,r3,r2
 10174d0:	e0bffe15 	stw	r2,-8(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 10174d4:	e0fff817 	ldw	r3,-32(fp)
 10174d8:	e0bff617 	ldw	r2,-40(fp)
 10174dc:	1885883a 	add	r2,r3,r2
 10174e0:	10c1ffcc 	andi	r3,r2,2047
 10174e4:	e0bffc17 	ldw	r2,-16(fp)
 10174e8:	10c00b15 	stw	r3,44(r2)
    }
    while (space > 0);
 10174ec:	e0bffe17 	ldw	r2,-8(fp)
 10174f0:	00bfcf16 	blt	zero,r2,1017430 <__alt_data_end+0xff817430>
 10174f4:	00000106 	br	10174fc <altera_avalon_jtag_uart_read+0xf8>
        n = in - out;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;

      if (n == 0)
        break; /* No more data available */
 10174f8:	0001883a 	nop
      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
 10174fc:	e0fff517 	ldw	r3,-44(fp)
 1017500:	e0bffd17 	ldw	r2,-12(fp)
 1017504:	1880141e 	bne	r3,r2,1017558 <altera_avalon_jtag_uart_read+0x154>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
 1017508:	e0bfff17 	ldw	r2,-4(fp)
 101750c:	1090000c 	andi	r2,r2,16384
 1017510:	1000131e 	bne	r2,zero,1017560 <altera_avalon_jtag_uart_read+0x15c>
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
        ;
    }
#else
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
 1017514:	0001883a 	nop
 1017518:	e0bffc17 	ldw	r2,-16(fp)
 101751c:	10c00a17 	ldw	r3,40(r2)
 1017520:	e0bff717 	ldw	r2,-36(fp)
 1017524:	1880051e 	bne	r3,r2,101753c <altera_avalon_jtag_uart_read+0x138>
 1017528:	e0bffc17 	ldw	r2,-16(fp)
 101752c:	10c00917 	ldw	r3,36(r2)
 1017530:	e0bffc17 	ldw	r2,-16(fp)
 1017534:	10800117 	ldw	r2,4(r2)
 1017538:	18bff736 	bltu	r3,r2,1017518 <__alt_data_end+0xff817518>
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
 101753c:	e0bffc17 	ldw	r2,-16(fp)
 1017540:	10c00a17 	ldw	r3,40(r2)
 1017544:	e0bff717 	ldw	r2,-36(fp)
 1017548:	18800726 	beq	r3,r2,1017568 <altera_avalon_jtag_uart_read+0x164>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
 101754c:	e0bffe17 	ldw	r2,-8(fp)
 1017550:	00bfb716 	blt	zero,r2,1017430 <__alt_data_end+0xff817430>
 1017554:	00000506 	br	101756c <altera_avalon_jtag_uart_read+0x168>
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
      break;
 1017558:	0001883a 	nop
 101755c:	00000306 	br	101756c <altera_avalon_jtag_uart_read+0x168>

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
      break;
 1017560:	0001883a 	nop
 1017564:	00000106 	br	101756c <altera_avalon_jtag_uart_read+0x168>
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
      break;
 1017568:	0001883a 	nop
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);

  if (ptr != buffer)
 101756c:	e0fff517 	ldw	r3,-44(fp)
 1017570:	e0bffd17 	ldw	r2,-12(fp)
 1017574:	18801826 	beq	r3,r2,10175d8 <altera_avalon_jtag_uart_read+0x1d4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1017578:	0005303a 	rdctl	r2,status
 101757c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1017580:	e0fffb17 	ldw	r3,-20(fp)
 1017584:	00bfff84 	movi	r2,-2
 1017588:	1884703a 	and	r2,r3,r2
 101758c:	1001703a 	wrctl	status,r2
  
  return context;
 1017590:	e0bffb17 	ldw	r2,-20(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
 1017594:	e0bffa15 	stw	r2,-24(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 1017598:	e0bffc17 	ldw	r2,-16(fp)
 101759c:	10800817 	ldw	r2,32(r2)
 10175a0:	10c00054 	ori	r3,r2,1
 10175a4:	e0bffc17 	ldw	r2,-16(fp)
 10175a8:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 10175ac:	e0bffc17 	ldw	r2,-16(fp)
 10175b0:	10800017 	ldw	r2,0(r2)
 10175b4:	10800104 	addi	r2,r2,4
 10175b8:	1007883a 	mov	r3,r2
 10175bc:	e0bffc17 	ldw	r2,-16(fp)
 10175c0:	10800817 	ldw	r2,32(r2)
 10175c4:	18800035 	stwio	r2,0(r3)
 10175c8:	e0bffa17 	ldw	r2,-24(fp)
 10175cc:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 10175d0:	e0bff917 	ldw	r2,-28(fp)
 10175d4:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
 10175d8:	e0fff517 	ldw	r3,-44(fp)
 10175dc:	e0bffd17 	ldw	r2,-12(fp)
 10175e0:	18800426 	beq	r3,r2,10175f4 <altera_avalon_jtag_uart_read+0x1f0>
    return ptr - buffer;
 10175e4:	e0fff517 	ldw	r3,-44(fp)
 10175e8:	e0bffd17 	ldw	r2,-12(fp)
 10175ec:	1885c83a 	sub	r2,r3,r2
 10175f0:	00000606 	br	101760c <altera_avalon_jtag_uart_read+0x208>
  else if (flags & O_NONBLOCK)
 10175f4:	e0bfff17 	ldw	r2,-4(fp)
 10175f8:	1090000c 	andi	r2,r2,16384
 10175fc:	10000226 	beq	r2,zero,1017608 <altera_avalon_jtag_uart_read+0x204>
    return -EWOULDBLOCK;
 1017600:	00bffd44 	movi	r2,-11
 1017604:	00000106 	br	101760c <altera_avalon_jtag_uart_read+0x208>
  else
    return -EIO;
 1017608:	00bffec4 	movi	r2,-5
}
 101760c:	e037883a 	mov	sp,fp
 1017610:	dfc00117 	ldw	ra,4(sp)
 1017614:	df000017 	ldw	fp,0(sp)
 1017618:	dec00204 	addi	sp,sp,8
 101761c:	f800283a 	ret

01017620 <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
 1017620:	defff304 	addi	sp,sp,-52
 1017624:	dfc00c15 	stw	ra,48(sp)
 1017628:	df000b15 	stw	fp,44(sp)
 101762c:	df000b04 	addi	fp,sp,44
 1017630:	e13ffc15 	stw	r4,-16(fp)
 1017634:	e17ffd15 	stw	r5,-12(fp)
 1017638:	e1bffe15 	stw	r6,-8(fp)
 101763c:	e1ffff15 	stw	r7,-4(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
 1017640:	e03ff515 	stw	zero,-44(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
 1017644:	e0bffd17 	ldw	r2,-12(fp)
 1017648:	e0bff715 	stw	r2,-36(fp)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 101764c:	00003706 	br	101772c <altera_avalon_jtag_uart_write+0x10c>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
 1017650:	e0bffc17 	ldw	r2,-16(fp)
 1017654:	10800c17 	ldw	r2,48(r2)
 1017658:	e0bff915 	stw	r2,-28(fp)
      out = sp->tx_out;
 101765c:	e0bffc17 	ldw	r2,-16(fp)
 1017660:	10800d17 	ldw	r2,52(r2)
 1017664:	e0bff515 	stw	r2,-44(fp)

      if (in < out)
 1017668:	e0fff917 	ldw	r3,-28(fp)
 101766c:	e0bff517 	ldw	r2,-44(fp)
 1017670:	1880062e 	bgeu	r3,r2,101768c <altera_avalon_jtag_uart_write+0x6c>
        n = out - 1 - in;
 1017674:	e0fff517 	ldw	r3,-44(fp)
 1017678:	e0bff917 	ldw	r2,-28(fp)
 101767c:	1885c83a 	sub	r2,r3,r2
 1017680:	10bfffc4 	addi	r2,r2,-1
 1017684:	e0bff615 	stw	r2,-40(fp)
 1017688:	00000b06 	br	10176b8 <altera_avalon_jtag_uart_write+0x98>
      else if (out > 0)
 101768c:	e0bff517 	ldw	r2,-44(fp)
 1017690:	10000526 	beq	r2,zero,10176a8 <altera_avalon_jtag_uart_write+0x88>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
 1017694:	00c20004 	movi	r3,2048
 1017698:	e0bff917 	ldw	r2,-28(fp)
 101769c:	1885c83a 	sub	r2,r3,r2
 10176a0:	e0bff615 	stw	r2,-40(fp)
 10176a4:	00000406 	br	10176b8 <altera_avalon_jtag_uart_write+0x98>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
 10176a8:	00c1ffc4 	movi	r3,2047
 10176ac:	e0bff917 	ldw	r2,-28(fp)
 10176b0:	1885c83a 	sub	r2,r3,r2
 10176b4:	e0bff615 	stw	r2,-40(fp)

      if (n == 0)
 10176b8:	e0bff617 	ldw	r2,-40(fp)
 10176bc:	10001e26 	beq	r2,zero,1017738 <altera_avalon_jtag_uart_write+0x118>
        break;

      if (n > count)
 10176c0:	e0fffe17 	ldw	r3,-8(fp)
 10176c4:	e0bff617 	ldw	r2,-40(fp)
 10176c8:	1880022e 	bgeu	r3,r2,10176d4 <altera_avalon_jtag_uart_write+0xb4>
        n = count;
 10176cc:	e0bffe17 	ldw	r2,-8(fp)
 10176d0:	e0bff615 	stw	r2,-40(fp)

      memcpy(sp->tx_buf + in, ptr, n);
 10176d4:	e0bffc17 	ldw	r2,-16(fp)
 10176d8:	10c20e04 	addi	r3,r2,2104
 10176dc:	e0bff917 	ldw	r2,-28(fp)
 10176e0:	1885883a 	add	r2,r3,r2
 10176e4:	e1bff617 	ldw	r6,-40(fp)
 10176e8:	e17ffd17 	ldw	r5,-12(fp)
 10176ec:	1009883a 	mov	r4,r2
 10176f0:	10099d40 	call	10099d4 <memcpy>
      ptr   += n;
 10176f4:	e0fffd17 	ldw	r3,-12(fp)
 10176f8:	e0bff617 	ldw	r2,-40(fp)
 10176fc:	1885883a 	add	r2,r3,r2
 1017700:	e0bffd15 	stw	r2,-12(fp)
      count -= n;
 1017704:	e0fffe17 	ldw	r3,-8(fp)
 1017708:	e0bff617 	ldw	r2,-40(fp)
 101770c:	1885c83a 	sub	r2,r3,r2
 1017710:	e0bffe15 	stw	r2,-8(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 1017714:	e0fff917 	ldw	r3,-28(fp)
 1017718:	e0bff617 	ldw	r2,-40(fp)
 101771c:	1885883a 	add	r2,r3,r2
 1017720:	10c1ffcc 	andi	r3,r2,2047
 1017724:	e0bffc17 	ldw	r2,-16(fp)
 1017728:	10c00c15 	stw	r3,48(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 101772c:	e0bffe17 	ldw	r2,-8(fp)
 1017730:	00bfc716 	blt	zero,r2,1017650 <__alt_data_end+0xff817650>
 1017734:	00000106 	br	101773c <altera_avalon_jtag_uart_write+0x11c>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;

      if (n == 0)
        break;
 1017738:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 101773c:	0005303a 	rdctl	r2,status
 1017740:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1017744:	e0fffb17 	ldw	r3,-20(fp)
 1017748:	00bfff84 	movi	r2,-2
 101774c:	1884703a 	and	r2,r3,r2
 1017750:	1001703a 	wrctl	status,r2
  
  return context;
 1017754:	e0bffb17 	ldw	r2,-20(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
 1017758:	e0bffa15 	stw	r2,-24(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 101775c:	e0bffc17 	ldw	r2,-16(fp)
 1017760:	10800817 	ldw	r2,32(r2)
 1017764:	10c00094 	ori	r3,r2,2
 1017768:	e0bffc17 	ldw	r2,-16(fp)
 101776c:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 1017770:	e0bffc17 	ldw	r2,-16(fp)
 1017774:	10800017 	ldw	r2,0(r2)
 1017778:	10800104 	addi	r2,r2,4
 101777c:	1007883a 	mov	r3,r2
 1017780:	e0bffc17 	ldw	r2,-16(fp)
 1017784:	10800817 	ldw	r2,32(r2)
 1017788:	18800035 	stwio	r2,0(r3)
 101778c:	e0bffa17 	ldw	r2,-24(fp)
 1017790:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 1017794:	e0bff817 	ldw	r2,-32(fp)
 1017798:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
 101779c:	e0bffe17 	ldw	r2,-8(fp)
 10177a0:	0080100e 	bge	zero,r2,10177e4 <altera_avalon_jtag_uart_write+0x1c4>
    {
      if (flags & O_NONBLOCK)
 10177a4:	e0bfff17 	ldw	r2,-4(fp)
 10177a8:	1090000c 	andi	r2,r2,16384
 10177ac:	1000101e 	bne	r2,zero,10177f0 <altera_avalon_jtag_uart_write+0x1d0>
      /*
       * No OS present: Always wait for data to be removed from buffer.  Once
       * the interrupt routine has removed some data then we will be able to
       * insert some more.
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
 10177b0:	0001883a 	nop
 10177b4:	e0bffc17 	ldw	r2,-16(fp)
 10177b8:	10c00d17 	ldw	r3,52(r2)
 10177bc:	e0bff517 	ldw	r2,-44(fp)
 10177c0:	1880051e 	bne	r3,r2,10177d8 <altera_avalon_jtag_uart_write+0x1b8>
 10177c4:	e0bffc17 	ldw	r2,-16(fp)
 10177c8:	10c00917 	ldw	r3,36(r2)
 10177cc:	e0bffc17 	ldw	r2,-16(fp)
 10177d0:	10800117 	ldw	r2,4(r2)
 10177d4:	18bff736 	bltu	r3,r2,10177b4 <__alt_data_end+0xff8177b4>
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
 10177d8:	e0bffc17 	ldw	r2,-16(fp)
 10177dc:	10800917 	ldw	r2,36(r2)
 10177e0:	1000051e 	bne	r2,zero,10177f8 <altera_avalon_jtag_uart_write+0x1d8>
         break;
    }
  }
  while (count > 0);
 10177e4:	e0bffe17 	ldw	r2,-8(fp)
 10177e8:	00bfd016 	blt	zero,r2,101772c <__alt_data_end+0xff81772c>
 10177ec:	00000306 	br	10177fc <altera_avalon_jtag_uart_write+0x1dc>
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
    {
      if (flags & O_NONBLOCK)
        break;
 10177f0:	0001883a 	nop
 10177f4:	00000106 	br	10177fc <altera_avalon_jtag_uart_write+0x1dc>
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
         break;
 10177f8:	0001883a 	nop
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);

  if (ptr != start)
 10177fc:	e0fffd17 	ldw	r3,-12(fp)
 1017800:	e0bff717 	ldw	r2,-36(fp)
 1017804:	18800426 	beq	r3,r2,1017818 <altera_avalon_jtag_uart_write+0x1f8>
    return ptr - start;
 1017808:	e0fffd17 	ldw	r3,-12(fp)
 101780c:	e0bff717 	ldw	r2,-36(fp)
 1017810:	1885c83a 	sub	r2,r3,r2
 1017814:	00000606 	br	1017830 <altera_avalon_jtag_uart_write+0x210>
  else if (flags & O_NONBLOCK)
 1017818:	e0bfff17 	ldw	r2,-4(fp)
 101781c:	1090000c 	andi	r2,r2,16384
 1017820:	10000226 	beq	r2,zero,101782c <altera_avalon_jtag_uart_write+0x20c>
    return -EWOULDBLOCK;
 1017824:	00bffd44 	movi	r2,-11
 1017828:	00000106 	br	1017830 <altera_avalon_jtag_uart_write+0x210>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
 101782c:	00bffec4 	movi	r2,-5
}
 1017830:	e037883a 	mov	sp,fp
 1017834:	dfc00117 	ldw	ra,4(sp)
 1017838:	df000017 	ldw	fp,0(sp)
 101783c:	dec00204 	addi	sp,sp,8
 1017840:	f800283a 	ret

01017844 <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
 1017844:	defffa04 	addi	sp,sp,-24
 1017848:	dfc00515 	stw	ra,20(sp)
 101784c:	df000415 	stw	fp,16(sp)
 1017850:	df000404 	addi	fp,sp,16
 1017854:	e13fff15 	stw	r4,-4(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
 1017858:	0007883a 	mov	r3,zero
 101785c:	e0bfff17 	ldw	r2,-4(fp)
 1017860:	10c00035 	stwio	r3,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
 1017864:	e0bfff17 	ldw	r2,-4(fp)
 1017868:	10800104 	addi	r2,r2,4
 101786c:	10800037 	ldwio	r2,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1017870:	0005303a 	rdctl	r2,status
 1017874:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1017878:	e0fffd17 	ldw	r3,-12(fp)
 101787c:	00bfff84 	movi	r2,-2
 1017880:	1884703a 	and	r2,r3,r2
 1017884:	1001703a 	wrctl	status,r2
  
  return context;
 1017888:	e0bffd17 	ldw	r2,-12(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
 101788c:	e0bffc15 	stw	r2,-16(fp)
  alt_tick ();
 1017890:	101a0d40 	call	101a0d4 <alt_tick>
 1017894:	e0bffc17 	ldw	r2,-16(fp)
 1017898:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 101789c:	e0bffe17 	ldw	r2,-8(fp)
 10178a0:	1001703a 	wrctl	status,r2
  alt_irq_enable_all(cpu_sr);
}
 10178a4:	0001883a 	nop
 10178a8:	e037883a 	mov	sp,fp
 10178ac:	dfc00117 	ldw	ra,4(sp)
 10178b0:	df000017 	ldw	fp,0(sp)
 10178b4:	dec00204 	addi	sp,sp,8
 10178b8:	f800283a 	ret

010178bc <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
 10178bc:	defff804 	addi	sp,sp,-32
 10178c0:	dfc00715 	stw	ra,28(sp)
 10178c4:	df000615 	stw	fp,24(sp)
 10178c8:	df000604 	addi	fp,sp,24
 10178cc:	e13ffc15 	stw	r4,-16(fp)
 10178d0:	e17ffd15 	stw	r5,-12(fp)
 10178d4:	e1bffe15 	stw	r6,-8(fp)
 10178d8:	e1ffff15 	stw	r7,-4(fp)
 10178dc:	e0bfff17 	ldw	r2,-4(fp)
 10178e0:	e0bffb15 	stw	r2,-20(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
 10178e4:	d0a0b317 	ldw	r2,-32052(gp)
 10178e8:	1000021e 	bne	r2,zero,10178f4 <alt_avalon_timer_sc_init+0x38>
  {
    _alt_tick_rate = nticks;
 10178ec:	e0bffb17 	ldw	r2,-20(fp)
 10178f0:	d0a0b315 	stw	r2,-32052(gp)
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
 10178f4:	e0bffc17 	ldw	r2,-16(fp)
 10178f8:	10800104 	addi	r2,r2,4
 10178fc:	00c001c4 	movi	r3,7
 1017900:	10c00035 	stwio	r3,0(r2)
            ALTERA_AVALON_TIMER_CONTROL_CONT_MSK |
            ALTERA_AVALON_TIMER_CONTROL_START_MSK);

  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
 1017904:	d8000015 	stw	zero,0(sp)
 1017908:	e1fffc17 	ldw	r7,-16(fp)
 101790c:	01804074 	movhi	r6,257
 1017910:	319e1104 	addi	r6,r6,30788
 1017914:	e17ffe17 	ldw	r5,-8(fp)
 1017918:	e13ffd17 	ldw	r4,-12(fp)
 101791c:	10164880 	call	1016488 <alt_ic_isr_register>
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
#endif  
}
 1017920:	0001883a 	nop
 1017924:	e037883a 	mov	sp,fp
 1017928:	dfc00117 	ldw	ra,4(sp)
 101792c:	df000017 	ldw	fp,0(sp)
 1017930:	dec00204 	addi	sp,sp,8
 1017934:	f800283a 	ret

01017938 <altera_avalon_uart_read_fd>:
 *
 */

int 
altera_avalon_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
 1017938:	defffa04 	addi	sp,sp,-24
 101793c:	dfc00515 	stw	ra,20(sp)
 1017940:	df000415 	stw	fp,16(sp)
 1017944:	df000404 	addi	fp,sp,16
 1017948:	e13ffd15 	stw	r4,-12(fp)
 101794c:	e17ffe15 	stw	r5,-8(fp)
 1017950:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
 1017954:	e0bffd17 	ldw	r2,-12(fp)
 1017958:	10800017 	ldw	r2,0(r2)
 101795c:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_read(&dev->state, buffer, space,
 1017960:	e0bffc17 	ldw	r2,-16(fp)
 1017964:	10c00a04 	addi	r3,r2,40
 1017968:	e0bffd17 	ldw	r2,-12(fp)
 101796c:	10800217 	ldw	r2,8(r2)
 1017970:	100f883a 	mov	r7,r2
 1017974:	e1bfff17 	ldw	r6,-4(fp)
 1017978:	e17ffe17 	ldw	r5,-8(fp)
 101797c:	1809883a 	mov	r4,r3
 1017980:	1017e4c0 	call	1017e4c <altera_avalon_uart_read>
      fd->fd_flags);
}
 1017984:	e037883a 	mov	sp,fp
 1017988:	dfc00117 	ldw	ra,4(sp)
 101798c:	df000017 	ldw	fp,0(sp)
 1017990:	dec00204 	addi	sp,sp,8
 1017994:	f800283a 	ret

01017998 <altera_avalon_uart_write_fd>:

int 
altera_avalon_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
 1017998:	defffa04 	addi	sp,sp,-24
 101799c:	dfc00515 	stw	ra,20(sp)
 10179a0:	df000415 	stw	fp,16(sp)
 10179a4:	df000404 	addi	fp,sp,16
 10179a8:	e13ffd15 	stw	r4,-12(fp)
 10179ac:	e17ffe15 	stw	r5,-8(fp)
 10179b0:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
 10179b4:	e0bffd17 	ldw	r2,-12(fp)
 10179b8:	10800017 	ldw	r2,0(r2)
 10179bc:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_write(&dev->state, buffer, space,
 10179c0:	e0bffc17 	ldw	r2,-16(fp)
 10179c4:	10c00a04 	addi	r3,r2,40
 10179c8:	e0bffd17 	ldw	r2,-12(fp)
 10179cc:	10800217 	ldw	r2,8(r2)
 10179d0:	100f883a 	mov	r7,r2
 10179d4:	e1bfff17 	ldw	r6,-4(fp)
 10179d8:	e17ffe17 	ldw	r5,-8(fp)
 10179dc:	1809883a 	mov	r4,r3
 10179e0:	10180640 	call	1018064 <altera_avalon_uart_write>
      fd->fd_flags);
}
 10179e4:	e037883a 	mov	sp,fp
 10179e8:	dfc00117 	ldw	ra,4(sp)
 10179ec:	df000017 	ldw	fp,0(sp)
 10179f0:	dec00204 	addi	sp,sp,8
 10179f4:	f800283a 	ret

010179f8 <altera_avalon_uart_close_fd>:

#endif /* ALTERA_AVALON_UART_USE_IOCTL */

int 
altera_avalon_uart_close_fd(alt_fd* fd)
{
 10179f8:	defffc04 	addi	sp,sp,-16
 10179fc:	dfc00315 	stw	ra,12(sp)
 1017a00:	df000215 	stw	fp,8(sp)
 1017a04:	df000204 	addi	fp,sp,8
 1017a08:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
 1017a0c:	e0bfff17 	ldw	r2,-4(fp)
 1017a10:	10800017 	ldw	r2,0(r2)
 1017a14:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_uart_close(&dev->state, fd->fd_flags);
 1017a18:	e0bffe17 	ldw	r2,-8(fp)
 1017a1c:	10c00a04 	addi	r3,r2,40
 1017a20:	e0bfff17 	ldw	r2,-4(fp)
 1017a24:	10800217 	ldw	r2,8(r2)
 1017a28:	100b883a 	mov	r5,r2
 1017a2c:	1809883a 	mov	r4,r3
 1017a30:	1017dbc0 	call	1017dbc <altera_avalon_uart_close>
}
 1017a34:	e037883a 	mov	sp,fp
 1017a38:	dfc00117 	ldw	ra,4(sp)
 1017a3c:	df000017 	ldw	fp,0(sp)
 1017a40:	dec00204 	addi	sp,sp,8
 1017a44:	f800283a 	ret

01017a48 <altera_avalon_uart_init>:
  alt_u32 status);

void 
altera_avalon_uart_init(altera_avalon_uart_state* sp, 
  alt_u32 irq_controller_id,  alt_u32 irq)
{
 1017a48:	defff804 	addi	sp,sp,-32
 1017a4c:	dfc00715 	stw	ra,28(sp)
 1017a50:	df000615 	stw	fp,24(sp)
 1017a54:	df000604 	addi	fp,sp,24
 1017a58:	e13ffd15 	stw	r4,-12(fp)
 1017a5c:	e17ffe15 	stw	r5,-8(fp)
 1017a60:	e1bfff15 	stw	r6,-4(fp)
  void* base = sp->base;
 1017a64:	e0bffd17 	ldw	r2,-12(fp)
 1017a68:	10800017 	ldw	r2,0(r2)
 1017a6c:	e0bffb15 	stw	r2,-20(fp)
 * HAL.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_no_error (void)
{
  return 0;
 1017a70:	0005883a 	mov	r2,zero
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
 1017a74:	1000041e 	bne	r2,zero,1017a88 <altera_avalon_uart_init+0x40>
 1017a78:	0005883a 	mov	r2,zero
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
 1017a7c:	1000021e 	bne	r2,zero,1017a88 <altera_avalon_uart_init+0x40>
 1017a80:	0005883a 	mov	r2,zero
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
 1017a84:	10000226 	beq	r2,zero,1017a90 <altera_avalon_uart_init+0x48>
 1017a88:	00800044 	movi	r2,1
 1017a8c:	00000106 	br	1017a94 <altera_avalon_uart_init+0x4c>
 1017a90:	0005883a 	mov	r2,zero
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
 1017a94:	e0bffc15 	stw	r2,-16(fp)
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
          ALT_SEM_CREATE (&sp->write_lock, 1);

  if (!error)
 1017a98:	e0bffc17 	ldw	r2,-16(fp)
 1017a9c:	10000f1e 	bne	r2,zero,1017adc <altera_avalon_uart_init+0x94>
  {
    /* enable interrupts at the device */
    sp->ctrl = ALTERA_AVALON_UART_CONTROL_RTS_MSK  |
 1017aa0:	e0bffd17 	ldw	r2,-12(fp)
 1017aa4:	00c32004 	movi	r3,3200
 1017aa8:	10c00115 	stw	r3,4(r2)
                ALTERA_AVALON_UART_CONTROL_RRDY_MSK |
                ALTERA_AVALON_UART_CONTROL_DCTS_MSK;

    IOWR_ALTERA_AVALON_UART_CONTROL(base, sp->ctrl); 
 1017aac:	e0bffb17 	ldw	r2,-20(fp)
 1017ab0:	10800304 	addi	r2,r2,12
 1017ab4:	e0fffd17 	ldw	r3,-12(fp)
 1017ab8:	18c00117 	ldw	r3,4(r3)
 1017abc:	10c00035 	stwio	r3,0(r2)
  
    /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
    alt_ic_isr_register(irq_controller_id, irq, altera_avalon_uart_irq, sp, 
 1017ac0:	d8000015 	stw	zero,0(sp)
 1017ac4:	e1fffd17 	ldw	r7,-12(fp)
 1017ac8:	01804074 	movhi	r6,257
 1017acc:	319ebd04 	addi	r6,r6,31476
 1017ad0:	e17fff17 	ldw	r5,-4(fp)
 1017ad4:	e13ffe17 	ldw	r4,-8(fp)
 1017ad8:	10164880 	call	1016488 <alt_ic_isr_register>
      0x0);
#else
    alt_irq_register (irq, sp, altera_avalon_uart_irq);
#endif  
  }
}
 1017adc:	0001883a 	nop
 1017ae0:	e037883a 	mov	sp,fp
 1017ae4:	dfc00117 	ldw	ra,4(sp)
 1017ae8:	df000017 	ldw	fp,0(sp)
 1017aec:	dec00204 	addi	sp,sp,8
 1017af0:	f800283a 	ret

01017af4 <altera_avalon_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_uart_irq(void* context)
#else
static void altera_avalon_uart_irq(void* context, alt_u32 id)
#endif
{
 1017af4:	defffa04 	addi	sp,sp,-24
 1017af8:	dfc00515 	stw	ra,20(sp)
 1017afc:	df000415 	stw	fp,16(sp)
 1017b00:	df000404 	addi	fp,sp,16
 1017b04:	e13fff15 	stw	r4,-4(fp)
  alt_u32 status;

  altera_avalon_uart_state* sp = (altera_avalon_uart_state*) context;
 1017b08:	e0bfff17 	ldw	r2,-4(fp)
 1017b0c:	e0bffc15 	stw	r2,-16(fp)
  void* base               = sp->base;
 1017b10:	e0bffc17 	ldw	r2,-16(fp)
 1017b14:	10800017 	ldw	r2,0(r2)
 1017b18:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Read the status register in order to determine the cause of the
   * interrupt.
   */

  status = IORD_ALTERA_AVALON_UART_STATUS(base);
 1017b1c:	e0bffd17 	ldw	r2,-12(fp)
 1017b20:	10800204 	addi	r2,r2,8
 1017b24:	10800037 	ldwio	r2,0(r2)
 1017b28:	e0bffe15 	stw	r2,-8(fp)

  /* Clear any error flags set at the device */
  IOWR_ALTERA_AVALON_UART_STATUS(base, 0);
 1017b2c:	e0bffd17 	ldw	r2,-12(fp)
 1017b30:	10800204 	addi	r2,r2,8
 1017b34:	0007883a 	mov	r3,zero
 1017b38:	10c00035 	stwio	r3,0(r2)

  /* Dummy read to ensure IRQ is negated before ISR returns */
  IORD_ALTERA_AVALON_UART_STATUS(base);
 1017b3c:	e0bffd17 	ldw	r2,-12(fp)
 1017b40:	10800204 	addi	r2,r2,8
 1017b44:	10800037 	ldwio	r2,0(r2)
  
  /* process a read irq */
  if (status & ALTERA_AVALON_UART_STATUS_RRDY_MSK)
 1017b48:	e0bffe17 	ldw	r2,-8(fp)
 1017b4c:	1080200c 	andi	r2,r2,128
 1017b50:	10000326 	beq	r2,zero,1017b60 <altera_avalon_uart_irq+0x6c>
  {
    altera_avalon_uart_rxirq(sp, status);
 1017b54:	e17ffe17 	ldw	r5,-8(fp)
 1017b58:	e13ffc17 	ldw	r4,-16(fp)
 1017b5c:	1017b900 	call	1017b90 <altera_avalon_uart_rxirq>
  }

  /* process a write irq */
  if (status & (ALTERA_AVALON_UART_STATUS_TRDY_MSK | 
 1017b60:	e0bffe17 	ldw	r2,-8(fp)
 1017b64:	1081100c 	andi	r2,r2,1088
 1017b68:	10000326 	beq	r2,zero,1017b78 <altera_avalon_uart_irq+0x84>
                  ALTERA_AVALON_UART_STATUS_DCTS_MSK))
  {
    altera_avalon_uart_txirq(sp, status);
 1017b6c:	e17ffe17 	ldw	r5,-8(fp)
 1017b70:	e13ffc17 	ldw	r4,-16(fp)
 1017b74:	1017c740 	call	1017c74 <altera_avalon_uart_txirq>
  }
  

}
 1017b78:	0001883a 	nop
 1017b7c:	e037883a 	mov	sp,fp
 1017b80:	dfc00117 	ldw	ra,4(sp)
 1017b84:	df000017 	ldw	fp,0(sp)
 1017b88:	dec00204 	addi	sp,sp,8
 1017b8c:	f800283a 	ret

01017b90 <altera_avalon_uart_rxirq>:
 * the receive circular buffer, and sets the apropriate flags to indicate 
 * that there is data ready to be processed.
 */
static void 
altera_avalon_uart_rxirq(altera_avalon_uart_state* sp, alt_u32 status)
{
 1017b90:	defffc04 	addi	sp,sp,-16
 1017b94:	df000315 	stw	fp,12(sp)
 1017b98:	df000304 	addi	fp,sp,12
 1017b9c:	e13ffe15 	stw	r4,-8(fp)
 1017ba0:	e17fff15 	stw	r5,-4(fp)
  alt_u32 next;
  
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
 1017ba4:	e0bfff17 	ldw	r2,-4(fp)
 1017ba8:	108000cc 	andi	r2,r2,3
 1017bac:	10002c1e 	bne	r2,zero,1017c60 <altera_avalon_uart_rxirq+0xd0>
   * In a multi-threaded environment, set the read event flag to indicate
   * that there is data ready. This is only done if the circular buffer was
   * previously empty.
   */

  if (sp->rx_end == sp->rx_start)
 1017bb0:	e0bffe17 	ldw	r2,-8(fp)
 1017bb4:	10800317 	ldw	r2,12(r2)
 1017bb8:	e0bffe17 	ldw	r2,-8(fp)
 1017bbc:	10800217 	ldw	r2,8(r2)
    ALT_FLAG_POST (sp->events, ALT_UART_READ_RDY, OS_FLAG_SET);
  }

  /* Determine which slot to use next in the circular buffer */

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
 1017bc0:	e0bffe17 	ldw	r2,-8(fp)
 1017bc4:	10800317 	ldw	r2,12(r2)
 1017bc8:	10800044 	addi	r2,r2,1
 1017bcc:	10800fcc 	andi	r2,r2,63
 1017bd0:	e0bffd15 	stw	r2,-12(fp)

  /* Transfer data from the device to the circular buffer */

  sp->rx_buf[sp->rx_end] = IORD_ALTERA_AVALON_UART_RXDATA(sp->base);
 1017bd4:	e0bffe17 	ldw	r2,-8(fp)
 1017bd8:	10800317 	ldw	r2,12(r2)
 1017bdc:	e0fffe17 	ldw	r3,-8(fp)
 1017be0:	18c00017 	ldw	r3,0(r3)
 1017be4:	18c00037 	ldwio	r3,0(r3)
 1017be8:	1809883a 	mov	r4,r3
 1017bec:	e0fffe17 	ldw	r3,-8(fp)
 1017bf0:	1885883a 	add	r2,r3,r2
 1017bf4:	10800704 	addi	r2,r2,28
 1017bf8:	11000005 	stb	r4,0(r2)

  sp->rx_end = next;
 1017bfc:	e0bffe17 	ldw	r2,-8(fp)
 1017c00:	e0fffd17 	ldw	r3,-12(fp)
 1017c04:	10c00315 	stw	r3,12(r2)

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
 1017c08:	e0bffe17 	ldw	r2,-8(fp)
 1017c0c:	10800317 	ldw	r2,12(r2)
 1017c10:	10800044 	addi	r2,r2,1
 1017c14:	10800fcc 	andi	r2,r2,63
 1017c18:	e0bffd15 	stw	r2,-12(fp)
  /*
   * If the cicular buffer was full, disable interrupts. Interrupts will be
   * re-enabled when data is removed from the buffer.
   */

  if (next == sp->rx_start)
 1017c1c:	e0bffe17 	ldw	r2,-8(fp)
 1017c20:	10c00217 	ldw	r3,8(r2)
 1017c24:	e0bffd17 	ldw	r2,-12(fp)
 1017c28:	18800e1e 	bne	r3,r2,1017c64 <altera_avalon_uart_rxirq+0xd4>
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
 1017c2c:	e0bffe17 	ldw	r2,-8(fp)
 1017c30:	10c00117 	ldw	r3,4(r2)
 1017c34:	00bfdfc4 	movi	r2,-129
 1017c38:	1886703a 	and	r3,r3,r2
 1017c3c:	e0bffe17 	ldw	r2,-8(fp)
 1017c40:	10c00115 	stw	r3,4(r2)
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
 1017c44:	e0bffe17 	ldw	r2,-8(fp)
 1017c48:	10800017 	ldw	r2,0(r2)
 1017c4c:	10800304 	addi	r2,r2,12
 1017c50:	e0fffe17 	ldw	r3,-8(fp)
 1017c54:	18c00117 	ldw	r3,4(r3)
 1017c58:	10c00035 	stwio	r3,0(r2)
 1017c5c:	00000106 	br	1017c64 <altera_avalon_uart_rxirq+0xd4>
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
                  ALTERA_AVALON_UART_STATUS_FE_MSK))
  {
    return;
 1017c60:	0001883a 	nop
  if (next == sp->rx_start)
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
  }   
}
 1017c64:	e037883a 	mov	sp,fp
 1017c68:	df000017 	ldw	fp,0(sp)
 1017c6c:	dec00104 	addi	sp,sp,4
 1017c70:	f800283a 	ret

01017c74 <altera_avalon_uart_txirq>:
 * buffer to the device, and sets the apropriate flags to indicate that 
 * there is data ready to be processed.
 */
static void 
altera_avalon_uart_txirq(altera_avalon_uart_state* sp, alt_u32 status)
{
 1017c74:	defffb04 	addi	sp,sp,-20
 1017c78:	df000415 	stw	fp,16(sp)
 1017c7c:	df000404 	addi	fp,sp,16
 1017c80:	e13ffc15 	stw	r4,-16(fp)
 1017c84:	e17ffd15 	stw	r5,-12(fp)
  /* Transfer data if there is some ready to be transfered */

  if (sp->tx_start != sp->tx_end)
 1017c88:	e0bffc17 	ldw	r2,-16(fp)
 1017c8c:	10c00417 	ldw	r3,16(r2)
 1017c90:	e0bffc17 	ldw	r2,-16(fp)
 1017c94:	10800517 	ldw	r2,20(r2)
 1017c98:	18803226 	beq	r3,r2,1017d64 <altera_avalon_uart_txirq+0xf0>
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
 1017c9c:	e0bffc17 	ldw	r2,-16(fp)
 1017ca0:	10800617 	ldw	r2,24(r2)
 1017ca4:	1080008c 	andi	r2,r2,2
 1017ca8:	10000326 	beq	r2,zero,1017cb8 <altera_avalon_uart_txirq+0x44>
      (status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
 1017cac:	e0bffd17 	ldw	r2,-12(fp)
 1017cb0:	1082000c 	andi	r2,r2,2048
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
 1017cb4:	10001d26 	beq	r2,zero,1017d2c <altera_avalon_uart_txirq+0xb8>
       * In a multi-threaded environment, set the write event flag to indicate
       * that there is space in the circular buffer. This is only done if the
       * buffer was previously empty.
       */

      if (sp->tx_start == ((sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK))
 1017cb8:	e0bffc17 	ldw	r2,-16(fp)
 1017cbc:	10800417 	ldw	r2,16(r2)
 1017cc0:	e0bffc17 	ldw	r2,-16(fp)
 1017cc4:	10800517 	ldw	r2,20(r2)
                       OS_FLAG_SET);
      }

      /* Write the data to the device */

      IOWR_ALTERA_AVALON_UART_TXDATA(sp->base, sp->tx_buf[sp->tx_start]);
 1017cc8:	e0bffc17 	ldw	r2,-16(fp)
 1017ccc:	10800017 	ldw	r2,0(r2)
 1017cd0:	10800104 	addi	r2,r2,4
 1017cd4:	e0fffc17 	ldw	r3,-16(fp)
 1017cd8:	18c00417 	ldw	r3,16(r3)
 1017cdc:	e13ffc17 	ldw	r4,-16(fp)
 1017ce0:	20c7883a 	add	r3,r4,r3
 1017ce4:	18c01704 	addi	r3,r3,92
 1017ce8:	18c00003 	ldbu	r3,0(r3)
 1017cec:	18c03fcc 	andi	r3,r3,255
 1017cf0:	10c00035 	stwio	r3,0(r2)

      sp->tx_start = (++sp->tx_start) & ALT_AVALON_UART_BUF_MSK;
 1017cf4:	e0bffc17 	ldw	r2,-16(fp)
 1017cf8:	10800417 	ldw	r2,16(r2)
 1017cfc:	10800044 	addi	r2,r2,1
 1017d00:	e0fffc17 	ldw	r3,-16(fp)
 1017d04:	18800415 	stw	r2,16(r3)
 1017d08:	10c00fcc 	andi	r3,r2,63
 1017d0c:	e0bffc17 	ldw	r2,-16(fp)
 1017d10:	10c00415 	stw	r3,16(r2)
      /*
       * In case the tranmit interrupt had previously been disabled by 
       * detecting a low value on CTS, it is reenabled here.
       */ 

      sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
 1017d14:	e0bffc17 	ldw	r2,-16(fp)
 1017d18:	10800117 	ldw	r2,4(r2)
 1017d1c:	10c01014 	ori	r3,r2,64
 1017d20:	e0bffc17 	ldw	r2,-16(fp)
 1017d24:	10c00115 	stw	r3,4(r2)
 1017d28:	00000e06 	br	1017d64 <altera_avalon_uart_txirq+0xf0>
       * the last write to the status register. To avoid this resulting in
       * deadlock, it's necessary to re-check the status register here
       * before throttling.
       */
 
      status = IORD_ALTERA_AVALON_UART_STATUS(sp->base); 
 1017d2c:	e0bffc17 	ldw	r2,-16(fp)
 1017d30:	10800017 	ldw	r2,0(r2)
 1017d34:	10800204 	addi	r2,r2,8
 1017d38:	10800037 	ldwio	r2,0(r2)
 1017d3c:	e0bffd15 	stw	r2,-12(fp)

      if (!(status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
 1017d40:	e0bffd17 	ldw	r2,-12(fp)
 1017d44:	1082000c 	andi	r2,r2,2048
 1017d48:	1000061e 	bne	r2,zero,1017d64 <altera_avalon_uart_txirq+0xf0>
      {
        sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
 1017d4c:	e0bffc17 	ldw	r2,-16(fp)
 1017d50:	10c00117 	ldw	r3,4(r2)
 1017d54:	00bfefc4 	movi	r2,-65
 1017d58:	1886703a 	and	r3,r3,r2
 1017d5c:	e0bffc17 	ldw	r2,-16(fp)
 1017d60:	10c00115 	stw	r3,4(r2)
  /*
   * If the circular buffer is empty, disable the interrupt. This will be
   * re-enabled when new data is placed in the buffer.
   */

  if (sp->tx_start == sp->tx_end)
 1017d64:	e0bffc17 	ldw	r2,-16(fp)
 1017d68:	10c00417 	ldw	r3,16(r2)
 1017d6c:	e0bffc17 	ldw	r2,-16(fp)
 1017d70:	10800517 	ldw	r2,20(r2)
 1017d74:	1880061e 	bne	r3,r2,1017d90 <altera_avalon_uart_txirq+0x11c>
  {
    sp->ctrl &= ~(ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
 1017d78:	e0bffc17 	ldw	r2,-16(fp)
 1017d7c:	10c00117 	ldw	r3,4(r2)
 1017d80:	00beefc4 	movi	r2,-1089
 1017d84:	1886703a 	and	r3,r3,r2
 1017d88:	e0bffc17 	ldw	r2,-16(fp)
 1017d8c:	10c00115 	stw	r3,4(r2)
                    ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
  }

  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
 1017d90:	e0bffc17 	ldw	r2,-16(fp)
 1017d94:	10800017 	ldw	r2,0(r2)
 1017d98:	10800304 	addi	r2,r2,12
 1017d9c:	e0fffc17 	ldw	r3,-16(fp)
 1017da0:	18c00117 	ldw	r3,4(r3)
 1017da4:	10c00035 	stwio	r3,0(r2)
}
 1017da8:	0001883a 	nop
 1017dac:	e037883a 	mov	sp,fp
 1017db0:	df000017 	ldw	fp,0(sp)
 1017db4:	dec00104 	addi	sp,sp,4
 1017db8:	f800283a 	ret

01017dbc <altera_avalon_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
 1017dbc:	defffd04 	addi	sp,sp,-12
 1017dc0:	df000215 	stw	fp,8(sp)
 1017dc4:	df000204 	addi	fp,sp,8
 1017dc8:	e13ffe15 	stw	r4,-8(fp)
 1017dcc:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
 1017dd0:	00000506 	br	1017de8 <altera_avalon_uart_close+0x2c>
    if (flags & O_NONBLOCK) {
 1017dd4:	e0bfff17 	ldw	r2,-4(fp)
 1017dd8:	1090000c 	andi	r2,r2,16384
 1017ddc:	10000226 	beq	r2,zero,1017de8 <altera_avalon_uart_close+0x2c>
      return -EWOULDBLOCK; 
 1017de0:	00bffd44 	movi	r2,-11
 1017de4:	00000606 	br	1017e00 <altera_avalon_uart_close+0x44>
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
 1017de8:	e0bffe17 	ldw	r2,-8(fp)
 1017dec:	10c00417 	ldw	r3,16(r2)
 1017df0:	e0bffe17 	ldw	r2,-8(fp)
 1017df4:	10800517 	ldw	r2,20(r2)
 1017df8:	18bff61e 	bne	r3,r2,1017dd4 <__alt_data_end+0xff817dd4>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
 1017dfc:	0005883a 	mov	r2,zero
}
 1017e00:	e037883a 	mov	sp,fp
 1017e04:	df000017 	ldw	fp,0(sp)
 1017e08:	dec00104 	addi	sp,sp,4
 1017e0c:	f800283a 	ret

01017e10 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 1017e10:	defffe04 	addi	sp,sp,-8
 1017e14:	dfc00115 	stw	ra,4(sp)
 1017e18:	df000015 	stw	fp,0(sp)
 1017e1c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 1017e20:	d0a02c17 	ldw	r2,-32592(gp)
 1017e24:	10000326 	beq	r2,zero,1017e34 <alt_get_errno+0x24>
 1017e28:	d0a02c17 	ldw	r2,-32592(gp)
 1017e2c:	103ee83a 	callr	r2
 1017e30:	00000106 	br	1017e38 <alt_get_errno+0x28>
 1017e34:	d0a0ae04 	addi	r2,gp,-32072
}
 1017e38:	e037883a 	mov	sp,fp
 1017e3c:	dfc00117 	ldw	ra,4(sp)
 1017e40:	df000017 	ldw	fp,0(sp)
 1017e44:	dec00204 	addi	sp,sp,8
 1017e48:	f800283a 	ret

01017e4c <altera_avalon_uart_read>:
 */

int 
altera_avalon_uart_read(altera_avalon_uart_state* sp, char* ptr, int len,
  int flags)
{
 1017e4c:	defff204 	addi	sp,sp,-56
 1017e50:	dfc00d15 	stw	ra,52(sp)
 1017e54:	df000c15 	stw	fp,48(sp)
 1017e58:	df000c04 	addi	fp,sp,48
 1017e5c:	e13ffc15 	stw	r4,-16(fp)
 1017e60:	e17ffd15 	stw	r5,-12(fp)
 1017e64:	e1bffe15 	stw	r6,-8(fp)
 1017e68:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             block;
  alt_u8          read_would_block = 0;
 1017e6c:	e03ff405 	stb	zero,-48(fp)
  int             count = 0;
 1017e70:	e03ff515 	stw	zero,-44(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  block = !(flags & O_NONBLOCK);
 1017e74:	e0bfff17 	ldw	r2,-4(fp)
 1017e78:	1090000c 	andi	r2,r2,16384
 1017e7c:	1005003a 	cmpeq	r2,r2,zero
 1017e80:	10803fcc 	andi	r2,r2,255
 1017e84:	e0bff615 	stw	r2,-40(fp)
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
 1017e88:	00001306 	br	1017ed8 <altera_avalon_uart_read+0x8c>
    {
      count++;
 1017e8c:	e0bff517 	ldw	r2,-44(fp)
 1017e90:	10800044 	addi	r2,r2,1
 1017e94:	e0bff515 	stw	r2,-44(fp)
      *ptr++ = sp->rx_buf[sp->rx_start];
 1017e98:	e0bffd17 	ldw	r2,-12(fp)
 1017e9c:	10c00044 	addi	r3,r2,1
 1017ea0:	e0fffd15 	stw	r3,-12(fp)
 1017ea4:	e0fffc17 	ldw	r3,-16(fp)
 1017ea8:	18c00217 	ldw	r3,8(r3)
 1017eac:	e13ffc17 	ldw	r4,-16(fp)
 1017eb0:	20c7883a 	add	r3,r4,r3
 1017eb4:	18c00704 	addi	r3,r3,28
 1017eb8:	18c00003 	ldbu	r3,0(r3)
 1017ebc:	10c00005 	stb	r3,0(r2)
      
      sp->rx_start = (sp->rx_start+1) & ALT_AVALON_UART_BUF_MSK;
 1017ec0:	e0bffc17 	ldw	r2,-16(fp)
 1017ec4:	10800217 	ldw	r2,8(r2)
 1017ec8:	10800044 	addi	r2,r2,1
 1017ecc:	10c00fcc 	andi	r3,r2,63
 1017ed0:	e0bffc17 	ldw	r2,-16(fp)
 1017ed4:	10c00215 	stw	r3,8(r2)
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
 1017ed8:	e0fff517 	ldw	r3,-44(fp)
 1017edc:	e0bffe17 	ldw	r2,-8(fp)
 1017ee0:	1880050e 	bge	r3,r2,1017ef8 <altera_avalon_uart_read+0xac>
 1017ee4:	e0bffc17 	ldw	r2,-16(fp)
 1017ee8:	10c00217 	ldw	r3,8(r2)
 1017eec:	e0bffc17 	ldw	r2,-16(fp)
 1017ef0:	10800317 	ldw	r2,12(r2)
 1017ef4:	18bfe51e 	bne	r3,r2,1017e8c <__alt_data_end+0xff817e8c>
    /*
     * If no data has been transferred, the circular buffer is empty, and
     * this is not a non-blocking access, block waiting for data to arrive.
     */

    if (!count && (sp->rx_start == sp->rx_end))
 1017ef8:	e0bff517 	ldw	r2,-44(fp)
 1017efc:	1000251e 	bne	r2,zero,1017f94 <altera_avalon_uart_read+0x148>
 1017f00:	e0bffc17 	ldw	r2,-16(fp)
 1017f04:	10c00217 	ldw	r3,8(r2)
 1017f08:	e0bffc17 	ldw	r2,-16(fp)
 1017f0c:	10800317 	ldw	r2,12(r2)
 1017f10:	1880201e 	bne	r3,r2,1017f94 <altera_avalon_uart_read+0x148>
    {
      if (!block)
 1017f14:	e0bff617 	ldw	r2,-40(fp)
 1017f18:	1000071e 	bne	r2,zero,1017f38 <altera_avalon_uart_read+0xec>
      {
        /* Set errno to indicate the reason we're not returning any data */

        ALT_ERRNO = EWOULDBLOCK;
 1017f1c:	1017e100 	call	1017e10 <alt_get_errno>
 1017f20:	1007883a 	mov	r3,r2
 1017f24:	008002c4 	movi	r2,11
 1017f28:	18800015 	stw	r2,0(r3)
        read_would_block = 1;
 1017f2c:	00800044 	movi	r2,1
 1017f30:	e0bff405 	stb	r2,-48(fp)
        break;
 1017f34:	00001b06 	br	1017fa4 <altera_avalon_uart_read+0x158>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1017f38:	0005303a 	rdctl	r2,status
 1017f3c:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1017f40:	e0fff917 	ldw	r3,-28(fp)
 1017f44:	00bfff84 	movi	r2,-2
 1017f48:	1884703a 	and	r2,r3,r2
 1017f4c:	1001703a 	wrctl	status,r2
  
  return context;
 1017f50:	e0bff917 	ldw	r2,-28(fp)
      {
       /* Block waiting for some data to arrive */

       /* First, ensure read interrupts are enabled to avoid deadlock */

       context = alt_irq_disable_all ();
 1017f54:	e0bff815 	stw	r2,-32(fp)
       sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
 1017f58:	e0bffc17 	ldw	r2,-16(fp)
 1017f5c:	10800117 	ldw	r2,4(r2)
 1017f60:	10c02014 	ori	r3,r2,128
 1017f64:	e0bffc17 	ldw	r2,-16(fp)
 1017f68:	10c00115 	stw	r3,4(r2)
       IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
 1017f6c:	e0bffc17 	ldw	r2,-16(fp)
 1017f70:	10800017 	ldw	r2,0(r2)
 1017f74:	10800304 	addi	r2,r2,12
 1017f78:	e0fffc17 	ldw	r3,-16(fp)
 1017f7c:	18c00117 	ldw	r3,4(r3)
 1017f80:	10c00035 	stwio	r3,0(r2)
 1017f84:	e0bff817 	ldw	r2,-32(fp)
 1017f88:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 1017f8c:	e0bffa17 	ldw	r2,-24(fp)
 1017f90:	1001703a 	wrctl	status,r2
                      OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                      0);
      }
    }
  }
  while (!count && len);
 1017f94:	e0bff517 	ldw	r2,-44(fp)
 1017f98:	1000021e 	bne	r2,zero,1017fa4 <altera_avalon_uart_read+0x158>
 1017f9c:	e0bffe17 	ldw	r2,-8(fp)
 1017fa0:	103fcd1e 	bne	r2,zero,1017ed8 <__alt_data_end+0xff817ed8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1017fa4:	0005303a 	rdctl	r2,status
 1017fa8:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1017fac:	e0fffb17 	ldw	r3,-20(fp)
 1017fb0:	00bfff84 	movi	r2,-2
 1017fb4:	1884703a 	and	r2,r3,r2
 1017fb8:	1001703a 	wrctl	status,r2
  
  return context;
 1017fbc:	e0bffb17 	ldw	r2,-20(fp)
  /*
   * Ensure that interrupts are enabled, so that the circular buffer can
   * re-fill.
   */

  context = alt_irq_disable_all ();
 1017fc0:	e0bff815 	stw	r2,-32(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
 1017fc4:	e0bffc17 	ldw	r2,-16(fp)
 1017fc8:	10800117 	ldw	r2,4(r2)
 1017fcc:	10c02014 	ori	r3,r2,128
 1017fd0:	e0bffc17 	ldw	r2,-16(fp)
 1017fd4:	10c00115 	stw	r3,4(r2)
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
 1017fd8:	e0bffc17 	ldw	r2,-16(fp)
 1017fdc:	10800017 	ldw	r2,0(r2)
 1017fe0:	10800304 	addi	r2,r2,12
 1017fe4:	e0fffc17 	ldw	r3,-16(fp)
 1017fe8:	18c00117 	ldw	r3,4(r3)
 1017fec:	10c00035 	stwio	r3,0(r2)
 1017ff0:	e0bff817 	ldw	r2,-32(fp)
 1017ff4:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 1017ff8:	e0bff717 	ldw	r2,-36(fp)
 1017ffc:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* Return the number of bytes read */
  if(read_would_block) {
 1018000:	e0bff403 	ldbu	r2,-48(fp)
 1018004:	10000226 	beq	r2,zero,1018010 <altera_avalon_uart_read+0x1c4>
    return -EWOULDBLOCK;
 1018008:	00bffd44 	movi	r2,-11
 101800c:	00000106 	br	1018014 <altera_avalon_uart_read+0x1c8>
  }
  else {
    return count;
 1018010:	e0bff517 	ldw	r2,-44(fp)
  }
}
 1018014:	e037883a 	mov	sp,fp
 1018018:	dfc00117 	ldw	ra,4(sp)
 101801c:	df000017 	ldw	fp,0(sp)
 1018020:	dec00204 	addi	sp,sp,8
 1018024:	f800283a 	ret

01018028 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 1018028:	defffe04 	addi	sp,sp,-8
 101802c:	dfc00115 	stw	ra,4(sp)
 1018030:	df000015 	stw	fp,0(sp)
 1018034:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 1018038:	d0a02c17 	ldw	r2,-32592(gp)
 101803c:	10000326 	beq	r2,zero,101804c <alt_get_errno+0x24>
 1018040:	d0a02c17 	ldw	r2,-32592(gp)
 1018044:	103ee83a 	callr	r2
 1018048:	00000106 	br	1018050 <alt_get_errno+0x28>
 101804c:	d0a0ae04 	addi	r2,gp,-32072
}
 1018050:	e037883a 	mov	sp,fp
 1018054:	dfc00117 	ldw	ra,4(sp)
 1018058:	df000017 	ldw	fp,0(sp)
 101805c:	dec00204 	addi	sp,sp,8
 1018060:	f800283a 	ret

01018064 <altera_avalon_uart_write>:
 */

int
altera_avalon_uart_write(altera_avalon_uart_state* sp, const char* ptr, int len,
  int flags)
{
 1018064:	defff204 	addi	sp,sp,-56
 1018068:	dfc00d15 	stw	ra,52(sp)
 101806c:	df000c15 	stw	fp,48(sp)
 1018070:	df000c04 	addi	fp,sp,48
 1018074:	e13ffc15 	stw	r4,-16(fp)
 1018078:	e17ffd15 	stw	r5,-12(fp)
 101807c:	e1bffe15 	stw	r6,-8(fp)
 1018080:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             no_block;
  alt_u32         next;
  int             count = len;
 1018084:	e0bffe17 	ldw	r2,-8(fp)
 1018088:	e0bff415 	stw	r2,-48(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  no_block = (flags & O_NONBLOCK);
 101808c:	e0bfff17 	ldw	r2,-4(fp)
 1018090:	1090000c 	andi	r2,r2,16384
 1018094:	e0bff515 	stw	r2,-44(fp)
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
 1018098:	00003c06 	br	101818c <altera_avalon_uart_write+0x128>
  {
    /* Determine the next slot in the buffer to access */

    next = (sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK;
 101809c:	e0bffc17 	ldw	r2,-16(fp)
 10180a0:	10800517 	ldw	r2,20(r2)
 10180a4:	10800044 	addi	r2,r2,1
 10180a8:	10800fcc 	andi	r2,r2,63
 10180ac:	e0bff715 	stw	r2,-36(fp)

    /* block waiting for space if necessary */

    if (next == sp->tx_start)
 10180b0:	e0bffc17 	ldw	r2,-16(fp)
 10180b4:	10c00417 	ldw	r3,16(r2)
 10180b8:	e0bff717 	ldw	r2,-36(fp)
 10180bc:	1880221e 	bne	r3,r2,1018148 <altera_avalon_uart_write+0xe4>
    {
      if (no_block)
 10180c0:	e0bff517 	ldw	r2,-44(fp)
 10180c4:	10000526 	beq	r2,zero,10180dc <altera_avalon_uart_write+0x78>
      {
        /* Set errno to indicate why this function returned early */
 
        ALT_ERRNO = EWOULDBLOCK;
 10180c8:	10180280 	call	1018028 <alt_get_errno>
 10180cc:	1007883a 	mov	r3,r2
 10180d0:	008002c4 	movi	r2,11
 10180d4:	18800015 	stw	r2,0(r3)
        break;
 10180d8:	00002e06 	br	1018194 <altera_avalon_uart_write+0x130>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 10180dc:	0005303a 	rdctl	r2,status
 10180e0:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 10180e4:	e0fff917 	ldw	r3,-28(fp)
 10180e8:	00bfff84 	movi	r2,-2
 10180ec:	1884703a 	and	r2,r3,r2
 10180f0:	1001703a 	wrctl	status,r2
  
  return context;
 10180f4:	e0bff917 	ldw	r2,-28(fp)
      {
        /* Block waiting for space in the circular buffer */

        /* First, ensure transmit interrupts are enabled to avoid deadlock */

        context = alt_irq_disable_all ();
 10180f8:	e0bff815 	stw	r2,-32(fp)
        sp->ctrl |= (ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
 10180fc:	e0bffc17 	ldw	r2,-16(fp)
 1018100:	10800117 	ldw	r2,4(r2)
 1018104:	10c11014 	ori	r3,r2,1088
 1018108:	e0bffc17 	ldw	r2,-16(fp)
 101810c:	10c00115 	stw	r3,4(r2)
                        ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
        IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
 1018110:	e0bffc17 	ldw	r2,-16(fp)
 1018114:	10800017 	ldw	r2,0(r2)
 1018118:	10800304 	addi	r2,r2,12
 101811c:	e0fffc17 	ldw	r3,-16(fp)
 1018120:	18c00117 	ldw	r3,4(r3)
 1018124:	10c00035 	stwio	r3,0(r2)
 1018128:	e0bff817 	ldw	r2,-32(fp)
 101812c:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 1018130:	e0bff617 	ldw	r2,-40(fp)
 1018134:	1001703a 	wrctl	status,r2
          ALT_FLAG_PEND (sp->events, 
                         ALT_UART_WRITE_RDY,
                         OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                         0);
        }
        while ((next == sp->tx_start));
 1018138:	e0bffc17 	ldw	r2,-16(fp)
 101813c:	10c00417 	ldw	r3,16(r2)
 1018140:	e0bff717 	ldw	r2,-36(fp)
 1018144:	18bffc26 	beq	r3,r2,1018138 <__alt_data_end+0xff818138>
      }
    }

    count--;
 1018148:	e0bff417 	ldw	r2,-48(fp)
 101814c:	10bfffc4 	addi	r2,r2,-1
 1018150:	e0bff415 	stw	r2,-48(fp)

    /* Add the next character to the transmit buffer */

    sp->tx_buf[sp->tx_end] = *ptr++;
 1018154:	e0bffc17 	ldw	r2,-16(fp)
 1018158:	10c00517 	ldw	r3,20(r2)
 101815c:	e0bffd17 	ldw	r2,-12(fp)
 1018160:	11000044 	addi	r4,r2,1
 1018164:	e13ffd15 	stw	r4,-12(fp)
 1018168:	10800003 	ldbu	r2,0(r2)
 101816c:	1009883a 	mov	r4,r2
 1018170:	e0bffc17 	ldw	r2,-16(fp)
 1018174:	10c5883a 	add	r2,r2,r3
 1018178:	10801704 	addi	r2,r2,92
 101817c:	11000005 	stb	r4,0(r2)
    sp->tx_end = next;
 1018180:	e0bffc17 	ldw	r2,-16(fp)
 1018184:	e0fff717 	ldw	r3,-36(fp)
 1018188:	10c00515 	stw	r3,20(r2)
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
 101818c:	e0bff417 	ldw	r2,-48(fp)
 1018190:	103fc21e 	bne	r2,zero,101809c <__alt_data_end+0xff81809c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1018194:	0005303a 	rdctl	r2,status
 1018198:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 101819c:	e0fffb17 	ldw	r3,-20(fp)
 10181a0:	00bfff84 	movi	r2,-2
 10181a4:	1884703a 	and	r2,r3,r2
 10181a8:	1001703a 	wrctl	status,r2
  
  return context;
 10181ac:	e0bffb17 	ldw	r2,-20(fp)
  /* 
   * Ensure that interrupts are enabled, so that the circular buffer can 
   * drain.
   */

  context = alt_irq_disable_all ();
 10181b0:	e0bff815 	stw	r2,-32(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
 10181b4:	e0bffc17 	ldw	r2,-16(fp)
 10181b8:	10800117 	ldw	r2,4(r2)
 10181bc:	10c11014 	ori	r3,r2,1088
 10181c0:	e0bffc17 	ldw	r2,-16(fp)
 10181c4:	10c00115 	stw	r3,4(r2)
                 ALTERA_AVALON_UART_CONTROL_DCTS_MSK;
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
 10181c8:	e0bffc17 	ldw	r2,-16(fp)
 10181cc:	10800017 	ldw	r2,0(r2)
 10181d0:	10800304 	addi	r2,r2,12
 10181d4:	e0fffc17 	ldw	r3,-16(fp)
 10181d8:	18c00117 	ldw	r3,4(r3)
 10181dc:	10c00035 	stwio	r3,0(r2)
 10181e0:	e0bff817 	ldw	r2,-32(fp)
 10181e4:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 10181e8:	e0bffa17 	ldw	r2,-24(fp)
 10181ec:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* return the number of bytes written */

  return (len - count);
 10181f0:	e0fffe17 	ldw	r3,-8(fp)
 10181f4:	e0bff417 	ldw	r2,-48(fp)
 10181f8:	1885c83a 	sub	r2,r3,r2
}
 10181fc:	e037883a 	mov	sp,fp
 1018200:	dfc00117 	ldw	ra,4(sp)
 1018204:	df000017 	ldw	fp,0(sp)
 1018208:	dec00204 	addi	sp,sp,8
 101820c:	f800283a 	ret

01018210 <alt_adc_irq>:
 * alt_adc_irq()
 *
 * Interrupt handler for the altera modular adc.
 */
static void alt_adc_irq(void *context)
{
 1018210:	defff904 	addi	sp,sp,-28
 1018214:	dfc00615 	stw	ra,24(sp)
 1018218:	df000515 	stw	fp,20(sp)
 101821c:	df000504 	addi	fp,sp,20
 1018220:	e13fff15 	stw	r4,-4(fp)
    alt_modular_adc_dev *dev = (alt_modular_adc_dev *) context;
 1018224:	e0bfff17 	ldw	r2,-4(fp)
 1018228:	e0bffb15 	stw	r2,-20(fp)
    alt_irq_context cpu_sr = 0;
 101822c:	e03ffc15 	stw	zero,-16(fp)

	if(NULL != dev)
 1018230:	e0bffb17 	ldw	r2,-20(fp)
 1018234:	10001a26 	beq	r2,zero,10182a0 <alt_adc_irq+0x90>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1018238:	0005303a 	rdctl	r2,status
 101823c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 1018240:	e0fffe17 	ldw	r3,-8(fp)
 1018244:	00bfff84 	movi	r2,-2
 1018248:	1884703a 	and	r2,r3,r2
 101824c:	1001703a 	wrctl	status,r2
  
  return context;
 1018250:	e0bffe17 	ldw	r2,-8(fp)
	{
	    cpu_sr = alt_irq_disable_all();
 1018254:	e0bffc15 	stw	r2,-16(fp)
		* Other interrupts are explicitly disabled if callbacks
		* are registered because there is no guarantee that they are 
		* pre-emption-safe. This allows the driver to support 
		* interrupt pre-emption.
		*/
		if(dev->callback) 
 1018258:	e0bffb17 	ldw	r2,-20(fp)
 101825c:	10800a17 	ldw	r2,40(r2)
 1018260:	10000626 	beq	r2,zero,101827c <alt_adc_irq+0x6c>
		{
			dev->callback (dev->callback_context);
 1018264:	e0bffb17 	ldw	r2,-20(fp)
 1018268:	10800a17 	ldw	r2,40(r2)
 101826c:	e0fffb17 	ldw	r3,-20(fp)
 1018270:	18c00b17 	ldw	r3,44(r3)
 1018274:	1809883a 	mov	r4,r3
 1018278:	103ee83a 	callr	r2
		}
    
		/* clear the IRQ status */
		adc_clear_interrupt_status(dev->sample_store_base);
 101827c:	e0bffb17 	ldw	r2,-20(fp)
 1018280:	10800c17 	ldw	r2,48(r2)
 1018284:	1009883a 	mov	r4,r2
 1018288:	10186bc0 	call	10186bc <adc_clear_interrupt_status>
 101828c:	e0bffc17 	ldw	r2,-16(fp)
 1018290:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 1018294:	e0bffd17 	ldw	r2,-12(fp)
 1018298:	1001703a 	wrctl	status,r2
	    
		alt_irq_enable_all(cpu_sr);
	}
	
    return;
 101829c:	0001883a 	nop
 10182a0:	0001883a 	nop
}
 10182a4:	e037883a 	mov	sp,fp
 10182a8:	dfc00117 	ldw	ra,4(sp)
 10182ac:	df000017 	ldw	fp,0(sp)
 10182b0:	dec00204 	addi	sp,sp,8
 10182b4:	f800283a 	ret

010182b8 <alt_adc_word_read>:
 * Returns:
 * 0 -> success
 * -EINVAL -> Invalid arguments
**/
int alt_adc_word_read (alt_u32 sample_store_base, alt_u32* dest_ptr, alt_u32 len)
{
 10182b8:	defff804 	addi	sp,sp,-32
 10182bc:	df000715 	stw	fp,28(sp)
 10182c0:	df000704 	addi	fp,sp,28
 10182c4:	e13ffd15 	stw	r4,-12(fp)
 10182c8:	e17ffe15 	stw	r5,-8(fp)
 10182cc:	e1bfff15 	stw	r6,-4(fp)
    alt_u32 word = 0;
 10182d0:	e03ff915 	stw	zero,-28(fp)
    alt_u32 word_length = len;
 10182d4:	e0bfff17 	ldw	r2,-4(fp)
 10182d8:	e0bffb15 	stw	r2,-20(fp)
    alt_u32* dest_buf = dest_ptr;
 10182dc:	e0bffe17 	ldw	r2,-8(fp)
 10182e0:	e0bffa15 	stw	r2,-24(fp)
    alt_u32 base = sample_store_base;
 10182e4:	e0bffd17 	ldw	r2,-12(fp)
 10182e8:	e0bffc15 	stw	r2,-16(fp)
     
    /* return -EINVAL if invalid arguments passed into function */
    if(NULL == dest_buf)
 10182ec:	e0bffa17 	ldw	r2,-24(fp)
 10182f0:	1000021e 	bne	r2,zero,10182fc <alt_adc_word_read+0x44>
    {
    	return -EINVAL;
 10182f4:	00bffa84 	movi	r2,-22
 10182f8:	00001606 	br	1018354 <alt_adc_word_read+0x9c>
    }

    for(word = 0; word < word_length; word++)
 10182fc:	e03ff915 	stw	zero,-28(fp)
 1018300:	00001006 	br	1018344 <alt_adc_word_read+0x8c>
    {
       *dest_buf = IORD_32DIRECT((base + (word * 4)),0);
 1018304:	e0bff917 	ldw	r2,-28(fp)
 1018308:	1085883a 	add	r2,r2,r2
 101830c:	1085883a 	add	r2,r2,r2
 1018310:	1007883a 	mov	r3,r2
 1018314:	e0bffc17 	ldw	r2,-16(fp)
 1018318:	1885883a 	add	r2,r3,r2
 101831c:	10800037 	ldwio	r2,0(r2)
 1018320:	1007883a 	mov	r3,r2
 1018324:	e0bffa17 	ldw	r2,-24(fp)
 1018328:	10c00015 	stw	r3,0(r2)

       dest_buf++;
 101832c:	e0bffa17 	ldw	r2,-24(fp)
 1018330:	10800104 	addi	r2,r2,4
 1018334:	e0bffa15 	stw	r2,-24(fp)
    if(NULL == dest_buf)
    {
    	return -EINVAL;
    }

    for(word = 0; word < word_length; word++)
 1018338:	e0bff917 	ldw	r2,-28(fp)
 101833c:	10800044 	addi	r2,r2,1
 1018340:	e0bff915 	stw	r2,-28(fp)
 1018344:	e0fff917 	ldw	r3,-28(fp)
 1018348:	e0bffb17 	ldw	r2,-20(fp)
 101834c:	18bfed36 	bltu	r3,r2,1018304 <__alt_data_end+0xff818304>
       *dest_buf = IORD_32DIRECT((base + (word * 4)),0);

       dest_buf++;
    }

    return 0;
 1018350:	0005883a 	mov	r2,zero

}
 1018354:	e037883a 	mov	sp,fp
 1018358:	df000017 	ldw	fp,0(sp)
 101835c:	dec00104 	addi	sp,sp,4
 1018360:	f800283a 	ret

01018364 <altera_modular_adc_init>:


void altera_modular_adc_init(alt_modular_adc_dev* dev, alt_32 ic_id, alt_32 irq)
{
 1018364:	defffa04 	addi	sp,sp,-24
 1018368:	dfc00515 	stw	ra,20(sp)
 101836c:	df000415 	stw	fp,16(sp)
 1018370:	df000404 	addi	fp,sp,16
 1018374:	e13ffd15 	stw	r4,-12(fp)
 1018378:	e17ffe15 	stw	r5,-8(fp)
 101837c:	e1bfff15 	stw	r6,-4(fp)
    extern alt_llist altera_modular_adc_list;
    alt_dev_llist_insert((alt_dev_llist*) dev, &altera_modular_adc_list);
 1018380:	d1602f04 	addi	r5,gp,-32580
 1018384:	e13ffd17 	ldw	r4,-12(fp)
 1018388:	10199f40 	call	10199f4 <alt_dev_llist_insert>
	
	if ((0 <= ic_id) && (0 <= irq))
 101838c:	e0bffe17 	ldw	r2,-8(fp)
 1018390:	10000b16 	blt	r2,zero,10183c0 <altera_modular_adc_init+0x5c>
 1018394:	e0bfff17 	ldw	r2,-4(fp)
 1018398:	10000916 	blt	r2,zero,10183c0 <altera_modular_adc_init+0x5c>
	{
          /* Install IRQ handler */
	  #ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
              alt_ic_isr_register(ic_id, irq, alt_adc_irq, 
 101839c:	e0bffe17 	ldw	r2,-8(fp)
 10183a0:	e0ffff17 	ldw	r3,-4(fp)
 10183a4:	d8000015 	stw	zero,0(sp)
 10183a8:	e1fffd17 	ldw	r7,-12(fp)
 10183ac:	018040b4 	movhi	r6,258
 10183b0:	31a08404 	addi	r6,r6,-32240
 10183b4:	180b883a 	mov	r5,r3
 10183b8:	1009883a 	mov	r4,r2
 10183bc:	10164880 	call	1016488 <alt_ic_isr_register>
                      dev, NULL);
          #else
             alt_irq_register(irq, dev, alt_adc_irq);
          #endif 
	}
}
 10183c0:	0001883a 	nop
 10183c4:	e037883a 	mov	sp,fp
 10183c8:	dfc00117 	ldw	ra,4(sp)
 10183cc:	df000017 	ldw	fp,0(sp)
 10183d0:	dec00204 	addi	sp,sp,8
 10183d4:	f800283a 	ret

010183d8 <alt_adc_register_callback>:
void alt_adc_register_callback(
	alt_modular_adc_dev *dev,
	alt_adc_callback callback,
	void *context,
	alt_u32 sample_store_base)
{
 10183d8:	defffa04 	addi	sp,sp,-24
 10183dc:	dfc00515 	stw	ra,20(sp)
 10183e0:	df000415 	stw	fp,16(sp)
 10183e4:	df000404 	addi	fp,sp,16
 10183e8:	e13ffc15 	stw	r4,-16(fp)
 10183ec:	e17ffd15 	stw	r5,-12(fp)
 10183f0:	e1bffe15 	stw	r6,-8(fp)
 10183f4:	e1ffff15 	stw	r7,-4(fp)
    dev->callback         = callback;
 10183f8:	e0bffc17 	ldw	r2,-16(fp)
 10183fc:	e0fffd17 	ldw	r3,-12(fp)
 1018400:	10c00a15 	stw	r3,40(r2)
    dev->callback_context = context;
 1018404:	e0bffc17 	ldw	r2,-16(fp)
 1018408:	e0fffe17 	ldw	r3,-8(fp)
 101840c:	10c00b15 	stw	r3,44(r2)
    dev->sample_store_base = sample_store_base;
 1018410:	e0bffc17 	ldw	r2,-16(fp)
 1018414:	e0ffff17 	ldw	r3,-4(fp)
 1018418:	10c00c15 	stw	r3,48(r2)
	
	if(NULL != callback)
 101841c:	e0bffd17 	ldw	r2,-12(fp)
 1018420:	10000726 	beq	r2,zero,1018440 <alt_adc_register_callback+0x68>
	{
                adc_clear_interrupt_status(sample_store_base);
 1018424:	e0bfff17 	ldw	r2,-4(fp)
 1018428:	1009883a 	mov	r4,r2
 101842c:	10186bc0 	call	10186bc <adc_clear_interrupt_status>
		adc_interrupt_enable(sample_store_base);
 1018430:	e0bfff17 	ldw	r2,-4(fp)
 1018434:	1009883a 	mov	r4,r2
 1018438:	10186300 	call	1018630 <adc_interrupt_enable>
                adc_clear_interrupt_status(sample_store_base);
	}
	
    
	
    return ;
 101843c:	00000706 	br	101845c <alt_adc_register_callback+0x84>
                adc_clear_interrupt_status(sample_store_base);
		adc_interrupt_enable(sample_store_base);
	}
	else
	{
		adc_interrupt_disable(sample_store_base);
 1018440:	e0bfff17 	ldw	r2,-4(fp)
 1018444:	1009883a 	mov	r4,r2
 1018448:	10186740 	call	1018674 <adc_interrupt_disable>
                adc_clear_interrupt_status(sample_store_base);
 101844c:	e0bfff17 	ldw	r2,-4(fp)
 1018450:	1009883a 	mov	r4,r2
 1018454:	10186bc0 	call	10186bc <adc_clear_interrupt_status>
	}
	
    
	
    return ;
 1018458:	0001883a 	nop
}
 101845c:	e037883a 	mov	sp,fp
 1018460:	dfc00117 	ldw	ra,4(sp)
 1018464:	df000017 	ldw	fp,0(sp)
 1018468:	dec00204 	addi	sp,sp,8
 101846c:	f800283a 	ret

01018470 <altera_modular_adc_open>:

alt_modular_adc_dev* altera_modular_adc_open (const char *name)
{
 1018470:	defffc04 	addi	sp,sp,-16
 1018474:	dfc00315 	stw	ra,12(sp)
 1018478:	df000215 	stw	fp,8(sp)
 101847c:	df000204 	addi	fp,sp,8
 1018480:	e13fff15 	stw	r4,-4(fp)
    alt_modular_adc_dev *dev = NULL;
 1018484:	e03ffe15 	stw	zero,-8(fp)

    /* Find requested device */
    dev = (alt_modular_adc_dev*) alt_find_dev (name, &altera_modular_adc_list);
 1018488:	d1602f04 	addi	r5,gp,-32580
 101848c:	e13fff17 	ldw	r4,-4(fp)
 1018490:	1019b580 	call	1019b58 <alt_find_dev>
 1018494:	e0bffe15 	stw	r2,-8(fp)

    return dev;
 1018498:	e0bffe17 	ldw	r2,-8(fp)
}
 101849c:	e037883a 	mov	sp,fp
 10184a0:	dfc00117 	ldw	ra,4(sp)
 10184a4:	df000017 	ldw	fp,0(sp)
 10184a8:	dec00204 	addi	sp,sp,8
 10184ac:	f800283a 	ret

010184b0 <adc_stop>:

void adc_stop(int sequencer_base)
{
 10184b0:	defffe04 	addi	sp,sp,-8
 10184b4:	df000115 	stw	fp,4(sp)
 10184b8:	df000104 	addi	fp,sp,4
 10184bc:	e13fff15 	stw	r4,-4(fp)
    ALTERA_MODULAR_ADC_SEQUENCER_STOP(sequencer_base);
 10184c0:	e0bfff17 	ldw	r2,-4(fp)
 10184c4:	e0ffff17 	ldw	r3,-4(fp)
 10184c8:	19000037 	ldwio	r4,0(r3)
 10184cc:	00ffff84 	movi	r3,-2
 10184d0:	20c6703a 	and	r3,r4,r3
 10184d4:	10c00035 	stwio	r3,0(r2)
 10184d8:	0001883a 	nop
 10184dc:	e0bfff17 	ldw	r2,-4(fp)
 10184e0:	10800037 	ldwio	r2,0(r2)
 10184e4:	1080004c 	andi	r2,r2,1
 10184e8:	103ffc1e 	bne	r2,zero,10184dc <__alt_data_end+0xff8184dc>
}
 10184ec:	0001883a 	nop
 10184f0:	e037883a 	mov	sp,fp
 10184f4:	df000017 	ldw	fp,0(sp)
 10184f8:	dec00104 	addi	sp,sp,4
 10184fc:	f800283a 	ret

01018500 <adc_start>:

void adc_start(int sequencer_base)
{
 1018500:	defffe04 	addi	sp,sp,-8
 1018504:	df000115 	stw	fp,4(sp)
 1018508:	df000104 	addi	fp,sp,4
 101850c:	e13fff15 	stw	r4,-4(fp)
    ALTERA_MODULAR_ADC_SEQUENCER_START(sequencer_base);
 1018510:	e0bfff17 	ldw	r2,-4(fp)
 1018514:	e0ffff17 	ldw	r3,-4(fp)
 1018518:	18c00037 	ldwio	r3,0(r3)
 101851c:	18c00054 	ori	r3,r3,1
 1018520:	10c00035 	stwio	r3,0(r2)
}
 1018524:	0001883a 	nop
 1018528:	e037883a 	mov	sp,fp
 101852c:	df000017 	ldw	fp,0(sp)
 1018530:	dec00104 	addi	sp,sp,4
 1018534:	f800283a 	ret

01018538 <adc_set_mode_run_once>:

void adc_set_mode_run_once(int sequencer_base)
{
 1018538:	defffe04 	addi	sp,sp,-8
 101853c:	df000115 	stw	fp,4(sp)
 1018540:	df000104 	addi	fp,sp,4
 1018544:	e13fff15 	stw	r4,-4(fp)
    /* Note: Stop the ADC before calling this function,
       changing ADC mode while RUN bit is set has no effect. */
    ALTERA_MODULAR_ADC_SEQUENCER_MODE_RUN_ONCE(sequencer_base);
 1018548:	e0bfff17 	ldw	r2,-4(fp)
 101854c:	e0ffff17 	ldw	r3,-4(fp)
 1018550:	19000037 	ldwio	r4,0(r3)
 1018554:	00fffc44 	movi	r3,-15
 1018558:	20c6703a 	and	r3,r4,r3
 101855c:	18c00094 	ori	r3,r3,2
 1018560:	10c00035 	stwio	r3,0(r2)
}
 1018564:	0001883a 	nop
 1018568:	e037883a 	mov	sp,fp
 101856c:	df000017 	ldw	fp,0(sp)
 1018570:	dec00104 	addi	sp,sp,4
 1018574:	f800283a 	ret

01018578 <adc_set_mode_run_continuously>:

void adc_set_mode_run_continuously(int sequencer_base)
{
 1018578:	defffe04 	addi	sp,sp,-8
 101857c:	df000115 	stw	fp,4(sp)
 1018580:	df000104 	addi	fp,sp,4
 1018584:	e13fff15 	stw	r4,-4(fp)
    /* Note: Stop the ADC before calling this function,
       changing ADC mode while RUN bit is set has no effect. */
    ALTERA_MODULAR_ADC_SEQUENCER_MODE_RUN_CONTINUOUSLY(sequencer_base);
 1018588:	e0bfff17 	ldw	r2,-4(fp)
 101858c:	e0ffff17 	ldw	r3,-4(fp)
 1018590:	19000037 	ldwio	r4,0(r3)
 1018594:	00fffc44 	movi	r3,-15
 1018598:	20c6703a 	and	r3,r4,r3
 101859c:	10c00035 	stwio	r3,0(r2)
}
 10185a0:	0001883a 	nop
 10185a4:	e037883a 	mov	sp,fp
 10185a8:	df000017 	ldw	fp,0(sp)
 10185ac:	dec00104 	addi	sp,sp,4
 10185b0:	f800283a 	ret

010185b4 <adc_recalibrate>:

void adc_recalibrate(int sequencer_base)
{
 10185b4:	defffc04 	addi	sp,sp,-16
 10185b8:	dfc00315 	stw	ra,12(sp)
 10185bc:	df000215 	stw	fp,8(sp)
 10185c0:	df000204 	addi	fp,sp,8
 10185c4:	e13fff15 	stw	r4,-4(fp)
         2. Start the ADC Sequencer Core.
         5. Poll for RUN bit to be clear
         6. Restore CMD register
     */
    alt_u32 backup_cmd_reg;
    backup_cmd_reg = IORD_ALTERA_MODULAR_ADC_SEQUENCER_CMD_REG(sequencer_base);
 10185c8:	e0bfff17 	ldw	r2,-4(fp)
 10185cc:	10800037 	ldwio	r2,0(r2)
 10185d0:	e0bffe15 	stw	r2,-8(fp)
    adc_stop(sequencer_base);
 10185d4:	e13fff17 	ldw	r4,-4(fp)
 10185d8:	10184b00 	call	10184b0 <adc_stop>
    ALTERA_MODULAR_ADC_SEQUENCER_MODE_RUN_RECALIBRATION(sequencer_base);
 10185dc:	e0bfff17 	ldw	r2,-4(fp)
 10185e0:	e0ffff17 	ldw	r3,-4(fp)
 10185e4:	18c00037 	ldwio	r3,0(r3)
 10185e8:	18c00394 	ori	r3,r3,14
 10185ec:	10c00035 	stwio	r3,0(r2)
    adc_start(sequencer_base);
 10185f0:	e13fff17 	ldw	r4,-4(fp)
 10185f4:	10185000 	call	1018500 <adc_start>
    while(IORD_ALTERA_MODULAR_ADC_SEQUENCER_CMD_REG(sequencer_base)
 10185f8:	0001883a 	nop
 10185fc:	e0bfff17 	ldw	r2,-4(fp)
 1018600:	10800037 	ldwio	r2,0(r2)
             & ALTERA_MODULAR_ADC_SEQUENCER_CMD_RUN_MSK);
 1018604:	1080004c 	andi	r2,r2,1
    alt_u32 backup_cmd_reg;
    backup_cmd_reg = IORD_ALTERA_MODULAR_ADC_SEQUENCER_CMD_REG(sequencer_base);
    adc_stop(sequencer_base);
    ALTERA_MODULAR_ADC_SEQUENCER_MODE_RUN_RECALIBRATION(sequencer_base);
    adc_start(sequencer_base);
    while(IORD_ALTERA_MODULAR_ADC_SEQUENCER_CMD_REG(sequencer_base)
 1018608:	103ffc1e 	bne	r2,zero,10185fc <__alt_data_end+0xff8185fc>
             & ALTERA_MODULAR_ADC_SEQUENCER_CMD_RUN_MSK);
    IOWR_ALTERA_MODULAR_ADC_SEQUENCER_CMD_REG(sequencer_base, backup_cmd_reg);
 101860c:	e0bfff17 	ldw	r2,-4(fp)
 1018610:	e0fffe17 	ldw	r3,-8(fp)
 1018614:	10c00035 	stwio	r3,0(r2)
}
 1018618:	0001883a 	nop
 101861c:	e037883a 	mov	sp,fp
 1018620:	dfc00117 	ldw	ra,4(sp)
 1018624:	df000017 	ldw	fp,0(sp)
 1018628:	dec00204 	addi	sp,sp,8
 101862c:	f800283a 	ret

01018630 <adc_interrupt_enable>:

void adc_interrupt_enable(int sample_store_base)
{
 1018630:	defffe04 	addi	sp,sp,-8
 1018634:	df000115 	stw	fp,4(sp)
 1018638:	df000104 	addi	fp,sp,4
 101863c:	e13fff15 	stw	r4,-4(fp)
    ALTERA_MODULAR_ADC_SAMPLE_STORAGE_IRQ_ENABLE(sample_store_base);
 1018640:	e0bfff17 	ldw	r2,-4(fp)
 1018644:	10804004 	addi	r2,r2,256
 1018648:	1007883a 	mov	r3,r2
 101864c:	e0bfff17 	ldw	r2,-4(fp)
 1018650:	10804004 	addi	r2,r2,256
 1018654:	10800037 	ldwio	r2,0(r2)
 1018658:	10800054 	ori	r2,r2,1
 101865c:	18800035 	stwio	r2,0(r3)
}
 1018660:	0001883a 	nop
 1018664:	e037883a 	mov	sp,fp
 1018668:	df000017 	ldw	fp,0(sp)
 101866c:	dec00104 	addi	sp,sp,4
 1018670:	f800283a 	ret

01018674 <adc_interrupt_disable>:

void adc_interrupt_disable(int sample_store_base)
{
 1018674:	defffe04 	addi	sp,sp,-8
 1018678:	df000115 	stw	fp,4(sp)
 101867c:	df000104 	addi	fp,sp,4
 1018680:	e13fff15 	stw	r4,-4(fp)
    ALTERA_MODULAR_ADC_SAMPLE_STORAGE_IRQ_DISABLE(sample_store_base);
 1018684:	e0bfff17 	ldw	r2,-4(fp)
 1018688:	10804004 	addi	r2,r2,256
 101868c:	1009883a 	mov	r4,r2
 1018690:	e0bfff17 	ldw	r2,-4(fp)
 1018694:	10804004 	addi	r2,r2,256
 1018698:	10c00037 	ldwio	r3,0(r2)
 101869c:	00bfff84 	movi	r2,-2
 10186a0:	1884703a 	and	r2,r3,r2
 10186a4:	20800035 	stwio	r2,0(r4)
}
 10186a8:	0001883a 	nop
 10186ac:	e037883a 	mov	sp,fp
 10186b0:	df000017 	ldw	fp,0(sp)
 10186b4:	dec00104 	addi	sp,sp,4
 10186b8:	f800283a 	ret

010186bc <adc_clear_interrupt_status>:

void adc_clear_interrupt_status(int sample_store_base)
{
 10186bc:	defffe04 	addi	sp,sp,-8
 10186c0:	df000115 	stw	fp,4(sp)
 10186c4:	df000104 	addi	fp,sp,4
 10186c8:	e13fff15 	stw	r4,-4(fp)
    CLEAR_ALTERA_MODULAR_ADC_SAMPLE_STORAGE_IRQ_STATUS(sample_store_base);
 10186cc:	e0bfff17 	ldw	r2,-4(fp)
 10186d0:	10804104 	addi	r2,r2,260
 10186d4:	1007883a 	mov	r3,r2
 10186d8:	e0bfff17 	ldw	r2,-4(fp)
 10186dc:	10804104 	addi	r2,r2,260
 10186e0:	10800037 	ldwio	r2,0(r2)
 10186e4:	10800054 	ori	r2,r2,1
 10186e8:	18800035 	stwio	r2,0(r3)
}
 10186ec:	0001883a 	nop
 10186f0:	e037883a 	mov	sp,fp
 10186f4:	df000017 	ldw	fp,0(sp)
 10186f8:	dec00104 	addi	sp,sp,4
 10186fc:	f800283a 	ret

01018700 <adc_interrupt_asserted>:

int adc_interrupt_asserted(int sample_store_base)
{
 1018700:	defffe04 	addi	sp,sp,-8
 1018704:	df000115 	stw	fp,4(sp)
 1018708:	df000104 	addi	fp,sp,4
 101870c:	e13fff15 	stw	r4,-4(fp)
    return((READ_ALTERA_MODULAR_ADC_SAMPLE_STORAGE_IRQ_STATUS(sample_store_base)==1) ? -1 : 0);
 1018710:	e0bfff17 	ldw	r2,-4(fp)
 1018714:	10804104 	addi	r2,r2,260
 1018718:	10800037 	ldwio	r2,0(r2)
 101871c:	1080004c 	andi	r2,r2,1
 1018720:	10000226 	beq	r2,zero,101872c <adc_interrupt_asserted+0x2c>
 1018724:	00bfffc4 	movi	r2,-1
 1018728:	00000106 	br	1018730 <adc_interrupt_asserted+0x30>
 101872c:	0005883a 	mov	r2,zero
}
 1018730:	e037883a 	mov	sp,fp
 1018734:	df000017 	ldw	fp,0(sp)
 1018738:	dec00104 	addi	sp,sp,4
 101873c:	f800283a 	ret

01018740 <adc_wait_for_interrupt>:

void adc_wait_for_interrupt(int sample_store_base)
{
 1018740:	defffe04 	addi	sp,sp,-8
 1018744:	df000115 	stw	fp,4(sp)
 1018748:	df000104 	addi	fp,sp,4
 101874c:	e13fff15 	stw	r4,-4(fp)
    WAIT_FOR_ALTERA_MODULAR_ADC_SAMPLE_STORAGE_IRQ(sample_store_base);
 1018750:	0001883a 	nop
 1018754:	e0bfff17 	ldw	r2,-4(fp)
 1018758:	10804104 	addi	r2,r2,260
 101875c:	10800037 	ldwio	r2,0(r2)
 1018760:	1080004c 	andi	r2,r2,1
 1018764:	103ffb26 	beq	r2,zero,1018754 <__alt_data_end+0xff818754>
}
 1018768:	0001883a 	nop
 101876c:	e037883a 	mov	sp,fp
 1018770:	df000017 	ldw	fp,0(sp)
 1018774:	dec00104 	addi	sp,sp,4
 1018778:	f800283a 	ret

0101877c <alt_flash_device_register>:

typedef struct alt_flash_dev alt_flash_dev; 
typedef alt_flash_dev alt_flash_fd;

static ALT_INLINE int alt_flash_device_register( alt_flash_fd* fd)
{
 101877c:	defffd04 	addi	sp,sp,-12
 1018780:	dfc00215 	stw	ra,8(sp)
 1018784:	df000115 	stw	fp,4(sp)
 1018788:	df000104 	addi	fp,sp,4
 101878c:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_flash_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) fd, &alt_flash_dev_list);
 1018790:	d1603304 	addi	r5,gp,-32564
 1018794:	e13fff17 	ldw	r4,-4(fp)
 1018798:	10199f40 	call	10199f4 <alt_dev_llist_insert>
}
 101879c:	e037883a 	mov	sp,fp
 10187a0:	dfc00117 	ldw	ra,4(sp)
 10187a4:	df000017 	ldw	fp,0(sp)
 10187a8:	dec00204 	addi	sp,sp,8
 10187ac:	f800283a 	ret

010187b0 <alt_onchip_flash_read>:
    alt_flash_dev *flash_info,
    int           offset,
    void          *dest_addr,
    int           length
)
{
 10187b0:	defff704 	addi	sp,sp,-36
 10187b4:	dfc00815 	stw	ra,32(sp)
 10187b8:	df000715 	stw	fp,28(sp)
 10187bc:	df000704 	addi	fp,sp,28
 10187c0:	e13ffc15 	stw	r4,-16(fp)
 10187c4:	e17ffd15 	stw	r5,-12(fp)
 10187c8:	e1bffe15 	stw	r6,-8(fp)
 10187cc:	e1ffff15 	stw	r7,-4(fp)
    int ret_code = 0;
 10187d0:	e03ff915 	stw	zero,-28(fp)
    alt_onchip_flash_dev* flash = (alt_onchip_flash_dev*)flash_info;
 10187d4:	e0bffc17 	ldw	r2,-16(fp)
 10187d8:	e0bffa15 	stw	r2,-24(fp)

    /* Make sure the input parameters is not outside of this device's range. */
    if ((offset >= flash->dev.length) || ((offset+length) > flash->dev.length)) {
 10187dc:	e0bffa17 	ldw	r2,-24(fp)
 10187e0:	10800b17 	ldw	r2,44(r2)
 10187e4:	e0fffd17 	ldw	r3,-12(fp)
 10187e8:	1880060e 	bge	r3,r2,1018804 <alt_onchip_flash_read+0x54>
 10187ec:	e0fffd17 	ldw	r3,-12(fp)
 10187f0:	e0bfff17 	ldw	r2,-4(fp)
 10187f4:	1885883a 	add	r2,r3,r2
 10187f8:	e0fffa17 	ldw	r3,-24(fp)
 10187fc:	18c00b17 	ldw	r3,44(r3)
 1018800:	1880020e 	bge	r3,r2,101880c <alt_onchip_flash_read+0x5c>
        return -EFAULT;
 1018804:	00bffc84 	movi	r2,-14
 1018808:	00001706 	br	1018868 <alt_onchip_flash_read+0xb8>
    }
    
    memcpy(dest_addr, (alt_u8*)flash->dev.base_addr+offset, length);
 101880c:	e0bffa17 	ldw	r2,-24(fp)
 1018810:	10c00a17 	ldw	r3,40(r2)
 1018814:	e0bffd17 	ldw	r2,-12(fp)
 1018818:	1885883a 	add	r2,r3,r2
 101881c:	e0ffff17 	ldw	r3,-4(fp)
 1018820:	180d883a 	mov	r6,r3
 1018824:	100b883a 	mov	r5,r2
 1018828:	e13ffe17 	ldw	r4,-8(fp)
 101882c:	10099d40 	call	10099d4 <memcpy>

    if (NULL != flash->csr_base) {
 1018830:	e0bffa17 	ldw	r2,-24(fp)
 1018834:	10802f17 	ldw	r2,188(r2)
 1018838:	10000a26 	beq	r2,zero,1018864 <alt_onchip_flash_read+0xb4>
        int read_status = IORD_ALTERA_ONCHIP_FLASH_STATUS(flash->csr_base) & ALTERA_ONCHIP_FLASH_STATUS_READ_MSK;
 101883c:	e0bffa17 	ldw	r2,-24(fp)
 1018840:	10802f17 	ldw	r2,188(r2)
 1018844:	10800037 	ldwio	r2,0(r2)
 1018848:	1080010c 	andi	r2,r2,4
 101884c:	e0bffb15 	stw	r2,-20(fp)
        if (read_status != ALTERA_ONCHIP_FLASH_STATUS_READ_PASSED) {
 1018850:	e0bffb17 	ldw	r2,-20(fp)
 1018854:	10800120 	cmpeqi	r2,r2,4
 1018858:	1000021e 	bne	r2,zero,1018864 <alt_onchip_flash_read+0xb4>
            /* Read failed.  Return error.*/
            ret_code = -EIO;
 101885c:	00bffec4 	movi	r2,-5
 1018860:	e0bff915 	stw	r2,-28(fp)
        }
    }
    return ret_code;
 1018864:	e0bff917 	ldw	r2,-28(fp)
}
 1018868:	e037883a 	mov	sp,fp
 101886c:	dfc00117 	ldw	ra,4(sp)
 1018870:	df000017 	ldw	fp,0(sp)
 1018874:	dec00204 	addi	sp,sp,8
 1018878:	f800283a 	ret

0101887c <alt_onchip_flash_get_info>:
(
    alt_flash_fd *fd,
    flash_region **info,
    int          *number_of_regions
)
{
 101887c:	defffa04 	addi	sp,sp,-24
 1018880:	df000515 	stw	fp,20(sp)
 1018884:	df000504 	addi	fp,sp,20
 1018888:	e13ffd15 	stw	r4,-12(fp)
 101888c:	e17ffe15 	stw	r5,-8(fp)
 1018890:	e1bfff15 	stw	r6,-4(fp)
    int ret_code = 0;
 1018894:	e03ffb15 	stw	zero,-20(fp)

    alt_flash_dev* flash = (alt_flash_dev*)fd;
 1018898:	e0bffd17 	ldw	r2,-12(fp)
 101889c:	e0bffc15 	stw	r2,-16(fp)

    if (NULL != number_of_regions)
 10188a0:	e0bfff17 	ldw	r2,-4(fp)
 10188a4:	10000426 	beq	r2,zero,10188b8 <alt_onchip_flash_get_info+0x3c>
    {
        /* Pass the number of region to user */
        *number_of_regions = flash->number_of_regions;
 10188a8:	e0bffc17 	ldw	r2,-16(fp)
 10188ac:	10c00c17 	ldw	r3,48(r2)
 10188b0:	e0bfff17 	ldw	r2,-4(fp)
 10188b4:	10c00015 	stw	r3,0(r2)
    }

    if (!flash->number_of_regions)
 10188b8:	e0bffc17 	ldw	r2,-16(fp)
 10188bc:	10800c17 	ldw	r2,48(r2)
 10188c0:	1000031e 	bne	r2,zero,10188d0 <alt_onchip_flash_get_info+0x54>
    {
        ret_code = -ENOMEM;
 10188c4:	00bffd04 	movi	r2,-12
 10188c8:	e0bffb15 	stw	r2,-20(fp)
 10188cc:	00000d06 	br	1018904 <alt_onchip_flash_get_info+0x88>
    }
    else if (flash->number_of_regions > ALT_MAX_NUMBER_OF_FLASH_REGIONS)
 10188d0:	e0bffc17 	ldw	r2,-16(fp)
 10188d4:	10800c17 	ldw	r2,48(r2)
 10188d8:	10800250 	cmplti	r2,r2,9
 10188dc:	1000031e 	bne	r2,zero,10188ec <alt_onchip_flash_get_info+0x70>
    {
        ret_code = -EFAULT;
 10188e0:	00bffc84 	movi	r2,-14
 10188e4:	e0bffb15 	stw	r2,-20(fp)
 10188e8:	00000606 	br	1018904 <alt_onchip_flash_get_info+0x88>
    }
    else
    {
        if (NULL != info)
 10188ec:	e0bffe17 	ldw	r2,-8(fp)
 10188f0:	10000426 	beq	r2,zero,1018904 <alt_onchip_flash_get_info+0x88>
        {
            /* Pass the table of erase blocks to user */
            *info = &flash->region_info[0];
 10188f4:	e0bffc17 	ldw	r2,-16(fp)
 10188f8:	10c00d04 	addi	r3,r2,52
 10188fc:	e0bffe17 	ldw	r2,-8(fp)
 1018900:	10c00015 	stw	r3,0(r2)
        }
    }

    return ret_code;
 1018904:	e0bffb17 	ldw	r2,-20(fp)
}
 1018908:	e037883a 	mov	sp,fp
 101890c:	df000017 	ldw	fp,0(sp)
 1018910:	dec00104 	addi	sp,sp,4
 1018914:	f800283a 	ret

01018918 <alt_onchip_flash_erase_block>:
int alt_onchip_flash_erase_block
(
    alt_flash_dev *flash_info,
    int           block_offset
)
{
 1018918:	defff904 	addi	sp,sp,-28
 101891c:	dfc00615 	stw	ra,24(sp)
 1018920:	df000515 	stw	fp,20(sp)
 1018924:	df000504 	addi	fp,sp,20
 1018928:	e13ffe15 	stw	r4,-8(fp)
 101892c:	e17fff15 	stw	r5,-4(fp)
    int ret_code = 0;
 1018930:	e03ffb15 	stw	zero,-20(fp)
    alt_onchip_flash_dev *flash = (alt_onchip_flash_dev*)flash_info;
 1018934:	e0bffe17 	ldw	r2,-8(fp)
 1018938:	e0bffc15 	stw	r2,-16(fp)
    int page_address;

    /* Make sure the input parameters is not outside of this device's range. */
    if (block_offset >= flash->dev.length) {
 101893c:	e0bffc17 	ldw	r2,-16(fp)
 1018940:	10800b17 	ldw	r2,44(r2)
 1018944:	e0ffff17 	ldw	r3,-4(fp)
 1018948:	18800216 	blt	r3,r2,1018954 <alt_onchip_flash_erase_block+0x3c>
        return -EFAULT;
 101894c:	00bffc84 	movi	r2,-14
 1018950:	00004606 	br	1018a6c <alt_onchip_flash_erase_block+0x154>
    }

    /* Make sure IP support write and erase operation */
    if ((flash->csr_base == NULL) || (flash->is_read_only)) {
 1018954:	e0bffc17 	ldw	r2,-16(fp)
 1018958:	10802f17 	ldw	r2,188(r2)
 101895c:	10000326 	beq	r2,zero,101896c <alt_onchip_flash_erase_block+0x54>
 1018960:	e0bffc17 	ldw	r2,-16(fp)
 1018964:	10802e17 	ldw	r2,184(r2)
 1018968:	10000226 	beq	r2,zero,1018974 <alt_onchip_flash_erase_block+0x5c>
        return -ENODEV;
 101896c:	00bffb44 	movi	r2,-19
 1018970:	00003e06 	br	1018a6c <alt_onchip_flash_erase_block+0x154>
    }

    /* The block_offset must be page size aligned */
    if ((block_offset & (flash->page_size - 1)) != 0)
 1018974:	e0bffc17 	ldw	r2,-16(fp)
 1018978:	10803f17 	ldw	r2,252(r2)
 101897c:	10ffffc4 	addi	r3,r2,-1
 1018980:	e0bfff17 	ldw	r2,-4(fp)
 1018984:	1884703a 	and	r2,r3,r2
 1018988:	10000226 	beq	r2,zero,1018994 <alt_onchip_flash_erase_block+0x7c>
    {
        /* The address is not aligned */
        return -EINVAL;
 101898c:	00bffa84 	movi	r2,-22
 1018990:	00003606 	br	1018a6c <alt_onchip_flash_erase_block+0x154>
    }

    /* Wait until flash controller idle */
    ret_code = alt_onchip_flash_poll_for_status_to_go_idle(flash);
 1018994:	e13ffc17 	ldw	r4,-16(fp)
 1018998:	101950c0 	call	101950c <alt_onchip_flash_poll_for_status_to_go_idle>
 101899c:	e0bffb15 	stw	r2,-20(fp)
    if (ret_code != 0)
 10189a0:	e0bffb17 	ldw	r2,-20(fp)
 10189a4:	10000226 	beq	r2,zero,10189b0 <alt_onchip_flash_erase_block+0x98>
    {
        return ret_code;
 10189a8:	e0bffb17 	ldw	r2,-20(fp)
 10189ac:	00002f06 	br	1018a6c <alt_onchip_flash_erase_block+0x154>
    }

    /* Enable write and erase operation */
    ALTERA_ONCHIP_FLASH_ENABLE_WRITE_AND_ERASE_OPERATION(flash->csr_base);
 10189b0:	e0bffc17 	ldw	r2,-16(fp)
 10189b4:	10802f17 	ldw	r2,188(r2)
 10189b8:	10c00104 	addi	r3,r2,4
 10189bc:	e0bffc17 	ldw	r2,-16(fp)
 10189c0:	10802f17 	ldw	r2,188(r2)
 10189c4:	10800104 	addi	r2,r2,4
 10189c8:	10800037 	ldwio	r2,0(r2)
 10189cc:	113c002c 	andhi	r4,r2,61440
 10189d0:	00802034 	movhi	r2,128
 10189d4:	10bfffc4 	addi	r2,r2,-1
 10189d8:	2084b03a 	or	r2,r4,r2
 10189dc:	18800035 	stwio	r2,0(r3)

    /* Calculate Page erase address, it is 32bit word addressing*/
    page_address = block_offset / 4;
 10189e0:	e0bfff17 	ldw	r2,-4(fp)
 10189e4:	1000010e 	bge	r2,zero,10189ec <alt_onchip_flash_erase_block+0xd4>
 10189e8:	108000c4 	addi	r2,r2,3
 10189ec:	1005d0ba 	srai	r2,r2,2
 10189f0:	e0bffd15 	stw	r2,-12(fp)

    /* Perform Page erase operation */
    ALTERA_ONCHIP_FLASH_PAGE_ERASE(flash->csr_base, page_address);
 10189f4:	e0bffc17 	ldw	r2,-16(fp)
 10189f8:	10802f17 	ldw	r2,188(r2)
 10189fc:	10800104 	addi	r2,r2,4
 1018a00:	e0fffc17 	ldw	r3,-16(fp)
 1018a04:	18c02f17 	ldw	r3,188(r3)
 1018a08:	18c00104 	addi	r3,r3,4
 1018a0c:	18c00037 	ldwio	r3,0(r3)
 1018a10:	193c002c 	andhi	r4,r3,61440
 1018a14:	e0fffd17 	ldw	r3,-12(fp)
 1018a18:	18c01c34 	orhi	r3,r3,112
 1018a1c:	20c6b03a 	or	r3,r4,r3
 1018a20:	10c00035 	stwio	r3,0(r2)

    /* Wait until flash controller idle */
    ret_code = alt_onchip_flash_poll_for_status_to_go_idle(flash);
 1018a24:	e13ffc17 	ldw	r4,-16(fp)
 1018a28:	101950c0 	call	101950c <alt_onchip_flash_poll_for_status_to_go_idle>
 1018a2c:	e0bffb15 	stw	r2,-20(fp)

    /* Wait until flash controller indicate erase passed */
    ret_code = alt_onchip_flash_poll_for_status_erase_passed(flash);
 1018a30:	e13ffc17 	ldw	r4,-16(fp)
 1018a34:	101959c0 	call	101959c <alt_onchip_flash_poll_for_status_erase_passed>
 1018a38:	e0bffb15 	stw	r2,-20(fp)

    /* Disable write and erase operation */
    ALTERA_ONCHIP_FLASH_DISABLE_WRITE_AND_ERASE_OPERATION(flash->csr_base);
 1018a3c:	e0bffc17 	ldw	r2,-16(fp)
 1018a40:	10802f17 	ldw	r2,188(r2)
 1018a44:	10c00104 	addi	r3,r2,4
 1018a48:	e0bffc17 	ldw	r2,-16(fp)
 1018a4c:	10802f17 	ldw	r2,188(r2)
 1018a50:	10800104 	addi	r2,r2,4
 1018a54:	11000037 	ldwio	r4,0(r2)
 1018a58:	00840034 	movhi	r2,4096
 1018a5c:	10bfffc4 	addi	r2,r2,-1
 1018a60:	2084b03a 	or	r2,r4,r2
 1018a64:	18800035 	stwio	r2,0(r3)

    return ret_code;
 1018a68:	e0bffb17 	ldw	r2,-20(fp)
}
 1018a6c:	e037883a 	mov	sp,fp
 1018a70:	dfc00117 	ldw	ra,4(sp)
 1018a74:	df000017 	ldw	fp,0(sp)
 1018a78:	dec00204 	addi	sp,sp,8
 1018a7c:	f800283a 	ret

01018a80 <alt_onchip_flash_write_block>:
    int           block_offset,
    int           data_offset,
    const void    *data,
    int           length
)
{
 1018a80:	defff204 	addi	sp,sp,-56
 1018a84:	dfc00d15 	stw	ra,52(sp)
 1018a88:	df000c15 	stw	fp,48(sp)
 1018a8c:	df000c04 	addi	fp,sp,48
 1018a90:	e13ffc15 	stw	r4,-16(fp)
 1018a94:	e17ffd15 	stw	r5,-12(fp)
 1018a98:	e1bffe15 	stw	r6,-8(fp)
 1018a9c:	e1ffff15 	stw	r7,-4(fp)
    int ret_code = 0;
 1018aa0:	e03ff415 	stw	zero,-48(fp)
    alt_onchip_flash_dev *flash = (alt_onchip_flash_dev*)flash_info;
 1018aa4:	e0bffc17 	ldw	r2,-16(fp)
 1018aa8:	e0bff815 	stw	r2,-32(fp)
    int buffer_offset = 0;
 1018aac:	e03ff515 	stw	zero,-44(fp)
    int length_of_current_write;
    int current_data_offset = data_offset;
 1018ab0:	e0bffe17 	ldw	r2,-8(fp)
 1018ab4:	e0bff615 	stw	r2,-40(fp)
    int next_data_offset;
    alt_u32 chunk_of_data;

    /* Make sure the input parameters is not outside of this device's range. */
    if (
        (block_offset >= flash->dev.length) ||
 1018ab8:	e0bff817 	ldw	r2,-32(fp)
 1018abc:	10800b17 	ldw	r2,44(r2)
    int current_data_offset = data_offset;
    int next_data_offset;
    alt_u32 chunk_of_data;

    /* Make sure the input parameters is not outside of this device's range. */
    if (
 1018ac0:	e0fffd17 	ldw	r3,-12(fp)
 1018ac4:	18800a0e 	bge	r3,r2,1018af0 <alt_onchip_flash_write_block+0x70>
        (block_offset >= flash->dev.length) ||
        (data_offset >= flash->dev.length) ||
 1018ac8:	e0bff817 	ldw	r2,-32(fp)
 1018acc:	10800b17 	ldw	r2,44(r2)
    int next_data_offset;
    alt_u32 chunk_of_data;

    /* Make sure the input parameters is not outside of this device's range. */
    if (
        (block_offset >= flash->dev.length) ||
 1018ad0:	e0fffe17 	ldw	r3,-8(fp)
 1018ad4:	1880060e 	bge	r3,r2,1018af0 <alt_onchip_flash_write_block+0x70>
        (data_offset >= flash->dev.length) ||
        (length > (flash->dev.length - data_offset))
 1018ad8:	e0bff817 	ldw	r2,-32(fp)
 1018adc:	10c00b17 	ldw	r3,44(r2)
 1018ae0:	e0bffe17 	ldw	r2,-8(fp)
 1018ae4:	1887c83a 	sub	r3,r3,r2
    alt_u32 chunk_of_data;

    /* Make sure the input parameters is not outside of this device's range. */
    if (
        (block_offset >= flash->dev.length) ||
        (data_offset >= flash->dev.length) ||
 1018ae8:	e0800217 	ldw	r2,8(fp)
 1018aec:	1880020e 	bge	r3,r2,1018af8 <alt_onchip_flash_write_block+0x78>
        (length > (flash->dev.length - data_offset))
    ) {
        return -EFAULT;
 1018af0:	00bffc84 	movi	r2,-14
 1018af4:	00009306 	br	1018d44 <alt_onchip_flash_write_block+0x2c4>
    }

    /* Make sure IP support support write and erase operation */
    if ((flash->csr_base == NULL) || (flash->is_read_only != 0)) {
 1018af8:	e0bff817 	ldw	r2,-32(fp)
 1018afc:	10802f17 	ldw	r2,188(r2)
 1018b00:	10000326 	beq	r2,zero,1018b10 <alt_onchip_flash_write_block+0x90>
 1018b04:	e0bff817 	ldw	r2,-32(fp)
 1018b08:	10802e17 	ldw	r2,184(r2)
 1018b0c:	10000226 	beq	r2,zero,1018b18 <alt_onchip_flash_write_block+0x98>
        return -ENODEV;
 1018b10:	00bffb44 	movi	r2,-19
 1018b14:	00008b06 	br	1018d44 <alt_onchip_flash_write_block+0x2c4>
    }

    /* Wait until flash controller idle */
    ret_code = alt_onchip_flash_poll_for_status_to_go_idle(flash);
 1018b18:	e13ff817 	ldw	r4,-32(fp)
 1018b1c:	101950c0 	call	101950c <alt_onchip_flash_poll_for_status_to_go_idle>
 1018b20:	e0bff415 	stw	r2,-48(fp)
    if (ret_code != 0)
 1018b24:	e0bff417 	ldw	r2,-48(fp)
 1018b28:	10000226 	beq	r2,zero,1018b34 <alt_onchip_flash_write_block+0xb4>
    {
        return ret_code;
 1018b2c:	e0bff417 	ldw	r2,-48(fp)
 1018b30:	00008406 	br	1018d44 <alt_onchip_flash_write_block+0x2c4>
    }

    /* Enable write and erase operation */
    ALTERA_ONCHIP_FLASH_ENABLE_WRITE_AND_ERASE_OPERATION(flash->csr_base);
 1018b34:	e0bff817 	ldw	r2,-32(fp)
 1018b38:	10802f17 	ldw	r2,188(r2)
 1018b3c:	10c00104 	addi	r3,r2,4
 1018b40:	e0bff817 	ldw	r2,-32(fp)
 1018b44:	10802f17 	ldw	r2,188(r2)
 1018b48:	10800104 	addi	r2,r2,4
 1018b4c:	10800037 	ldwio	r2,0(r2)
 1018b50:	113c002c 	andhi	r4,r2,61440
 1018b54:	00802034 	movhi	r2,128
 1018b58:	10bfffc4 	addi	r2,r2,-1
 1018b5c:	2084b03a 	or	r2,r4,r2
 1018b60:	18800035 	stwio	r2,0(r3)

    /* Check data length */
    while (length)
 1018b64:	00006506 	br	1018cfc <alt_onchip_flash_write_block+0x27c>
    {
        /* Minimum write size to onchip flash is 32 bits of data */
        chunk_of_data = 0xFFFFFFFF;
 1018b68:	00bfffc4 	movi	r2,-1
 1018b6c:	e0bffb15 	stw	r2,-20(fp)

        /* The start of data_offset must be 4 bytes (32 bits) aligned */
        if ((current_data_offset & (ALTERA_ONCHIP_FLASH_DATA_ALIGN_SIZE - 1)) == 0)
 1018b70:	e0bff617 	ldw	r2,-40(fp)
 1018b74:	108000cc 	andi	r2,r2,3
 1018b78:	10001e1e 	bne	r2,zero,1018bf4 <alt_onchip_flash_write_block+0x174>
        {
            /* The address is 4-byte aligned here */
            next_data_offset = (current_data_offset + ALTERA_ONCHIP_FLASH_DATA_ALIGN_SIZE) & ~(ALTERA_ONCHIP_FLASH_DATA_ALIGN_SIZE - 1);
 1018b7c:	e0bff617 	ldw	r2,-40(fp)
 1018b80:	10c00104 	addi	r3,r2,4
 1018b84:	00bfff04 	movi	r2,-4
 1018b88:	1884703a 	and	r2,r3,r2
 1018b8c:	e0bff715 	stw	r2,-36(fp)
            length_of_current_write = MIN(length, next_data_offset - current_data_offset);
 1018b90:	e0fff717 	ldw	r3,-36(fp)
 1018b94:	e0bff617 	ldw	r2,-40(fp)
 1018b98:	1885c83a 	sub	r2,r3,r2
 1018b9c:	e0c00217 	ldw	r3,8(fp)
 1018ba0:	1880010e 	bge	r3,r2,1018ba8 <alt_onchip_flash_write_block+0x128>
 1018ba4:	1805883a 	mov	r2,r3
 1018ba8:	e0bff915 	stw	r2,-28(fp)
            /* Prepare the 4 bytes chunk of data to be written */
            memcpy(&chunk_of_data, &((alt_u8*)data)[buffer_offset], length_of_current_write);
 1018bac:	e0bff517 	ldw	r2,-44(fp)
 1018bb0:	e0ffff17 	ldw	r3,-4(fp)
 1018bb4:	1887883a 	add	r3,r3,r2
 1018bb8:	e13ff917 	ldw	r4,-28(fp)
 1018bbc:	e0bffb04 	addi	r2,fp,-20
 1018bc0:	200d883a 	mov	r6,r4
 1018bc4:	180b883a 	mov	r5,r3
 1018bc8:	1009883a 	mov	r4,r2
 1018bcc:	10099d40 	call	10099d4 <memcpy>
            buffer_offset += length_of_current_write;
 1018bd0:	e0fff517 	ldw	r3,-44(fp)
 1018bd4:	e0bff917 	ldw	r2,-28(fp)
 1018bd8:	1885883a 	add	r2,r3,r2
 1018bdc:	e0bff515 	stw	r2,-44(fp)
            length -= length_of_current_write;
 1018be0:	e0c00217 	ldw	r3,8(fp)
 1018be4:	e0bff917 	ldw	r2,-28(fp)
 1018be8:	1885c83a 	sub	r2,r3,r2
 1018bec:	e0800215 	stw	r2,8(fp)
 1018bf0:	00003006 	br	1018cb4 <alt_onchip_flash_write_block+0x234>
        } else {
            /* Calculate how many padding bytes need to be added before the start of a data offset */
            int padding = current_data_offset & (ALTERA_ONCHIP_FLASH_DATA_ALIGN_SIZE - 1);
 1018bf4:	e0bff617 	ldw	r2,-40(fp)
 1018bf8:	108000cc 	andi	r2,r2,3
 1018bfc:	e0bffa15 	stw	r2,-24(fp)

            /* Calculate new 4-byte aligned data offset */
            current_data_offset = current_data_offset - padding;
 1018c00:	e0fff617 	ldw	r3,-40(fp)
 1018c04:	e0bffa17 	ldw	r2,-24(fp)
 1018c08:	1885c83a 	sub	r2,r3,r2
 1018c0c:	e0bff615 	stw	r2,-40(fp)
            next_data_offset = (current_data_offset + ALTERA_ONCHIP_FLASH_DATA_ALIGN_SIZE) & ~(ALTERA_ONCHIP_FLASH_DATA_ALIGN_SIZE - 1);
 1018c10:	e0bff617 	ldw	r2,-40(fp)
 1018c14:	10c00104 	addi	r3,r2,4
 1018c18:	00bfff04 	movi	r2,-4
 1018c1c:	1884703a 	and	r2,r3,r2
 1018c20:	e0bff715 	stw	r2,-36(fp)
            length_of_current_write = MIN(length + padding, next_data_offset - current_data_offset);
 1018c24:	e0fff717 	ldw	r3,-36(fp)
 1018c28:	e0bff617 	ldw	r2,-40(fp)
 1018c2c:	1889c83a 	sub	r4,r3,r2
 1018c30:	e0c00217 	ldw	r3,8(fp)
 1018c34:	e0bffa17 	ldw	r2,-24(fp)
 1018c38:	1887883a 	add	r3,r3,r2
 1018c3c:	2005883a 	mov	r2,r4
 1018c40:	1880010e 	bge	r3,r2,1018c48 <alt_onchip_flash_write_block+0x1c8>
 1018c44:	1805883a 	mov	r2,r3
 1018c48:	e0bff915 	stw	r2,-28(fp)
            /* Prepare the 4 bytes chunk of data to be written */
            memcpy((void *)(((int)&chunk_of_data) + (int)padding), &((alt_u8*)data)[buffer_offset], length_of_current_write - padding);
 1018c4c:	e0fffb04 	addi	r3,fp,-20
 1018c50:	e0bffa17 	ldw	r2,-24(fp)
 1018c54:	1885883a 	add	r2,r3,r2
 1018c58:	100f883a 	mov	r7,r2
 1018c5c:	e0bff517 	ldw	r2,-44(fp)
 1018c60:	e0ffff17 	ldw	r3,-4(fp)
 1018c64:	1889883a 	add	r4,r3,r2
 1018c68:	e0fff917 	ldw	r3,-28(fp)
 1018c6c:	e0bffa17 	ldw	r2,-24(fp)
 1018c70:	1885c83a 	sub	r2,r3,r2
 1018c74:	100d883a 	mov	r6,r2
 1018c78:	200b883a 	mov	r5,r4
 1018c7c:	3809883a 	mov	r4,r7
 1018c80:	10099d40 	call	10099d4 <memcpy>
            buffer_offset += length_of_current_write - padding;
 1018c84:	e0fff917 	ldw	r3,-28(fp)
 1018c88:	e0bffa17 	ldw	r2,-24(fp)
 1018c8c:	1885c83a 	sub	r2,r3,r2
 1018c90:	e0fff517 	ldw	r3,-44(fp)
 1018c94:	1885883a 	add	r2,r3,r2
 1018c98:	e0bff515 	stw	r2,-44(fp)
            length -= length_of_current_write - padding;
 1018c9c:	e0fff917 	ldw	r3,-28(fp)
 1018ca0:	e0bffa17 	ldw	r2,-24(fp)
 1018ca4:	1885c83a 	sub	r2,r3,r2
 1018ca8:	e0c00217 	ldw	r3,8(fp)
 1018cac:	1885c83a 	sub	r2,r3,r2
 1018cb0:	e0800215 	stw	r2,8(fp)
        }

        /* Writing to flash via IO 32 bits at a time */
        IOWR_32DIRECT(flash->dev.base_addr, current_data_offset, chunk_of_data);
 1018cb4:	e0bff817 	ldw	r2,-32(fp)
 1018cb8:	10c00a17 	ldw	r3,40(r2)
 1018cbc:	e0bff617 	ldw	r2,-40(fp)
 1018cc0:	1885883a 	add	r2,r3,r2
 1018cc4:	e0fffb17 	ldw	r3,-20(fp)
 1018cc8:	10c00035 	stwio	r3,0(r2)

        /* Wait until flash controller idle */
        ret_code = alt_onchip_flash_poll_for_status_to_go_idle(flash);
 1018ccc:	e13ff817 	ldw	r4,-32(fp)
 1018cd0:	101950c0 	call	101950c <alt_onchip_flash_poll_for_status_to_go_idle>
 1018cd4:	e0bff415 	stw	r2,-48(fp)
        if (ret_code != 0)
 1018cd8:	e0bff417 	ldw	r2,-48(fp)
 1018cdc:	10000a1e 	bne	r2,zero,1018d08 <alt_onchip_flash_write_block+0x288>
        {
            break;
        }

        /* Wait until flash controller indicate write passed */
        ret_code = alt_onchip_flash_poll_for_status_write_passed(flash);
 1018ce0:	e13ff817 	ldw	r4,-32(fp)
 1018ce4:	101962c0 	call	101962c <alt_onchip_flash_poll_for_status_write_passed>
 1018ce8:	e0bff415 	stw	r2,-48(fp)
        if (ret_code != 0)
 1018cec:	e0bff417 	ldw	r2,-48(fp)
 1018cf0:	1000071e 	bne	r2,zero,1018d10 <alt_onchip_flash_write_block+0x290>
        {
            break;
        }

        /* Prepare to write next 4 bytes */
        current_data_offset = next_data_offset;
 1018cf4:	e0bff717 	ldw	r2,-36(fp)
 1018cf8:	e0bff615 	stw	r2,-40(fp)

    /* Enable write and erase operation */
    ALTERA_ONCHIP_FLASH_ENABLE_WRITE_AND_ERASE_OPERATION(flash->csr_base);

    /* Check data length */
    while (length)
 1018cfc:	e0800217 	ldw	r2,8(fp)
 1018d00:	103f991e 	bne	r2,zero,1018b68 <__alt_data_end+0xff818b68>
 1018d04:	00000306 	br	1018d14 <alt_onchip_flash_write_block+0x294>

        /* Wait until flash controller idle */
        ret_code = alt_onchip_flash_poll_for_status_to_go_idle(flash);
        if (ret_code != 0)
        {
            break;
 1018d08:	0001883a 	nop
 1018d0c:	00000106 	br	1018d14 <alt_onchip_flash_write_block+0x294>

        /* Wait until flash controller indicate write passed */
        ret_code = alt_onchip_flash_poll_for_status_write_passed(flash);
        if (ret_code != 0)
        {
            break;
 1018d10:	0001883a 	nop
        /* Prepare to write next 4 bytes */
        current_data_offset = next_data_offset;
    }

    /* Disable write and erase operation */
    ALTERA_ONCHIP_FLASH_DISABLE_WRITE_AND_ERASE_OPERATION(flash->csr_base);
 1018d14:	e0bff817 	ldw	r2,-32(fp)
 1018d18:	10802f17 	ldw	r2,188(r2)
 1018d1c:	10c00104 	addi	r3,r2,4
 1018d20:	e0bff817 	ldw	r2,-32(fp)
 1018d24:	10802f17 	ldw	r2,188(r2)
 1018d28:	10800104 	addi	r2,r2,4
 1018d2c:	11000037 	ldwio	r4,0(r2)
 1018d30:	00840034 	movhi	r2,4096
 1018d34:	10bfffc4 	addi	r2,r2,-1
 1018d38:	2084b03a 	or	r2,r4,r2
 1018d3c:	18800035 	stwio	r2,0(r3)

    return ret_code;
 1018d40:	e0bff417 	ldw	r2,-48(fp)
}
 1018d44:	e037883a 	mov	sp,fp
 1018d48:	dfc00117 	ldw	ra,4(sp)
 1018d4c:	df000017 	ldw	fp,0(sp)
 1018d50:	dec00204 	addi	sp,sp,8
 1018d54:	f800283a 	ret

01018d58 <alt_onchip_flash_write>:
    alt_flash_dev *flash_info,
    int           offset,
    const void    *src_addr,
    int           length
)
{
 1018d58:	defff104 	addi	sp,sp,-60
 1018d5c:	dfc00e15 	stw	ra,56(sp)
 1018d60:	df000d15 	stw	fp,52(sp)
 1018d64:	df000d04 	addi	fp,sp,52
 1018d68:	e13ffc15 	stw	r4,-16(fp)
 1018d6c:	e17ffd15 	stw	r5,-12(fp)
 1018d70:	e1bffe15 	stw	r6,-8(fp)
 1018d74:	e1ffff15 	stw	r7,-4(fp)
    int         ret_code = 0;
 1018d78:	e03ff415 	stw	zero,-48(fp)
    int         i,j;
    int         data_to_write;
    int         current_offset;
    int         full_length = length;
 1018d7c:	e0bfff17 	ldw	r2,-4(fp)
 1018d80:	e0bff815 	stw	r2,-32(fp)
    int         start_offset = offset;
 1018d84:	e0bffd17 	ldw	r2,-12(fp)
 1018d88:	e0bff915 	stw	r2,-28(fp)
    alt_onchip_flash_dev* flash = (alt_onchip_flash_dev*)flash_info;
 1018d8c:	e0bffc17 	ldw	r2,-16(fp)
 1018d90:	e0bffa15 	stw	r2,-24(fp)

    /* Make sure the input parameters is not outside of this device's range. */
    if ((offset >= flash->dev.length) || (length > (flash->dev.length - offset)))
 1018d94:	e0bffa17 	ldw	r2,-24(fp)
 1018d98:	10800b17 	ldw	r2,44(r2)
 1018d9c:	e0fffd17 	ldw	r3,-12(fp)
 1018da0:	1880060e 	bge	r3,r2,1018dbc <alt_onchip_flash_write+0x64>
 1018da4:	e0bffa17 	ldw	r2,-24(fp)
 1018da8:	10c00b17 	ldw	r3,44(r2)
 1018dac:	e0bffd17 	ldw	r2,-12(fp)
 1018db0:	1887c83a 	sub	r3,r3,r2
 1018db4:	e0bfff17 	ldw	r2,-4(fp)
 1018db8:	1880020e 	bge	r3,r2,1018dc4 <alt_onchip_flash_write+0x6c>
    {
        return -EFAULT;
 1018dbc:	00bffc84 	movi	r2,-14
 1018dc0:	00009606 	br	101901c <alt_onchip_flash_write+0x2c4>
    }

    /*
    * First and foremost which sectors are affected?
    */
    for(i=0;i<flash->dev.number_of_regions;i++)
 1018dc4:	e03ff515 	stw	zero,-44(fp)
 1018dc8:	00008706 	br	1018fe8 <alt_onchip_flash_write+0x290>
    {
        /* Is it in this erase block region?*/
        if((offset >= flash->dev.region_info[i].offset) &&
 1018dcc:	e0fffa17 	ldw	r3,-24(fp)
 1018dd0:	e0bff517 	ldw	r2,-44(fp)
 1018dd4:	1004913a 	slli	r2,r2,4
 1018dd8:	1885883a 	add	r2,r3,r2
 1018ddc:	10800d04 	addi	r2,r2,52
 1018de0:	10800017 	ldw	r2,0(r2)
 1018de4:	e0fffd17 	ldw	r3,-12(fp)
 1018de8:	18807c16 	blt	r3,r2,1018fdc <alt_onchip_flash_write+0x284>
            (offset < (flash->dev.region_info[i].offset +
 1018dec:	e0fffa17 	ldw	r3,-24(fp)
 1018df0:	e0bff517 	ldw	r2,-44(fp)
 1018df4:	1004913a 	slli	r2,r2,4
 1018df8:	1885883a 	add	r2,r3,r2
 1018dfc:	10800d04 	addi	r2,r2,52
 1018e00:	10c00017 	ldw	r3,0(r2)
            flash->dev.region_info[i].region_size)))
 1018e04:	e13ffa17 	ldw	r4,-24(fp)
 1018e08:	e0bff517 	ldw	r2,-44(fp)
 1018e0c:	1004913a 	slli	r2,r2,4
 1018e10:	2085883a 	add	r2,r4,r2
 1018e14:	10800e04 	addi	r2,r2,56
 1018e18:	10800017 	ldw	r2,0(r2)
    */
    for(i=0;i<flash->dev.number_of_regions;i++)
    {
        /* Is it in this erase block region?*/
        if((offset >= flash->dev.region_info[i].offset) &&
            (offset < (flash->dev.region_info[i].offset +
 1018e1c:	1885883a 	add	r2,r3,r2
    * First and foremost which sectors are affected?
    */
    for(i=0;i<flash->dev.number_of_regions;i++)
    {
        /* Is it in this erase block region?*/
        if((offset >= flash->dev.region_info[i].offset) &&
 1018e20:	e0fffd17 	ldw	r3,-12(fp)
 1018e24:	18806d0e 	bge	r3,r2,1018fdc <alt_onchip_flash_write+0x284>
            (offset < (flash->dev.region_info[i].offset +
            flash->dev.region_info[i].region_size)))
        {
            current_offset = flash->dev.region_info[i].offset;
 1018e28:	e0fffa17 	ldw	r3,-24(fp)
 1018e2c:	e0bff517 	ldw	r2,-44(fp)
 1018e30:	1004913a 	slli	r2,r2,4
 1018e34:	1885883a 	add	r2,r3,r2
 1018e38:	10800d04 	addi	r2,r2,52
 1018e3c:	10800017 	ldw	r2,0(r2)
 1018e40:	e0bff715 	stw	r2,-36(fp)

            for(j=0;j<flash->dev.region_info[i].number_of_blocks;j++)
 1018e44:	e03ff615 	stw	zero,-40(fp)
 1018e48:	00005c06 	br	1018fbc <alt_onchip_flash_write+0x264>
            {
                if ((offset >= current_offset ) &&
 1018e4c:	e0fffd17 	ldw	r3,-12(fp)
 1018e50:	e0bff717 	ldw	r2,-36(fp)
 1018e54:	18804d16 	blt	r3,r2,1018f8c <alt_onchip_flash_write+0x234>
                    (offset < (current_offset +
                    flash->dev.region_info[i].block_size)))
 1018e58:	e0fffa17 	ldw	r3,-24(fp)
 1018e5c:	e0bff517 	ldw	r2,-44(fp)
 1018e60:	10800104 	addi	r2,r2,4
 1018e64:	1004913a 	slli	r2,r2,4
 1018e68:	1885883a 	add	r2,r3,r2
 1018e6c:	10c00017 	ldw	r3,0(r2)
            current_offset = flash->dev.region_info[i].offset;

            for(j=0;j<flash->dev.region_info[i].number_of_blocks;j++)
            {
                if ((offset >= current_offset ) &&
                    (offset < (current_offset +
 1018e70:	e0bff717 	ldw	r2,-36(fp)
 1018e74:	1885883a 	add	r2,r3,r2
        {
            current_offset = flash->dev.region_info[i].offset;

            for(j=0;j<flash->dev.region_info[i].number_of_blocks;j++)
            {
                if ((offset >= current_offset ) &&
 1018e78:	e0fffd17 	ldw	r3,-12(fp)
 1018e7c:	1880430e 	bge	r3,r2,1018f8c <alt_onchip_flash_write+0x234>
                {
                    /*
                    * Check if the contents of the block are different
                    * from the data we wish to put there
                    */
                    data_to_write = (current_offset + flash->dev.region_info[i].block_size - offset);
 1018e80:	e0fffa17 	ldw	r3,-24(fp)
 1018e84:	e0bff517 	ldw	r2,-44(fp)
 1018e88:	10800104 	addi	r2,r2,4
 1018e8c:	1004913a 	slli	r2,r2,4
 1018e90:	1885883a 	add	r2,r3,r2
 1018e94:	10c00017 	ldw	r3,0(r2)
 1018e98:	e0bff717 	ldw	r2,-36(fp)
 1018e9c:	1887883a 	add	r3,r3,r2
 1018ea0:	e0bffd17 	ldw	r2,-12(fp)
 1018ea4:	1885c83a 	sub	r2,r3,r2
 1018ea8:	e0bffb15 	stw	r2,-20(fp)
                    data_to_write = MIN(data_to_write, length);
 1018eac:	e0fffb17 	ldw	r3,-20(fp)
 1018eb0:	e0bfff17 	ldw	r2,-4(fp)
 1018eb4:	1880010e 	bge	r3,r2,1018ebc <alt_onchip_flash_write+0x164>
 1018eb8:	1805883a 	mov	r2,r3
 1018ebc:	e0bffb15 	stw	r2,-20(fp)
                    if(memcmp(src_addr, (alt_u8*)flash->dev.base_addr+offset, data_to_write))
 1018ec0:	e0bffa17 	ldw	r2,-24(fp)
 1018ec4:	10c00a17 	ldw	r3,40(r2)
 1018ec8:	e0bffd17 	ldw	r2,-12(fp)
 1018ecc:	1885883a 	add	r2,r3,r2
 1018ed0:	e0fffb17 	ldw	r3,-20(fp)
 1018ed4:	180d883a 	mov	r6,r3
 1018ed8:	100b883a 	mov	r5,r2
 1018edc:	e13ffe17 	ldw	r4,-8(fp)
 1018ee0:	101a3f80 	call	101a3f8 <memcmp>
 1018ee4:	10001326 	beq	r2,zero,1018f34 <alt_onchip_flash_write+0x1dc>
                    {
                        ret_code = (*flash->dev.erase_block)(&flash->dev, current_offset);
 1018ee8:	e0bffa17 	ldw	r2,-24(fp)
 1018eec:	10800817 	ldw	r2,32(r2)
 1018ef0:	e0fffa17 	ldw	r3,-24(fp)
 1018ef4:	e17ff717 	ldw	r5,-36(fp)
 1018ef8:	1809883a 	mov	r4,r3
 1018efc:	103ee83a 	callr	r2
 1018f00:	e0bff415 	stw	r2,-48(fp)

                        if (!ret_code)
 1018f04:	e0bff417 	ldw	r2,-48(fp)
 1018f08:	10000a1e 	bne	r2,zero,1018f34 <alt_onchip_flash_write+0x1dc>
                        {
                            ret_code = (*flash->dev.write_block)(
 1018f0c:	e0bffa17 	ldw	r2,-24(fp)
 1018f10:	10800917 	ldw	r2,36(r2)
 1018f14:	e13ffa17 	ldw	r4,-24(fp)
 1018f18:	e0fffb17 	ldw	r3,-20(fp)
 1018f1c:	d8c00015 	stw	r3,0(sp)
 1018f20:	e1fffe17 	ldw	r7,-8(fp)
 1018f24:	e1bffd17 	ldw	r6,-12(fp)
 1018f28:	e17ff717 	ldw	r5,-36(fp)
 1018f2c:	103ee83a 	callr	r2
 1018f30:	e0bff415 	stw	r2,-48(fp)
                                                                data_to_write);
                        }
                    }

                    /* Was this the last block? */
                    if ((length == data_to_write) || ret_code)
 1018f34:	e0ffff17 	ldw	r3,-4(fp)
 1018f38:	e0bffb17 	ldw	r2,-20(fp)
 1018f3c:	18802e26 	beq	r3,r2,1018ff8 <alt_onchip_flash_write+0x2a0>
 1018f40:	e0bff417 	ldw	r2,-48(fp)
 1018f44:	10002c1e 	bne	r2,zero,1018ff8 <alt_onchip_flash_write+0x2a0>
                    {
                        goto finished;
                    }

                    length -= data_to_write;
 1018f48:	e0ffff17 	ldw	r3,-4(fp)
 1018f4c:	e0bffb17 	ldw	r2,-20(fp)
 1018f50:	1885c83a 	sub	r2,r3,r2
 1018f54:	e0bfff15 	stw	r2,-4(fp)
                    offset = current_offset + flash->dev.region_info[i].block_size;
 1018f58:	e0fffa17 	ldw	r3,-24(fp)
 1018f5c:	e0bff517 	ldw	r2,-44(fp)
 1018f60:	10800104 	addi	r2,r2,4
 1018f64:	1004913a 	slli	r2,r2,4
 1018f68:	1885883a 	add	r2,r3,r2
 1018f6c:	10c00017 	ldw	r3,0(r2)
 1018f70:	e0bff717 	ldw	r2,-36(fp)
 1018f74:	1885883a 	add	r2,r3,r2
 1018f78:	e0bffd15 	stw	r2,-12(fp)
                    src_addr = (alt_u8*)src_addr + data_to_write;
 1018f7c:	e0bffb17 	ldw	r2,-20(fp)
 1018f80:	e0fffe17 	ldw	r3,-8(fp)
 1018f84:	1885883a 	add	r2,r3,r2
 1018f88:	e0bffe15 	stw	r2,-8(fp)
                }
                current_offset += flash->dev.region_info[i].block_size;
 1018f8c:	e0fffa17 	ldw	r3,-24(fp)
 1018f90:	e0bff517 	ldw	r2,-44(fp)
 1018f94:	10800104 	addi	r2,r2,4
 1018f98:	1004913a 	slli	r2,r2,4
 1018f9c:	1885883a 	add	r2,r3,r2
 1018fa0:	10800017 	ldw	r2,0(r2)
 1018fa4:	e0fff717 	ldw	r3,-36(fp)
 1018fa8:	1885883a 	add	r2,r3,r2
 1018fac:	e0bff715 	stw	r2,-36(fp)
            (offset < (flash->dev.region_info[i].offset +
            flash->dev.region_info[i].region_size)))
        {
            current_offset = flash->dev.region_info[i].offset;

            for(j=0;j<flash->dev.region_info[i].number_of_blocks;j++)
 1018fb0:	e0bff617 	ldw	r2,-40(fp)
 1018fb4:	10800044 	addi	r2,r2,1
 1018fb8:	e0bff615 	stw	r2,-40(fp)
 1018fbc:	e0fffa17 	ldw	r3,-24(fp)
 1018fc0:	e0bff517 	ldw	r2,-44(fp)
 1018fc4:	1004913a 	slli	r2,r2,4
 1018fc8:	1885883a 	add	r2,r3,r2
 1018fcc:	10800f04 	addi	r2,r2,60
 1018fd0:	10800017 	ldw	r2,0(r2)
 1018fd4:	e0fff617 	ldw	r3,-40(fp)
 1018fd8:	18bf9c16 	blt	r3,r2,1018e4c <__alt_data_end+0xff818e4c>
    }

    /*
    * First and foremost which sectors are affected?
    */
    for(i=0;i<flash->dev.number_of_regions;i++)
 1018fdc:	e0bff517 	ldw	r2,-44(fp)
 1018fe0:	10800044 	addi	r2,r2,1
 1018fe4:	e0bff515 	stw	r2,-44(fp)
 1018fe8:	e0bffa17 	ldw	r2,-24(fp)
 1018fec:	10800c17 	ldw	r2,48(r2)
 1018ff0:	e0fff517 	ldw	r3,-44(fp)
 1018ff4:	18bf7516 	blt	r3,r2,1018dcc <__alt_data_end+0xff818dcc>
            }
        }
    }

finished:
    alt_dcache_flush((alt_u8*)flash->dev.base_addr+start_offset, full_length);
 1018ff8:	e0bffa17 	ldw	r2,-24(fp)
 1018ffc:	10c00a17 	ldw	r3,40(r2)
 1019000:	e0bff917 	ldw	r2,-28(fp)
 1019004:	1885883a 	add	r2,r3,r2
 1019008:	e0fff817 	ldw	r3,-32(fp)
 101900c:	180b883a 	mov	r5,r3
 1019010:	1009883a 	mov	r4,r2
 1019014:	10199400 	call	1019940 <alt_dcache_flush>
    return ret_code;
 1019018:	e0bff417 	ldw	r2,-48(fp)
}
 101901c:	e037883a 	mov	sp,fp
 1019020:	dfc00117 	ldw	ra,4(sp)
 1019024:	df000017 	ldw	fp,0(sp)
 1019028:	dec00204 	addi	sp,sp,8
 101902c:	f800283a 	ret

01019030 <altera_onchip_flash_init>:
**/
void altera_onchip_flash_init
(
    alt_onchip_flash_dev *flash
)
{
 1019030:	defff504 	addi	sp,sp,-44
 1019034:	dfc00a15 	stw	ra,40(sp)
 1019038:	df000915 	stw	fp,36(sp)
 101903c:	dc000815 	stw	r16,32(sp)
 1019040:	df000904 	addi	fp,sp,36
 1019044:	e13ffe15 	stw	r4,-8(fp)
    /* A region is a sector of the onchip flash */
    int number_of_regions;
    flash_region* region_info;
    int sector1_status = ALTERA_ONCHIP_FLASH_STATUS_SECTOR1_AVAILABLE;
 1019048:	e03ff815 	stw	zero,-32(fp)
    int sector2_status = ALTERA_ONCHIP_FLASH_STATUS_SECTOR2_AVAILABLE;
 101904c:	e03ff915 	stw	zero,-28(fp)
    int sector3_status = ALTERA_ONCHIP_FLASH_STATUS_SECTOR3_AVAILABLE;
 1019050:	e03ffa15 	stw	zero,-24(fp)
    int sector4_status = ALTERA_ONCHIP_FLASH_STATUS_SECTOR4_AVAILABLE;
 1019054:	e03ffb15 	stw	zero,-20(fp)
    int sector5_status = ALTERA_ONCHIP_FLASH_STATUS_SECTOR5_AVAILABLE;
 1019058:	e03ffc15 	stw	zero,-16(fp)

    /* Set up flash_region data structures. */
    number_of_regions = 0;
 101905c:	e03ff715 	stw	zero,-36(fp)
    region_info = &flash->dev.region_info[0];
 1019060:	e0bffe17 	ldw	r2,-8(fp)
 1019064:	10800d04 	addi	r2,r2,52
 1019068:	e0bffd15 	stw	r2,-12(fp)

    if (flash->csr_base != NULL) {
 101906c:	e0bffe17 	ldw	r2,-8(fp)
 1019070:	10802f17 	ldw	r2,188(r2)
 1019074:	10001926 	beq	r2,zero,10190dc <altera_onchip_flash_init+0xac>
        sector1_status = IORD_ALTERA_ONCHIP_FLASH_STATUS(flash->csr_base) & ALTERA_ONCHIP_FLASH_STATUS_SECTOR1_MSK;
 1019078:	e0bffe17 	ldw	r2,-8(fp)
 101907c:	10802f17 	ldw	r2,188(r2)
 1019080:	10800037 	ldwio	r2,0(r2)
 1019084:	1080080c 	andi	r2,r2,32
 1019088:	e0bff815 	stw	r2,-32(fp)
        sector2_status = IORD_ALTERA_ONCHIP_FLASH_STATUS(flash->csr_base) & ALTERA_ONCHIP_FLASH_STATUS_SECTOR2_MSK;
 101908c:	e0bffe17 	ldw	r2,-8(fp)
 1019090:	10802f17 	ldw	r2,188(r2)
 1019094:	10800037 	ldwio	r2,0(r2)
 1019098:	1080100c 	andi	r2,r2,64
 101909c:	e0bff915 	stw	r2,-28(fp)
        sector3_status = IORD_ALTERA_ONCHIP_FLASH_STATUS(flash->csr_base) & ALTERA_ONCHIP_FLASH_STATUS_SECTOR3_MSK;
 10190a0:	e0bffe17 	ldw	r2,-8(fp)
 10190a4:	10802f17 	ldw	r2,188(r2)
 10190a8:	10800037 	ldwio	r2,0(r2)
 10190ac:	1080200c 	andi	r2,r2,128
 10190b0:	e0bffa15 	stw	r2,-24(fp)
        sector4_status = IORD_ALTERA_ONCHIP_FLASH_STATUS(flash->csr_base) & ALTERA_ONCHIP_FLASH_STATUS_SECTOR4_MSK;
 10190b4:	e0bffe17 	ldw	r2,-8(fp)
 10190b8:	10802f17 	ldw	r2,188(r2)
 10190bc:	10800037 	ldwio	r2,0(r2)
 10190c0:	1080400c 	andi	r2,r2,256
 10190c4:	e0bffb15 	stw	r2,-20(fp)
        sector5_status = IORD_ALTERA_ONCHIP_FLASH_STATUS(flash->csr_base) & ALTERA_ONCHIP_FLASH_STATUS_SECTOR5_MSK;
 10190c8:	e0bffe17 	ldw	r2,-8(fp)
 10190cc:	10802f17 	ldw	r2,188(r2)
 10190d0:	10800037 	ldwio	r2,0(r2)
 10190d4:	1080800c 	andi	r2,r2,512
 10190d8:	e0bffc15 	stw	r2,-16(fp)
    }

    if ((flash->sector1_enabled == 1) && (sector1_status != ALTERA_ONCHIP_FLASH_STATUS_SECTOR1_UNAVAILABLE)) {
 10190dc:	e0bffe17 	ldw	r2,-8(fp)
 10190e0:	10803017 	ldw	r2,192(r2)
 10190e4:	10800058 	cmpnei	r2,r2,1
 10190e8:	10002f1e 	bne	r2,zero,10191a8 <altera_onchip_flash_init+0x178>
 10190ec:	e0bff817 	ldw	r2,-32(fp)
 10190f0:	10800820 	cmpeqi	r2,r2,32
 10190f4:	10002c1e 	bne	r2,zero,10191a8 <altera_onchip_flash_init+0x178>

        region_info[number_of_regions].offset = flash->sector1_start_addr;
 10190f8:	e0bff717 	ldw	r2,-36(fp)
 10190fc:	1004913a 	slli	r2,r2,4
 1019100:	e0fffd17 	ldw	r3,-12(fp)
 1019104:	1885883a 	add	r2,r3,r2
 1019108:	e0fffe17 	ldw	r3,-8(fp)
 101910c:	18c03117 	ldw	r3,196(r3)
 1019110:	10c00015 	stw	r3,0(r2)
        region_info[number_of_regions].region_size = flash->sector1_end_addr - flash->sector1_start_addr + 1;
 1019114:	e0bff717 	ldw	r2,-36(fp)
 1019118:	1004913a 	slli	r2,r2,4
 101911c:	e0fffd17 	ldw	r3,-12(fp)
 1019120:	1885883a 	add	r2,r3,r2
 1019124:	e0fffe17 	ldw	r3,-8(fp)
 1019128:	19003217 	ldw	r4,200(r3)
 101912c:	e0fffe17 	ldw	r3,-8(fp)
 1019130:	18c03117 	ldw	r3,196(r3)
 1019134:	20c7c83a 	sub	r3,r4,r3
 1019138:	18c00044 	addi	r3,r3,1
 101913c:	10c00115 	stw	r3,4(r2)
        region_info[number_of_regions].number_of_blocks = flash->dev.region_info[number_of_regions].region_size / flash->page_size;
 1019140:	e0bff717 	ldw	r2,-36(fp)
 1019144:	1004913a 	slli	r2,r2,4
 1019148:	e0fffd17 	ldw	r3,-12(fp)
 101914c:	18a1883a 	add	r16,r3,r2
 1019150:	e0fffe17 	ldw	r3,-8(fp)
 1019154:	e0bff717 	ldw	r2,-36(fp)
 1019158:	1004913a 	slli	r2,r2,4
 101915c:	1885883a 	add	r2,r3,r2
 1019160:	10800e04 	addi	r2,r2,56
 1019164:	10c00017 	ldw	r3,0(r2)
 1019168:	e0bffe17 	ldw	r2,-8(fp)
 101916c:	10803f17 	ldw	r2,252(r2)
 1019170:	100b883a 	mov	r5,r2
 1019174:	1809883a 	mov	r4,r3
 1019178:	10096ac0 	call	10096ac <__divsi3>
 101917c:	80800215 	stw	r2,8(r16)
        region_info[number_of_regions].block_size = flash->page_size;
 1019180:	e0bff717 	ldw	r2,-36(fp)
 1019184:	1004913a 	slli	r2,r2,4
 1019188:	e0fffd17 	ldw	r3,-12(fp)
 101918c:	1885883a 	add	r2,r3,r2
 1019190:	e0fffe17 	ldw	r3,-8(fp)
 1019194:	18c03f17 	ldw	r3,252(r3)
 1019198:	10c00315 	stw	r3,12(r2)

        number_of_regions++;
 101919c:	e0bff717 	ldw	r2,-36(fp)
 10191a0:	10800044 	addi	r2,r2,1
 10191a4:	e0bff715 	stw	r2,-36(fp)
    }

    if ((flash->sector2_enabled == 1) && (sector2_status != ALTERA_ONCHIP_FLASH_STATUS_SECTOR2_UNAVAILABLE)) {
 10191a8:	e0bffe17 	ldw	r2,-8(fp)
 10191ac:	10803317 	ldw	r2,204(r2)
 10191b0:	10800058 	cmpnei	r2,r2,1
 10191b4:	10002f1e 	bne	r2,zero,1019274 <altera_onchip_flash_init+0x244>
 10191b8:	e0bff917 	ldw	r2,-28(fp)
 10191bc:	10801020 	cmpeqi	r2,r2,64
 10191c0:	10002c1e 	bne	r2,zero,1019274 <altera_onchip_flash_init+0x244>

        region_info[number_of_regions].offset = flash->sector2_start_addr;
 10191c4:	e0bff717 	ldw	r2,-36(fp)
 10191c8:	1004913a 	slli	r2,r2,4
 10191cc:	e0fffd17 	ldw	r3,-12(fp)
 10191d0:	1885883a 	add	r2,r3,r2
 10191d4:	e0fffe17 	ldw	r3,-8(fp)
 10191d8:	18c03417 	ldw	r3,208(r3)
 10191dc:	10c00015 	stw	r3,0(r2)
        region_info[number_of_regions].region_size = flash->sector2_end_addr - flash->sector2_start_addr + 1;
 10191e0:	e0bff717 	ldw	r2,-36(fp)
 10191e4:	1004913a 	slli	r2,r2,4
 10191e8:	e0fffd17 	ldw	r3,-12(fp)
 10191ec:	1885883a 	add	r2,r3,r2
 10191f0:	e0fffe17 	ldw	r3,-8(fp)
 10191f4:	19003517 	ldw	r4,212(r3)
 10191f8:	e0fffe17 	ldw	r3,-8(fp)
 10191fc:	18c03417 	ldw	r3,208(r3)
 1019200:	20c7c83a 	sub	r3,r4,r3
 1019204:	18c00044 	addi	r3,r3,1
 1019208:	10c00115 	stw	r3,4(r2)
        region_info[number_of_regions].number_of_blocks = flash->dev.region_info[number_of_regions].region_size / flash->page_size;
 101920c:	e0bff717 	ldw	r2,-36(fp)
 1019210:	1004913a 	slli	r2,r2,4
 1019214:	e0fffd17 	ldw	r3,-12(fp)
 1019218:	18a1883a 	add	r16,r3,r2
 101921c:	e0fffe17 	ldw	r3,-8(fp)
 1019220:	e0bff717 	ldw	r2,-36(fp)
 1019224:	1004913a 	slli	r2,r2,4
 1019228:	1885883a 	add	r2,r3,r2
 101922c:	10800e04 	addi	r2,r2,56
 1019230:	10c00017 	ldw	r3,0(r2)
 1019234:	e0bffe17 	ldw	r2,-8(fp)
 1019238:	10803f17 	ldw	r2,252(r2)
 101923c:	100b883a 	mov	r5,r2
 1019240:	1809883a 	mov	r4,r3
 1019244:	10096ac0 	call	10096ac <__divsi3>
 1019248:	80800215 	stw	r2,8(r16)
        region_info[number_of_regions].block_size = flash->page_size;
 101924c:	e0bff717 	ldw	r2,-36(fp)
 1019250:	1004913a 	slli	r2,r2,4
 1019254:	e0fffd17 	ldw	r3,-12(fp)
 1019258:	1885883a 	add	r2,r3,r2
 101925c:	e0fffe17 	ldw	r3,-8(fp)
 1019260:	18c03f17 	ldw	r3,252(r3)
 1019264:	10c00315 	stw	r3,12(r2)

        number_of_regions++;
 1019268:	e0bff717 	ldw	r2,-36(fp)
 101926c:	10800044 	addi	r2,r2,1
 1019270:	e0bff715 	stw	r2,-36(fp)
	}

    if ((flash->sector3_enabled == 1) && (sector3_status != ALTERA_ONCHIP_FLASH_STATUS_SECTOR3_UNAVAILABLE)) {
 1019274:	e0bffe17 	ldw	r2,-8(fp)
 1019278:	10803617 	ldw	r2,216(r2)
 101927c:	10800058 	cmpnei	r2,r2,1
 1019280:	10002f1e 	bne	r2,zero,1019340 <altera_onchip_flash_init+0x310>
 1019284:	e0bffa17 	ldw	r2,-24(fp)
 1019288:	10802020 	cmpeqi	r2,r2,128
 101928c:	10002c1e 	bne	r2,zero,1019340 <altera_onchip_flash_init+0x310>

        region_info[number_of_regions].offset = flash->sector3_start_addr;
 1019290:	e0bff717 	ldw	r2,-36(fp)
 1019294:	1004913a 	slli	r2,r2,4
 1019298:	e0fffd17 	ldw	r3,-12(fp)
 101929c:	1885883a 	add	r2,r3,r2
 10192a0:	e0fffe17 	ldw	r3,-8(fp)
 10192a4:	18c03717 	ldw	r3,220(r3)
 10192a8:	10c00015 	stw	r3,0(r2)
        region_info[number_of_regions].region_size = flash->sector3_end_addr - flash->sector3_start_addr + 1;
 10192ac:	e0bff717 	ldw	r2,-36(fp)
 10192b0:	1004913a 	slli	r2,r2,4
 10192b4:	e0fffd17 	ldw	r3,-12(fp)
 10192b8:	1885883a 	add	r2,r3,r2
 10192bc:	e0fffe17 	ldw	r3,-8(fp)
 10192c0:	19003817 	ldw	r4,224(r3)
 10192c4:	e0fffe17 	ldw	r3,-8(fp)
 10192c8:	18c03717 	ldw	r3,220(r3)
 10192cc:	20c7c83a 	sub	r3,r4,r3
 10192d0:	18c00044 	addi	r3,r3,1
 10192d4:	10c00115 	stw	r3,4(r2)
        region_info[number_of_regions].number_of_blocks = flash->dev.region_info[number_of_regions].region_size / flash->page_size;
 10192d8:	e0bff717 	ldw	r2,-36(fp)
 10192dc:	1004913a 	slli	r2,r2,4
 10192e0:	e0fffd17 	ldw	r3,-12(fp)
 10192e4:	18a1883a 	add	r16,r3,r2
 10192e8:	e0fffe17 	ldw	r3,-8(fp)
 10192ec:	e0bff717 	ldw	r2,-36(fp)
 10192f0:	1004913a 	slli	r2,r2,4
 10192f4:	1885883a 	add	r2,r3,r2
 10192f8:	10800e04 	addi	r2,r2,56
 10192fc:	10c00017 	ldw	r3,0(r2)
 1019300:	e0bffe17 	ldw	r2,-8(fp)
 1019304:	10803f17 	ldw	r2,252(r2)
 1019308:	100b883a 	mov	r5,r2
 101930c:	1809883a 	mov	r4,r3
 1019310:	10096ac0 	call	10096ac <__divsi3>
 1019314:	80800215 	stw	r2,8(r16)
        region_info[number_of_regions].block_size = flash->page_size;
 1019318:	e0bff717 	ldw	r2,-36(fp)
 101931c:	1004913a 	slli	r2,r2,4
 1019320:	e0fffd17 	ldw	r3,-12(fp)
 1019324:	1885883a 	add	r2,r3,r2
 1019328:	e0fffe17 	ldw	r3,-8(fp)
 101932c:	18c03f17 	ldw	r3,252(r3)
 1019330:	10c00315 	stw	r3,12(r2)

        number_of_regions++;
 1019334:	e0bff717 	ldw	r2,-36(fp)
 1019338:	10800044 	addi	r2,r2,1
 101933c:	e0bff715 	stw	r2,-36(fp)
	}

	if ((flash->sector4_enabled == 1) && (sector4_status != ALTERA_ONCHIP_FLASH_STATUS_SECTOR4_UNAVAILABLE)) {
 1019340:	e0bffe17 	ldw	r2,-8(fp)
 1019344:	10803917 	ldw	r2,228(r2)
 1019348:	10800058 	cmpnei	r2,r2,1
 101934c:	10002f1e 	bne	r2,zero,101940c <altera_onchip_flash_init+0x3dc>
 1019350:	e0bffb17 	ldw	r2,-20(fp)
 1019354:	10804020 	cmpeqi	r2,r2,256
 1019358:	10002c1e 	bne	r2,zero,101940c <altera_onchip_flash_init+0x3dc>

        region_info[number_of_regions].offset = flash->sector4_start_addr;
 101935c:	e0bff717 	ldw	r2,-36(fp)
 1019360:	1004913a 	slli	r2,r2,4
 1019364:	e0fffd17 	ldw	r3,-12(fp)
 1019368:	1885883a 	add	r2,r3,r2
 101936c:	e0fffe17 	ldw	r3,-8(fp)
 1019370:	18c03a17 	ldw	r3,232(r3)
 1019374:	10c00015 	stw	r3,0(r2)
        region_info[number_of_regions].region_size = flash->sector4_end_addr - flash->sector4_start_addr + 1;
 1019378:	e0bff717 	ldw	r2,-36(fp)
 101937c:	1004913a 	slli	r2,r2,4
 1019380:	e0fffd17 	ldw	r3,-12(fp)
 1019384:	1885883a 	add	r2,r3,r2
 1019388:	e0fffe17 	ldw	r3,-8(fp)
 101938c:	19003b17 	ldw	r4,236(r3)
 1019390:	e0fffe17 	ldw	r3,-8(fp)
 1019394:	18c03a17 	ldw	r3,232(r3)
 1019398:	20c7c83a 	sub	r3,r4,r3
 101939c:	18c00044 	addi	r3,r3,1
 10193a0:	10c00115 	stw	r3,4(r2)
        region_info[number_of_regions].number_of_blocks = flash->dev.region_info[number_of_regions].region_size / flash->page_size;
 10193a4:	e0bff717 	ldw	r2,-36(fp)
 10193a8:	1004913a 	slli	r2,r2,4
 10193ac:	e0fffd17 	ldw	r3,-12(fp)
 10193b0:	18a1883a 	add	r16,r3,r2
 10193b4:	e0fffe17 	ldw	r3,-8(fp)
 10193b8:	e0bff717 	ldw	r2,-36(fp)
 10193bc:	1004913a 	slli	r2,r2,4
 10193c0:	1885883a 	add	r2,r3,r2
 10193c4:	10800e04 	addi	r2,r2,56
 10193c8:	10c00017 	ldw	r3,0(r2)
 10193cc:	e0bffe17 	ldw	r2,-8(fp)
 10193d0:	10803f17 	ldw	r2,252(r2)
 10193d4:	100b883a 	mov	r5,r2
 10193d8:	1809883a 	mov	r4,r3
 10193dc:	10096ac0 	call	10096ac <__divsi3>
 10193e0:	80800215 	stw	r2,8(r16)
        region_info[number_of_regions].block_size = flash->page_size;
 10193e4:	e0bff717 	ldw	r2,-36(fp)
 10193e8:	1004913a 	slli	r2,r2,4
 10193ec:	e0fffd17 	ldw	r3,-12(fp)
 10193f0:	1885883a 	add	r2,r3,r2
 10193f4:	e0fffe17 	ldw	r3,-8(fp)
 10193f8:	18c03f17 	ldw	r3,252(r3)
 10193fc:	10c00315 	stw	r3,12(r2)

        number_of_regions++;
 1019400:	e0bff717 	ldw	r2,-36(fp)
 1019404:	10800044 	addi	r2,r2,1
 1019408:	e0bff715 	stw	r2,-36(fp)
	}

    if ((flash->sector5_enabled == 1) && (sector5_status != ALTERA_ONCHIP_FLASH_STATUS_SECTOR5_UNAVAILABLE)) {
 101940c:	e0bffe17 	ldw	r2,-8(fp)
 1019410:	10803c17 	ldw	r2,240(r2)
 1019414:	10800058 	cmpnei	r2,r2,1
 1019418:	10002f1e 	bne	r2,zero,10194d8 <altera_onchip_flash_init+0x4a8>
 101941c:	e0bffc17 	ldw	r2,-16(fp)
 1019420:	10808020 	cmpeqi	r2,r2,512
 1019424:	10002c1e 	bne	r2,zero,10194d8 <altera_onchip_flash_init+0x4a8>

        region_info[number_of_regions].offset = flash->sector5_start_addr;
 1019428:	e0bff717 	ldw	r2,-36(fp)
 101942c:	1004913a 	slli	r2,r2,4
 1019430:	e0fffd17 	ldw	r3,-12(fp)
 1019434:	1885883a 	add	r2,r3,r2
 1019438:	e0fffe17 	ldw	r3,-8(fp)
 101943c:	18c03d17 	ldw	r3,244(r3)
 1019440:	10c00015 	stw	r3,0(r2)
        region_info[number_of_regions].region_size = flash->sector5_end_addr - flash->sector5_start_addr + 1;
 1019444:	e0bff717 	ldw	r2,-36(fp)
 1019448:	1004913a 	slli	r2,r2,4
 101944c:	e0fffd17 	ldw	r3,-12(fp)
 1019450:	1885883a 	add	r2,r3,r2
 1019454:	e0fffe17 	ldw	r3,-8(fp)
 1019458:	19003e17 	ldw	r4,248(r3)
 101945c:	e0fffe17 	ldw	r3,-8(fp)
 1019460:	18c03d17 	ldw	r3,244(r3)
 1019464:	20c7c83a 	sub	r3,r4,r3
 1019468:	18c00044 	addi	r3,r3,1
 101946c:	10c00115 	stw	r3,4(r2)
        region_info[number_of_regions].number_of_blocks = flash->dev.region_info[number_of_regions].region_size / flash->page_size;
 1019470:	e0bff717 	ldw	r2,-36(fp)
 1019474:	1004913a 	slli	r2,r2,4
 1019478:	e0fffd17 	ldw	r3,-12(fp)
 101947c:	18a1883a 	add	r16,r3,r2
 1019480:	e0fffe17 	ldw	r3,-8(fp)
 1019484:	e0bff717 	ldw	r2,-36(fp)
 1019488:	1004913a 	slli	r2,r2,4
 101948c:	1885883a 	add	r2,r3,r2
 1019490:	10800e04 	addi	r2,r2,56
 1019494:	10c00017 	ldw	r3,0(r2)
 1019498:	e0bffe17 	ldw	r2,-8(fp)
 101949c:	10803f17 	ldw	r2,252(r2)
 10194a0:	100b883a 	mov	r5,r2
 10194a4:	1809883a 	mov	r4,r3
 10194a8:	10096ac0 	call	10096ac <__divsi3>
 10194ac:	80800215 	stw	r2,8(r16)
        region_info[number_of_regions].block_size = flash->page_size;
 10194b0:	e0bff717 	ldw	r2,-36(fp)
 10194b4:	1004913a 	slli	r2,r2,4
 10194b8:	e0fffd17 	ldw	r3,-12(fp)
 10194bc:	1885883a 	add	r2,r3,r2
 10194c0:	e0fffe17 	ldw	r3,-8(fp)
 10194c4:	18c03f17 	ldw	r3,252(r3)
 10194c8:	10c00315 	stw	r3,12(r2)

        number_of_regions++;
 10194cc:	e0bff717 	ldw	r2,-36(fp)
 10194d0:	10800044 	addi	r2,r2,1
 10194d4:	e0bff715 	stw	r2,-36(fp)
    }

    /* Update number of regions. */
    flash->dev.number_of_regions = number_of_regions;
 10194d8:	e0bffe17 	ldw	r2,-8(fp)
 10194dc:	e0fff717 	ldw	r3,-36(fp)
 10194e0:	10c00c15 	stw	r3,48(r2)

    /*
    *  Register this device as a valid flash device type
    */
    alt_flash_device_register(&(flash->dev));
 10194e4:	e0bffe17 	ldw	r2,-8(fp)
 10194e8:	1009883a 	mov	r4,r2
 10194ec:	101877c0 	call	101877c <alt_flash_device_register>
}
 10194f0:	0001883a 	nop
 10194f4:	e6ffff04 	addi	sp,fp,-4
 10194f8:	dfc00217 	ldw	ra,8(sp)
 10194fc:	df000117 	ldw	fp,4(sp)
 1019500:	dc000017 	ldw	r16,0(sp)
 1019504:	dec00304 	addi	sp,sp,12
 1019508:	f800283a 	ret

0101950c <alt_onchip_flash_poll_for_status_to_go_idle>:
**/
int alt_onchip_flash_poll_for_status_to_go_idle
(
    alt_onchip_flash_dev *flash
)
{
 101950c:	defffa04 	addi	sp,sp,-24
 1019510:	dfc00515 	stw	ra,20(sp)
 1019514:	df000415 	stw	fp,16(sp)
 1019518:	df000404 	addi	fp,sp,16
 101951c:	e13fff15 	stw	r4,-4(fp)
    int ret_code = 0;
 1019520:	e03ffc15 	stw	zero,-16(fp)
    int timeout = ALTERA_ONCHIP_FLASH_STATUS_BIT_POLLING_TIMEOUT_VALUE;
 1019524:	008002f4 	movhi	r2,11
 1019528:	10ab9804 	addi	r2,r2,-20896
 101952c:	e0bffe15 	stw	r2,-8(fp)
    int count_down = ALTERA_ONCHIP_FLASH_STATUS_BIT_POLLING_TIMEOUT_VALUE;
 1019530:	008002f4 	movhi	r2,11
 1019534:	10ab9804 	addi	r2,r2,-20896
 1019538:	e0bffd15 	stw	r2,-12(fp)

    while (
 101953c:	00000c06 	br	1019570 <alt_onchip_flash_poll_for_status_to_go_idle+0x64>
        (IORD_ALTERA_ONCHIP_FLASH_STATUS(flash->csr_base) &
              ALTERA_ONCHIP_FLASH_STATUS_BUSY_MSK
        ) !=  ALTERA_ONCHIP_FLASH_STATUS_BUSY_IDLE
    ) {
	 
	alt_busy_sleep(1); /* delay 1us */
 1019540:	01000044 	movi	r4,1
 1019544:	10197e80 	call	10197e8 <alt_busy_sleep>

        /* If timeout value is zero, it will never timeout. */
        if (timeout != 0) {
 1019548:	e0bffe17 	ldw	r2,-8(fp)
 101954c:	10000826 	beq	r2,zero,1019570 <alt_onchip_flash_poll_for_status_to_go_idle+0x64>
            count_down--;
 1019550:	e0bffd17 	ldw	r2,-12(fp)
 1019554:	10bfffc4 	addi	r2,r2,-1
 1019558:	e0bffd15 	stw	r2,-12(fp)
            if (count_down == 0) {
 101955c:	e0bffd17 	ldw	r2,-12(fp)
 1019560:	1000031e 	bne	r2,zero,1019570 <alt_onchip_flash_poll_for_status_to_go_idle+0x64>
                /* Timeout */
                ret_code = -ETIMEDOUT;
 1019564:	00bfe304 	movi	r2,-116
 1019568:	e0bffc15 	stw	r2,-16(fp)
                break;
 101956c:	00000506 	br	1019584 <alt_onchip_flash_poll_for_status_to_go_idle+0x78>
    int ret_code = 0;
    int timeout = ALTERA_ONCHIP_FLASH_STATUS_BIT_POLLING_TIMEOUT_VALUE;
    int count_down = ALTERA_ONCHIP_FLASH_STATUS_BIT_POLLING_TIMEOUT_VALUE;

    while (
        (IORD_ALTERA_ONCHIP_FLASH_STATUS(flash->csr_base) &
 1019570:	e0bfff17 	ldw	r2,-4(fp)
 1019574:	10802f17 	ldw	r2,188(r2)
 1019578:	10800037 	ldwio	r2,0(r2)
 101957c:	108000cc 	andi	r2,r2,3
{
    int ret_code = 0;
    int timeout = ALTERA_ONCHIP_FLASH_STATUS_BIT_POLLING_TIMEOUT_VALUE;
    int count_down = ALTERA_ONCHIP_FLASH_STATUS_BIT_POLLING_TIMEOUT_VALUE;

    while (
 1019580:	103fef1e 	bne	r2,zero,1019540 <__alt_data_end+0xff819540>
                break;
            }
        }
    }

    return ret_code;
 1019584:	e0bffc17 	ldw	r2,-16(fp)
}
 1019588:	e037883a 	mov	sp,fp
 101958c:	dfc00117 	ldw	ra,4(sp)
 1019590:	df000017 	ldw	fp,0(sp)
 1019594:	dec00204 	addi	sp,sp,8
 1019598:	f800283a 	ret

0101959c <alt_onchip_flash_poll_for_status_erase_passed>:
**/
int alt_onchip_flash_poll_for_status_erase_passed
(
    alt_onchip_flash_dev *flash
)
{
 101959c:	defffa04 	addi	sp,sp,-24
 10195a0:	dfc00515 	stw	ra,20(sp)
 10195a4:	df000415 	stw	fp,16(sp)
 10195a8:	df000404 	addi	fp,sp,16
 10195ac:	e13fff15 	stw	r4,-4(fp)
    int ret_code = 0;
 10195b0:	e03ffc15 	stw	zero,-16(fp)
    int timeout = ALTERA_ONCHIP_FLASH_STATUS_BIT_POLLING_TIMEOUT_VALUE;
 10195b4:	008002f4 	movhi	r2,11
 10195b8:	10ab9804 	addi	r2,r2,-20896
 10195bc:	e0bffe15 	stw	r2,-8(fp)
    int count_down = ALTERA_ONCHIP_FLASH_STATUS_BIT_POLLING_TIMEOUT_VALUE;
 10195c0:	008002f4 	movhi	r2,11
 10195c4:	10ab9804 	addi	r2,r2,-20896
 10195c8:	e0bffd15 	stw	r2,-12(fp)

    while (
 10195cc:	00000c06 	br	1019600 <alt_onchip_flash_poll_for_status_erase_passed+0x64>
        (IORD_ALTERA_ONCHIP_FLASH_STATUS(flash->csr_base) &
              ALTERA_ONCHIP_FLASH_STATUS_ERASE_MSK
        ) !=  ALTERA_ONCHIP_FLASH_STATUS_ERASE_PASSED
    ) {

	alt_busy_sleep(1); /* delay 1us */
 10195d0:	01000044 	movi	r4,1
 10195d4:	10197e80 	call	10197e8 <alt_busy_sleep>

        /* If timeout value is zero, it will never timeout. */
        if (timeout != 0) {
 10195d8:	e0bffe17 	ldw	r2,-8(fp)
 10195dc:	10000826 	beq	r2,zero,1019600 <alt_onchip_flash_poll_for_status_erase_passed+0x64>
            count_down--;
 10195e0:	e0bffd17 	ldw	r2,-12(fp)
 10195e4:	10bfffc4 	addi	r2,r2,-1
 10195e8:	e0bffd15 	stw	r2,-12(fp)
            if (count_down == 0) {
 10195ec:	e0bffd17 	ldw	r2,-12(fp)
 10195f0:	1000031e 	bne	r2,zero,1019600 <alt_onchip_flash_poll_for_status_erase_passed+0x64>
                /* Timeout */
                ret_code = -ETIMEDOUT;
 10195f4:	00bfe304 	movi	r2,-116
 10195f8:	e0bffc15 	stw	r2,-16(fp)
                break;
 10195fc:	00000506 	br	1019614 <alt_onchip_flash_poll_for_status_erase_passed+0x78>
    int ret_code = 0;
    int timeout = ALTERA_ONCHIP_FLASH_STATUS_BIT_POLLING_TIMEOUT_VALUE;
    int count_down = ALTERA_ONCHIP_FLASH_STATUS_BIT_POLLING_TIMEOUT_VALUE;

    while (
        (IORD_ALTERA_ONCHIP_FLASH_STATUS(flash->csr_base) &
 1019600:	e0bfff17 	ldw	r2,-4(fp)
 1019604:	10802f17 	ldw	r2,188(r2)
 1019608:	10800037 	ldwio	r2,0(r2)
 101960c:	1080040c 	andi	r2,r2,16
{
    int ret_code = 0;
    int timeout = ALTERA_ONCHIP_FLASH_STATUS_BIT_POLLING_TIMEOUT_VALUE;
    int count_down = ALTERA_ONCHIP_FLASH_STATUS_BIT_POLLING_TIMEOUT_VALUE;

    while (
 1019610:	103fef26 	beq	r2,zero,10195d0 <__alt_data_end+0xff8195d0>
                break;
            }
        }
    }

    return ret_code;
 1019614:	e0bffc17 	ldw	r2,-16(fp)
}
 1019618:	e037883a 	mov	sp,fp
 101961c:	dfc00117 	ldw	ra,4(sp)
 1019620:	df000017 	ldw	fp,0(sp)
 1019624:	dec00204 	addi	sp,sp,8
 1019628:	f800283a 	ret

0101962c <alt_onchip_flash_poll_for_status_write_passed>:
**/
int alt_onchip_flash_poll_for_status_write_passed
(
    alt_onchip_flash_dev *flash
)
{
 101962c:	defffa04 	addi	sp,sp,-24
 1019630:	dfc00515 	stw	ra,20(sp)
 1019634:	df000415 	stw	fp,16(sp)
 1019638:	df000404 	addi	fp,sp,16
 101963c:	e13fff15 	stw	r4,-4(fp)
    int ret_code = 0;
 1019640:	e03ffc15 	stw	zero,-16(fp)
    int timeout = ALTERA_ONCHIP_FLASH_STATUS_BIT_POLLING_TIMEOUT_VALUE;
 1019644:	008002f4 	movhi	r2,11
 1019648:	10ab9804 	addi	r2,r2,-20896
 101964c:	e0bffe15 	stw	r2,-8(fp)
    int count_down = ALTERA_ONCHIP_FLASH_STATUS_BIT_POLLING_TIMEOUT_VALUE;
 1019650:	008002f4 	movhi	r2,11
 1019654:	10ab9804 	addi	r2,r2,-20896
 1019658:	e0bffd15 	stw	r2,-12(fp)

    while (
 101965c:	00000c06 	br	1019690 <alt_onchip_flash_poll_for_status_write_passed+0x64>
        (IORD_ALTERA_ONCHIP_FLASH_STATUS(flash->csr_base) &
              ALTERA_ONCHIP_FLASH_STATUS_WRITE_MSK
        ) !=  ALTERA_ONCHIP_FLASH_STATUS_WRITE_PASSED
    ) {

	alt_busy_sleep(1); /* delay 1us */
 1019660:	01000044 	movi	r4,1
 1019664:	10197e80 	call	10197e8 <alt_busy_sleep>

        /* If timeout value is zero, it will never timeout. */
        if (timeout != 0) {
 1019668:	e0bffe17 	ldw	r2,-8(fp)
 101966c:	10000826 	beq	r2,zero,1019690 <alt_onchip_flash_poll_for_status_write_passed+0x64>
            count_down--;
 1019670:	e0bffd17 	ldw	r2,-12(fp)
 1019674:	10bfffc4 	addi	r2,r2,-1
 1019678:	e0bffd15 	stw	r2,-12(fp)
            if (count_down == 0) {
 101967c:	e0bffd17 	ldw	r2,-12(fp)
 1019680:	1000031e 	bne	r2,zero,1019690 <alt_onchip_flash_poll_for_status_write_passed+0x64>
                /* Timeout */
                ret_code = -ETIMEDOUT;
 1019684:	00bfe304 	movi	r2,-116
 1019688:	e0bffc15 	stw	r2,-16(fp)
                break;
 101968c:	00000506 	br	10196a4 <alt_onchip_flash_poll_for_status_write_passed+0x78>
    int ret_code = 0;
    int timeout = ALTERA_ONCHIP_FLASH_STATUS_BIT_POLLING_TIMEOUT_VALUE;
    int count_down = ALTERA_ONCHIP_FLASH_STATUS_BIT_POLLING_TIMEOUT_VALUE;

    while (
        (IORD_ALTERA_ONCHIP_FLASH_STATUS(flash->csr_base) &
 1019690:	e0bfff17 	ldw	r2,-4(fp)
 1019694:	10802f17 	ldw	r2,188(r2)
 1019698:	10800037 	ldwio	r2,0(r2)
 101969c:	1080020c 	andi	r2,r2,8
{
    int ret_code = 0;
    int timeout = ALTERA_ONCHIP_FLASH_STATUS_BIT_POLLING_TIMEOUT_VALUE;
    int count_down = ALTERA_ONCHIP_FLASH_STATUS_BIT_POLLING_TIMEOUT_VALUE;

    while (
 10196a0:	103fef26 	beq	r2,zero,1019660 <__alt_data_end+0xff819660>
                break;
            }
        }
    }

    return ret_code;
 10196a4:	e0bffc17 	ldw	r2,-16(fp)
}
 10196a8:	e037883a 	mov	sp,fp
 10196ac:	dfc00117 	ldw	ra,4(sp)
 10196b0:	df000017 	ldw	fp,0(sp)
 10196b4:	dec00204 	addi	sp,sp,8
 10196b8:	f800283a 	ret

010196bc <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
 10196bc:	defff504 	addi	sp,sp,-44
 10196c0:	df000a15 	stw	fp,40(sp)
 10196c4:	df000a04 	addi	fp,sp,40
 10196c8:	e13ffc15 	stw	r4,-16(fp)
 10196cc:	e17ffd15 	stw	r5,-12(fp)
 10196d0:	e1bffe15 	stw	r6,-8(fp)
 10196d4:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
 10196d8:	e03ff615 	stw	zero,-40(fp)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 10196dc:	d0a0b317 	ldw	r2,-32052(gp)
  
  if (alt_ticks_per_second ())
 10196e0:	10003c26 	beq	r2,zero,10197d4 <alt_alarm_start+0x118>
  {
    if (alarm)
 10196e4:	e0bffc17 	ldw	r2,-16(fp)
 10196e8:	10003826 	beq	r2,zero,10197cc <alt_alarm_start+0x110>
    {
      alarm->callback = callback;
 10196ec:	e0bffc17 	ldw	r2,-16(fp)
 10196f0:	e0fffe17 	ldw	r3,-8(fp)
 10196f4:	10c00315 	stw	r3,12(r2)
      alarm->context  = context;
 10196f8:	e0bffc17 	ldw	r2,-16(fp)
 10196fc:	e0ffff17 	ldw	r3,-4(fp)
 1019700:	10c00515 	stw	r3,20(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 1019704:	0005303a 	rdctl	r2,status
 1019708:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 101970c:	e0fff917 	ldw	r3,-28(fp)
 1019710:	00bfff84 	movi	r2,-2
 1019714:	1884703a 	and	r2,r3,r2
 1019718:	1001703a 	wrctl	status,r2
  
  return context;
 101971c:	e0bff917 	ldw	r2,-28(fp)
 
      irq_context = alt_irq_disable_all ();
 1019720:	e0bff815 	stw	r2,-32(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
 1019724:	d0a0b417 	ldw	r2,-32048(gp)
      
      current_nticks = alt_nticks();
 1019728:	e0bff615 	stw	r2,-40(fp)
      
      alarm->time = nticks + current_nticks + 1; 
 101972c:	e0fffd17 	ldw	r3,-12(fp)
 1019730:	e0bff617 	ldw	r2,-40(fp)
 1019734:	1885883a 	add	r2,r3,r2
 1019738:	10c00044 	addi	r3,r2,1
 101973c:	e0bffc17 	ldw	r2,-16(fp)
 1019740:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
 1019744:	e0bffc17 	ldw	r2,-16(fp)
 1019748:	10c00217 	ldw	r3,8(r2)
 101974c:	e0bff617 	ldw	r2,-40(fp)
 1019750:	1880042e 	bgeu	r3,r2,1019764 <alt_alarm_start+0xa8>
      {
        alarm->rollover = 1;
 1019754:	e0bffc17 	ldw	r2,-16(fp)
 1019758:	00c00044 	movi	r3,1
 101975c:	10c00405 	stb	r3,16(r2)
 1019760:	00000206 	br	101976c <alt_alarm_start+0xb0>
      }
      else
      {
        alarm->rollover = 0;
 1019764:	e0bffc17 	ldw	r2,-16(fp)
 1019768:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
 101976c:	e0bffc17 	ldw	r2,-16(fp)
 1019770:	d0e03504 	addi	r3,gp,-32556
 1019774:	e0fffa15 	stw	r3,-24(fp)
 1019778:	e0bffb15 	stw	r2,-20(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 101977c:	e0bffb17 	ldw	r2,-20(fp)
 1019780:	e0fffa17 	ldw	r3,-24(fp)
 1019784:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
 1019788:	e0bffa17 	ldw	r2,-24(fp)
 101978c:	10c00017 	ldw	r3,0(r2)
 1019790:	e0bffb17 	ldw	r2,-20(fp)
 1019794:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 1019798:	e0bffa17 	ldw	r2,-24(fp)
 101979c:	10800017 	ldw	r2,0(r2)
 10197a0:	e0fffb17 	ldw	r3,-20(fp)
 10197a4:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
 10197a8:	e0bffa17 	ldw	r2,-24(fp)
 10197ac:	e0fffb17 	ldw	r3,-20(fp)
 10197b0:	10c00015 	stw	r3,0(r2)
 10197b4:	e0bff817 	ldw	r2,-32(fp)
 10197b8:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 10197bc:	e0bff717 	ldw	r2,-36(fp)
 10197c0:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
 10197c4:	0005883a 	mov	r2,zero
 10197c8:	00000306 	br	10197d8 <alt_alarm_start+0x11c>
    }
    else
    {
      return -EINVAL;
 10197cc:	00bffa84 	movi	r2,-22
 10197d0:	00000106 	br	10197d8 <alt_alarm_start+0x11c>
    }
  }
  else
  {
    return -ENOTSUP;
 10197d4:	00bfde84 	movi	r2,-134
  }
}
 10197d8:	e037883a 	mov	sp,fp
 10197dc:	df000017 	ldw	fp,0(sp)
 10197e0:	dec00104 	addi	sp,sp,4
 10197e4:	f800283a 	ret

010197e8 <alt_busy_sleep>:
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
 10197e8:	defffa04 	addi	sp,sp,-24
 10197ec:	dfc00515 	stw	ra,20(sp)
 10197f0:	df000415 	stw	fp,16(sp)
 10197f4:	df000404 	addi	fp,sp,16
 10197f8:	e13fff15 	stw	r4,-4(fp)
  {
    cycles_per_loop = 9;
  }
  else  
  {
    cycles_per_loop = 3;
 10197fc:	008000c4 	movi	r2,3
 1019800:	e0bffd15 	stw	r2,-12(fp)
  }
  

  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));
 1019804:	e0fffd17 	ldw	r3,-12(fp)
 1019808:	008003f4 	movhi	r2,15
 101980c:	10909004 	addi	r2,r2,16960
 1019810:	1885383a 	mul	r2,r3,r2
 1019814:	100b883a 	mov	r5,r2
 1019818:	01017db4 	movhi	r4,1526
 101981c:	21384004 	addi	r4,r4,-7936
 1019820:	10097a40 	call	10097a4 <__udivsi3>
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
 1019824:	100b883a 	mov	r5,r2
 1019828:	01200034 	movhi	r4,32768
 101982c:	213fffc4 	addi	r4,r4,-1
 1019830:	10097a40 	call	10097a4 <__udivsi3>
 1019834:	100b883a 	mov	r5,r2
 1019838:	e13fff17 	ldw	r4,-4(fp)
 101983c:	10097a40 	call	10097a4 <__udivsi3>
 1019840:	e0bffe15 	stw	r2,-8(fp)
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
 1019844:	e0bffe17 	ldw	r2,-8(fp)
 1019848:	10002a26 	beq	r2,zero,10198f4 <alt_busy_sleep+0x10c>
  {
    for(i=0;i<big_loops;i++)
 101984c:	e03ffc15 	stw	zero,-16(fp)
 1019850:	00001706 	br	10198b0 <alt_busy_sleep+0xc8>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
 1019854:	00a00034 	movhi	r2,32768
 1019858:	10bfffc4 	addi	r2,r2,-1
 101985c:	10bfffc4 	addi	r2,r2,-1
 1019860:	103ffe1e 	bne	r2,zero,101985c <__alt_data_end+0xff81985c>
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
      (cycles_per_loop * 1000000)));
 1019864:	e0fffd17 	ldw	r3,-12(fp)
 1019868:	008003f4 	movhi	r2,15
 101986c:	10909004 	addi	r2,r2,16960
 1019870:	1885383a 	mul	r2,r3,r2
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
 1019874:	100b883a 	mov	r5,r2
 1019878:	01017db4 	movhi	r4,1526
 101987c:	21384004 	addi	r4,r4,-7936
 1019880:	10097a40 	call	10097a4 <__udivsi3>
 1019884:	100b883a 	mov	r5,r2
 1019888:	01200034 	movhi	r4,32768
 101988c:	213fffc4 	addi	r4,r4,-1
 1019890:	10097a40 	call	10097a4 <__udivsi3>
 1019894:	1007883a 	mov	r3,r2
 1019898:	e0bfff17 	ldw	r2,-4(fp)
 101989c:	10c5c83a 	sub	r2,r2,r3
 10198a0:	e0bfff15 	stw	r2,-4(fp)
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
 10198a4:	e0bffc17 	ldw	r2,-16(fp)
 10198a8:	10800044 	addi	r2,r2,1
 10198ac:	e0bffc15 	stw	r2,-16(fp)
 10198b0:	e0fffc17 	ldw	r3,-16(fp)
 10198b4:	e0bffe17 	ldw	r2,-8(fp)
 10198b8:	18bfe616 	blt	r3,r2,1019854 <__alt_data_end+0xff819854>
      "\n\tbne %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
 10198bc:	e0fffd17 	ldw	r3,-12(fp)
 10198c0:	008003f4 	movhi	r2,15
 10198c4:	10909004 	addi	r2,r2,16960
 10198c8:	1885383a 	mul	r2,r3,r2
 10198cc:	100b883a 	mov	r5,r2
 10198d0:	01017db4 	movhi	r4,1526
 10198d4:	21384004 	addi	r4,r4,-7936
 10198d8:	10097a40 	call	10097a4 <__udivsi3>
 10198dc:	1007883a 	mov	r3,r2
 10198e0:	e0bfff17 	ldw	r2,-4(fp)
 10198e4:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
 10198e8:	10bfffc4 	addi	r2,r2,-1
 10198ec:	103ffe1e 	bne	r2,zero,10198e8 <__alt_data_end+0xff8198e8>
 10198f0:	00000d06 	br	1019928 <alt_busy_sleep+0x140>
      "\n\tbgt %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
 10198f4:	e0fffd17 	ldw	r3,-12(fp)
 10198f8:	008003f4 	movhi	r2,15
 10198fc:	10909004 	addi	r2,r2,16960
 1019900:	1885383a 	mul	r2,r3,r2
 1019904:	100b883a 	mov	r5,r2
 1019908:	01017db4 	movhi	r4,1526
 101990c:	21384004 	addi	r4,r4,-7936
 1019910:	10097a40 	call	10097a4 <__udivsi3>
 1019914:	1007883a 	mov	r3,r2
 1019918:	e0bfff17 	ldw	r2,-4(fp)
 101991c:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
 1019920:	10bfffc4 	addi	r2,r2,-1
 1019924:	00bffe16 	blt	zero,r2,1019920 <__alt_data_end+0xff819920>
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
 1019928:	0005883a 	mov	r2,zero
}
 101992c:	e037883a 	mov	sp,fp
 1019930:	dfc00117 	ldw	ra,4(sp)
 1019934:	df000017 	ldw	fp,0(sp)
 1019938:	dec00204 	addi	sp,sp,8
 101993c:	f800283a 	ret

01019940 <alt_dcache_flush>:
 *
 * Any dirty lines in the data cache are written back to memory.
 */

void alt_dcache_flush (void* start, alt_u32 len)
{
 1019940:	defffb04 	addi	sp,sp,-20
 1019944:	df000415 	stw	fp,16(sp)
 1019948:	df000404 	addi	fp,sp,16
 101994c:	e13ffe15 	stw	r4,-8(fp)
 1019950:	e17fff15 	stw	r5,-4(fp)
#if NIOS2_DCACHE_SIZE > 0

  char* i;
  char* end = ((char*) start) + len; 
 1019954:	e0fffe17 	ldw	r3,-8(fp)
 1019958:	e0bfff17 	ldw	r2,-4(fp)
 101995c:	1885883a 	add	r2,r3,r2
 1019960:	e0bffd15 	stw	r2,-12(fp)

  for (i = start; i < end; i+= NIOS2_DCACHE_LINE_SIZE)
 1019964:	e0bffe17 	ldw	r2,-8(fp)
 1019968:	e0bffc15 	stw	r2,-16(fp)
 101996c:	00000506 	br	1019984 <alt_dcache_flush+0x44>
  { 
    ALT_FLUSH_DATA(i); 
 1019970:	e0bffc17 	ldw	r2,-16(fp)
 1019974:	1000001b 	flushda	0(r2)
#if NIOS2_DCACHE_SIZE > 0

  char* i;
  char* end = ((char*) start) + len; 

  for (i = start; i < end; i+= NIOS2_DCACHE_LINE_SIZE)
 1019978:	e0bffc17 	ldw	r2,-16(fp)
 101997c:	10800804 	addi	r2,r2,32
 1019980:	e0bffc15 	stw	r2,-16(fp)
 1019984:	e0fffc17 	ldw	r3,-16(fp)
 1019988:	e0bffd17 	ldw	r2,-12(fp)
 101998c:	18bff836 	bltu	r3,r2,1019970 <__alt_data_end+0xff819970>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_DCACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_DCACHE_LINE_SIZE - 1))
 1019990:	e0bffe17 	ldw	r2,-8(fp)
 1019994:	108007cc 	andi	r2,r2,31
 1019998:	10000226 	beq	r2,zero,10199a4 <alt_dcache_flush+0x64>
  {
    ALT_FLUSH_DATA(i);
 101999c:	e0bffc17 	ldw	r2,-16(fp)
 10199a0:	1000001b 	flushda	0(r2)
  }

#endif /* NIOS2_DCACHE_SIZE > 0 */
}
 10199a4:	0001883a 	nop
 10199a8:	e037883a 	mov	sp,fp
 10199ac:	df000017 	ldw	fp,0(sp)
 10199b0:	dec00104 	addi	sp,sp,4
 10199b4:	f800283a 	ret

010199b8 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 10199b8:	defffe04 	addi	sp,sp,-8
 10199bc:	dfc00115 	stw	ra,4(sp)
 10199c0:	df000015 	stw	fp,0(sp)
 10199c4:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 10199c8:	d0a02c17 	ldw	r2,-32592(gp)
 10199cc:	10000326 	beq	r2,zero,10199dc <alt_get_errno+0x24>
 10199d0:	d0a02c17 	ldw	r2,-32592(gp)
 10199d4:	103ee83a 	callr	r2
 10199d8:	00000106 	br	10199e0 <alt_get_errno+0x28>
 10199dc:	d0a0ae04 	addi	r2,gp,-32072
}
 10199e0:	e037883a 	mov	sp,fp
 10199e4:	dfc00117 	ldw	ra,4(sp)
 10199e8:	df000017 	ldw	fp,0(sp)
 10199ec:	dec00204 	addi	sp,sp,8
 10199f0:	f800283a 	ret

010199f4 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
 10199f4:	defffa04 	addi	sp,sp,-24
 10199f8:	dfc00515 	stw	ra,20(sp)
 10199fc:	df000415 	stw	fp,16(sp)
 1019a00:	df000404 	addi	fp,sp,16
 1019a04:	e13ffe15 	stw	r4,-8(fp)
 1019a08:	e17fff15 	stw	r5,-4(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
 1019a0c:	e0bffe17 	ldw	r2,-8(fp)
 1019a10:	10000326 	beq	r2,zero,1019a20 <alt_dev_llist_insert+0x2c>
 1019a14:	e0bffe17 	ldw	r2,-8(fp)
 1019a18:	10800217 	ldw	r2,8(r2)
 1019a1c:	1000061e 	bne	r2,zero,1019a38 <alt_dev_llist_insert+0x44>
  {
    ALT_ERRNO = EINVAL;
 1019a20:	10199b80 	call	10199b8 <alt_get_errno>
 1019a24:	1007883a 	mov	r3,r2
 1019a28:	00800584 	movi	r2,22
 1019a2c:	18800015 	stw	r2,0(r3)
    return -EINVAL;
 1019a30:	00bffa84 	movi	r2,-22
 1019a34:	00001306 	br	1019a84 <alt_dev_llist_insert+0x90>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
 1019a38:	e0bffe17 	ldw	r2,-8(fp)
 1019a3c:	e0ffff17 	ldw	r3,-4(fp)
 1019a40:	e0fffc15 	stw	r3,-16(fp)
 1019a44:	e0bffd15 	stw	r2,-12(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 1019a48:	e0bffd17 	ldw	r2,-12(fp)
 1019a4c:	e0fffc17 	ldw	r3,-16(fp)
 1019a50:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
 1019a54:	e0bffc17 	ldw	r2,-16(fp)
 1019a58:	10c00017 	ldw	r3,0(r2)
 1019a5c:	e0bffd17 	ldw	r2,-12(fp)
 1019a60:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 1019a64:	e0bffc17 	ldw	r2,-16(fp)
 1019a68:	10800017 	ldw	r2,0(r2)
 1019a6c:	e0fffd17 	ldw	r3,-12(fp)
 1019a70:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
 1019a74:	e0bffc17 	ldw	r2,-16(fp)
 1019a78:	e0fffd17 	ldw	r3,-12(fp)
 1019a7c:	10c00015 	stw	r3,0(r2)

  return 0;  
 1019a80:	0005883a 	mov	r2,zero
}
 1019a84:	e037883a 	mov	sp,fp
 1019a88:	dfc00117 	ldw	ra,4(sp)
 1019a8c:	df000017 	ldw	fp,0(sp)
 1019a90:	dec00204 	addi	sp,sp,8
 1019a94:	f800283a 	ret

01019a98 <_do_ctors>:
/*
 * Run the C++ static constructors.
 */

void _do_ctors(void)
{
 1019a98:	defffd04 	addi	sp,sp,-12
 1019a9c:	dfc00215 	stw	ra,8(sp)
 1019aa0:	df000115 	stw	fp,4(sp)
 1019aa4:	df000104 	addi	fp,sp,4
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 1019aa8:	008040b4 	movhi	r2,258
 1019aac:	10a9cf04 	addi	r2,r2,-22724
 1019ab0:	e0bfff15 	stw	r2,-4(fp)
 1019ab4:	00000606 	br	1019ad0 <_do_ctors+0x38>
        (*ctor) (); 
 1019ab8:	e0bfff17 	ldw	r2,-4(fp)
 1019abc:	10800017 	ldw	r2,0(r2)
 1019ac0:	103ee83a 	callr	r2

void _do_ctors(void)
{
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 1019ac4:	e0bfff17 	ldw	r2,-4(fp)
 1019ac8:	10bfff04 	addi	r2,r2,-4
 1019acc:	e0bfff15 	stw	r2,-4(fp)
 1019ad0:	e0ffff17 	ldw	r3,-4(fp)
 1019ad4:	008040b4 	movhi	r2,258
 1019ad8:	10a9d004 	addi	r2,r2,-22720
 1019adc:	18bff62e 	bgeu	r3,r2,1019ab8 <__alt_data_end+0xff819ab8>
        (*ctor) (); 
}
 1019ae0:	0001883a 	nop
 1019ae4:	e037883a 	mov	sp,fp
 1019ae8:	dfc00117 	ldw	ra,4(sp)
 1019aec:	df000017 	ldw	fp,0(sp)
 1019af0:	dec00204 	addi	sp,sp,8
 1019af4:	f800283a 	ret

01019af8 <_do_dtors>:
/*
 * Run the C++ static destructors.
 */

void _do_dtors(void)
{
 1019af8:	defffd04 	addi	sp,sp,-12
 1019afc:	dfc00215 	stw	ra,8(sp)
 1019b00:	df000115 	stw	fp,4(sp)
 1019b04:	df000104 	addi	fp,sp,4
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
 1019b08:	008040b4 	movhi	r2,258
 1019b0c:	10a9cf04 	addi	r2,r2,-22724
 1019b10:	e0bfff15 	stw	r2,-4(fp)
 1019b14:	00000606 	br	1019b30 <_do_dtors+0x38>
        (*dtor) (); 
 1019b18:	e0bfff17 	ldw	r2,-4(fp)
 1019b1c:	10800017 	ldw	r2,0(r2)
 1019b20:	103ee83a 	callr	r2

void _do_dtors(void)
{
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
 1019b24:	e0bfff17 	ldw	r2,-4(fp)
 1019b28:	10bfff04 	addi	r2,r2,-4
 1019b2c:	e0bfff15 	stw	r2,-4(fp)
 1019b30:	e0ffff17 	ldw	r3,-4(fp)
 1019b34:	008040b4 	movhi	r2,258
 1019b38:	10a9d004 	addi	r2,r2,-22720
 1019b3c:	18bff62e 	bgeu	r3,r2,1019b18 <__alt_data_end+0xff819b18>
        (*dtor) (); 
}
 1019b40:	0001883a 	nop
 1019b44:	e037883a 	mov	sp,fp
 1019b48:	dfc00117 	ldw	ra,4(sp)
 1019b4c:	df000017 	ldw	fp,0(sp)
 1019b50:	dec00204 	addi	sp,sp,8
 1019b54:	f800283a 	ret

01019b58 <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
 1019b58:	defffa04 	addi	sp,sp,-24
 1019b5c:	dfc00515 	stw	ra,20(sp)
 1019b60:	df000415 	stw	fp,16(sp)
 1019b64:	df000404 	addi	fp,sp,16
 1019b68:	e13ffe15 	stw	r4,-8(fp)
 1019b6c:	e17fff15 	stw	r5,-4(fp)
  alt_dev* next = (alt_dev*) llist->next;
 1019b70:	e0bfff17 	ldw	r2,-4(fp)
 1019b74:	10800017 	ldw	r2,0(r2)
 1019b78:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
 1019b7c:	e13ffe17 	ldw	r4,-8(fp)
 1019b80:	1009da40 	call	1009da4 <strlen>
 1019b84:	10800044 	addi	r2,r2,1
 1019b88:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 1019b8c:	00000d06 	br	1019bc4 <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
 1019b90:	e0bffc17 	ldw	r2,-16(fp)
 1019b94:	10800217 	ldw	r2,8(r2)
 1019b98:	e0fffd17 	ldw	r3,-12(fp)
 1019b9c:	180d883a 	mov	r6,r3
 1019ba0:	e17ffe17 	ldw	r5,-8(fp)
 1019ba4:	1009883a 	mov	r4,r2
 1019ba8:	101a3f80 	call	101a3f8 <memcmp>
 1019bac:	1000021e 	bne	r2,zero,1019bb8 <alt_find_dev+0x60>
    {
      /* match found */

      return next;
 1019bb0:	e0bffc17 	ldw	r2,-16(fp)
 1019bb4:	00000706 	br	1019bd4 <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
 1019bb8:	e0bffc17 	ldw	r2,-16(fp)
 1019bbc:	10800017 	ldw	r2,0(r2)
 1019bc0:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 1019bc4:	e0fffc17 	ldw	r3,-16(fp)
 1019bc8:	e0bfff17 	ldw	r2,-4(fp)
 1019bcc:	18bff01e 	bne	r3,r2,1019b90 <__alt_data_end+0xff819b90>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
 1019bd0:	0005883a 	mov	r2,zero
}
 1019bd4:	e037883a 	mov	sp,fp
 1019bd8:	dfc00117 	ldw	ra,4(sp)
 1019bdc:	df000017 	ldw	fp,0(sp)
 1019be0:	dec00204 	addi	sp,sp,8
 1019be4:	f800283a 	ret

01019be8 <alt_flash_open_dev>:
#include "priv/alt_file.h"

ALT_LLIST_HEAD(alt_flash_dev_list);

alt_flash_fd* alt_flash_open_dev(const char* name)
{
 1019be8:	defffc04 	addi	sp,sp,-16
 1019bec:	dfc00315 	stw	ra,12(sp)
 1019bf0:	df000215 	stw	fp,8(sp)
 1019bf4:	df000204 	addi	fp,sp,8
 1019bf8:	e13fff15 	stw	r4,-4(fp)
  alt_flash_dev* dev = (alt_flash_dev*)alt_find_dev(name, &alt_flash_dev_list);
 1019bfc:	d1603304 	addi	r5,gp,-32564
 1019c00:	e13fff17 	ldw	r4,-4(fp)
 1019c04:	1019b580 	call	1019b58 <alt_find_dev>
 1019c08:	e0bffe15 	stw	r2,-8(fp)

  if ((dev) && dev->open)
 1019c0c:	e0bffe17 	ldw	r2,-8(fp)
 1019c10:	10000926 	beq	r2,zero,1019c38 <alt_flash_open_dev+0x50>
 1019c14:	e0bffe17 	ldw	r2,-8(fp)
 1019c18:	10800317 	ldw	r2,12(r2)
 1019c1c:	10000626 	beq	r2,zero,1019c38 <alt_flash_open_dev+0x50>
  {
    return dev->open(dev, name);
 1019c20:	e0bffe17 	ldw	r2,-8(fp)
 1019c24:	10800317 	ldw	r2,12(r2)
 1019c28:	e17fff17 	ldw	r5,-4(fp)
 1019c2c:	e13ffe17 	ldw	r4,-8(fp)
 1019c30:	103ee83a 	callr	r2
 1019c34:	00000106 	br	1019c3c <alt_flash_open_dev+0x54>
  }

  return dev;
 1019c38:	e0bffe17 	ldw	r2,-8(fp)
}
 1019c3c:	e037883a 	mov	sp,fp
 1019c40:	dfc00117 	ldw	ra,4(sp)
 1019c44:	df000017 	ldw	fp,0(sp)
 1019c48:	dec00204 	addi	sp,sp,8
 1019c4c:	f800283a 	ret

01019c50 <alt_flash_close_dev>:

void alt_flash_close_dev(alt_flash_fd* fd)
{
 1019c50:	defffd04 	addi	sp,sp,-12
 1019c54:	dfc00215 	stw	ra,8(sp)
 1019c58:	df000115 	stw	fp,4(sp)
 1019c5c:	df000104 	addi	fp,sp,4
 1019c60:	e13fff15 	stw	r4,-4(fp)
  if (fd && fd->close)
 1019c64:	e0bfff17 	ldw	r2,-4(fp)
 1019c68:	10000826 	beq	r2,zero,1019c8c <alt_flash_close_dev+0x3c>
 1019c6c:	e0bfff17 	ldw	r2,-4(fp)
 1019c70:	10800417 	ldw	r2,16(r2)
 1019c74:	10000526 	beq	r2,zero,1019c8c <alt_flash_close_dev+0x3c>
  {
    fd->close(fd);
 1019c78:	e0bfff17 	ldw	r2,-4(fp)
 1019c7c:	10800417 	ldw	r2,16(r2)
 1019c80:	e13fff17 	ldw	r4,-4(fp)
 1019c84:	103ee83a 	callr	r2
  }
  return;
 1019c88:	0001883a 	nop
 1019c8c:	0001883a 	nop
}
 1019c90:	e037883a 	mov	sp,fp
 1019c94:	dfc00117 	ldw	ra,4(sp)
 1019c98:	df000017 	ldw	fp,0(sp)
 1019c9c:	dec00204 	addi	sp,sp,8
 1019ca0:	f800283a 	ret

01019ca4 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
 1019ca4:	defff904 	addi	sp,sp,-28
 1019ca8:	dfc00615 	stw	ra,24(sp)
 1019cac:	df000515 	stw	fp,20(sp)
 1019cb0:	df000504 	addi	fp,sp,20
 1019cb4:	e13ffc15 	stw	r4,-16(fp)
 1019cb8:	e17ffd15 	stw	r5,-12(fp)
 1019cbc:	e1bffe15 	stw	r6,-8(fp)
 1019cc0:	e1ffff15 	stw	r7,-4(fp)
  int old;

  old = open (name, flags, mode);
 1019cc4:	e1bfff17 	ldw	r6,-4(fp)
 1019cc8:	e17ffe17 	ldw	r5,-8(fp)
 1019ccc:	e13ffd17 	ldw	r4,-12(fp)
 1019cd0:	1019ee40 	call	1019ee4 <open>
 1019cd4:	e0bffb15 	stw	r2,-20(fp)

  if (old >= 0)
 1019cd8:	e0bffb17 	ldw	r2,-20(fp)
 1019cdc:	10001c16 	blt	r2,zero,1019d50 <alt_open_fd+0xac>
  {
    fd->dev      = alt_fd_list[old].dev;
 1019ce0:	008040b4 	movhi	r2,258
 1019ce4:	10ae7a04 	addi	r2,r2,-17944
 1019ce8:	e0fffb17 	ldw	r3,-20(fp)
 1019cec:	18c00324 	muli	r3,r3,12
 1019cf0:	10c5883a 	add	r2,r2,r3
 1019cf4:	10c00017 	ldw	r3,0(r2)
 1019cf8:	e0bffc17 	ldw	r2,-16(fp)
 1019cfc:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
 1019d00:	008040b4 	movhi	r2,258
 1019d04:	10ae7a04 	addi	r2,r2,-17944
 1019d08:	e0fffb17 	ldw	r3,-20(fp)
 1019d0c:	18c00324 	muli	r3,r3,12
 1019d10:	10c5883a 	add	r2,r2,r3
 1019d14:	10800104 	addi	r2,r2,4
 1019d18:	10c00017 	ldw	r3,0(r2)
 1019d1c:	e0bffc17 	ldw	r2,-16(fp)
 1019d20:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
 1019d24:	008040b4 	movhi	r2,258
 1019d28:	10ae7a04 	addi	r2,r2,-17944
 1019d2c:	e0fffb17 	ldw	r3,-20(fp)
 1019d30:	18c00324 	muli	r3,r3,12
 1019d34:	10c5883a 	add	r2,r2,r3
 1019d38:	10800204 	addi	r2,r2,8
 1019d3c:	10c00017 	ldw	r3,0(r2)
 1019d40:	e0bffc17 	ldw	r2,-16(fp)
 1019d44:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
 1019d48:	e13ffb17 	ldw	r4,-20(fp)
 1019d4c:	1016a240 	call	1016a24 <alt_release_fd>
  }
} 
 1019d50:	0001883a 	nop
 1019d54:	e037883a 	mov	sp,fp
 1019d58:	dfc00117 	ldw	ra,4(sp)
 1019d5c:	df000017 	ldw	fp,0(sp)
 1019d60:	dec00204 	addi	sp,sp,8
 1019d64:	f800283a 	ret

01019d68 <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
 1019d68:	defffb04 	addi	sp,sp,-20
 1019d6c:	dfc00415 	stw	ra,16(sp)
 1019d70:	df000315 	stw	fp,12(sp)
 1019d74:	df000304 	addi	fp,sp,12
 1019d78:	e13ffd15 	stw	r4,-12(fp)
 1019d7c:	e17ffe15 	stw	r5,-8(fp)
 1019d80:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
 1019d84:	01c07fc4 	movi	r7,511
 1019d88:	01800044 	movi	r6,1
 1019d8c:	e17ffd17 	ldw	r5,-12(fp)
 1019d90:	010040b4 	movhi	r4,258
 1019d94:	212e7d04 	addi	r4,r4,-17932
 1019d98:	1019ca40 	call	1019ca4 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
 1019d9c:	01c07fc4 	movi	r7,511
 1019da0:	000d883a 	mov	r6,zero
 1019da4:	e17ffe17 	ldw	r5,-8(fp)
 1019da8:	010040b4 	movhi	r4,258
 1019dac:	212e7a04 	addi	r4,r4,-17944
 1019db0:	1019ca40 	call	1019ca4 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
 1019db4:	01c07fc4 	movi	r7,511
 1019db8:	01800044 	movi	r6,1
 1019dbc:	e17fff17 	ldw	r5,-4(fp)
 1019dc0:	010040b4 	movhi	r4,258
 1019dc4:	212e8004 	addi	r4,r4,-17920
 1019dc8:	1019ca40 	call	1019ca4 <alt_open_fd>
}  
 1019dcc:	0001883a 	nop
 1019dd0:	e037883a 	mov	sp,fp
 1019dd4:	dfc00117 	ldw	ra,4(sp)
 1019dd8:	df000017 	ldw	fp,0(sp)
 1019ddc:	dec00204 	addi	sp,sp,8
 1019de0:	f800283a 	ret

01019de4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 1019de4:	defffe04 	addi	sp,sp,-8
 1019de8:	dfc00115 	stw	ra,4(sp)
 1019dec:	df000015 	stw	fp,0(sp)
 1019df0:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 1019df4:	d0a02c17 	ldw	r2,-32592(gp)
 1019df8:	10000326 	beq	r2,zero,1019e08 <alt_get_errno+0x24>
 1019dfc:	d0a02c17 	ldw	r2,-32592(gp)
 1019e00:	103ee83a 	callr	r2
 1019e04:	00000106 	br	1019e0c <alt_get_errno+0x28>
 1019e08:	d0a0ae04 	addi	r2,gp,-32072
}
 1019e0c:	e037883a 	mov	sp,fp
 1019e10:	dfc00117 	ldw	ra,4(sp)
 1019e14:	df000017 	ldw	fp,0(sp)
 1019e18:	dec00204 	addi	sp,sp,8
 1019e1c:	f800283a 	ret

01019e20 <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
 1019e20:	defffd04 	addi	sp,sp,-12
 1019e24:	df000215 	stw	fp,8(sp)
 1019e28:	df000204 	addi	fp,sp,8
 1019e2c:	e13fff15 	stw	r4,-4(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
 1019e30:	e0bfff17 	ldw	r2,-4(fp)
 1019e34:	10800217 	ldw	r2,8(r2)
 1019e38:	10d00034 	orhi	r3,r2,16384
 1019e3c:	e0bfff17 	ldw	r2,-4(fp)
 1019e40:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
 1019e44:	e03ffe15 	stw	zero,-8(fp)
 1019e48:	00001d06 	br	1019ec0 <alt_file_locked+0xa0>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
 1019e4c:	008040b4 	movhi	r2,258
 1019e50:	10ae7a04 	addi	r2,r2,-17944
 1019e54:	e0fffe17 	ldw	r3,-8(fp)
 1019e58:	18c00324 	muli	r3,r3,12
 1019e5c:	10c5883a 	add	r2,r2,r3
 1019e60:	10c00017 	ldw	r3,0(r2)
 1019e64:	e0bfff17 	ldw	r2,-4(fp)
 1019e68:	10800017 	ldw	r2,0(r2)
 1019e6c:	1880111e 	bne	r3,r2,1019eb4 <alt_file_locked+0x94>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
 1019e70:	008040b4 	movhi	r2,258
 1019e74:	10ae7a04 	addi	r2,r2,-17944
 1019e78:	e0fffe17 	ldw	r3,-8(fp)
 1019e7c:	18c00324 	muli	r3,r3,12
 1019e80:	10c5883a 	add	r2,r2,r3
 1019e84:	10800204 	addi	r2,r2,8
 1019e88:	10800017 	ldw	r2,0(r2)
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
 1019e8c:	1000090e 	bge	r2,zero,1019eb4 <alt_file_locked+0x94>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
 1019e90:	e0bffe17 	ldw	r2,-8(fp)
 1019e94:	10c00324 	muli	r3,r2,12
 1019e98:	008040b4 	movhi	r2,258
 1019e9c:	10ae7a04 	addi	r2,r2,-17944
 1019ea0:	1887883a 	add	r3,r3,r2
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
 1019ea4:	e0bfff17 	ldw	r2,-4(fp)
 1019ea8:	18800226 	beq	r3,r2,1019eb4 <alt_file_locked+0x94>
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
 1019eac:	00bffcc4 	movi	r2,-13
 1019eb0:	00000806 	br	1019ed4 <alt_file_locked+0xb4>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
 1019eb4:	e0bffe17 	ldw	r2,-8(fp)
 1019eb8:	10800044 	addi	r2,r2,1
 1019ebc:	e0bffe15 	stw	r2,-8(fp)
 1019ec0:	d0a02b17 	ldw	r2,-32596(gp)
 1019ec4:	1007883a 	mov	r3,r2
 1019ec8:	e0bffe17 	ldw	r2,-8(fp)
 1019ecc:	18bfdf2e 	bgeu	r3,r2,1019e4c <__alt_data_end+0xff819e4c>
    }
  }
  
  /* The device is not locked */
 
  return 0;
 1019ed0:	0005883a 	mov	r2,zero
}
 1019ed4:	e037883a 	mov	sp,fp
 1019ed8:	df000017 	ldw	fp,0(sp)
 1019edc:	dec00104 	addi	sp,sp,4
 1019ee0:	f800283a 	ret

01019ee4 <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
 1019ee4:	defff604 	addi	sp,sp,-40
 1019ee8:	dfc00915 	stw	ra,36(sp)
 1019eec:	df000815 	stw	fp,32(sp)
 1019ef0:	df000804 	addi	fp,sp,32
 1019ef4:	e13ffd15 	stw	r4,-12(fp)
 1019ef8:	e17ffe15 	stw	r5,-8(fp)
 1019efc:	e1bfff15 	stw	r6,-4(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
 1019f00:	00bfffc4 	movi	r2,-1
 1019f04:	e0bff915 	stw	r2,-28(fp)
  int status = -ENODEV;
 1019f08:	00bffb44 	movi	r2,-19
 1019f0c:	e0bffa15 	stw	r2,-24(fp)
  int isafs = 0;
 1019f10:	e03ffb15 	stw	zero,-20(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
 1019f14:	d1602904 	addi	r5,gp,-32604
 1019f18:	e13ffd17 	ldw	r4,-12(fp)
 1019f1c:	1019b580 	call	1019b58 <alt_find_dev>
 1019f20:	e0bff815 	stw	r2,-32(fp)
 1019f24:	e0bff817 	ldw	r2,-32(fp)
 1019f28:	1000051e 	bne	r2,zero,1019f40 <open+0x5c>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
 1019f2c:	e13ffd17 	ldw	r4,-12(fp)
 1019f30:	101a2000 	call	101a200 <alt_find_file>
 1019f34:	e0bff815 	stw	r2,-32(fp)
    isafs = 1;
 1019f38:	00800044 	movi	r2,1
 1019f3c:	e0bffb15 	stw	r2,-20(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
 1019f40:	e0bff817 	ldw	r2,-32(fp)
 1019f44:	10002926 	beq	r2,zero,1019fec <open+0x108>
  {
    if ((index = alt_get_fd (dev)) < 0)
 1019f48:	e13ff817 	ldw	r4,-32(fp)
 1019f4c:	101a3080 	call	101a308 <alt_get_fd>
 1019f50:	e0bff915 	stw	r2,-28(fp)
 1019f54:	e0bff917 	ldw	r2,-28(fp)
 1019f58:	1000030e 	bge	r2,zero,1019f68 <open+0x84>
    {
      status = index;
 1019f5c:	e0bff917 	ldw	r2,-28(fp)
 1019f60:	e0bffa15 	stw	r2,-24(fp)
 1019f64:	00002306 	br	1019ff4 <open+0x110>
    }
    else
    {
      fd = &alt_fd_list[index];
 1019f68:	e0bff917 	ldw	r2,-28(fp)
 1019f6c:	10c00324 	muli	r3,r2,12
 1019f70:	008040b4 	movhi	r2,258
 1019f74:	10ae7a04 	addi	r2,r2,-17944
 1019f78:	1885883a 	add	r2,r3,r2
 1019f7c:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
 1019f80:	e0fffe17 	ldw	r3,-8(fp)
 1019f84:	00900034 	movhi	r2,16384
 1019f88:	10bfffc4 	addi	r2,r2,-1
 1019f8c:	1886703a 	and	r3,r3,r2
 1019f90:	e0bffc17 	ldw	r2,-16(fp)
 1019f94:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
 1019f98:	e0bffb17 	ldw	r2,-20(fp)
 1019f9c:	1000051e 	bne	r2,zero,1019fb4 <open+0xd0>
 1019fa0:	e13ffc17 	ldw	r4,-16(fp)
 1019fa4:	1019e200 	call	1019e20 <alt_file_locked>
 1019fa8:	e0bffa15 	stw	r2,-24(fp)
 1019fac:	e0bffa17 	ldw	r2,-24(fp)
 1019fb0:	10001016 	blt	r2,zero,1019ff4 <open+0x110>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
 1019fb4:	e0bff817 	ldw	r2,-32(fp)
 1019fb8:	10800317 	ldw	r2,12(r2)
 1019fbc:	10000826 	beq	r2,zero,1019fe0 <open+0xfc>
 1019fc0:	e0bff817 	ldw	r2,-32(fp)
 1019fc4:	10800317 	ldw	r2,12(r2)
 1019fc8:	e1ffff17 	ldw	r7,-4(fp)
 1019fcc:	e1bffe17 	ldw	r6,-8(fp)
 1019fd0:	e17ffd17 	ldw	r5,-12(fp)
 1019fd4:	e13ffc17 	ldw	r4,-16(fp)
 1019fd8:	103ee83a 	callr	r2
 1019fdc:	00000106 	br	1019fe4 <open+0x100>
 1019fe0:	0005883a 	mov	r2,zero
 1019fe4:	e0bffa15 	stw	r2,-24(fp)
 1019fe8:	00000206 	br	1019ff4 <open+0x110>
      }
    }
  }
  else
  {
    status = -ENODEV;
 1019fec:	00bffb44 	movi	r2,-19
 1019ff0:	e0bffa15 	stw	r2,-24(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
 1019ff4:	e0bffa17 	ldw	r2,-24(fp)
 1019ff8:	1000090e 	bge	r2,zero,101a020 <open+0x13c>
  {
    alt_release_fd (index);  
 1019ffc:	e13ff917 	ldw	r4,-28(fp)
 101a000:	1016a240 	call	1016a24 <alt_release_fd>
    ALT_ERRNO = -status;
 101a004:	1019de40 	call	1019de4 <alt_get_errno>
 101a008:	1007883a 	mov	r3,r2
 101a00c:	e0bffa17 	ldw	r2,-24(fp)
 101a010:	0085c83a 	sub	r2,zero,r2
 101a014:	18800015 	stw	r2,0(r3)
    return -1;
 101a018:	00bfffc4 	movi	r2,-1
 101a01c:	00000106 	br	101a024 <open+0x140>
  }
  
  /* return the reference upon success */

  return index;
 101a020:	e0bff917 	ldw	r2,-28(fp)
}
 101a024:	e037883a 	mov	sp,fp
 101a028:	dfc00117 	ldw	ra,4(sp)
 101a02c:	df000017 	ldw	fp,0(sp)
 101a030:	dec00204 	addi	sp,sp,8
 101a034:	f800283a 	ret

0101a038 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
 101a038:	defffa04 	addi	sp,sp,-24
 101a03c:	df000515 	stw	fp,20(sp)
 101a040:	df000504 	addi	fp,sp,20
 101a044:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 101a048:	0005303a 	rdctl	r2,status
 101a04c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 101a050:	e0fffc17 	ldw	r3,-16(fp)
 101a054:	00bfff84 	movi	r2,-2
 101a058:	1884703a 	and	r2,r3,r2
 101a05c:	1001703a 	wrctl	status,r2
  
  return context;
 101a060:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
 101a064:	e0bffb15 	stw	r2,-20(fp)
  alt_llist_remove (&alarm->llist);
 101a068:	e0bfff17 	ldw	r2,-4(fp)
 101a06c:	e0bffd15 	stw	r2,-12(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
 101a070:	e0bffd17 	ldw	r2,-12(fp)
 101a074:	10800017 	ldw	r2,0(r2)
 101a078:	e0fffd17 	ldw	r3,-12(fp)
 101a07c:	18c00117 	ldw	r3,4(r3)
 101a080:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
 101a084:	e0bffd17 	ldw	r2,-12(fp)
 101a088:	10800117 	ldw	r2,4(r2)
 101a08c:	e0fffd17 	ldw	r3,-12(fp)
 101a090:	18c00017 	ldw	r3,0(r3)
 101a094:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
 101a098:	e0bffd17 	ldw	r2,-12(fp)
 101a09c:	e0fffd17 	ldw	r3,-12(fp)
 101a0a0:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
 101a0a4:	e0bffd17 	ldw	r2,-12(fp)
 101a0a8:	e0fffd17 	ldw	r3,-12(fp)
 101a0ac:	10c00015 	stw	r3,0(r2)
 101a0b0:	e0bffb17 	ldw	r2,-20(fp)
 101a0b4:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 101a0b8:	e0bffe17 	ldw	r2,-8(fp)
 101a0bc:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
 101a0c0:	0001883a 	nop
 101a0c4:	e037883a 	mov	sp,fp
 101a0c8:	df000017 	ldw	fp,0(sp)
 101a0cc:	dec00104 	addi	sp,sp,4
 101a0d0:	f800283a 	ret

0101a0d4 <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
 101a0d4:	defffb04 	addi	sp,sp,-20
 101a0d8:	dfc00415 	stw	ra,16(sp)
 101a0dc:	df000315 	stw	fp,12(sp)
 101a0e0:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
 101a0e4:	d0a03517 	ldw	r2,-32556(gp)
 101a0e8:	e0bffd15 	stw	r2,-12(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
 101a0ec:	d0a0b417 	ldw	r2,-32048(gp)
 101a0f0:	10800044 	addi	r2,r2,1
 101a0f4:	d0a0b415 	stw	r2,-32048(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 101a0f8:	00002e06 	br	101a1b4 <alt_tick+0xe0>
  {
    next = (alt_alarm*) alarm->llist.next;
 101a0fc:	e0bffd17 	ldw	r2,-12(fp)
 101a100:	10800017 	ldw	r2,0(r2)
 101a104:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
 101a108:	e0bffd17 	ldw	r2,-12(fp)
 101a10c:	10800403 	ldbu	r2,16(r2)
 101a110:	10803fcc 	andi	r2,r2,255
 101a114:	10000426 	beq	r2,zero,101a128 <alt_tick+0x54>
 101a118:	d0a0b417 	ldw	r2,-32048(gp)
 101a11c:	1000021e 	bne	r2,zero,101a128 <alt_tick+0x54>
    {
      alarm->rollover = 0;
 101a120:	e0bffd17 	ldw	r2,-12(fp)
 101a124:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
 101a128:	e0bffd17 	ldw	r2,-12(fp)
 101a12c:	10800217 	ldw	r2,8(r2)
 101a130:	d0e0b417 	ldw	r3,-32048(gp)
 101a134:	18801d36 	bltu	r3,r2,101a1ac <alt_tick+0xd8>
 101a138:	e0bffd17 	ldw	r2,-12(fp)
 101a13c:	10800403 	ldbu	r2,16(r2)
 101a140:	10803fcc 	andi	r2,r2,255
 101a144:	1000191e 	bne	r2,zero,101a1ac <alt_tick+0xd8>
    {
      next_callback = alarm->callback (alarm->context);
 101a148:	e0bffd17 	ldw	r2,-12(fp)
 101a14c:	10800317 	ldw	r2,12(r2)
 101a150:	e0fffd17 	ldw	r3,-12(fp)
 101a154:	18c00517 	ldw	r3,20(r3)
 101a158:	1809883a 	mov	r4,r3
 101a15c:	103ee83a 	callr	r2
 101a160:	e0bfff15 	stw	r2,-4(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
 101a164:	e0bfff17 	ldw	r2,-4(fp)
 101a168:	1000031e 	bne	r2,zero,101a178 <alt_tick+0xa4>
      {
        alt_alarm_stop (alarm);
 101a16c:	e13ffd17 	ldw	r4,-12(fp)
 101a170:	101a0380 	call	101a038 <alt_alarm_stop>
 101a174:	00000d06 	br	101a1ac <alt_tick+0xd8>
      }
      else
      {
        alarm->time += next_callback;
 101a178:	e0bffd17 	ldw	r2,-12(fp)
 101a17c:	10c00217 	ldw	r3,8(r2)
 101a180:	e0bfff17 	ldw	r2,-4(fp)
 101a184:	1887883a 	add	r3,r3,r2
 101a188:	e0bffd17 	ldw	r2,-12(fp)
 101a18c:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
 101a190:	e0bffd17 	ldw	r2,-12(fp)
 101a194:	10c00217 	ldw	r3,8(r2)
 101a198:	d0a0b417 	ldw	r2,-32048(gp)
 101a19c:	1880032e 	bgeu	r3,r2,101a1ac <alt_tick+0xd8>
        {
          alarm->rollover = 1;
 101a1a0:	e0bffd17 	ldw	r2,-12(fp)
 101a1a4:	00c00044 	movi	r3,1
 101a1a8:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
 101a1ac:	e0bffe17 	ldw	r2,-8(fp)
 101a1b0:	e0bffd15 	stw	r2,-12(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 101a1b4:	e0fffd17 	ldw	r3,-12(fp)
 101a1b8:	d0a03504 	addi	r2,gp,-32556
 101a1bc:	18bfcf1e 	bne	r3,r2,101a0fc <__alt_data_end+0xff81a0fc>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
 101a1c0:	0001883a 	nop
}
 101a1c4:	0001883a 	nop
 101a1c8:	e037883a 	mov	sp,fp
 101a1cc:	dfc00117 	ldw	ra,4(sp)
 101a1d0:	df000017 	ldw	fp,0(sp)
 101a1d4:	dec00204 	addi	sp,sp,8
 101a1d8:	f800283a 	ret

0101a1dc <altera_nios2_gen2_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
 101a1dc:	deffff04 	addi	sp,sp,-4
 101a1e0:	df000015 	stw	fp,0(sp)
 101a1e4:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
 101a1e8:	000170fa 	wrctl	ienable,zero
}
 101a1ec:	0001883a 	nop
 101a1f0:	e037883a 	mov	sp,fp
 101a1f4:	df000017 	ldw	fp,0(sp)
 101a1f8:	dec00104 	addi	sp,sp,4
 101a1fc:	f800283a 	ret

0101a200 <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
 101a200:	defffb04 	addi	sp,sp,-20
 101a204:	dfc00415 	stw	ra,16(sp)
 101a208:	df000315 	stw	fp,12(sp)
 101a20c:	df000304 	addi	fp,sp,12
 101a210:	e13fff15 	stw	r4,-4(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
 101a214:	d0a02717 	ldw	r2,-32612(gp)
 101a218:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
 101a21c:	00003106 	br	101a2e4 <alt_find_file+0xe4>
  {
    len = strlen(next->name);
 101a220:	e0bffd17 	ldw	r2,-12(fp)
 101a224:	10800217 	ldw	r2,8(r2)
 101a228:	1009883a 	mov	r4,r2
 101a22c:	1009da40 	call	1009da4 <strlen>
 101a230:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
 101a234:	e0bffd17 	ldw	r2,-12(fp)
 101a238:	10c00217 	ldw	r3,8(r2)
 101a23c:	e0bffe17 	ldw	r2,-8(fp)
 101a240:	10bfffc4 	addi	r2,r2,-1
 101a244:	1885883a 	add	r2,r3,r2
 101a248:	10800003 	ldbu	r2,0(r2)
 101a24c:	10803fcc 	andi	r2,r2,255
 101a250:	1080201c 	xori	r2,r2,128
 101a254:	10bfe004 	addi	r2,r2,-128
 101a258:	10800bd8 	cmpnei	r2,r2,47
 101a25c:	1000031e 	bne	r2,zero,101a26c <alt_find_file+0x6c>
    {
      len -= 1;
 101a260:	e0bffe17 	ldw	r2,-8(fp)
 101a264:	10bfffc4 	addi	r2,r2,-1
 101a268:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
 101a26c:	e0bffe17 	ldw	r2,-8(fp)
 101a270:	e0ffff17 	ldw	r3,-4(fp)
 101a274:	1885883a 	add	r2,r3,r2
 101a278:	10800003 	ldbu	r2,0(r2)
 101a27c:	10803fcc 	andi	r2,r2,255
 101a280:	1080201c 	xori	r2,r2,128
 101a284:	10bfe004 	addi	r2,r2,-128
 101a288:	10800be0 	cmpeqi	r2,r2,47
 101a28c:	1000081e 	bne	r2,zero,101a2b0 <alt_find_file+0xb0>
 101a290:	e0bffe17 	ldw	r2,-8(fp)
 101a294:	e0ffff17 	ldw	r3,-4(fp)
 101a298:	1885883a 	add	r2,r3,r2
 101a29c:	10800003 	ldbu	r2,0(r2)
 101a2a0:	10803fcc 	andi	r2,r2,255
 101a2a4:	1080201c 	xori	r2,r2,128
 101a2a8:	10bfe004 	addi	r2,r2,-128
 101a2ac:	10000a1e 	bne	r2,zero,101a2d8 <alt_find_file+0xd8>
        !memcmp (next->name, name, len))
 101a2b0:	e0bffd17 	ldw	r2,-12(fp)
 101a2b4:	10800217 	ldw	r2,8(r2)
 101a2b8:	e0fffe17 	ldw	r3,-8(fp)
 101a2bc:	180d883a 	mov	r6,r3
 101a2c0:	e17fff17 	ldw	r5,-4(fp)
 101a2c4:	1009883a 	mov	r4,r2
 101a2c8:	101a3f80 	call	101a3f8 <memcmp>
    if (next->name[len-1] == '/')
    {
      len -= 1;
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
 101a2cc:	1000021e 	bne	r2,zero,101a2d8 <alt_find_file+0xd8>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
 101a2d0:	e0bffd17 	ldw	r2,-12(fp)
 101a2d4:	00000706 	br	101a2f4 <alt_find_file+0xf4>
    }
    next = (alt_dev*) next->llist.next;
 101a2d8:	e0bffd17 	ldw	r2,-12(fp)
 101a2dc:	10800017 	ldw	r2,0(r2)
 101a2e0:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
 101a2e4:	e0fffd17 	ldw	r3,-12(fp)
 101a2e8:	d0a02704 	addi	r2,gp,-32612
 101a2ec:	18bfcc1e 	bne	r3,r2,101a220 <__alt_data_end+0xff81a220>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
 101a2f0:	0005883a 	mov	r2,zero
}
 101a2f4:	e037883a 	mov	sp,fp
 101a2f8:	dfc00117 	ldw	ra,4(sp)
 101a2fc:	df000017 	ldw	fp,0(sp)
 101a300:	dec00204 	addi	sp,sp,8
 101a304:	f800283a 	ret

0101a308 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
 101a308:	defffc04 	addi	sp,sp,-16
 101a30c:	df000315 	stw	fp,12(sp)
 101a310:	df000304 	addi	fp,sp,12
 101a314:	e13fff15 	stw	r4,-4(fp)
  alt_32 i;
  int rc = -EMFILE;
 101a318:	00bffa04 	movi	r2,-24
 101a31c:	e0bffe15 	stw	r2,-8(fp)
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
 101a320:	e03ffd15 	stw	zero,-12(fp)
 101a324:	00001906 	br	101a38c <alt_get_fd+0x84>
  {
    if (!alt_fd_list[i].dev)
 101a328:	008040b4 	movhi	r2,258
 101a32c:	10ae7a04 	addi	r2,r2,-17944
 101a330:	e0fffd17 	ldw	r3,-12(fp)
 101a334:	18c00324 	muli	r3,r3,12
 101a338:	10c5883a 	add	r2,r2,r3
 101a33c:	10800017 	ldw	r2,0(r2)
 101a340:	10000f1e 	bne	r2,zero,101a380 <alt_get_fd+0x78>
    {
      alt_fd_list[i].dev = dev;
 101a344:	008040b4 	movhi	r2,258
 101a348:	10ae7a04 	addi	r2,r2,-17944
 101a34c:	e0fffd17 	ldw	r3,-12(fp)
 101a350:	18c00324 	muli	r3,r3,12
 101a354:	10c5883a 	add	r2,r2,r3
 101a358:	e0ffff17 	ldw	r3,-4(fp)
 101a35c:	10c00015 	stw	r3,0(r2)
      if (i > alt_max_fd)
 101a360:	d0e02b17 	ldw	r3,-32596(gp)
 101a364:	e0bffd17 	ldw	r2,-12(fp)
 101a368:	1880020e 	bge	r3,r2,101a374 <alt_get_fd+0x6c>
      {
        alt_max_fd = i;
 101a36c:	e0bffd17 	ldw	r2,-12(fp)
 101a370:	d0a02b15 	stw	r2,-32596(gp)
      }
      rc = i;
 101a374:	e0bffd17 	ldw	r2,-12(fp)
 101a378:	e0bffe15 	stw	r2,-8(fp)
      goto alt_get_fd_exit;
 101a37c:	00000606 	br	101a398 <alt_get_fd+0x90>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
 101a380:	e0bffd17 	ldw	r2,-12(fp)
 101a384:	10800044 	addi	r2,r2,1
 101a388:	e0bffd15 	stw	r2,-12(fp)
 101a38c:	e0bffd17 	ldw	r2,-12(fp)
 101a390:	10800810 	cmplti	r2,r2,32
 101a394:	103fe41e 	bne	r2,zero,101a328 <__alt_data_end+0xff81a328>
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);

  return rc;
 101a398:	e0bffe17 	ldw	r2,-8(fp)
}
 101a39c:	e037883a 	mov	sp,fp
 101a3a0:	df000017 	ldw	fp,0(sp)
 101a3a4:	dec00104 	addi	sp,sp,4
 101a3a8:	f800283a 	ret

0101a3ac <atexit>:
 101a3ac:	200b883a 	mov	r5,r4
 101a3b0:	000f883a 	mov	r7,zero
 101a3b4:	000d883a 	mov	r6,zero
 101a3b8:	0009883a 	mov	r4,zero
 101a3bc:	101a4741 	jmpi	101a474 <__register_exitproc>

0101a3c0 <exit>:
 101a3c0:	defffe04 	addi	sp,sp,-8
 101a3c4:	000b883a 	mov	r5,zero
 101a3c8:	dc000015 	stw	r16,0(sp)
 101a3cc:	dfc00115 	stw	ra,4(sp)
 101a3d0:	2021883a 	mov	r16,r4
 101a3d4:	101a58c0 	call	101a58c <__call_exitprocs>
 101a3d8:	008040b4 	movhi	r2,258
 101a3dc:	10b39a04 	addi	r2,r2,-12696
 101a3e0:	11000017 	ldw	r4,0(r2)
 101a3e4:	20800f17 	ldw	r2,60(r4)
 101a3e8:	10000126 	beq	r2,zero,101a3f0 <exit+0x30>
 101a3ec:	103ee83a 	callr	r2
 101a3f0:	8009883a 	mov	r4,r16
 101a3f4:	101a70c0 	call	101a70c <_exit>

0101a3f8 <memcmp>:
 101a3f8:	01c000c4 	movi	r7,3
 101a3fc:	3980192e 	bgeu	r7,r6,101a464 <memcmp+0x6c>
 101a400:	2144b03a 	or	r2,r4,r5
 101a404:	11c4703a 	and	r2,r2,r7
 101a408:	10000f26 	beq	r2,zero,101a448 <memcmp+0x50>
 101a40c:	20800003 	ldbu	r2,0(r4)
 101a410:	28c00003 	ldbu	r3,0(r5)
 101a414:	10c0151e 	bne	r2,r3,101a46c <memcmp+0x74>
 101a418:	31bfff84 	addi	r6,r6,-2
 101a41c:	01ffffc4 	movi	r7,-1
 101a420:	00000406 	br	101a434 <memcmp+0x3c>
 101a424:	20800003 	ldbu	r2,0(r4)
 101a428:	28c00003 	ldbu	r3,0(r5)
 101a42c:	31bfffc4 	addi	r6,r6,-1
 101a430:	10c00e1e 	bne	r2,r3,101a46c <memcmp+0x74>
 101a434:	21000044 	addi	r4,r4,1
 101a438:	29400044 	addi	r5,r5,1
 101a43c:	31fff91e 	bne	r6,r7,101a424 <__alt_data_end+0xff81a424>
 101a440:	0005883a 	mov	r2,zero
 101a444:	f800283a 	ret
 101a448:	20c00017 	ldw	r3,0(r4)
 101a44c:	28800017 	ldw	r2,0(r5)
 101a450:	18bfee1e 	bne	r3,r2,101a40c <__alt_data_end+0xff81a40c>
 101a454:	31bfff04 	addi	r6,r6,-4
 101a458:	21000104 	addi	r4,r4,4
 101a45c:	29400104 	addi	r5,r5,4
 101a460:	39bff936 	bltu	r7,r6,101a448 <__alt_data_end+0xff81a448>
 101a464:	303fe91e 	bne	r6,zero,101a40c <__alt_data_end+0xff81a40c>
 101a468:	003ff506 	br	101a440 <__alt_data_end+0xff81a440>
 101a46c:	10c5c83a 	sub	r2,r2,r3
 101a470:	f800283a 	ret

0101a474 <__register_exitproc>:
 101a474:	defffa04 	addi	sp,sp,-24
 101a478:	dc000315 	stw	r16,12(sp)
 101a47c:	040040b4 	movhi	r16,258
 101a480:	84339a04 	addi	r16,r16,-12696
 101a484:	80c00017 	ldw	r3,0(r16)
 101a488:	dc400415 	stw	r17,16(sp)
 101a48c:	dfc00515 	stw	ra,20(sp)
 101a490:	18805217 	ldw	r2,328(r3)
 101a494:	2023883a 	mov	r17,r4
 101a498:	10003726 	beq	r2,zero,101a578 <__register_exitproc+0x104>
 101a49c:	10c00117 	ldw	r3,4(r2)
 101a4a0:	010007c4 	movi	r4,31
 101a4a4:	20c00e16 	blt	r4,r3,101a4e0 <__register_exitproc+0x6c>
 101a4a8:	1a000044 	addi	r8,r3,1
 101a4ac:	8800221e 	bne	r17,zero,101a538 <__register_exitproc+0xc4>
 101a4b0:	18c00084 	addi	r3,r3,2
 101a4b4:	18c7883a 	add	r3,r3,r3
 101a4b8:	18c7883a 	add	r3,r3,r3
 101a4bc:	12000115 	stw	r8,4(r2)
 101a4c0:	10c7883a 	add	r3,r2,r3
 101a4c4:	19400015 	stw	r5,0(r3)
 101a4c8:	0005883a 	mov	r2,zero
 101a4cc:	dfc00517 	ldw	ra,20(sp)
 101a4d0:	dc400417 	ldw	r17,16(sp)
 101a4d4:	dc000317 	ldw	r16,12(sp)
 101a4d8:	dec00604 	addi	sp,sp,24
 101a4dc:	f800283a 	ret
 101a4e0:	00800034 	movhi	r2,0
 101a4e4:	10800004 	addi	r2,r2,0
 101a4e8:	10002626 	beq	r2,zero,101a584 <__register_exitproc+0x110>
 101a4ec:	01006404 	movi	r4,400
 101a4f0:	d9400015 	stw	r5,0(sp)
 101a4f4:	d9800115 	stw	r6,4(sp)
 101a4f8:	d9c00215 	stw	r7,8(sp)
 101a4fc:	00000000 	call	0 <__reset-0x80000>
 101a500:	d9400017 	ldw	r5,0(sp)
 101a504:	d9800117 	ldw	r6,4(sp)
 101a508:	d9c00217 	ldw	r7,8(sp)
 101a50c:	10001d26 	beq	r2,zero,101a584 <__register_exitproc+0x110>
 101a510:	81000017 	ldw	r4,0(r16)
 101a514:	10000115 	stw	zero,4(r2)
 101a518:	02000044 	movi	r8,1
 101a51c:	22405217 	ldw	r9,328(r4)
 101a520:	0007883a 	mov	r3,zero
 101a524:	12400015 	stw	r9,0(r2)
 101a528:	20805215 	stw	r2,328(r4)
 101a52c:	10006215 	stw	zero,392(r2)
 101a530:	10006315 	stw	zero,396(r2)
 101a534:	883fde26 	beq	r17,zero,101a4b0 <__alt_data_end+0xff81a4b0>
 101a538:	18c9883a 	add	r4,r3,r3
 101a53c:	2109883a 	add	r4,r4,r4
 101a540:	1109883a 	add	r4,r2,r4
 101a544:	21802215 	stw	r6,136(r4)
 101a548:	01800044 	movi	r6,1
 101a54c:	12406217 	ldw	r9,392(r2)
 101a550:	30cc983a 	sll	r6,r6,r3
 101a554:	4992b03a 	or	r9,r9,r6
 101a558:	12406215 	stw	r9,392(r2)
 101a55c:	21c04215 	stw	r7,264(r4)
 101a560:	01000084 	movi	r4,2
 101a564:	893fd21e 	bne	r17,r4,101a4b0 <__alt_data_end+0xff81a4b0>
 101a568:	11006317 	ldw	r4,396(r2)
 101a56c:	218cb03a 	or	r6,r4,r6
 101a570:	11806315 	stw	r6,396(r2)
 101a574:	003fce06 	br	101a4b0 <__alt_data_end+0xff81a4b0>
 101a578:	18805304 	addi	r2,r3,332
 101a57c:	18805215 	stw	r2,328(r3)
 101a580:	003fc606 	br	101a49c <__alt_data_end+0xff81a49c>
 101a584:	00bfffc4 	movi	r2,-1
 101a588:	003fd006 	br	101a4cc <__alt_data_end+0xff81a4cc>

0101a58c <__call_exitprocs>:
 101a58c:	defff504 	addi	sp,sp,-44
 101a590:	df000915 	stw	fp,36(sp)
 101a594:	dd400615 	stw	r21,24(sp)
 101a598:	dc800315 	stw	r18,12(sp)
 101a59c:	dfc00a15 	stw	ra,40(sp)
 101a5a0:	ddc00815 	stw	r23,32(sp)
 101a5a4:	dd800715 	stw	r22,28(sp)
 101a5a8:	dd000515 	stw	r20,20(sp)
 101a5ac:	dcc00415 	stw	r19,16(sp)
 101a5b0:	dc400215 	stw	r17,8(sp)
 101a5b4:	dc000115 	stw	r16,4(sp)
 101a5b8:	d9000015 	stw	r4,0(sp)
 101a5bc:	2839883a 	mov	fp,r5
 101a5c0:	04800044 	movi	r18,1
 101a5c4:	057fffc4 	movi	r21,-1
 101a5c8:	008040b4 	movhi	r2,258
 101a5cc:	10b39a04 	addi	r2,r2,-12696
 101a5d0:	12000017 	ldw	r8,0(r2)
 101a5d4:	45005217 	ldw	r20,328(r8)
 101a5d8:	44c05204 	addi	r19,r8,328
 101a5dc:	a0001c26 	beq	r20,zero,101a650 <__call_exitprocs+0xc4>
 101a5e0:	a0800117 	ldw	r2,4(r20)
 101a5e4:	15ffffc4 	addi	r23,r2,-1
 101a5e8:	b8000d16 	blt	r23,zero,101a620 <__call_exitprocs+0x94>
 101a5ec:	14000044 	addi	r16,r2,1
 101a5f0:	8421883a 	add	r16,r16,r16
 101a5f4:	8421883a 	add	r16,r16,r16
 101a5f8:	84402004 	addi	r17,r16,128
 101a5fc:	a463883a 	add	r17,r20,r17
 101a600:	a421883a 	add	r16,r20,r16
 101a604:	e0001e26 	beq	fp,zero,101a680 <__call_exitprocs+0xf4>
 101a608:	80804017 	ldw	r2,256(r16)
 101a60c:	e0801c26 	beq	fp,r2,101a680 <__call_exitprocs+0xf4>
 101a610:	bdffffc4 	addi	r23,r23,-1
 101a614:	843fff04 	addi	r16,r16,-4
 101a618:	8c7fff04 	addi	r17,r17,-4
 101a61c:	bd7ff91e 	bne	r23,r21,101a604 <__alt_data_end+0xff81a604>
 101a620:	00800034 	movhi	r2,0
 101a624:	10800004 	addi	r2,r2,0
 101a628:	10000926 	beq	r2,zero,101a650 <__call_exitprocs+0xc4>
 101a62c:	a0800117 	ldw	r2,4(r20)
 101a630:	1000301e 	bne	r2,zero,101a6f4 <__call_exitprocs+0x168>
 101a634:	a0800017 	ldw	r2,0(r20)
 101a638:	10003226 	beq	r2,zero,101a704 <__call_exitprocs+0x178>
 101a63c:	a009883a 	mov	r4,r20
 101a640:	98800015 	stw	r2,0(r19)
 101a644:	00000000 	call	0 <__reset-0x80000>
 101a648:	9d000017 	ldw	r20,0(r19)
 101a64c:	a03fe41e 	bne	r20,zero,101a5e0 <__alt_data_end+0xff81a5e0>
 101a650:	dfc00a17 	ldw	ra,40(sp)
 101a654:	df000917 	ldw	fp,36(sp)
 101a658:	ddc00817 	ldw	r23,32(sp)
 101a65c:	dd800717 	ldw	r22,28(sp)
 101a660:	dd400617 	ldw	r21,24(sp)
 101a664:	dd000517 	ldw	r20,20(sp)
 101a668:	dcc00417 	ldw	r19,16(sp)
 101a66c:	dc800317 	ldw	r18,12(sp)
 101a670:	dc400217 	ldw	r17,8(sp)
 101a674:	dc000117 	ldw	r16,4(sp)
 101a678:	dec00b04 	addi	sp,sp,44
 101a67c:	f800283a 	ret
 101a680:	a0800117 	ldw	r2,4(r20)
 101a684:	80c00017 	ldw	r3,0(r16)
 101a688:	10bfffc4 	addi	r2,r2,-1
 101a68c:	15c01426 	beq	r2,r23,101a6e0 <__call_exitprocs+0x154>
 101a690:	80000015 	stw	zero,0(r16)
 101a694:	183fde26 	beq	r3,zero,101a610 <__alt_data_end+0xff81a610>
 101a698:	95c8983a 	sll	r4,r18,r23
 101a69c:	a0806217 	ldw	r2,392(r20)
 101a6a0:	a5800117 	ldw	r22,4(r20)
 101a6a4:	2084703a 	and	r2,r4,r2
 101a6a8:	10000b26 	beq	r2,zero,101a6d8 <__call_exitprocs+0x14c>
 101a6ac:	a0806317 	ldw	r2,396(r20)
 101a6b0:	2088703a 	and	r4,r4,r2
 101a6b4:	20000c1e 	bne	r4,zero,101a6e8 <__call_exitprocs+0x15c>
 101a6b8:	89400017 	ldw	r5,0(r17)
 101a6bc:	d9000017 	ldw	r4,0(sp)
 101a6c0:	183ee83a 	callr	r3
 101a6c4:	a0800117 	ldw	r2,4(r20)
 101a6c8:	15bfbf1e 	bne	r2,r22,101a5c8 <__alt_data_end+0xff81a5c8>
 101a6cc:	98800017 	ldw	r2,0(r19)
 101a6d0:	153fcf26 	beq	r2,r20,101a610 <__alt_data_end+0xff81a610>
 101a6d4:	003fbc06 	br	101a5c8 <__alt_data_end+0xff81a5c8>
 101a6d8:	183ee83a 	callr	r3
 101a6dc:	003ff906 	br	101a6c4 <__alt_data_end+0xff81a6c4>
 101a6e0:	a5c00115 	stw	r23,4(r20)
 101a6e4:	003feb06 	br	101a694 <__alt_data_end+0xff81a694>
 101a6e8:	89000017 	ldw	r4,0(r17)
 101a6ec:	183ee83a 	callr	r3
 101a6f0:	003ff406 	br	101a6c4 <__alt_data_end+0xff81a6c4>
 101a6f4:	a0800017 	ldw	r2,0(r20)
 101a6f8:	a027883a 	mov	r19,r20
 101a6fc:	1029883a 	mov	r20,r2
 101a700:	003fb606 	br	101a5dc <__alt_data_end+0xff81a5dc>
 101a704:	0005883a 	mov	r2,zero
 101a708:	003ffb06 	br	101a6f8 <__alt_data_end+0xff81a6f8>

0101a70c <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
 101a70c:	defffd04 	addi	sp,sp,-12
 101a710:	df000215 	stw	fp,8(sp)
 101a714:	df000204 	addi	fp,sp,8
 101a718:	e13fff15 	stw	r4,-4(fp)
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
  ALT_OS_STOP();
 101a71c:	0001883a 	nop
 101a720:	e0bfff17 	ldw	r2,-4(fp)
 101a724:	e0bffe15 	stw	r2,-8(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  register int r2 asm ("r2") = exit_code;
 101a728:	e0bffe17 	ldw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "r"(r2), "r"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
 101a72c:	10000226 	beq	r2,zero,101a738 <_exit+0x2c>
    ALT_SIM_FAIL();
 101a730:	002af070 	cmpltui	zero,zero,43969
 101a734:	00000106 	br	101a73c <_exit+0x30>
  } else {
    ALT_SIM_PASS();
 101a738:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
 101a73c:	003fff06 	br	101a73c <__alt_data_end+0xff81a73c>
